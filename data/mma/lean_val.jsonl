{"input": "Statement in natural language:\nFor a given affine subspace 's' of real numbers in a point 'P', which is nonempty and a complete space, the distance from a point 'p' to its orthogonal projection on 's' is zero if and only if the point 'p' is in the subspace 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_orthogonalProjection_eq_zero_iff {s : AffineSubspace \u211d P} [Nonempty s]\n    [CompleteSpace s.direction] {p : P} : dist p (orthogonalProjection s p) = 0 \u2194 p \u2208 s :="}
{"input": "Statement in natural language:\nThe image of a function f over a set s and the insertion of an element b into a set t is equal to the union of the image of the function f applied to each element of set s and b, and the image of the function f over set s and set t.\nTranslate the statement in natural language to Lean:", "output": "theorem image2_insert_right : image2 f s (insert b t) = (fun a => f a b) '' s \u222a image2 f s t :="}
{"input": "Statement in natural language:\nIf a function 'f' from 'E' to the pair 'F, G' is continuously differentiable at a point 'x' in 'E', then the first component of the function 'f' is also continuously differentiable at the same point 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiffAt.fst {f : E \u2192 F \u00d7 G} {x : E} (hf : ContDiffAt \ud835\udd5c n f x) :\n    ContDiffAt \ud835\udd5c n (fun x => (f x).1) x :="}
{"input": "Statement in natural language:\nIf a set 's' of group 'G' is measurable, then the inverse of the set 's' is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasurableSet.inv {s : Set G} (hs : MeasurableSet s) : MeasurableSet s\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any type '\u03b1' that can be cast to a natural number, casting 'n' to '\u03b1' and then back to a natural number will result in the original number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofDual_natCast [NatCast \u03b1] (n : \u2115) : (ofDual n : \u03b1) = n :="}
{"input": "Statement in natural language:\nFor a subsemigroup S of N and a monoid homomorphism f from M to N, the preimage of S under f is equal to the comap of S under f.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_comap (S : Subsemigroup N) (f : M \u2192\u2099* N) : (S.comap f : Set M) = f \u207b\u00b9' S :="}
{"input": "Statement in natural language:\nFor a given finite set 's' and a function 'f' from '\u03b1' to 'M', the support of the function 'f' on the set 's' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem support_onFinset_subset {s : Finset \u03b1} {f : \u03b1 \u2192 M} {hf} :\n    (onFinset s f hf).support \u2286 s :="}
{"input": "Statement in natural language:\nFor three cocompact maps (f from \u03b3 to \u03b4, g from \u03b2 to \u03b3, and h from \u03b1 to \u03b2), the composition of f and g, followed by the composition with h, is equal to the composition of f with the composition of g and h. This is essentially stating the associativity property for the composition of cocompact maps.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_assoc (f : CocompactMap \u03b3 \u03b4) (g : CocompactMap \u03b2 \u03b3) (h : CocompactMap \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h) :="}
{"input": "Statement in natural language:\nIf a function 'p' from an index set '\u03b9' to a point set 'P' is injective (meaning it never maps distinct elements of '\u03b9' to the same element of 'P'), and if the function that maps each element of the range of 'p' to 'P' is affine independent (meaning no point in the range can be expressed as an affine combination of the others), then the function 'p' itself is also affine independent.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineIndependent.of_set_of_injective {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k (fun x => x : Set.range p \u2192 P)) (hi : Function.Injective p) :\n    AffineIndependent k p :="}
{"input": "Statement in natural language:\nThe difference of two power series f' and g', when considered as a Laurent series, is equal to the original difference of the power series f' and g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sub : ((f' - g' : PowerSeries R') : LaurentSeries R') = f' - g' :="}
{"input": "Statement in natural language:\nFor any element 'a' of a set '\u03b1' and any unit 'u' of '\u03b1', the division of 'a' by 'u' using the division operation defined by principal ideals is equal to the division of 'a' by 'u' using the standard division operation.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.divp_eq_div (a : \u03b1) (u : \u03b1\u02e3) : a /\u209a u = a / u :="}
{"input": "Statement in natural language:\nFor any two finite sets 's' and 't', with 's' having elements of type '\u03b9' and 't' having elements of type '\u03b9'', and functions 'ws' and 'zs' mapping elements of 's' to real numbers and elements of a vector space 'E' respectively, and functions 'wt' and 'zt' mapping elements of 't' to real numbers and elements of a vector space 'E' respectively, if the sum of the values of 'ws' over all elements in 's' equals 1 and the sum of the values of 'wt' over all elements in 't' equals 1, and for any two real numbers 'a' and 'b' such that 'a' plus 'b' equals 1, then the weighted sum of the center of mass of 's' and 't' is equal to the center of mass of the disjoint union of 's' and 't', where the weights are given by the functions 'ws' and 'wt' scaled by 'a' and 'b' respectively, and the positions are given by the functions 'zs' and 'zt'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finset.centerMass_segment' (s : Finset \u03b9) (t : Finset \u03b9') (ws : \u03b9 \u2192 R) (zs : \u03b9 \u2192 E)\n    (wt : \u03b9' \u2192 R) (zt : \u03b9' \u2192 E) (hws : (\u2211 i in s, ws i) = 1) (hwt : (\u2211 i in t, wt i) = 1) (a b : R)\n    (hab : a + b = 1) : a \u2022 s.centerMass ws zs + b \u2022 t.centerMass wt zt = (s.disjSum t).centerMass\n    (Sum.elim (fun i => a * ws i) fun j => b * wt j) (Sum.elim zs zt) :="}
{"input": "Statement in natural language:\nFor a given element 'x' of type '\u03b1', a function 'u' from finite set 'Fin m' to '\u03b1', and an element 'i' of 'Fin m', the value of the vector constructed by prepending 'x' to 'u' at the successor of 'i' is equal to the value of 'u' at 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem cons_val_succ (x : \u03b1) (u : Fin m \u2192 \u03b1) (i : Fin m) : vecCons x u i.succ = u i :="}
{"input": "Statement in natural language:\nFor a given type \u03b3 with an addition and zero operation, if for all indices i and elements y of type \u03b2 i, the function f applied to the singleton of i and y equals the function g applied to the same singleton, then f and g are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem addHom_ext {\u03b3 : Type w} [AddZeroClass \u03b3] \u2983f g : (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03b3\u2984\n    (H : \u2200 (i : \u03b9) (y : \u03b2 i), f (single i y) = g (single i y)) : f = g :="}
{"input": "Statement in natural language:\nThe difference between two simple graphs, G and G', is equal to the graph G with the set of edges from G' deleted.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_eq_deleteEdges (G G' : SimpleGraph V) : G \\ G' = G.deleteEdges G'.edgeSet :="}
{"input": "Statement in natural language:\nFor any two valuations 'v' and 'v'' of a field 'K' with values in two linearly ordered commutative groups with zero '\u0393\u2080' and '\u0393'\u2080' respectively, 'v' is equivalent to 'v'' if and only if for all elements 'x' in 'K', 'v' of 'x' is less than 1 if and only if 'v'' of 'x' is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 :="}
{"input": "Statement in natural language:\nFor any semiring S, any polynomial p with coefficients in R, any ring homomorphism f from R to S, and any natural number k, the k-th derivative of the polynomial obtained by applying f to the coefficients of p is equal to the polynomial obtained by applying f to the coefficients of the k-th derivative of p.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_derivative_map [Semiring S] (p : R[X]) (f : R \u2192+* S) (k : \u2115) :\n    (Polynomial.derivative^[k]) (p.map f) = ((Polynomial.derivative^[k]) p).map f :="}
{"input": "Statement in natural language:\nFor any element 'c' from the ring 'R', the application of the algebra map from 'R' to the opposite of the algebra 'A' is equal to the opposite operation applied to the algebra map from 'R' to 'A' on 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem algebraMap_apply (c : R) : algebraMap R A\u1d50\u1d52\u1d56 c = op (algebraMap R A c) :="}
{"input": "Statement in natural language:\nThe angle between vector x and vector y is equal to the angle between vector y and vector x.\nTranslate the statement in natural language to Lean:", "output": "theorem angle_comm (x y : V) : angle x y = angle y x :="}
{"input": "Statement in natural language:\nAn element 'a' is in the filtered set 's' if and only if 'a' is in 's' and 'a' satisfies the property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_filter {a : \u03b1} {s} : a \u2208 filter p s \u2194 a \u2208 s \u2227 p a :="}
{"input": "Statement in natural language:\nFor a continuous function 'f' from '\u03b1' to '\u03b2', the application of the 'star' operation to 'f' is equal to the 'star' operation applied to the result of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_star (f : C(\u03b1, \u03b2)) : \u21d1(star f) = star (\u21d1f) :="}
{"input": "Statement in natural language:\nFor any three games x, y, and z, if x is equivalent to y, then if y is left-disjoint with z, x is also left-disjoint with z.\nTranslate the statement in natural language to Lean:", "output": "theorem lf_of_equiv_of_lf {x y z : PGame} (h\u2081 : x \u2248 y) : y \u29cf z \u2192 x \u29cf z :="}
{"input": "Statement in natural language:\nFor a countable index set \u03b9, which is nonempty, and a measure \u03bc on a set \u03b1, if we have a sequence of functions f from \u03b9 to the space of functions from \u03b1 to \u03b2 such that each function in the sequence is almost everywhere measurable with respect to \u03bc, and for almost every x in the measure space, there exists a limit l in \u03b2 such that the sequence of function values at x tends to l as n tends to infinity, then there exists a limit function f_lim from \u03b1 to \u03b2 which is measurable, and for almost every x in the measure space, the sequence of function values at x tends to the value of the limit function at x as n tends to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_limit_of_tendsto_metrizable_ae {\u03b9} [Countable \u03b9] [Nonempty \u03b9] {\u03bc : Measure \u03b1}\n    {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {L : Filter \u03b9} [L.IsCountablyGenerated] (hf : \u2200 n, AEMeasurable (f n) \u03bc)\n    (h_ae_tendsto : \u2200\u1d50 x \u2202\u03bc, \u2203 l : \u03b2, Tendsto (fun n => f n x) L (\ud835\udcdd l)) :\n    \u2203 (f_lim : \u03b1 \u2192 \u03b2)(hf_lim_meas : Measurable f_lim),\n      \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) L (\ud835\udcdd (f_lim x)) :="}
{"input": "Statement in natural language:\nThe finite rank of the dual module over a field K and a vector space V is equal to the finite rank of the vector space V over the field K.\nTranslate the statement in natural language to Lean:", "output": "theorem dual_finrank_eq : finrank K (Module.Dual K V) = finrank K V :="}
{"input": "Statement in natural language:\nFor a functor 'F' from 'J' to 'C' that has a colimit, and for any object 'X' in 'C', if two morphisms 'f' and 'f'' from the colimit of 'F' to 'X' make the same diagram commute for all 'j' in 'J' (i.e., the composition of the colimit cocone's injection morphism for 'j' and 'f' is equal to the composition of the colimit cocone's injection morphism for 'j' and 'f''), then 'f' and 'f'' must be the same morphism.\nTranslate the statement in natural language to Lean:", "output": "theorem colimit.hom_ext {F : J \u2964 C} [HasColimit F] {X : C} {f f' : colimit F \u27f6 X}\n    (w : \u2200 j, colimit.\u03b9 F j \u226b f = colimit.\u03b9 F j \u226b f') : f = f' :="}
{"input": "Statement in natural language:\nFor any natural number 'b' and any list of natural numbers 'L', the integer representation of the natural number obtained from the digits of 'L' in base 'b' is equal to the integer obtained from the digits of 'L' in base 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_int_ofDigits (b : \u2115) (L : List \u2115) : ((ofDigits b L : \u2115) : \u2124) = ofDigits (b : \u2124) L :="}
{"input": "Statement in natural language:\nThe number one is an element of the set s in the ring R.\nTranslate the statement in natural language to Lean:", "output": "theorem one_mem : (1 : R) \u2208 s :="}
{"input": "Statement in natural language:\nFor an isometry 'h' from a set '\u03b1' to a set '\u03b2', the preimage under the inverse of 'h' is equal to the image under 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_symm (h : \u03b1 \u2243\u1d62 \u03b2) : preimage h.symm = image h :="}
{"input": "Statement in natural language:\nThe symmetric difference of a and b is equal to the symmetric difference of b and a. This means that the operation of symmetric difference is commutative.\nTranslate the statement in natural language to Lean:", "output": "theorem symmDiff_comm : a \u2206 b = b \u2206 a :="}
{"input": "Statement in natural language:\nFor any element 'x' of a ring 'R' and any natural number 'n', the valuation of 'x' raised to the power 'n' is equal to 'n' times the valuation of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x) :="}
{"input": "Statement in natural language:\nIf a measure \u03bd is right invariant under multiplication, then the measure-preserving function that maps a pair of elements (z.1, z.2) in the group G to another pair (z.1, z.2 * z.1) preserves the product measure \u03bc.prod \u03bd.\nTranslate the statement in natural language to Lean:", "output": "theorem measurePreserving_prod_mul_right [IsMulRightInvariant \u03bd] :\n    MeasurePreserving (fun z : G \u00d7 G => (z.1, z.2 * z.1)) (\u03bc.prod \u03bd) (\u03bc.prod \u03bd) :="}
{"input": "Statement in natural language:\nFor any four elements a\u2081, a\u2082, b\u2081, b\u2082 of a certain type \u03b1, if the product of a\u2081 and b\u2081 is less than or equal to the product of a\u2082 and b\u2082, then either a\u2081 is less than or equal to a\u2082 or b\u2081 is less than or equal to b\u2082. This is under the condition that \u03b1 is a covariant class under multiplication and the 'less than' relation, both in its regular and swapped form.\nTranslate the statement in natural language to Lean:", "output": "theorem le_or_le_of_mul_le_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    a\u2081 * b\u2081 \u2264 a\u2082 * b\u2082 \u2192 a\u2081 \u2264 a\u2082 \u2228 b\u2081 \u2264 b\u2082 :="}
{"input": "Statement in natural language:\nThe composition of the coercion function and the exponential order isomorphism function is equal to the exponential function.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_comp_expOrderIso : (\u2191) \u2218 expOrderIso = exp :="}
{"input": "Statement in natural language:\nFor any natural number 'm' and any finite number 'i' within a certain range 'n', 'm' is less than or equal to the sum of 'm' and 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_coe_natAdd (m : \u2115) (i : Fin n) : m \u2264 natAdd m i :="}
{"input": "Statement in natural language:\nIf a type \u03b1 is unique and finite, then the cardinality (or the number of elements) of \u03b1 is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem card_unique [Unique \u03b1] [h : Fintype \u03b1] : Fintype.card \u03b1 = 1 :="}
{"input": "Statement in natural language:\nThe first element of the product of p and q, when mapped with the first function from the set R to the sets M and M\u2082, is equal to p.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_map_fst : (prod p q).map (fst R M M\u2082) = p :="}
{"input": "Statement in natural language:\nA set 's' of any type '\u03b1' is a unit if and only if 's' itself is a unit.\nTranslate the statement in natural language to Lean:", "output": "theorem isUnit_coe : IsUnit (s : Set \u03b1) \u2194 IsUnit s :="}
{"input": "Statement in natural language:\nIf 'x' is a fixed point of a permutation 'e', then 'x' is also a fixed point of the 'n'-th power of the permutation 'e'. Here, 'n' is a natural number.\nTranslate the statement in natural language to Lean:", "output": "theorem perm_pow (h : IsFixedPt e x) (n : \u2115) : IsFixedPt (\u21d1(e ^ n)) x :="}
{"input": "Statement in natural language:\nIf there is a less than or equal to comap function 'f' from 'A' to 'B', and 'A'' is less than or equal to 'A', and 'B' is less than or equal to 'B'', then there is a less than or equal to comap function 'f' from 'A'' to 'B''.\nTranslate the statement in natural language to Lean:", "output": "theorem LEComap.mono (h : LEComap f A B) (hA : A' \u2264 A) (hB : B \u2264 B') : LEComap f A' B' :="}
{"input": "Statement in natural language:\nFor a natural number 'q' and given 'q' is the exponential characteristic of a ring 'R', 'q' is either a prime number or equals to one.\nTranslate the statement in natural language to Lean:", "output": "theorem expChar_is_prime_or_one (q : \u2115) [hq : ExpChar R q] : Nat.Prime q \u2228 q = 1 :="}
{"input": "Statement in natural language:\nFor a given formal multilinear series 'p' and a non-negative real number 'r' that is greater than zero and less than the radius of 'p', there exists a positive constant 'C' such that for all natural numbers 'n', the norm of the 'n'-th term of 'p' is less than or equal to 'C' divided by 'r' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_le_div_pow_of_pos_of_lt_radius (p : FormalMultilinearSeries \ud835\udd5c E F) {r : \u211d\u22650}\n    (h0 : 0 < r) (h : (r : \u211d\u22650\u221e) < p.radius) : \u2203 C > 0, \u2200 n, \u2016p n\u2016 \u2264 C / (r : \u211d) ^ n :="}
{"input": "Statement in natural language:\nIf a positive number 'a' is greater than zero, then half of 'a' is also greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem half_pos (h : 0 < a) : 0 < a / 2 :="}
{"input": "Statement in natural language:\nThe cycle type of the identity permutation (represented by 1) on any set \u03b1 is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleType_one : (1 : Perm \u03b1).cycleType = 0 :="}
{"input": "Statement in natural language:\nIf 'p' is a prime number and 'p' divides the product of 'a' and 'b', then 'p' must divide either 'a' or 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_or_dvd (hp : Prime p) {a b : \u03b1} (h : p \u2223 a * b) : p \u2223 a \u2228 p \u2223 b :="}
{"input": "Statement in natural language:\nFor a given element 'a' in a subsingleton 'E', the norm of 'a' is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_of_subsingleton' [Subsingleton E] (a : E) : \u2016a\u2016 = 0 :="}
{"input": "Statement in natural language:\nIf a function 'f' from '\u03b1' to '\u03b2' is bounded under the cofinite filter (meaning that there exists a lower bound for all but finitely many elements of the function), then the range of the function is bounded below. This is under the condition that '\u03b2' is a semilattice under the operation of infimum (greatest lower bound).\nTranslate the statement in natural language to Lean:", "output": "theorem IsBoundedUnder.bddBelow_range_of_cofinite [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) cofinite f) : BddBelow (range f) :="}
{"input": "Statement in natural language:\nFor a finite type \u03b9, a set of vectors v is linearly independent over a ring R if and only if for any function g from \u03b9 to R, if the sum of the scalar products of g(i) and v(i) for all i equals zero, then g(i) equals zero for all i.\nTranslate the statement in natural language to Lean:", "output": "theorem Fintype.linearIndependent_iff [Fintype \u03b9] :\n    LinearIndependent R v \u2194 \u2200 g : \u03b9 \u2192 R, (\u2211 i, g i \u2022 v i) = 0 \u2192 \u2200 i, g i = 0 :="}
{"input": "Statement in natural language:\nFor a nontrivial ring R, the degree of the product of a multiset t is equal to the sum of the degrees of the elements of t when each element is mapped by a function f.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_multiset_prod [Nontrivial R] : t.prod.degree = (t.map fun f => degree f).sum :="}
{"input": "Statement in natural language:\nThe p-adic valuation of 0 is 0.\nTranslate the statement in natural language to Lean:", "output": "theorem zero : padicValNat p 0 = 0 :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, if two morphisms (functions) f and g from \u03b1 to \u03b2 are such that for every element a of type \u03b1, the result of applying f and g to a is the same, then f and g are the same function.\nTranslate the statement in natural language to Lean:", "output": "theorem types_ext {\u03b1 \u03b2 : Type u} (f g : \u03b1 \u27f6 \u03b2) (h : \u2200 a : \u03b1, f a = g a) : f = g :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c in a normed group E, the distance between the quotient of a and b and c is equal to the distance between a and the product of c and b.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_div_eq_dist_mul_left (a b c : E) : dist (a / b) c = dist a (c * b) :="}
{"input": "Statement in natural language:\nThe set difference of x and y is equal to the intersection of x and the complement of y.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_eq : x \\ y = x \u2293 y\u1d9c :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any unit 'u' of the ring of integers modulo 'n', the inverse of 'u' in the ring of integers modulo 'n' is equal to the inverse of 'u' in the group of units of the ring of integers modulo 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_coe_unit {n : \u2115} (u : (ZMod n)\u02e3) : (u : ZMod n)\u207b\u00b9 = (u\u207b\u00b9 : (ZMod n)\u02e3) :="}
{"input": "Statement in natural language:\nFor a given integer in the form of a square root of d, the greatest common divisor of the real part and the imaginary part of the integer is zero if and only if the integer itself is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem gcd_eq_zero_iff (a : \u2124\u221ad) : Int.gcd a.re a.im = 0 \u2194 a = 0 :="}
{"input": "Statement in natural language:\nSubtracting the real part of a quaternion 'a' from 'a' itself results in the imaginary part of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_self_re : a - a.re = a.im :="}
{"input": "Statement in natural language:\nFor any isomorphism '\u03b1' between two objects 'X' and 'Y', the inverse of the symmetry of '\u03b1' is equal to the homomorphism of '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_inv (\u03b1 : X \u2245 Y) : \u03b1.symm.inv = \u03b1.hom :="}
{"input": "Statement in natural language:\nIn the context of an ordered set with no minimum element, a value is the predecessor limit if and only if it is the maximum value.\nTranslate the statement in natural language to Lean:", "output": "theorem isPredLimit_iff_of_noMin [NoMinOrder \u03b1] : IsPredLimit a \u2194 IsMax a :="}
{"input": "Statement in natural language:\nThe signed measure of the negation of 'j' is equal to the negation of the signed measure of 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem toSignedMeasure_neg : (-j).toSignedMeasure = -j.toSignedMeasure :="}
{"input": "Statement in natural language:\nIf we have functions 'c' and 'g' mapping from a set 'X' to a set 'E', and a set 's' of 'X', and a function 'f' that for every 'x' gives a continuously differentiable bump function at 'c x'. If 'c', the inner radius function of 'f', the outer radius function of 'f', and 'g' are all continuously differentiable within 's' at a point 'x', then the function that maps 'x' to the value of the bump function 'f x' at 'g x' is also continuously differentiable within 's' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.ContDiffWithinAt.contDiffBump {c g : X \u2192 E} {s : Set X}\n    {f : \u2200 x, ContDiffBump (c x)} {x : X} (hc : ContDiffWithinAt \u211d n c s x)\n    (hr : ContDiffWithinAt \u211d n (fun x => (f x).rIn) s x)\n    (hR : ContDiffWithinAt \u211d n (fun x => (f x).rOut) s x)\n    (hg : ContDiffWithinAt \u211d n g s x) :\n    ContDiffWithinAt \u211d n (fun x => f x (g x)) s x :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type 'WithBot \u03b1' (which means the type \u03b1 together with a bottom element), if 's' does not include only the bottom element, then the supremum (the least upper bound) of 's' is equal to the supremum of the preimage of 's' under the function that maps each element to its corresponding element in \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem WithBot.sSup_eq [SupSet \u03b1] {s : Set (WithBot \u03b1)} (hs : \u00acs \u2286 {\u22a5}) :\n    sSup s = \u2191(sSup ((\u2191) \u207b\u00b9' s) : \u03b1) :="}
{"input": "Statement in natural language:\nThe map of an ideal through a function is less than or equal to the ideal range of the function.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_idealRange : I.map f \u2264 f.idealRange :="}
{"input": "Statement in natural language:\nFor a given free additive monoid 'l', the count of elements satisfying a predicate 'p' in 'l' is equal to the count of elements satisfying the same predicate 'p' in the list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem countp_apply (l : FreeAddMonoid \u03b1) : countp p l = List.countp p l :="}
{"input": "Statement in natural language:\nFor any subgroup H\u2081 of a group G, where H\u2081 is normal, and any subgroup H\u2082 of the quotient group G/H\u2081, where H\u2082 is also normal, the composition of the comap (preimage under a group homomorphism) of the center of the quotient group (G/H\u2081)/H\u2082 by the canonical projection mk' H\u2082 and the canonical projection mk' H\u2081 is equal to the comap of the center of the quotient group G/H\u2082.comap(mk' H\u2081) by the canonical projection mk' of the comap of H\u2082 by mk' H\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_comap_center {H\u2081 : Subgroup G} [H\u2081.Normal] {H\u2082 : Subgroup (G \u29f8 H\u2081)} [H\u2082.Normal] :\n    ((Subgroup.center ((G \u29f8 H\u2081) \u29f8 H\u2082)).comap (mk' H\u2082)).comap (mk' H\u2081) =\n      (Subgroup.center (G \u29f8 H\u2082.comap (mk' H\u2081))).comap (mk' (H\u2082.comap (mk' H\u2081))) :="}
{"input": "Statement in natural language:\nFor any nonempty set 's' in a preordered set '\u03b1', where '\u03b1' is directed with respect to the order '\u2264', there exists an element 'M' such that every element 'i' in 's' is less than or equal to 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finset.exists_le [Nonempty \u03b1] [Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] (s : Finset \u03b1) :\n    \u2203 M, \u2200 i \u2208 s, i \u2264 M :="}
{"input": "Statement in natural language:\nThe essential supremum of a function f with respect to a measure \u03bc is equal to zero if and only if the function f is almost everywhere equal to zero with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem essSup_eq_zero_iff : essSup f \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0 :="}
{"input": "Statement in natural language:\nInserting an element 'b' of type '\u03b2 a' into an empty set, where 'a' is any element, is equivalent to creating a singleton set with 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem insert_empty (a) (b : \u03b2 a) : insert a b \u2205 = singleton a b :="}
{"input": "Statement in natural language:\nIf a matrix A is symmetric, then the scalar multiplication of any scalar k and A is also symmetric. This is under the condition that the scalar multiplication operation is defined for the scalar type R and the matrix element type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSymm.smul [SMul R \u03b1] {A : Matrix n n \u03b1} (h : A.IsSymm) (k : R) : (k \u2022 A).IsSymm :="}
{"input": "Statement in natural language:\nThe factorization of a natural number 'n' raised to the power 'k' is equal to 'k' times the factorization of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem factorization_pow (n k : \u2115) : factorization (n ^ k) = k \u2022 n.factorization :="}
{"input": "Statement in natural language:\nFor any word 'w' in the set M that is not empty, there exist indices 'i' and 'j' and a non-empty word 'w'' in M between 'i' and 'j' such that 'w'' when converted to a word equals 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_word (w : Word M) (h : w \u2260 empty) : \u2203 (i j : _)(w' : NeWord M i j), w'.toWord = w :="}
{"input": "Statement in natural language:\nThe span of a singleton set containing an element 'y' from a set 'P' is not equal to zero if and only if the element 'y' itself is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem spanSingleton_ne_zero_iff {y : P} : spanSingleton S y \u2260 0 \u2194 y \u2260 0 :="}
{"input": "Statement in natural language:\nFor any two sets s and t in a metric space, if the Hausdorff distance between s and t is not infinite, then the infimum distance from a point x to the set t is less than or equal to the infimum distance from x to the set s plus the Hausdorff distance between s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem infDist_le_infDist_add_hausdorffDist (fin : hausdorffEdist s t \u2260 \u22a4) :\n    infDist x t \u2264 infDist x s + hausdorffDist s t :="}
{"input": "Statement in natural language:\nFor a function 'f' from \u03b2 to \u03b1, and sets 's' and 't' of \u03b2, and an element 'z' of \u03b2, if 't' is compact, 'f' is continuous on 't', 'z' is an element of 't', and for all 'z'' in 't' but not in 's', 'f' at 'z' is less than 'f' at 'z'', then there exists an 'x' in 's' such that 'x' is a minimum on 'f' over 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompact.exists_isMinOn_mem_subset {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2} {z : \u03b2}\n    (ht : IsCompact t) (hf : ContinuousOn f t) (hz : z \u2208 t) (hfz : \u2200 z' \u2208 t \\ s, f z < f z') :\n    \u2203 x \u2208 s, IsMinOn f t x :="}
{"input": "Statement in natural language:\nThe scalar multiplication of any number 'a' and the bottom element of the filter on beta equals the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_filter_bot : a \u2022 (\u22a5 : Filter \u03b2) = \u22a5 :="}
{"input": "Statement in natural language:\nIf a scalar multiplication of a scalar 'a' and an element 's' from a module 'M' is scalar multiplication regular, then the element 's' itself is scalar multiplication regular.\nTranslate the statement in natural language to Lean:", "output": "theorem of_smul (a : R) (ab : IsSMulRegular M (a \u2022 s)) : IsSMulRegular M s :="}
{"input": "Statement in natural language:\nThe commutator of two elements g\u2081 and g\u2082 equals one if and only if g\u2081 and g\u2082 commute.\nTranslate the statement in natural language to Lean:", "output": "theorem commutatorElement_eq_one_iff_commute : \u2045g\u2081, g\u2082\u2046 = 1 \u2194 Commute g\u2081 g\u2082 :="}
{"input": "Statement in natural language:\nIf space Y is contractible and there is a homotopy equivalence between space X and Y, then space X is also contractible.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousMap.HomotopyEquiv.contractibleSpace [ContractibleSpace Y] (e : X \u2243\u2095 Y) :\n    ContractibleSpace X :="}
{"input": "Statement in natural language:\nFor a given element 'x' and an element 'y' from the set 'M', the mapping of the element 'mk' 'S' 'x' 'y' under the function 'g' with respect to 'Q' and 'hy' is equal to the element 'mk' 'Q' of 'g x' and the pair consisting of 'g y' and the second element of the pair 'hy y'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_mk' (x) (y : M) : map Q g hy (mk' S x y) = mk' Q (g x) \u27e8g y, hy y.2\u27e9 :="}
{"input": "Statement in natural language:\nThe function 'pure', which maps from an arbitrary type \u03b1 to a NonemptyInterval of \u03b1, is injective. This means that each element of \u03b1 is mapped to a unique NonemptyInterval of \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem pure_injective : Injective (pure : \u03b1 \u2192 NonemptyInterval \u03b1) :="}
{"input": "Statement in natural language:\nFor a set 's' of elements of type \u03b1, if 's' is bounded below and 's' is nonempty, then the supremum (least upper bound) of the set of lower bounds of 's' is equal to the infimum (greatest lower bound) of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem csSup_lower_bounds_eq_csInf {s : Set \u03b1} (h : BddBelow s) (hs : s.Nonempty) :\n    sSup (lowerBounds s) = sInf s :="}
{"input": "Statement in natural language:\nFor any matrix A with elements from a ring R, the kernel of the linear map defined by the multiplication of the transpose of A and A itself is equal to the kernel of the linear map defined by the multiplication of A.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_mulVecLin_transpose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (A\u1d40 \u2b1d A).mulVecLin = LinearMap.ker (mulVecLin A) :="}
{"input": "Statement in natural language:\nThe function 'f' is continuously differentiable for all 'n' if and only if 'f' is continuously differentiable for all natural numbers 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem contDiff_all_iff_nat : (\u2200 n, ContDiff \ud835\udd5c n f) \u2194 \u2200 n : \u2115, ContDiff \ud835\udd5c n f :="}
{"input": "Statement in natural language:\nFor a given tagged prepartition '\u03c0' of an interval 'I', if '\u03c0' is a partition and for every subinterval 'J' in '\u03c0', there exists a prepartition '\u03c0i' of 'J' that is also a partition, then the bi-union prepartition of '\u03c0' and '\u03c0i' is also a partition.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPartition.biUnionPrepartition {\u03c0 : TaggedPrepartition I} (h : IsPartition \u03c0)\n    {\u03c0i : \u2200 J, Prepartition J} (hi : \u2200 J \u2208 \u03c0, (\u03c0i J).IsPartition) :\n    (\u03c0.biUnionPrepartition \u03c0i).IsPartition :="}
{"input": "Statement in natural language:\nFor any element 'x' of a group 'G', if 'x' is greater than or equal to 1, and for any integer 'n' that is greater than or equal to 0, then 1 is less than or equal to 'x' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem one_le_zpow {x : G} (H : 1 \u2264 x) {n : \u2124} (hn : 0 \u2264 n) : 1 \u2264 x ^ n :="}
{"input": "Statement in natural language:\nThe logarithm function with base b tends to infinity as its input tends to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_logb_atTop : Tendsto (logb b) atTop atTop :="}
{"input": "Statement in natural language:\nThe result of merge sorting a single-element list (containing an element 'a') according to a certain relation 'r' is the same single-element list.\nTranslate the statement in natural language to Lean:", "output": "theorem mergeSort_singleton (a : \u03b1) : [a].mergeSort r = [a] :="}
{"input": "Statement in natural language:\nThe set of all elements greater than a given value 'a' is disjoint from the set of all elements less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_Ioi_Iio (a : \u03b1) : Disjoint (Ioi a) (Iio a) :="}
{"input": "Statement in natural language:\nFor any two multisets 'm' and 'n' of natural numbers, if 'm' is less than 'n', then the sum of the elements in 'm' is less than the sum of the elements in 'n'. Here, 'id' is the identity function.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_id_lt_of_lt (m n : \u03b9 \u2192\u2080 \u2115) (h : m < n) : (m.sum fun _ => id) < n.sum fun _ => id :="}
{"input": "Statement in natural language:\nFor a bilinear function 'f' mapping from 'E' to 'F' to 'G', and for a pair 'x' from 'E' and 'F', the function 'f' has a formal power series at 'x'. This formal power series is given by the formal power series of the bilinear function 'f' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFPowerSeriesAt_bilinear (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    HasFPowerSeriesAt (fun x : E \u00d7 F => f x.1 x.2) (f.fpowerSeriesBilinear x) x :="}
{"input": "Statement in natural language:\nFor a given filter 'f' and an element 'a' of type '\u03b1', 'f' is less than or equal to the pure function of 'a' if and only if the set containing 'a' is an element of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_pure_iff {f : Filter \u03b1} {a : \u03b1} : f \u2264 pure a \u2194 {a} \u2208 f :="}
{"input": "Statement in natural language:\nThe application of the function \u03b3, which is a continuous map from the interval I to the topological space X, is equal to \u03b3 itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mk : \u21d1(\u03b3 : C(I, X)) = \u03b3 :="}
{"input": "Statement in natural language:\nFor any character 'c' and any two lists of characters 'cs1' and 'cs2', and any two positive numbers 'i1' and 'i2', the less than operation on the pair consisting of the list starting with 'c' followed by 'cs1' and 'i1' plus the character 'c', and the pair consisting of the list starting with 'c' followed by 'cs2' and 'i2' plus the character 'c', is equal to the less than operation on the pair consisting of 'cs1' and 'i1', and the pair consisting of 'cs2' and 'i2'.\nTranslate the statement in natural language to Lean:", "output": "theorem ltb_cons_addChar (c : Char) (cs\u2081 cs\u2082 : List Char) (i\u2081 i\u2082 : Pos) :\n    ltb \u27e8\u27e8c :: cs\u2081\u27e9, i\u2081 + c\u27e9 \u27e8\u27e8c :: cs\u2082\u27e9, i\u2082 + c\u27e9 = ltb \u27e8\u27e8cs\u2081\u27e9, i\u2081\u27e9 \u27e8\u27e8cs\u2082\u27e9, i\u2082\u27e9 :="}
{"input": "Statement in natural language:\nFor any \u03b1, \u03b2, and h, the composition of the map from w to w' with \u03b1, \u03b2, and h and the inclusion map of f' and g' at w' is equal to the composition of the inclusion map of f and g at w and the cokernel map of f to f' with \u03b1 on the left, \u03b2 on the left, and the simplification of h and the symmetry of \u03b2.w as the proof.\nTranslate the statement in natural language to Lean:", "output": "theorem map_\u03b9 (\u03b1 \u03b2 h) :\n    map w w' \u03b1 \u03b2 h \u226b \u03b9 f' g' w' =\n      \u03b9 f g w \u226b cokernel.map f f' \u03b1.left \u03b2.left (by simp [h, \u03b2.w.symm]) :="}
{"input": "Statement in natural language:\nIf a, b, and c are semiconjugate by a certain function, then the function that multiplies by a is semiconjugate to the function that multiplies by c, with respect to the function that multiplies by b.\nTranslate the statement in natural language to Lean:", "output": "theorem SemiconjBy.function_semiconj_mul_right_swap (h : SemiconjBy a b c) :\n    Function.Semiconj (\u00b7 * a) (\u00b7 * c) (\u00b7 * b) :="}
{"input": "Statement in natural language:\nFor any elements 'a' of the type 'WithBot \u03b1' and 'b' of the type 'WithTop \u03b1\u1d52\u1d48', 'a' is less than the dual of 'b' in 'WithTop' if and only if 'b' is less than the dual of 'a' in 'WithBot'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_ofDual_iff {a : WithBot \u03b1} {b : WithTop \u03b1\u1d52\u1d48} :\n    a < WithTop.ofDual b \u2194 b < WithBot.toDual a :="}
{"input": "Statement in natural language:\nIf the infimum of sets s and t is nonempty, then set s is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem Nonempty.of_infs_left : (s \u22bc t).Nonempty \u2192 s.Nonempty :="}
{"input": "Statement in natural language:\nFor a group G with a finite index center, the transfer of the center power of G applied to an element g of G is equal to g raised to the power of the index of the center of G.\nTranslate the statement in natural language to Lean:", "output": "theorem transferCenterPow_apply [FiniteIndex (center G)] (g : G) :\n    \u2191(transferCenterPow G g) = g ^ (center G).index :="}
{"input": "Statement in natural language:\nIf a is greater than 0 and a is less than or equal to b, then the reciprocal of b is less than or equal to the reciprocal of a.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_le_inv_of_le (ha : 0 < a) (h : a \u2264 b) : b\u207b\u00b9 \u2264 a\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor a non-zero element 'x' of a module 'M', the kernel of the linear map to the span of the singleton set containing 'x' is the zero submodule.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_toSpanSingleton {x : M} (h : x \u2260 0) : LinearMap.ker (toSpanSingleton R M x) = \u22a5 :="}
{"input": "Statement in natural language:\nThe kernel of the function 'lsingle a' (which is a linear map from M to the function \u03b1 \u2192\u2080 M) is the bottom element, often representing the zero element or the smallest possible subspace.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_lsingle (a : \u03b1) : ker (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M) = \u22a5 :="}
{"input": "Statement in natural language:\nIf there is at least one element in set \u03b1, and \u03b1 is a semilattice with an infimum operation, and \u03b2 is a set with a preorder relation and no minimum element, and there is a function f from \u03b1 to \u03b2 that tends to negative infinity as \u03b1 tends to negative infinity, then the range of function f is not bounded below.\nTranslate the statement in natural language to Lean:", "output": "theorem unbounded_of_tendsto_atBot' [Nonempty \u03b1] [SemilatticeInf \u03b1] [Preorder \u03b2] [NoMinOrder \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (h : Tendsto f atBot atBot) : \u00acBddBelow (range f) :="}
{"input": "Statement in natural language:\nIf for every element x in a set s, the range of the function f applied to x is bounded above, and for every index i, the function f at index i is lower semicontinuous on set s, then the function that maps each element x' to the supremum of the set of all f i x' is also lower semicontinuous on set s.\nTranslate the statement in natural language to Lean:", "output": "theorem lowerSemicontinuousOn_ciSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200 x \u2208 s, BddAbove (range fun i => f i x)) (h : \u2200 i, LowerSemicontinuousOn (f i) s) :\n    LowerSemicontinuousOn (fun x' => \u2a06 i, f i x') s :="}
{"input": "Statement in natural language:\nFor any box I, the open interval of the box is a subset of the box itself.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioo_subset_coe (I : Box \u03b9) : Box.Ioo I \u2286 I :="}
{"input": "Statement in natural language:\nFor any positive real number x, there exists a positive rational number q such that q is less than x.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_pos_rat_lt {x : \u03b1} (x0 : 0 < x) : \u2203 q : \u211a, 0 < q \u2227 (q : \u03b1) < x :="}
{"input": "Statement in natural language:\nIf c is a non-zero element of extended non-negative real numbers, then the measure obtained by scaling \u03bc by c is an open positive measure.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpenPosMeasure_smul {c : \u211d\u22650\u221e} (h : c \u2260 0) : IsOpenPosMeasure (c \u2022 \u03bc) :="}
{"input": "Statement in natural language:\nThe line map from p1 to p2 is Lipschitz continuous with Lipschitz constant equal to the non-negative distance between p1 and p2.\nTranslate the statement in natural language to Lean:", "output": "theorem lipschitzWith_lineMap (p\u2081 p\u2082 : P) : LipschitzWith (nndist p\u2081 p\u2082) (lineMap p\u2081 p\u2082 : \ud835\udd5c \u2192 P) :="}
{"input": "Statement in natural language:\nIf a function 'f' is strictly monotonic, and for all 'p', 'f' of 'a' is less than or equal to 'p', then 'a' is less than or equal to any 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictMono.minimal_of_minimal_image (hf : StrictMono f) {a} (hmin : \u2200 p, f a \u2264 p) (x : \u03b1) :\n    a \u2264 x :="}
{"input": "Statement in natural language:\nIf an element x is in list l, then the previous element of x in list l is also in list l.\nTranslate the statement in natural language to Lean:", "output": "theorem prev_mem (h : x \u2208 l) : l.prev x h \u2208 l :="}
{"input": "Statement in natural language:\nThe logarithm function with base 'b' is injective (or one-to-one) on the set of all positive real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem logb_injOn_pos : Set.InjOn (logb b) (Set.Ioi 0) :="}
{"input": "Statement in natural language:\nFor any real number 'a' that is less than zero, and any two real numbers 'b' and 'c', the comparison of the product of 'a' and 'b' with the product of 'a' and 'c' is the same as the comparison of 'c' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem cmp_mul_neg_left {a : \u03b1} (ha : a < 0) (b c : \u03b1) : cmp (a * b) (a * c) = cmp c b :="}
{"input": "Statement in natural language:\nThe square of the norm of a complex number x is equal to the square of the absolute value of the same complex number x.\nTranslate the statement in natural language to Lean:", "output": "theorem normSq_eq_abs (x : \u2102) : normSq x = (Complex.abs x) ^ 2 :="}
{"input": "Statement in natural language:\nFor a sequence of functions 'f' from natural numbers to a measure space '\u03b1' and a normed space 'E', where each function is almost everywhere strongly measurable with respect to a measure '\u03bc', and for a real number 'p' greater than or equal to 1, and a sequence of non-negative extended real numbers 'B' whose sum is not infinite, if the p-th root of the integral over the measure space of the sum of the norms of the differences between consecutive functions in the sequence 'f', raised to the power 'p', is less than or equal to the sum of the sequence 'B', then almost everywhere in the measure space, the sum of the norms of the differences between consecutive functions in the sequence 'f' is less than infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_nnnorm_sub_ae_lt_top {f : \u2115 \u2192 \u03b1 \u2192 E} (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc)\n    {p : \u211d} (hp1 : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e} (hB : (\u2211' i, B i) \u2260 \u221e)\n    (h : (\u222b\u207b a, (\u2211' i, \u2016f (i + 1) a - f i a\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p) \u2264 \u2211' i, B i) :\n    \u2200\u1d50 x \u2202\u03bc, (\u2211' i, \u2016f (i + 1) x - f i x\u2016\u208a : \u211d\u22650\u221e) < \u221e :="}
{"input": "Statement in natural language:\nThe hyperbolic cosine of a real number 'x' is equal to the hyperbolic cosine of 'x' considered as a complex number.\nTranslate the statement in natural language to Lean:", "output": "theorem ofReal_cosh (x : \u211d) : (Real.cosh x : \u2102) = cosh x :="}
{"input": "Statement in natural language:\nFor any complex shape 'c', applying the symmetry operation twice will yield the original complex shape 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_symm (c : ComplexShape \u03b9) : c.symm.symm = c :="}
{"input": "Statement in natural language:\nFor a function 'f' with a right inverse 'f_inv', a function 'g' from 'G\u2081' to 'G\u2083', and a condition 'hg' that the kernel of 'f' is less than or equal to the kernel of 'g', for any element 'x' in 'G\u2081', applying the function 'f.liftOfRightInverseAux f_inv hf g hg' to 'f(x)' results in 'g(x)'.\nTranslate the statement in natural language to Lean:", "output": "theorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : G\u2081 \u2192* G\u2083)\n    (hg : f.ker \u2264 g.ker) (x : G\u2081) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x :="}
{"input": "Statement in natural language:\nFor a non-unital algebra, the composition of two algebra homomorphisms (functions that preserve the structure of an algebra), f and g, applied to an element x, is equal to applying the function f to the result of applying the function g to x. This is essentially stating that the composition of functions is associative.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_apply (f : B \u2192\u2099\u2090[R] C) (g : A \u2192\u2099\u2090[R] B) (x : A) : f.comp g x = f (g x) :="}
{"input": "Statement in natural language:\nIf 'f' is a monoid homomorphism from 'M' to 'N', and 'x' is a unit in 'M', then the image of 'x' under 'f' is a unit in 'N'.\nTranslate the statement in natural language to Lean:", "output": "theorem map' {f : M \u2192 N} (hf : IsMonoidHom f) {x : M} (h : IsUnit x) : IsUnit (f x) :="}
{"input": "Statement in natural language:\nFor a natural number 'p' and an add group with one 'R' that has characteristic 'p', the casting of a natural number 'a' to 'R' is equal to another natural number 'b' if and only if 'a' is congruent to 'b' modulo 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem CharP.natCast_eq_natCast [AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2115} :\n    (a : R) = b \u2194 a \u2261 b [MOD p] :="}
{"input": "Statement in natural language:\nFor any two finite sets s and t, the intersection of set s with the union of sets t and s is equal to set s.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_union_self (s t : Finset \u03b1) : s \u2229 (t \u222a s) = s :="}
{"input": "Statement in natural language:\nFor any four elements a\u2081, a\u2082, b\u2081, b\u2082 in a normed group E, the non-negative distance between the product of a\u2081 and a\u2082 and the product of b\u2081 and b\u2082 is less than or equal to the sum of the non-negative distance between a\u2081 and b\u2081 and the non-negative distance between a\u2082 and b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_mul_mul_le (a\u2081 a\u2082 b\u2081 b\u2082 : E) :\n    nndist (a\u2081 * a\u2082) (b\u2081 * b\u2082) \u2264 nndist a\u2081 b\u2081 + nndist a\u2082 b\u2082 :="}
{"input": "Statement in natural language:\nFor any given set of points P, there exists a subset t such that t is a subset of s, the affine span of t is equal to the affine span of s, and t is affinely independent. This means that no point in t can be expressed as a linear combination of the other points in t.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_affineIndependent (s : Set P) :\n    \u2203 (t : _) (_ : t \u2286 s), affineSpan k t = affineSpan k s \u2227 AffineIndependent k ((\u2191) : t \u2192 P) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' from the sum of two types '\u03b1' and '\u03b2', both of which have a less than operation, 'a' is less than 'b' in the lexicographic order if and only if 'a' is less than 'b' in the order defined by the less than operation on each type.\nTranslate the statement in natural language to Lean:", "output": "theorem toLex_lt_toLex [LT \u03b1] [LT \u03b2] {a b : Sum \u03b1 \u03b2} :\n    toLex a < toLex b \u2194 Lex (\u00b7 < \u00b7) (\u00b7 < \u00b7) a b :="}
{"input": "Statement in natural language:\nFor a function 'f' from \ud835\udd5c to E, a non-negative real number 'r', and a point 'x' in \ud835\udd5c, if 'f' has a formal power series 'p' on a ball centered at 'x' with radius 'r', and for every positive real number 'r'', there exists a formal power series 'p'' such that 'f' has this power series on a ball centered at 'x' with radius 'r'', then 'f' has the formal power series 'p' on a ball centered at 'x' with an infinite radius.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFPowerSeriesOnBall.r_eq_top_of_exists {f : \ud835\udd5c \u2192 E} {r : \u211d\u22650\u221e} {x : \ud835\udd5c}\n    {p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c E} (h : HasFPowerSeriesOnBall f p x r)\n    (h' : \u2200 (r' : \u211d\u22650) (_ : 0 < r'), \u2203 p' : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c E,\n      HasFPowerSeriesOnBall f p' x r') :\n    HasFPowerSeriesOnBall f p x \u221e :="}
{"input": "Statement in natural language:\nIf a function f has a derivative f' at a point x, and another function g has a derivative g' at the same point x, and if the value of function f at point x is greater than 0, then the derivative at point x of the function that is the result of raising f(x) to the power of g(x) is equal to the sum of two terms: the first term is g(x) times f(x) raised to the power of (g(x) - 1), all multiplied by f', and the second term is f(x) raised to the power of g(x) times the natural logarithm of f(x), all multiplied by g'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivAt.rpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) (h : 0 < f x) :\n    HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') x :="}
{"input": "Statement in natural language:\nFor any zero element \u03b1 and for all i, where \u03b1 is multiplied with zero in \u03b2 i, given any \u03b1 (denoted as k) and for all i in \u03b2 i, the Hamming norm of the scaled vector (k \u2022 x) is less than or equal to the Hamming norm of the original vector x.\nTranslate the statement in natural language to Lean:", "output": "theorem hammingNorm_smul_le_hammingNorm [Zero \u03b1] [\u2200 i, SMulWithZero \u03b1 (\u03b2 i)] {k : \u03b1}\n    {x : \u2200 i, \u03b2 i} : hammingNorm (k \u2022 x) \u2264 hammingNorm x :="}
{"input": "Statement in natural language:\nFor any two complex numbers 'a' and 'b', where 'a' is not equal to zero, the function that raises 'a' to the power of 'x' is continuous at 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousAt_const_cpow {a b : \u2102} (ha : a \u2260 0) : ContinuousAt (fun x : \u2102 => a ^ x) b :="}
{"input": "Statement in natural language:\nFor any function 'f' from some set '\u03b1' to the set of natural numbers, if you first convert 'f' to a multiset and then convert that multiset back to a function, you will end up with the original function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finsupp.toMultiset_toFinsupp (f : \u03b1 \u2192\u2080 \u2115) :\n    Multiset.toFinsupp (Finsupp.toMultiset f) = f :="}
{"input": "Statement in natural language:\nThe application of the inverse of the extension of a cospan (formed by objects iX, iY, and iZ with morphisms wf and wg) to the object WalkingCospan.one is equal to the inverse of iZ.\nTranslate the statement in natural language to Lean:", "output": "theorem cospanExt_inv_app_one : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.one = iZ.inv :="}
{"input": "Statement in natural language:\nFor an equivalence 'e' between two types '\u03b1' and '\u03b2', 'e' is injective.\nTranslate the statement in natural language to Lean:", "output": "theorem injective (e : \u03b1 \u2243 \u03b2) : Injective e :="}
{"input": "Statement in natural language:\nThe extension of function 'f' in the completion of a uniform space is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_extension : Continuous (Completion.extension f) :="}
{"input": "Statement in natural language:\nFor a given linear ordered field '\ud835\udd5c', a set 's' in '\ud835\udd5c', and an element 'x' in '\ud835\udd5c' that belongs to 's', 's' is star-convex with respect to 'x' if and only if 's' is order-connected.\nTranslate the statement in natural language to Lean:", "output": "theorem starConvex_iff_ordConnected [LinearOrderedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c} (hx : x \u2208 s) :\n    StarConvex \ud835\udd5c x s \u2194 s.OrdConnected :="}
{"input": "Statement in natural language:\nZero is equal to the extended distance between two points x and y if and only if x is equal to y.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_eq_edist {x y : \u03b3} : 0 = edist x y \u2194 x = y :="}
{"input": "Statement in natural language:\nFor any finite measure \u03bd, if \u03bd is less than or equal to \u03bc, then subtracting \u03bd from \u03bc and then adding \u03bd back equals \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_add_cancel_of_le [IsFiniteMeasure \u03bd] (h\u2081 : \u03bd \u2264 \u03bc) : \u03bc - \u03bd + \u03bd = \u03bc :="}
{"input": "Statement in natural language:\nAn element 'x' belongs to the greatest lower bound (infimum) of a function 'f' that maps from an arbitrary type '\u03b9' to a convex cone in a vector space 'E' over a scalar field '\ud835\udd5c', if and only if 'x' belongs to the function 'f' for all 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_iInf {\u03b9 : Sort _} {x : E} {f : \u03b9 \u2192 ConvexCone \ud835\udd5c E} : x \u2208 iInf f \u2194 \u2200 i, x \u2208 f i :="}
{"input": "Statement in natural language:\nThe order of a power series \u03c6 is equal to infinity if and only if \u03c6 is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem order_eq_top {\u03c6 : PowerSeries R} : \u03c6.order = \u22a4 \u2194 \u03c6 = 0 :="}
{"input": "Statement in natural language:\nFor any two pairs of elements (x, y) from the sets M and S, if the product of the second element of y and the first element of x equals the product of the second element of x and the first element of y, then x and y have the relation r in the set S.\nTranslate the statement in natural language to Lean:", "output": "theorem r_of_eq {x y : M \u00d7 S} (h : \u2191y.2 * x.1 = \u2191x.2 * y.1) : r S x y :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type '\u03b1' and a given finite set 's' of type '\u03b1', the list representation of 's' is equal to a list containing only 'a' if and only if 's' is a set containing only 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem toList_eq_singleton_iff {a : \u03b1} {s : Finset \u03b1} : s.toList = [a] \u2194 s = {a} :="}
{"input": "Statement in natural language:\nFor any additive commutative monoid and multiplicative structure, given two 3x3 matrices, the multiplication of these two matrices results in a new 3x3 matrix where each element is the sum of the products of the corresponding elements in the rows of the first matrix and the columns of the second matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_fin_three [AddCommMonoid \u03b1] [Mul \u03b1]\n    (a\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1) :\n    !![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083;\n       a\u2082\u2081, a\u2082\u2082, a\u2082\u2083;\n       a\u2083\u2081, a\u2083\u2082, a\u2083\u2083] \u2b1d !![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083;\n                           b\u2082\u2081, b\u2082\u2082, b\u2082\u2083;\n                           b\u2083\u2081, b\u2083\u2082, b\u2083\u2083] =\n    !![a\u2081\u2081*b\u2081\u2081 + a\u2081\u2082*b\u2082\u2081 + a\u2081\u2083*b\u2083\u2081, a\u2081\u2081*b\u2081\u2082 + a\u2081\u2082*b\u2082\u2082 + a\u2081\u2083*b\u2083\u2082, a\u2081\u2081*b\u2081\u2083 + a\u2081\u2082*b\u2082\u2083 + a\u2081\u2083*b\u2083\u2083;\n       a\u2082\u2081*b\u2081\u2081 + a\u2082\u2082*b\u2082\u2081 + a\u2082\u2083*b\u2083\u2081, a\u2082\u2081*b\u2081\u2082 + a\u2082\u2082*b\u2082\u2082 + a\u2082\u2083*b\u2083\u2082, a\u2082\u2081*b\u2081\u2083 + a\u2082\u2082*b\u2082\u2083 + a\u2082\u2083*b\u2083\u2083;\n       a\u2083\u2081*b\u2081\u2081 + a\u2083\u2082*b\u2082\u2081 + a\u2083\u2083*b\u2083\u2081, a\u2083\u2081*b\u2081\u2082 + a\u2083\u2082*b\u2082\u2082 + a\u2083\u2083*b\u2083\u2082, a\u2083\u2081*b\u2081\u2083 + a\u2083\u2082*b\u2082\u2083 + a\u2083\u2083*b\u2083\u2083] :="}
{"input": "Statement in natural language:\nFor a given order-preserving function 'f' from '\u03b1' to '\u03b2' and an interval 's' of '\u03b1', the dual of the mapped interval under 'f' is equal to the mapped dual interval under the dual of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem dual_map (f : \u03b1 \u2192o \u03b2) (s : Interval \u03b1) : dual (s.map f) = s.dual.map (OrderHom.dual f) :="}
{"input": "Statement in natural language:\nFor any two elements x and y of the tropical semiring over R, the untropical function applied to x equals the untropical function applied to y if and only if x equals y. This means that the untropical function is injective.\nTranslate the statement in natural language to Lean:", "output": "theorem untrop_inj_iff (x y : Tropical R) : untrop x = untrop y \u2194 x = y :="}
{"input": "Statement in natural language:\nMultiplying any element M by 1 results in M itself.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_one : M * 1 = M :="}
{"input": "Statement in natural language:\nA hyperreal number 'x' is infinite if and only if for every real number 'r', the absolute value of 'r' is less than the absolute value of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem infinite_iff_abs_lt_abs {x : \u211d*} : Infinite x \u2194 \u2200 r : \u211d, (|r| : \u211d*) < |x| :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set 'F' and a set 's' of 'N', the closure of the preimage of 's' under 'f' is less than or equal to the preimage of the closure of 's' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mclosure_preimage_le (f : F) (s : Set N) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f :="}
{"input": "Statement in natural language:\nThe normalized factors of one, in the context of a unique factorization domain, are equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem normalizedFactors_one : normalizedFactors (1 : \u03b1) = 0 :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any stream 's', the tail of the stream obtained by dropping 'n' elements from 's' is equal to the stream obtained by dropping 'n' elements from the tail of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem tail_drop (n : Nat) (s : Stream' \u03b1) : tail (drop n s) = drop n (tail s) :="}
{"input": "Statement in natural language:\nFor a given real number 'r' that is greater than 0, and another real number 'c', and a continuous linear map 'f' from E to \ud835\udd5c, if for all 'z' in the closed ball centered at 0 with radius 'r', the norm of 'f z' is less than or equal to 'c', then the norm of 'f' is less than or equal to 'c' divided by 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousLinearMap.op_norm_bound_of_ball_bound {r : \u211d} (r_pos : 0 < r) (c : \u211d)\n    (f : E \u2192L[\ud835\udd5c] \ud835\udd5c) (h : \u2200 z \u2208 closedBall (0 : E) r, \u2016f z\u2016 \u2264 c) : \u2016f\u2016 \u2264 c / r :="}
{"input": "Statement in natural language:\nIf a set s is a subset of S and S is less than or equal to the closure of s, then the closure of s is equal to S.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_eq_of_le (h\u2081 : s \u2286 S) (h\u2082 : S \u2264 closure s) : closure s = S :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set '\u03b1' to a set 'E', and two subsets 's' and 't' of '\u03b1', if 's' and 't' are disjoint with respect to measure '\u03bc', 't' is a null measurable set with respect to '\u03bc', the measure of 's' and 't' are not infinite, and 'f' is integrable on 's' and 't' with respect to '\u03bc', then the integral of 'f' over the union of 's' and 't' is equal to the weighted sum of the integral of 'f' over 's' and 't', where the weights are the measures of 's' and 't' divided by the sum of the measures of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem average_union {f : \u03b1 \u2192 E} {s t : Set \u03b1} (hd : AEDisjoint \u03bc s t) (ht : NullMeasurableSet t \u03bc)\n    (hs\u03bc : \u03bc s \u2260 \u221e) (ht\u03bc : \u03bc t \u2260 \u221e) (hfs : IntegrableOn f s \u03bc) (hft : IntegrableOn f t \u03bc) :\n    (\u2a0d x in s \u222a t, f x \u2202\u03bc) =\n      (((\u03bc s).toReal / ((\u03bc s).toReal + (\u03bc t).toReal)) \u2022 \u2a0d x in s, f x \u2202\u03bc) +\n        ((\u03bc t).toReal / ((\u03bc s).toReal + (\u03bc t).toReal)) \u2022 \u2a0d x in t, f x \u2202\u03bc :="}
{"input": "Statement in natural language:\nThe sign of an integer 'a' is equal to the integer 'a' divided by the absolute value of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem sign_eq_ediv_abs (a : \u2124) : sign a = a / |a| :="}
{"input": "Statement in natural language:\nThe rank of the top subalgebra of E over the field F is equal to the rank of the module E over the field F.\nTranslate the statement in natural language to Lean:", "output": "theorem Subalgebra.rank_top : Module.rank F (\u22a4 : Subalgebra F E) = Module.rank F E :="}
{"input": "Statement in natural language:\nThe product of charted spaces of H and H' is equal to the charted space of the pair (H, H').\nTranslate the statement in natural language to Lean:", "output": "theorem chartedSpaceSelf_prod : prodChartedSpace H H H' H' = chartedSpaceSelf (H \u00d7 H') :="}
{"input": "Statement in natural language:\nFor any two lists l\u2081 and l\u2082 of elements of type \u03b1, l\u2081 being a subset of l\u2082 as multisets is equivalent to l\u2081 being a subset of l\u2082 as lists.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_subset {l\u2081 l\u2082 : List \u03b1} : (l\u2081 : Multiset \u03b1) \u2286 l\u2082 \u2194 l\u2081 \u2286 l\u2082 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set 'n', where 'a' is not equal to 'i', and for any element 'c' of a ring 'R' and any matrix 'M' of size 'n x n' with elements from 'R', the result of multiplying the transvection of 'i', 'j', and 'c' with 'M' and then applying 'a' and 'b' is equal to the result of applying 'a' and 'b' to 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem transvection_mul_apply_of_ne (a b : n) (ha : a \u2260 i) (c : R) (M : Matrix n n R) :\n    (transvection i j c \u2b1d M) a b = M a b :="}
{"input": "Statement in natural language:\nA polynomial function 'f' is not equal to zero if and only if the Laurent polynomial of 'f' is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Polynomial.toLaurent_ne_zero {f : R[X]} : f \u2260 0 \u2194 toLaurent f \u2260 0 :="}
{"input": "Statement in natural language:\nFor any set 's' of any type '\u03b1', applying the operation 'op' followed by the operation 'unop' results in the original set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem op_unop (s : Set \u03b1) : s.op.unop = s :="}
{"input": "Statement in natural language:\nFor a unit matrix M and any matrix N, both of size m by m over a ring R, the determinant of the product of M, N, and the inverse of M is equal to the determinant of N.\nTranslate the statement in natural language to Lean:", "output": "theorem det_units_conj (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (\u2191M \u2b1d N \u2b1d \u2191M\u207b\u00b9 : Matrix m m R) = det N :="}
{"input": "Statement in natural language:\nFor a unit 'u' in the ring 'R' with a negative first element, and a ray 'v' in the module over 'R', the scalar multiplication of 'u' and 'v' equals the negation of 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem units_smul_of_neg (u : R\u02e3) (hu : u.1 < 0) (v : Module.Ray R M) : u \u2022 v = -v :="}
{"input": "Statement in natural language:\nThe cobounded set of any type \u03b1 is equivalent to the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem cobounded_eq_bot : cobounded \u03b1 = \u22a5 :="}
{"input": "Statement in natural language:\nIf we have a type H that is a group and is nontrivial, and we have a group G that is simple, then if there is a surjective function from G to H, H is also a simple group.\nTranslate the statement in natural language to Lean:", "output": "theorem isSimpleGroup_of_surjective {H : Type _} [Group H] [IsSimpleGroup G] [Nontrivial H]\n    (f : G \u2192* H) (hf : Function.Surjective f) : IsSimpleGroup H :="}
{"input": "Statement in natural language:\nFor a left distributive class \u03b1, if a divides b and a divides c, then a also divides the sum of b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_add [LeftDistribClass \u03b1] {a b c : \u03b1} (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c :="}
{"input": "Statement in natural language:\nThere is a bijective function that maps the interval (a, b) to the interval (a + d, b + d) by adding a constant d to each element in the interval (a, b).\nTranslate the statement in natural language to Lean:", "output": "theorem Ioc_add_bij : BijOn (\u00b7 + d) (Ioc a b) (Ioc (a + d) (b + d)) :="}
{"input": "Statement in natural language:\nIf we have a T2 space M\u2082 and a function f from M\u2081 to M\u2082, and if f is a compact operator, then for any set S in M\u2081 that is Von Neumann bounded, the closure of the image of S under f is compact.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompactOperator.isCompact_closure_image_of_isVonNBounded [T2Space M\u2082] {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) {S : Set M\u2081} (hS : IsVonNBounded \ud835\udd5c\u2081 S) :\n    IsCompact (closure <| f '' S) :="}
{"input": "Statement in natural language:\nFor any list of elements, the enumeration of the list is equal to the zipped combination of the range of the list's length and the list itself.\nTranslate the statement in natural language to Lean:", "output": "theorem enum_eq_zip_range (l : List \u03b1) : l.enum = (range l.length).zip l :="}
{"input": "Statement in natural language:\nFor any two rational numbers q\u2081 and q\u2082, the denominator of the sum of q\u2081 and q\u2082 divides the product of the denominators of q\u2081 and q\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem add_den_dvd (q\u2081 q\u2082 : \u211a) : (q\u2081 + q\u2082).den \u2223 q\u2081.den * q\u2082.den :="}
{"input": "Statement in natural language:\nFor any natural numbers 'n' and 'm', and any function 'f' that is a primitive recursive function on vectors of natural numbers, there exists a vector 'f' that is a primitive recursive function.\nTranslate the statement in natural language to Lean:", "output": "theorem Vec.prim {n m f} (hf : @Nat.Primrec'.Vec n m f) : Vec f :="}
{"input": "Statement in natural language:\nThe preimage of the interval from b to c (including b but excluding c) under the function that subtracts each element from a, is the interval from (a - c) to (a - b) (including (a - c) but excluding (a - b)).\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_const_sub_Ico : (fun x => a - x) \u207b\u00b9' Ico b c = Ioc (a - c) (a - b) :="}
{"input": "Statement in natural language:\nThe set of right moves for the game represented by the number 1 is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem one_rightMoves : RightMoves 1 = PEmpty :="}
{"input": "Statement in natural language:\nFor any elements 'a', 'b', 'c', and 'd' of a group with zero, if 'b' and 'd' are not zero and the division of 'a' by 'b' equals the division of 'c' by 'd', then the product of 'a' and 'd' equals the product of 'c' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_eq_mul_of_div_eq_div (a : G\u2080) {b : G\u2080} (c : G\u2080) {d : G\u2080} (hb : b \u2260 0) (hd : d \u2260 0)\n    (h : a / b = c / d) : a * d = c * b :="}
{"input": "Statement in natural language:\nFor a real-valued function 'f' and a real number 'x', if the image of the function 'f' over the interval greater than 'x' is bounded below and 'f' is a monotone function, then the greatest lower bound (infimum) of 'f' over the real numbers greater than 'x' is equal to the greatest lower bound (infimum) of 'f' over the rational numbers greater than 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_Ioi_eq_iInf_rat_gt {f : \u211d \u2192 \u211d} (x : \u211d) (hf : BddBelow (f '' Ioi x))\n    (hf_mono : Monotone f) : (\u2a05 r : Ioi x, f r) = \u2a05 q : { q' : \u211a // x < q' }, f q :="}
{"input": "Statement in natural language:\nFor a function 'f' from set A to set B, under the conditions of additive group structure and multiplicative action, the composition of 'f' with the identity function on set M is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem id_comp (f : A \u2192+[M] B) : (DistribMulActionHom.id M).comp f = f :="}
{"input": "Statement in natural language:\nFor a given uniform quantale 'q', types '\u03b1' and '\u03b2' of vector length 'n', a function 'g' from '\u03b1' to '\u03b2', an element 'x' of functor 'F' applied to '\u03b1', and an index 'i', the support of the function 'g' mapped over 'x' at index 'i' is equal to the image of the support of 'x' at index 'i' under the function 'g' at index 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem supp_map (h : q.IsUniform) {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) (x : F \u03b1) (i) :\n    supp (g <$$> x) i = g i '' supp x i :="}
{"input": "Statement in natural language:\nIf a number 'a' is a square, then 'a' is not a prime number.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSquare.not_prime (ha : IsSquare a) : \u00acPrime a :="}
{"input": "Statement in natural language:\nIn a T1 space, for any two distinct points x and y and any set s, the neighborhood of x within the set obtained by adding y to s is the same as the neighborhood of x within s.\nTranslate the statement in natural language to Lean:", "output": "theorem nhdsWithin_insert_of_ne [T1Space \u03b1] {x y : \u03b1} {s : Set \u03b1} (hxy : x \u2260 y) :\n    \ud835\udcdd[insert y s] x = \ud835\udcdd[s] x :="}
{"input": "Statement in natural language:\nFor any two finite sets s\u2081 and s\u2082, if s\u2081 is a subset of s\u2082, then s\u2081 is a proper subset of s\u2082 if and only if there exists an element x in s\u2082 that is not in s\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem ssubset_iff_of_subset {s\u2081 s\u2082 : Finset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2081 \u2282 s\u2082 \u2194 \u2203 x \u2208 s\u2082, x \u2209 s\u2081 :="}
{"input": "Statement in natural language:\nFor any type \u03b9, given a set t of type \u03b9, a function s from \u03b9 to a set of type \u03b2, if the union of all sets s i for i in t equals the universal set, then for any element x of type \u03b2, there exists an element i in t such that x is in the set s i.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_set_mem_of_union_eq_top {\u03b9 : Type _} (t : Set \u03b9) (s : \u03b9 \u2192 Set \u03b2)\n    (w : (\u22c3 i \u2208 t, s i) = \u22a4) (x : \u03b2) : \u2203 i \u2208 t, x \u2208 s i :="}
{"input": "Statement in natural language:\nFor any two Cauchy sequences f and g over a set \u03b1 with an absolute value function, the supremum (least upper bound) of the sequences when considered as functions from natural numbers to \u03b1 is equal to the supremum of f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sup (f g : CauSeq \u03b1 abs) : \u21d1(f \u2294 g) = (f : \u2115 \u2192 \u03b1) \u2294 g :="}
{"input": "Statement in natural language:\nIf two functions 'f' and 'g' are not equal, then there exists at least one input 'x' such that the output of function 'f' at 'x' is not equal to the output of function 'g' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_ne {f g : F} (h : f \u2260 g) : \u2203 x, f x \u2260 g x :="}
{"input": "Statement in natural language:\nThe absolute value of the imaginary unit in complex numbers is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_I : Complex.abs I = 1 :="}
{"input": "Statement in natural language:\nThe minimum value of a list 'l' is 'none' if and only if the list 'l' is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem minimum_eq_none {l : List \u03b1} : l.minimum = none \u2194 l = [] :="}
{"input": "Statement in natural language:\nThe following three conditions are equivalent for a morphism 'f' in an abelian category: 'f' is a monomorphism, the kernel of 'f' is zero, and 'f' is exact with zero as its left object.\nTranslate the statement in natural language to Lean:", "output": "theorem tfae_mono : TFAE [Mono f, kernel.\u03b9 f = 0, Exact (0 : Z \u27f6 X) f] :="}
{"input": "Statement in natural language:\nFor a given submodule P of a module M over a ring R, and a basis b of P indexed by \u03b9, an element x of M is in P if and only if there exists a function c from \u03b9 to R such that x is equal to the sum over i of the scalar product of c(i) and the i-th element of the basis b.\nTranslate the statement in natural language to Lean:", "output": "theorem Basis.mem_submodule_iff' {P : Submodule R M} (b : Basis \u03b9 R P) {x : M} :\n    x \u2208 P \u2194 \u2203 c : \u03b9 \u2192 R, x = \u2211 i, c i \u2022 (b i : M) :="}
{"input": "Statement in natural language:\nFor a multiplication operation in a set \u03b1, the unop (unary operation) of the product of x and y is equal to the product of the unop of y and the unop of x.\nTranslate the statement in natural language to Lean:", "output": "theorem unop_mul [Mul \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56) : unop (x * y) = unop y * unop x :="}
{"input": "Statement in natural language:\nIf function g (from \u03b1 to \u211d) is integrable and function f (from \u03b1 to \u03b2) is almost everywhere strongly measurable, and for almost every a, the norm of f(a) is less than or equal to g(a), then function f is integrable.\nTranslate the statement in natural language to Lean:", "output": "theorem Integrable.mono' {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u211d} (hg : Integrable g \u03bc)\n    (hf : AEStronglyMeasurable f \u03bc) (h : \u2200\u1d50 a \u2202\u03bc, \u2016f a\u2016 \u2264 g a) : Integrable f \u03bc :="}
{"input": "Statement in natural language:\nFor any real number r that is not equal to zero, the coequalizer of the division of p by r (expressed as a non-negative extended real number) is equal to the division of p by r.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_div (hr : r \u2260 0) : (\u2191(p / r) : \u211d\u22650\u221e) = p / r :="}
{"input": "Statement in natural language:\nIf 'x' is a periodic point for function 'f' with period 'n', and 'n' is less than the minimal period of 'f' at 'x', then 'n' must be equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPeriodicPt.eq_zero_of_lt_minimalPeriod (hx : IsPeriodicPt f n x)\n    (hn : n < minimalPeriod f x) : n = 0 :="}
{"input": "Statement in natural language:\nFor a non-zero polynomial 'p' and a real number 'a', the polynomial '(X - a)' raised to the power of 'the multiplicity of the root a in p plus one' does not divide 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_rootMultiplicity_not_dvd {p : R[X]} (p0 : p \u2260 0) (a : R) :\n    \u00ac(X - C a) ^ (rootMultiplicity a p + 1) \u2223 p :="}
{"input": "Statement in natural language:\nFor a set 's' and a function 't' that maps to sets, the product of 's' and the intersection over 't' is a subset of the intersection over the product of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_iInter_subset (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b1) : (s * \u22c2 i, t i) \u2286 \u22c2 i, s * t i :="}
{"input": "Statement in natural language:\nFor any real number 'x', any integer 'm', and any natural number 'n' where 'n' is greater than 0, 'x' plus 'n' times 'm' is less than the 'n'-th iteration of function 'f' applied to 'x' if and only if 'x' plus 'm' is less than the function 'f' applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_iterate_pos_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    x + n * m < (f^[n]) x \u2194 x + m < f x :="}
{"input": "Statement in natural language:\nThe mapping of a function 'f' over a set 's' is equal to the image of the set 's' under the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_map : (map f s : Set \u03b2) = f '' s :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that has a topological space, a measurable space, a second countable topology, a linear order, an order topology, and is a Borel space, given two measures \u03bc and \u03bd on \u03b1, if \u03bc is a finite measure and the measure of the entire space under \u03bc equals the measure of the entire space under \u03bd, and for all pairs of elements a and b such that a is less than b, the measure of the interval from a to b (exclusive of a, inclusive of b) under \u03bc equals the measure of the same interval under \u03bd, then \u03bc and \u03bd are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_of_Ioc_finite {\u03b1 : Type _} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) :\n    \u03bc = \u03bd :="}
{"input": "Statement in natural language:\nFor a given vector 'v' of type 'm' mapping to '\u03b1', when this vector is multiplied by a zero matrix (of dimensions 'm' by 'n' and entries of type '\u03b1'), the result is a zero vector. This is under the condition that 'm' is a finite type.\nTranslate the statement in natural language to Lean:", "output": "theorem vecMul_zero [Fintype m] (v : m \u2192 \u03b1) : vecMul v (0 : Matrix m n \u03b1) = 0 :="}
{"input": "Statement in natural language:\nThe cosine function tends to zero from the right as its argument tends to \u03c0/2 from the left.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_cos_pi_div_two : Tendsto cos (\ud835\udcdd[<] (\u03c0 / 2)) (\ud835\udcdd[>] 0) :="}
{"input": "Statement in natural language:\nThe function 'equivRealProd' is Antilipschitz with a constant of the square root of 2.\nTranslate the statement in natural language to Lean:", "output": "theorem antilipschitz_equivRealProd : AntilipschitzWith (NNReal.sqrt 2) equivRealProd :="}
{"input": "Statement in natural language:\nThe multiplicative identity (1) in the ring of fractions R[S\u207b\u00b9] is equal to the fraction 1 over 1.\nTranslate the statement in natural language to Lean:", "output": "theorem one_def : (1 : R[S\u207b\u00b9]) = 1 /\u2092 1 :="}
{"input": "Statement in natural language:\nThe interval starting from a given number 'a' is equal to the finite interval between 'a' and 'n' in the set of natural numbers, where 'n' is the final element of the set.\nTranslate the statement in natural language to Lean:", "output": "theorem Ici_eq_finset_subtype : Ici a = (Icc (a : \u2115) n).fin n :="}
{"input": "Statement in natural language:\nIf a function 'f' is null measurable with respect to a measure '\u03bc', then 'f' is measurable in the null measurable space of '\u03b1' with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem NullMeasurable.measurable' (h : NullMeasurable f \u03bc) :\n    @Measurable (NullMeasurableSpace \u03b1 \u03bc) \u03b2 _ _ f :="}
{"input": "Statement in natural language:\n\"a\" is a unit if and only if the product of \"a\" and \"a\" is a unit.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.isUnit_mul_self_iff : IsUnit (a * a) \u2194 IsUnit a :="}
{"input": "Statement in natural language:\nFor any two hyperreal numbers 'x' and 'y', if 'x' and 'y' are infinitesimal, then their sum 'x + y' is also infinitesimal.\nTranslate the statement in natural language to Lean:", "output": "theorem Infinitesimal.add {x y : \u211d*} (hx : Infinitesimal x) (hy : Infinitesimal y) :\n    Infinitesimal (x + y) :="}
{"input": "Statement in natural language:\nFor any two elements x\u2081 and x\u2082 from the unitization of a ring R and an additive group A, the first component of the product of x\u2081 and x\u2082 is equal to the product of the first components of x\u2081 and x\u2082. This holds under the conditions that R has a multiplication operation, A has both an addition and multiplication operation, and R and A have a scalar multiplication operation.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_mul [Mul R] [Add A] [Mul A] [SMul R A] (x\u2081 x\u2082 : Unitization R A) :\n    (x\u2081 * x\u2082).fst = x\u2081.fst * x\u2082.fst :="}
{"input": "Statement in natural language:\nIf a is covered by b, then the predecessor of b is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Wcovby.pred_le (h : a \u2a7f b) : pred b \u2264 a :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any two elements 'i' and 'j' of the finite set of size 'n+1', if 'i' is less than 'j', then the cycle range of 'i' and 'j' is equal to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleRange_of_gt {n : \u2115} {i j : Fin n.succ} (h : i < j) : cycleRange i j = j :="}
{"input": "Statement in natural language:\nFor a given set 's' of any type '\u03b1' and an element 'a' of the same type, if both the set 's' and the set resulting from inserting 'a' into 's' are finite, then converting the set resulting from inserting 'a' into 's' into a finite set is equivalent to inserting 'a' into the finite set obtained from 's'. This is under the condition that '\u03b1' has decidable equality, meaning that for any two elements of type '\u03b1', it can be decided whether they are equal or not.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinset_insert [DecidableEq \u03b1] {a : \u03b1} {s : Set \u03b1} [Fintype (insert a s : Set \u03b1)]\n    [Fintype s] : (insert a s).toFinset = insert a s.toFinset :="}
{"input": "Statement in natural language:\nIf a set 's' is countable, then there exists a permutation 'f' that is a cycle on 's' and for which the set of elements 'x' that 'f' does not map to themselves is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Set.Countable.exists_cycleOn (hs : s.Countable) :\n    \u2203 f : Perm \u03b1, f.IsCycleOn s \u2227 { x | f x \u2260 x } \u2286 s :="}
{"input": "Statement in natural language:\nFor any two hyperreal numbers 'x' and 'y' and any two real numbers 'r' and 's', if 'x' is a standard part of 'r' and 'y' is a standard part of 's', then the standard part of the difference between 'x' and 'y' is the difference between 'r' and 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSt.sub {x y : \u211d*} {r s : \u211d} (hxr : IsSt x r) (hys : IsSt y s) : IsSt (x - y) (r - s) :="}
{"input": "Statement in natural language:\nFor any sets s, t, and u, if s is a subset of t, then s is also a subset of the union of t and u.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_union_of_subset_left {s t : Set \u03b1} (h : s \u2286 t) (u : Set \u03b1) : s \u2286 t \u222a u :="}
{"input": "Statement in natural language:\nFor a given natural number 'n', if a function 'f' is continuously differentiable at a real number 'x' and the value of 'f' at 'x' is not equal to zero, then the function that takes 'x' to the logarithm of 'f(x)' is also continuously differentiable at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiffAt.log {n} (hf : ContDiffAt \u211d n f x) (hx : f x \u2260 0) :\n    ContDiffAt \u211d n (fun x => log (f x)) x :="}
{"input": "Statement in natural language:\nIf 'h' is a bounded linear map for 'f', then 'f' is differentiable at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsBoundedLinearMap.differentiableAt (h : IsBoundedLinearMap \ud835\udd5c f) : DifferentiableAt \ud835\udd5c f x :="}
{"input": "Statement in natural language:\nThe sphere of dimension 'n', distance 'd', and integer 'k' is a subset of the box of dimension 'n' and distance 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem sphere_subset_box : sphere n d k \u2286 box n d :="}
{"input": "Statement in natural language:\nFor any given stream 's' of type 'Stream' \u03b1, the stream that is formed by prepending the head of 's' to the tail of 's' is equal to the original stream 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem eta (s : Stream' \u03b1) : (head s::tail s) = s :="}
{"input": "Statement in natural language:\nFor any given natural number 'n', the function 'Finset.fin n' is monotone. This means that if 'a' is less than or equal to 'b', then 'Finset.fin n a' is less than or equal to 'Finset.fin n b'.\nTranslate the statement in natural language to Lean:", "output": "theorem fin_mono {n} : Monotone (Finset.fin n) :="}
{"input": "Statement in natural language:\nThe affine map of the affine isometry of a function f is equal to the affine map of the linear map of the same function f.\nTranslate the statement in natural language to Lean:", "output": "theorem toAffineIsometry_toAffineMap : f.toAffineIsometry.toAffineMap = f.toLinearMap.toAffineMap :="}
{"input": "Statement in natural language:\nIf x is coprime with the sum of the product of x and z, and y, then x is coprime with y.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCoprime.of_mul_add_left_right (h : IsCoprime x (x * z + y)) : IsCoprime x y :="}
{"input": "Statement in natural language:\nIf a category C has binary products and equalizers, then it also has pullbacks.\nTranslate the statement in natural language to Lean:", "output": "theorem hasPullbacks_of_hasBinaryProducts_of_hasEqualizers (C : Type u) [Category.{v} C]\n    [HasBinaryProducts C] [HasEqualizers C] : HasPullbacks C :="}
{"input": "Statement in natural language:\nFor any two outer measures 'm\u2081' and 'm\u2082' on a set '\u03b1', and any operation 'op' on non-negative extended real numbers, if for every subset 's' of '\u03b1', 'm\u2081' of 's' equals 'op' applied to 'm\u2082' of 's', then the trimmed version of 'm\u2081' on any subset 's' equals 'op' applied to the trimmed version of 'm\u2082' on that subset.\nTranslate the statement in natural language to Lean:", "output": "theorem trim_op {m\u2081 m\u2082 : OuterMeasure \u03b1} {op : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e} (h : \u2200 s, m\u2081 s = op (m\u2082 s))\n    (s : Set \u03b1) : m\u2081.trim s = op (m\u2082.trim s) :="}
{"input": "Statement in natural language:\nIf we have two topological spaces t\u2081 and t\u2082 on a group G, and both of these topological spaces are topological groups, then the intersection of t\u2081 and t\u2082 is also a topological group.\nTranslate the statement in natural language to Lean:", "output": "theorem topologicalGroup_inf {t\u2081 t\u2082 : TopologicalSpace G} (h\u2081 : @TopologicalGroup G t\u2081 _)\n    (h\u2082 : @TopologicalGroup G t\u2082 _) : @TopologicalGroup G (t\u2081 \u2293 t\u2082) _ :="}
{"input": "Statement in natural language:\nThe union of the image of the diagonal of a set 's' under the quotient map and the image of the off-diagonal of 's' under the quotient map is equal to the symmetric square of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_diag_union_image_offDiag :\n    s.diag.image Quotient.mk' \u222a s.offDiag.image Quotient.mk' = s.sym2 :="}
{"input": "Statement in natural language:\nFor any given multiset 's' of a certain type '\u03b1', where '\u03b1' is a commutative monoid, the noncommutative product of 's' (where all elements commute with each other) is equal to the commutative product of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem noncommProd_eq_prod {\u03b1 : Type _} [CommMonoid \u03b1] (s : Multiset \u03b1) :\n    (noncommProd s fun _ _ _ _ _ => Commute.all _ _) = prod s :="}
{"input": "Statement in natural language:\nThe cardinality (or size) of the support of a permutation f is equal to zero if and only if the permutation f is equal to the identity permutation.\nTranslate the statement in natural language to Lean:", "output": "theorem card_support_eq_zero {f : Perm \u03b1} : f.support.card = 0 \u2194 f = 1 :="}
{"input": "Statement in natural language:\nIf we have an element 'x' from a group 'G', and two numbers 'n' and 'm' that are both less than the order of 'x', then if 'x' raised to the power of 'n' equals 'x' raised to the power of 'm', it must be the case that 'n' equals 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_injective_of_lt_orderOf (x : G) (hn : n < orderOf x) (hm : m < orderOf x)\n    (eq : x ^ n = x ^ m) :\n    n = m :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps an element of type \u03b1 to a list of elements of type \u03b2, a function 'g' that maps an element of type \u03b1 to an element of type \u03c3, and a function 'h' that maps an element of type \u03b1 and a pair of an element of type \u03b2 and an element of type \u03c3 to an element of type \u03c3, if 'f', 'g', and 'h' are primitive recursive functions, then the function that maps an element of type \u03b1 to the result of folding the list obtained from 'f' with the function that maps a pair of an element of type \u03b2 and an element of type \u03c3 to the result of applying 'h' to the element of type \u03b1 and the pair, starting with the result of applying 'g' to the element of type \u03b1, is also a primitive recursive function.\nTranslate the statement in natural language to Lean:", "output": "theorem list_foldr {f : \u03b1 \u2192 List \u03b2} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u03b2 \u00d7 \u03c3 \u2192 \u03c3} (hf : Primrec f)\n    (hg : Primrec g) (hh : Primrec\u2082 h) :\n    Primrec fun a => (f a).foldr (fun b s => h a (b, s)) (g a) :="}
{"input": "Statement in natural language:\nFor a functor 'F' from 'J' to 'C' that has a colimit, the description of the colimit of 'F' with respect to the cocone of the colimit of 'F' is equal to the identity on the colimit of 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem colimit.desc_cocone {F : J \u2964 C} [HasColimit F] :\n    colimit.desc F (colimit.cocone F) = \ud835\udfd9 (colimit F) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' in a Heyting algebra, the supremum (or join) of 'a' and 'b' implies 'a' is equal to 'b' implies 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_himp_self_left (a b : \u03b1) : a \u2294 b \u21e8 a = b \u21e8 a :="}
{"input": "Statement in natural language:\nFor any natural number 'n', converting 'n' to a negative ZNum (an integer type in Lean) is equivalent to the negative of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_nat_toZNumNeg (n : \u2115) : Num.toZNumNeg n = -n :="}
{"input": "Statement in natural language:\nIf a function f\u2081 is eventually equal to a function f within a neighborhood of a point x in a set s, and if a set t is a subset of s, then for any natural number n, the nth iterated Fr\u00e9chet derivative of f\u2081 within the set t is eventually equal to the nth iterated Fr\u00e9chet derivative of f within the set t in the neighborhood of the point x in the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.EventuallyEq.iterated_fderiv_within' (h : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (ht : t \u2286 s) (n : \u2115) :\n    iteratedFDerivWithin \ud835\udd5c n f\u2081 t =\u1da0[\ud835\udcdd[s] x] iteratedFDerivWithin \ud835\udd5c n f t :="}
{"input": "Statement in natural language:\nFor a noncompact space X, the range of the embedding function (which maps X to the one-point compactification of X) is dense.\nTranslate the statement in natural language to Lean:", "output": "theorem denseRange_coe [NoncompactSpace X] : DenseRange ((\u2191) : X \u2192 OnePoint X) :="}
{"input": "Statement in natural language:\nIn a directed system G, where the function from i to j is defined by f(i, j, h), the mapping of an element x from i to itself (i.e., f(i, i, h) x) is equal to x itself.\nTranslate the statement in natural language to Lean:", "output": "theorem DirectedSystem.map_self [DirectedSystem G fun i j h => f i j h] (i x h) :\n    f i i h x = x :="}
{"input": "Statement in natural language:\nIf \"g x\" is an additive unit, then the composition of the lift of \"F\" at \"x\" with respect to \"hg\" and the mapping of \"F\" is equal to \"g\".\nTranslate the statement in natural language to Lean:", "output": "theorem AwayMap.lift_comp (hg : IsAddUnit (g x)) : (F.lift x hg).comp F.toMap = g :="}
{"input": "Statement in natural language:\nFor any sublist 'l\u2081' of 'l\u2082', the count of elements in 'l\u2081' that satisfy a certain property 'p' is less than or equal to the count of elements in 'l\u2082' that satisfy the same property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem Sublist.countp_le (s : l\u2081 <+ l\u2082) : countp p l\u2081 \u2264 countp p l\u2082 :="}
{"input": "Statement in natural language:\nFor any additive commutative group R and any two functions f and g from natural numbers to R, the following two conditions are equivalent:\n\n1. For every natural number n greater than 0, the sum of the function f over all divisors of n equals the value of the function g at n.\n2. For every natural number n greater than 0, the sum of the product of the M\u00f6bius function at the first element of the pair and the function g at the second element of the pair, over all pairs in the antidiagonal divisors of n, equals the value of the function f at n. \n\nHere, the M\u00f6bius function is a number-theoretic function denoted by \u03bc, and the antidiagonal of a number n is the set of pairs of natural numbers that multiply to n.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_eq_iff_sum_smul_moebius_eq [AddCommGroup R] {f g : \u2115 \u2192 R} :\n    (\u2200 n : \u2115, 0 < n \u2192 (\u2211 i in n.divisors, f i) = g n) \u2194\n      \u2200 n : \u2115, 0 < n \u2192 (\u2211 x : \u2115 \u00d7 \u2115 in n.divisorsAntidiagonal, \u03bc x.fst \u2022 g x.snd) = f n :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from type \u03b1 to type \u03b2, and a language 'l' of type \u03b1, the Kleene star of the mapped language 'l' through 'f' is equal to the Kleene star of the language 'l' after it has been mapped through 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_kstar (f : \u03b1 \u2192 \u03b2) (l : Language \u03b1) : map f l\u2217 = (map f l)\u2217 :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from '\u03b1' to '\u03b2' and any set 's' of '\u03b1', given that for all 'x', whether 'x' belongs to 's' is decidable, the restriction of the piecewise function of 's', 'f', and 'g' to the complement of 's' is equal to the restriction of 'g' to the complement of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem restrict_piecewise_compl (f g : \u03b1 \u2192 \u03b2) (s : Set \u03b1) [\u2200 x, Decidable (x \u2208 s)] :\n    s\u1d9c.restrict (piecewise s f g) = s\u1d9c.restrict g :="}
{"input": "Statement in natural language:\nFor any finite type \u03b9, if a prepartition \u03c0 is subordinate to a function r, and for every set J there is a prepartition \u03c0i, then the bi-union prepartition of \u03c0 and \u03c0i is also subordinate to the function r.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSubordinate.biUnionPrepartition [Fintype \u03b9] (h : IsSubordinate \u03c0 r)\n    (\u03c0i : \u2200 J, Prepartition J) : IsSubordinate (\u03c0.biUnionPrepartition \u03c0i) r :="}
{"input": "Statement in natural language:\nFor any two lower sets \ud835\udc9c and \u212c of finite sets of some type \u03b1, if every element t of \ud835\udc9c and \u212c is a subset of a set s, then the product of the cardinalities of \ud835\udc9c and \u212c is less than or equal to the product of the power of 2 to the cardinality of s and the cardinality of the intersection of \ud835\udc9c and \u212c.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLowerSet.le_card_inter_finset' (h\ud835\udc9c : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsLowerSet (\u212c : Set (Finset \u03b1))) (h\ud835\udc9cs : \u2200 t \u2208 \ud835\udc9c, t \u2286 s) (h\u212cs : \u2200 t \u2208 \u212c, t \u2286 s) :\n    \ud835\udc9c.card * \u212c.card \u2264 2 ^ s.card * (\ud835\udc9c \u2229 \u212c).card :="}
{"input": "Statement in natural language:\nFor any set 's' of elements of type \u03b1 and any two elements 'a' and 'u'' of type \u03b1 such that 'a' is less than 'u'', 's' is in the neighborhood within the set of elements greater than 'a' if and only if there exists an element 'u' in the closed-open interval between 'a' and 'u'' such that the open interval between 'a' and 'u' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : \u03b1} {s : Set \u03b1} (hu' : a < u') :\n    s \u2208 \ud835\udcdd[>] a \u2194 \u2203 u \u2208 Ioc a u', Ioo a u \u2286 s :="}
{"input": "Statement in natural language:\nIf the function f tends to c and the function g tends to a as x tends to l, then the function that maps x to the product of f(x) and g(x) tends to the product of c and a as x tends to l.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.smul {f : \u03b1 \u2192 M} {g : \u03b1 \u2192 X} {l : Filter \u03b1} {c : M} {a : X}\n    (hf : Tendsto f l (\ud835\udcdd c)) (hg : Tendsto g l (\ud835\udcdd a)) :\n    Tendsto (fun x => f x \u2022 g x) l (\ud835\udcdd <| c \u2022 a) :="}
{"input": "Statement in natural language:\nThe neighborhood filter of the additive representation of an element 'a' in a topological space is equal to the mapping of the additive representation on the neighborhood filter of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem nhds_ofAdd (a : \u03b1) : \ud835\udcdd (ofAdd a) = map ofAdd (\ud835\udcdd a) :="}
{"input": "Statement in natural language:\nIf for every rational number 'q', 'x' is less than 'q' if and only if 'y' is less than 'q', then 'x' equals 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_forall_lt_rat_iff_lt (h : \u2200 q : \u211a, x < q \u2194 y < q) : x = y :="}
{"input": "Statement in natural language:\nFor any element 'r' of ring 'R', the evaluation ring homomorphism at 'r' is equal to the evaluation at 'r'. This is a function from the polynomial ring 'R[X]' to the ring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_evalRingHom (r : R) : (evalRingHom r : R[X] \u2192 R) = eval r :="}
{"input": "Statement in natural language:\nIf 'X' is a zero object and 'f' is a morphism from 'Y' to 'X', then 'f' is equal to the morphism from 'Y' to the zero object 'X'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_from (h : IsZero X) (f : Y \u27f6 X) : f = h.from_ Y :="}
{"input": "Statement in natural language:\nFor any two integers 'a' and 'b', if 'a' is non-negative (greater than or equal to 0) and 'b' is non-positive (less than or equal to 0), then the absolute value of 'a' is equal to the absolute value of 'b' if and only if 'a' is equal to the negative of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem natAbs_inj_of_nonneg_of_nonpos {a b : \u2124} (ha : 0 \u2264 a) (hb : b \u2264 0) :\n    natAbs a = natAbs b \u2194 a = -b :="}
{"input": "Statement in natural language:\nFor any given type \u03b1 that has a decidable equality, if a multiset s does not contain any duplicate elements (Nodup s), then the intersection of s and any other multiset t (s \u2229 t) also does not contain any duplicate elements (Nodup (s \u2229 t)).\nTranslate the statement in natural language to Lean:", "output": "theorem Nodup.inter_left [DecidableEq \u03b1] (t) : Nodup s \u2192 Nodup (s \u2229 t) :="}
{"input": "Statement in natural language:\nFor any real numbers p, q, and r, and any functions f from \u03b1 to E and g from \u03b1 to F, if f and g are almost everywhere strongly measurable with respect to measure \u03bc, and for almost every x with respect to measure \u03bc, the seminorm of the function b applied to f(x) and g(x) is less than or equal to the product of the seminorms of f(x) and g(x), and if 0 is less than p which is less than q, and 1/p equals 1/q plus 1/r, then the p-seminorm of the function that maps x to b(f(x), g(x)) is less than or equal to the product of the q-seminorm of f and the r-seminorm of g.\nTranslate the statement in natural language to Lean:", "output": "theorem snorm'_le_snorm'_mul_snorm' {p q r : \u211d} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    {g : \u03b1 \u2192 F} (hg : AEStronglyMeasurable g \u03bc) (b : E \u2192 F \u2192 G)\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 \u2016f x\u2016\u208a * \u2016g x\u2016\u208a) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) :\n    snorm' (fun x => b (f x) (g x)) p \u03bc \u2264 snorm' f q \u03bc * snorm' g r \u03bc :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuous on a set 's', and if a function 'g' equals 'f' on a subset 's\u2081' of 's', then 'g' is also continuous on 's\u2081'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousOn.congr_mono {f g : \u03b1 \u2192 \u03b2} {s s\u2081 : Set \u03b1} (h : ContinuousOn f s)\n    (h' : EqOn g f s\u2081) (h\u2081 : s\u2081 \u2286 s) : ContinuousOn g s\u2081 :="}
{"input": "Statement in natural language:\nFor a given element 'b' of type '\u03b2', the coercion of the constant function from '\u03b1' to 'b' is equal to the function that assigns 'b' to every element of type '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_const (b : \u03b2) : \u21d1(const \u03b1 b) = Function.const \u03b1 b :="}
{"input": "Statement in natural language:\nFor any two p-adic numbers z1 and z2, if the norm of the sum of z1 and z2 is less than the norm of z1, then the norm of z1 is equal to the norm of z2.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_norm_add_lt_left {z1 z2 : \u211a_[p]} (h : \u2016z1 + z2\u2016 < \u2016z1\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :="}
{"input": "Statement in natural language:\nFor any simplicial object X in a category A, the composition of the map from P-infinity to the normalized Moore complex of X and the inclusion of the Moore complex map of X is equal to P-infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap (X : SimplicialObject A) :\n    PInftyToNormalizedMooreComplex X \u226b inclusionOfMooreComplexMap X = PInfty :="}
{"input": "Statement in natural language:\nFor any integer special linear group 'g', the negation of 'g' when coerced is equal to the negation of the coerced 'g' in the real special linear group.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_int_neg (g : SpecialLinearGroup n \u2124) : \u2191(-g) = (-\u2191g : SpecialLinearGroup n R) :="}
{"input": "Statement in natural language:\nFor any two sets s and t, the union of the set difference of s and t with t is equal to the union of s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem diff_union_self {s t : Set \u03b1} : s \\ t \u222a t = s \u222a t :="}
{"input": "Statement in natural language:\nFor a polynomial p that is not equal to zero, a value 'a' is a root of the polynomial if and only if 'a' satisfies the root condition of the polynomial p.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_roots (hp : p \u2260 0) : a \u2208 p.roots \u2194 IsRoot p a :="}
{"input": "Statement in natural language:\nFor any integers 'a', 'm', 'b', and 'n', the bitwise OR operation on the bit representation of 'a' and 'm' and the bit representation of 'b' and 'n' is equal to the bit representation of the logical OR operation on 'a' and 'b' and the bitwise OR operation on 'm' and 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem lor_bit (a m b n) : lor (bit a m) (bit b n) = bit (a || b) (lor m n) :="}
{"input": "Statement in natural language:\nThe top element of the open subgroup of G, when considered as a set of G, is equal to the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_top : ((\u22a4 : OpenSubgroup G) : Set G) = Set.univ :="}
{"input": "Statement in natural language:\nThe lift of the tensor product, when applied to a multilinear map over a ring R and some set s, is equal to the identity linear map.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_tprod : lift (tprod R : MultilinearMap R s _) = LinearMap.id :="}
{"input": "Statement in natural language:\nThe distance between the sum of the function f at 0 and the function g at 0, and the function f at the value of function g at 0, is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1 :="}
{"input": "Statement in natural language:\nIf the product of two integers m and n is odd, then n is also odd.\nTranslate the statement in natural language to Lean:", "output": "theorem Odd.of_mul_right (h : Odd (m * n)) : Odd n :="}
{"input": "Statement in natural language:\nIn a nontrivial algebraic structure M, zero is not a strictly multiplicative regular element.\nTranslate the statement in natural language to Lean:", "output": "theorem not_zero [nM : Nontrivial M] : \u00acIsSMulRegular M (0 : R) :="}
{"input": "Statement in natural language:\nFor any two non-negative extended real numbers p and q, where p is less than or equal to q, one of the following must be true:\n\n1. Both p and q are zero.\n2. p is zero and q is infinity.\n3. p is zero and q is a positive real number.\n4. Both p and q are infinity.\n5. p is a positive real number and q is infinity.\n6. Both p and q are positive real numbers and p is less than or equal to q.\nTranslate the statement in natural language to Lean:", "output": "theorem trichotomy\u2082 {p q : \u211d\u22650\u221e} (hpq : p \u2264 q) :\n    p = 0 \u2227 q = 0 \u2228\n      p = 0 \u2227 q = \u221e \u2228\n        p = 0 \u2227 0 < q.toReal \u2228\n          p = \u221e \u2227 q = \u221e \u2228\n            0 < p.toReal \u2227 q = \u221e \u2228 0 < p.toReal \u2227 0 < q.toReal \u2227 p.toReal \u2264 q.toReal :="}
{"input": "Statement in natural language:\nFor a given set of ideals in a ring R, the supremum of the set mapped by a function f is equal to the supremum of each ideal in the set mapped by the function f.\nTranslate the statement in natural language to Lean:", "output": "theorem map_sSup (s : Set (Ideal R)) : (sSup s).map f = \u2a06 I \u2208 s, (I : Ideal R).map f :="}
{"input": "Statement in natural language:\nThe representation of a number 'x' in modular arithmetic is less than 'p' and the difference between 'x' and its modular representation belongs to the maximal ideal of the ring of p-adic integers.\nTranslate the statement in natural language to Lean:", "output": "theorem zmodRepr_spec : zmodRepr x < p \u2227 x - zmodRepr x \u2208 maximalIdeal \u2124_[p] :="}
{"input": "Statement in natural language:\nThe symmetric difference of 'a' and 'b', excluding 'b', is equal to 'a' excluding 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem symmDiff_sdiff_right : a \u2206 b \\ b = a \\ b :="}
{"input": "Statement in natural language:\nFor a given hypothesis \"hp\", and a simple graph \"K\", and another hypothesis \"hp'\", the transfer of \"p\" over graph \"H\" with hypothesis \"hp\", when further transferred over graph \"K\" with hypothesis \"hp'\", is equal to the transfer of \"p\" over graph \"K\" with the hypothesis that is the result of transferring the edges of \"p\" with hypothesis \"hp\" and then applying \"hp'\".\nTranslate the statement in natural language to Lean:", "output": "theorem transfer_transfer (hp) {K : SimpleGraph V} (hp') :\n    (p.transfer H hp).transfer K hp' = p.transfer K (p.edges_transfer hp \u25b8 hp') :="}
{"input": "Statement in natural language:\nThe inverse of the difference between sets S and T under a function \u03d5 is equal to the difference between sets T and S under the same function \u03d5.\nTranslate the statement in natural language to Lean:", "output": "theorem diff_inv : (diff \u03d5 S T)\u207b\u00b9 = diff \u03d5 T S :="}
{"input": "Statement in natural language:\nFor a subgroup 's' of a group 'G', and any other subgroup 't' of 'G' such that 's' is a subset of 't', if 't' is a closed set, then the topological closure of 's' is also a subset of 't'. This is the minimal property of the topological closure of a subgroup.\nTranslate the statement in natural language to Lean:", "output": "theorem Subgroup.topologicalClosure_minimal (s : Subgroup G) {t : Subgroup G} (h : s \u2264 t)\n    (ht : IsClosed (t : Set G)) : s.topologicalClosure \u2264 t :="}
{"input": "Statement in natural language:\nIf a and b commute (meaning the order in which they are multiplied does not change the result), then for any natural numbers m and n, the multiplication of m and a commutes with the multiplication of n and b in the ring R.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_nat_mul_cast_nat_mul (h : Commute a b)\n    (m n : \u2115) : Commute (m * a : R) (n * b : R) :="}
{"input": "Statement in natural language:\nFor a given ring R and an element 'a' of type \u03b1, the total function of the single function applied to 'a' and 'c' is equal to 'c' scaled by the function 'v' applied to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem total_single (c : R) (a : \u03b1) : Finsupp.total \u03b1 M R v (single a c) = c \u2022 v a :="}
{"input": "Statement in natural language:\nThe function 'f' is strictly decreasing on the set 's' if and only if the function 'f' is strictly increasing on the set 's' when composed with the 'toDual' function.\nTranslate the statement in natural language to Lean:", "output": "theorem strictAntiOn_toDual_comp_iff : StrictAntiOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictMonoOn f s :="}
{"input": "Statement in natural language:\nThe representation of the number 1 in the context of a Free Abelian Group of any type \u03b1 is equal to the identity element of the group, which is also 1.\nTranslate the statement in natural language to Lean:", "output": "theorem of_one : (of 1 : FreeAbelianGroup \u03b1) = 1 :="}
{"input": "Statement in natural language:\nFor any type \u03b9 and any function f from \u03b9 to the real numbers, if for all elements in \u03b9 the function f returns a non-negative real number, then the supremum (least upper bound) of the set of all values of f is also non-negative.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_nonneg {\u03b9 : Sort _} {f : \u03b9 \u2192 \u211d} (hf : \u2200 i, 0 \u2264 f i) : 0 \u2264 \u2a06 i, f i :="}
{"input": "Statement in natural language:\nThe absolute value of an integer 'n' cast as a complex number is equal to the absolute value of 'n' as a complex number.\nTranslate the statement in natural language to Lean:", "output": "theorem int_cast_abs (n : \u2124) : (|\u2191n|) = Complex.abs n :="}
{"input": "Statement in natural language:\nThe imaginary part of the division of two elements 'z' and 'w' from a field 'K' is equal to the product of the imaginary part of 'z' and the real part of 'w' divided by the norm squared of 'w', minus the product of the real part of 'z' and the imaginary part of 'w' divided by the norm squared of 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem div_im (z w : K) : im (z / w) = im z * re w / normSq w - re z * im w / normSq w :="}
{"input": "Statement in natural language:\nIf a function f\u2082 has a derivative f\u2082' at a point x, then the function that maps x to the first component of f\u2082(x) has a derivative at x, which is the composition of the first component function with f\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivAt.fst (h : HasFDerivAt f\u2082 f\u2082' x) :\n    HasFDerivAt (fun x => (f\u2082 x).1) ((fst \ud835\udd5c F G).comp f\u2082') x :="}
{"input": "Statement in natural language:\nFor a scalar 'r' from the ring 'R', a seminorm 'p' on the additive group 'E', and an element 'x' from 'E', the application of the scaled seminorm 'r \u2022 p' to 'x' is equal to the scalar 'r' times the application of the seminorm 'p' to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_apply (r : R) (p : AddGroupSeminorm E) (x : E) : (r \u2022 p) x = r \u2022 p x :="}
{"input": "Statement in natural language:\nA set 's' of any type '\u03b1' is equal to the empty set if and only if 's' is equal to the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_eq_empty : (s : Set \u03b1) = \u2205 \u2194 s = \u22a5 :="}
{"input": "Statement in natural language:\nIf for every number \u03b5 greater than 1, a is less than the product of b and \u03b5, then a is less than or equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_forall_one_lt_lt_mul' (h : \u2200 \u03b5 : \u03b1, 1 < \u03b5 \u2192 a < b * \u03b5) : a \u2264 b :="}
{"input": "Statement in natural language:\nIf 'p' is a monic polynomial and 'r' is a root of 'p' (meaning that when 'r' is evaluated at 'p', the result is zero), then 'r' is an integer.\nTranslate the statement in natural language to Lean:", "output": "theorem isInteger_of_is_root_of_monic {p : A[X]} (hp : Monic p) {r : K} (hr : aeval r p = 0) :\n    IsInteger A r :="}
{"input": "Statement in natural language:\nThe empty multiset is disjoint with any given multiset 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_disjoint (l : Multiset \u03b1) : Disjoint 0 l"}
{"input": "Statement in natural language:\nFor a function 'f' from 'X' to 'L' and any two elements 'a' and 'b' in the Lie bracket 'lib R X', the application of the function 'liftAux R f' to the sum of 'a' and 'b' is equal to the sum of the application of the function 'liftAux R f' to 'a' and the application of the function 'liftAux R f' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem liftAux_map_add (f : X \u2192 L) (a b : lib R X) :\n    liftAux R f (a + b) = liftAux R f a + liftAux R f b :="}
{"input": "Statement in natural language:\nFor any three objects X, Y, Z in category C and morphisms f from X to Y and g from X to Z, given a pushout cocone c of f and g, the first morphism of the opposite of c is equal to the opposite of the left morphism of c.\nTranslate the statement in natural language to Lean:", "output": "theorem op_fst {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) : c.op.fst = c.inl.op :="}
{"input": "Statement in natural language:\nFor any function 'ts' mapping from an index set '\u03b9' to the topological spaces of a group 'G', if for every index 'i', the topological space 'ts(i)' forms a topological group, then the infimum of these topological spaces also forms a topological group.\nTranslate the statement in natural language to Lean:", "output": "theorem topologicalGroup_iInf {ts' : \u03b9 \u2192 TopologicalSpace G}\n    (h' : \u2200 i, @TopologicalGroup G (ts' i) _) : @TopologicalGroup G (\u2a05 i, ts' i) _ :="}
{"input": "Statement in natural language:\nFor a given point 'y' in the source of the extended chart at 'I' and 'x', the mapping of the neighborhood of 'y' under the inverse of the extended chart, restricted to the set 's' and the range of 'I', is equal to the neighborhood of 'y' restricted to the set 's'. This holds if 'y' is in the source of the extended chart at 'I' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_extChartAt_symm_nhdsWithin' {y : M} (hy : y \u2208 (extChartAt I x).source) :\n    map (extChartAt I x).symm (\ud835\udcdd[(extChartAt I x).symm \u207b\u00b9' s \u2229 range I] extChartAt I x y) =\n      \ud835\udcdd[s] y :="}
{"input": "Statement in natural language:\nIf a function f has a local extremum at a point a, then if we can derive a proposition p from the fact that f has a local minimum at a, and we can also derive the same proposition p from the fact that f has a local maximum at a, then the proposition p is true.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalExtr.elim {p : Prop} :\n    IsLocalExtr f a \u2192 (IsLocalMin f a \u2192 p) \u2192 (IsLocalMax f a \u2192 p) \u2192 p :="}
{"input": "Statement in natural language:\nA collection of functions is independently measurable if and only if for any finite set of indices and any collection of sets, where each set is measurable with respect to the corresponding function, the measure of the intersection of the preimages of the sets under the functions is equal to the product of the measures of the individual preimages.\nTranslate the statement in natural language to Lean:", "output": "theorem iIndepFun_iff_measure_inter_preimage_eq_mul {\u03b9 : Type _} {\u03b2 : \u03b9 \u2192 Type _}\n    (m : \u2200 x, MeasurableSpace (\u03b2 x)) (f : \u2200 i, \u03a9 \u2192 \u03b2 i) :\n    iIndepFun m f \u03bc \u2194\n      \u2200 (S : Finset \u03b9) {sets : \u2200 i : \u03b9, Set (\u03b2 i)} (_H : \u2200 i, i \u2208 S \u2192 MeasurableSet[m i] (sets i)),\n        \u03bc (\u22c2 i \u2208 S, f i \u207b\u00b9' sets i) = \u220f i in S, \u03bc (f i \u207b\u00b9' sets i) :="}
{"input": "Statement in natural language:\nFor any elements 'a' and 'b' of type '\u03b1', and for any multiset 's' of type '\u03b1', the fold operation on the multiset obtained by adding 'a' to 's' with 'b' as the initial value is equal to the fold operation on 's' with 'a * b' as the initial value.\nTranslate the statement in natural language to Lean:", "output": "theorem fold_cons'_left (b a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).fold op b = s.fold op (a * b) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set, the operation 'toIocMod' applied to the sum of a constant 'p' and 'a', and 'b', is equal to the sum of 'p' and the operation 'toIocMod' applied to 'a' and 'b'. This is under the condition that 'hp' holds.\nTranslate the statement in natural language to Lean:", "output": "theorem toIocMod_add_left' (a b : \u03b1) : toIocMod hp (p + a) b = p + toIocMod hp a b :="}
{"input": "Statement in natural language:\nFor any type '\u03b1' with a topological space structure, the entire set of '\u03b1' (denoted as Set.univ) is quasi-separated if and only if '\u03b1' is a quasi-separated space.\nTranslate the statement in natural language to Lean:", "output": "theorem isQuasiSeparated_univ_iff {\u03b1 : Type _} [TopologicalSpace \u03b1] :\n    IsQuasiSeparated (Set.univ : Set \u03b1) \u2194 QuasiSeparatedSpace \u03b1 :="}
{"input": "Statement in natural language:\nIf function 'g' is measurable and function 'f' is null measurable with respect to measure '\u03bc', then the composition of 'g' and 'f' is also null measurable with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem Measurable.comp_nullMeasurable {g : \u03b2 \u2192 \u03b3} (hg : Measurable g) (hf : NullMeasurable f \u03bc) :\n    NullMeasurable (g \u2218 f) \u03bc :="}
{"input": "Statement in natural language:\nFor any natural number 'm' and any finite number 'i' within the range of 'n + m', if the value of 'i' is less than 'n', then adding 'm' to the cast of 'i' (which is less than 'n') is equal to 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem castAdd_castLT (m : \u2115) (i : Fin (n + m)) (hi : i.val < n) :\n    castAdd m (castLT i hi) = i :="}
{"input": "Statement in natural language:\nFor any types \u03b1 and \u03b2, and for any function f from the sum of \u03b1 and \u03b2 to a finitely supported function on M, and for any element y of \u03b2, the second component of the sum of the finitely supported function and the product of the finitely supported function, evaluated at y, is equal to the function f evaluated at the sum of the right element y.\nTranslate the statement in natural language to Lean:", "output": "theorem snd_sumFinsuppAddEquivProdFinsupp {\u03b1 \u03b2 : Type _} (f : Sum \u03b1 \u03b2 \u2192\u2080 M) (y : \u03b2) :\n    (sumFinsuppAddEquivProdFinsupp f).2 y = f (Sum.inr y) :="}
{"input": "Statement in natural language:\nA list 'l' is a rotated version of list 'l'' if and only if list 'l'' is a rotated version of list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem isRotated_comm : l ~r l' \u2194 l' ~r l :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' greater than 0 and a composition 'c' of 'n', 'c' is equal to the single composition of 'n' if and only if the length of 'c' is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_single_iff_length {n : \u2115} (h : 0 < n) {c : Composition n} :\n    c = single n h \u2194 c.length = 1 :="}
{"input": "Statement in natural language:\nFor any three elements x\u2081, x\u2082, and x\u2083 in a given set \u03b1, the interval from x\u2081 to x\u2082 (inclusive of x\u2081 and exclusive of x\u2082) modulo some positive integer p is less than or equal to the interval from x\u2081 to x\u2083 (exclusive of x\u2081 and inclusive of x\u2083) modulo the same positive integer p if and only if the sum of the intervals from 0 to (x\u2082 - x\u2081) and from 0 to (x\u2081 - x\u2083) (both inclusive of 0 and exclusive of the end point) is less than or equal to p.\nTranslate the statement in natural language to Lean:", "output": "theorem toIxxMod_iff (x\u2081 x\u2082 x\u2083 : \u03b1) : toIcoMod hp x\u2081 x\u2082 \u2264 toIocMod hp x\u2081 x\u2083 \u2194\n    toIcoMod hp 0 (x\u2082 - x\u2081) + toIcoMod hp 0 (x\u2081 - x\u2083) \u2264 p :="}
{"input": "Statement in natural language:\nFor any three elements x, y, and y' in a module M, the polar of the quadratic form Q of x and the sum of y and y' is equal to the sum of the polar of the quadratic form Q of x and y and the polar of the quadratic form Q of x and y'.\nTranslate the statement in natural language to Lean:", "output": "theorem polar_add_right (x y y' : M) : polar Q x (y + y') = polar Q x y + polar Q x y' :="}
{"input": "Statement in natural language:\nFor any natural numbers n, \u03bd, and k, if k is less than \u03bd, then the k-th derivative of the Bernstein polynomial of n and \u03bd evaluated at 0 is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_derivative_at_0_eq_zero_of_lt (n : \u2115) {\u03bd k : \u2115} :\n    k < \u03bd \u2192 ((Polynomial.derivative^[k]) (bernsteinPolynomial R n \u03bd)).eval 0 = 0 :="}
{"input": "Statement in natural language:\nIf the functions f and g are continuous at a point a within a set s, and if g at point a is not equal to zero, then the function resulting from the division of f by g is also continuous at point a within the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousWithinAt.div (hf : ContinuousWithinAt f s a)\n    (hg : ContinuousWithinAt g s a) (h\u2080 : g a \u2260 0) : ContinuousWithinAt (f / g) s a :="}
{"input": "Statement in natural language:\nThe operation that maps an element from the set M to its opposite in M is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_op : Continuous (op : M \u2192 M\u1d50\u1d52\u1d56) :="}
{"input": "Statement in natural language:\nFor any two multisets s and t, s is less than or equal to the sum of t and s.\nTranslate the statement in natural language to Lean:", "output": "theorem le_add_left (s t : Multiset \u03b1) : s \u2264 t + s :="}
{"input": "Statement in natural language:\nFor a compact space \u03b1 and a set S in \u03b1 that is closed and nonempty, there exists a subset V of S that is also closed and nonempty, and is minimal in the sense that any other subset V' of V that is closed and nonempty must be equal to V.\nTranslate the statement in natural language to Lean:", "output": "theorem IsClosed.exists_minimal_nonempty_closed_subset [CompactSpace \u03b1] {S : Set \u03b1}\n    (hS : IsClosed S) (hne : S.Nonempty) :\n    \u2203 V : Set \u03b1, V \u2286 S \u2227 V.Nonempty \u2227 IsClosed V \u2227\n      \u2200 V' : Set \u03b1, V' \u2286 V \u2192 V'.Nonempty \u2192 IsClosed V' \u2192 V' = V :="}
{"input": "Statement in natural language:\nFor any function 'f' from 'i' to '\u03b1', the infimum (greatest lower bound) over all 'i' and 'j' of 'f i j' equals the top element if and only if for all 'i' and 'j', 'f i j' equals the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf\u2082_eq_top {f : \u2200 i, \u03ba i \u2192 \u03b1} : (\u2a05 (i) (j), f i j) = \u22a4 \u2194 \u2200 i j, f i j = \u22a4 :="}
{"input": "Statement in natural language:\nIf a measure \u03bd is less than or equal to a measure \u03bc, and if a function f belongs to the space of p-integrable functions with respect to the measure \u03bc, then the function f also belongs to the space of p-integrable functions with respect to the measure \u03bd.\nTranslate the statement in natural language to Lean:", "output": "theorem Mem\u2112p.mono_measure {f : \u03b1 \u2192 E} (h\u03bc\u03bd : \u03bd \u2264 \u03bc) (hf : Mem\u2112p f p \u03bc) : Mem\u2112p f p \u03bd :="}
{"input": "Statement in natural language:\nIf a function 'f' is convex on a set 's' in a field '\ud835\udd5c', then for any value 'r' in the ordered field '\u03b2', the set of all 'x' in 's' for which 'f(x)' is less than 'r' is also convex in '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem ConvexOn.convex_lt (hf : ConvexOn \ud835\udd5c s f) (r : \u03b2) : Convex \ud835\udd5c ({ x \u2208 s | f x < r }) :="}
{"input": "Statement in natural language:\nFor a given natural number N and a polynomial f of type R[X], the support of the reflection of f at N is equal to the image of the support of f under the function revAt N.\nTranslate the statement in natural language to Lean:", "output": "theorem reflect_support (N : \u2115) (f : R[X]) :\n    (reflect N f).support = Finset.image (revAt N) f.support :="}
{"input": "Statement in natural language:\nFor any Turing machine tape T and any integer i, the i-th element of the tape after moving left is equal to the (i-1)-th element of the original tape. This assumes that the type \u0393, which represents the symbols on the tape, is inhabited (i.e., there is at least one symbol).\nTranslate the statement in natural language to Lean:", "output": "theorem Tape.move_left_nth {\u0393} [Inhabited \u0393] :\n    \u2200 (T : Tape \u0393) (i : \u2124), (T.move Dir.left).nth i = T.nth (i - 1)"}
{"input": "Statement in natural language:\nFor a given element 'a' and a given multiset 's', the supremum (greatest element) of the multiset resulting from the non-duplicate insertion of 'a' into 's' is equal to the supremum of 'a' and the supremum of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).sup = a \u2294 s.sup :="}
{"input": "Statement in natural language:\nFor two multiplicative monoids with zero (M and N), a monoid homomorphism with zero (constructed with a function f and proofs h1 and hmul) is equal to the function f when both are considered as functions from M to N.\nTranslate the statement in natural language to Lean:", "output": "theorem MonoidWithZeroHom.coe_mk [MulZeroOneClass M] [MulZeroOneClass N] (f h1 hmul) :\n  (MonoidWithZeroHom.mk f h1 hmul : M \u2192 N) = (f : M \u2192 N) :="}
{"input": "Statement in natural language:\nIf the counit of a homomorphism 'h' is an isomorphism, then 'R' is faithful.\nTranslate the statement in natural language to Lean:", "output": "theorem R_faithful_of_counit_isIso [IsIso h.counit] : Faithful R :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the blocks of 'ones' of 'n' is equal to the replication of 'n' times of the natural number '1'.\nTranslate the statement in natural language to Lean:", "output": "theorem ones_blocks (n : \u2115) : (ones n).blocks = replicate n (1 : \u2115) :="}
{"input": "Statement in natural language:\nThe co-domain of the indexed supremum of a function mapping to an upper set is equal to the intersection of the function over all indices.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_iSup (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2191(\u2a06 i, f i) : Set \u03b1) = \u22c2 i, f i :="}
{"input": "Statement in natural language:\nFor all lists 'l' of any type '\u03b1', the function 'List.length' is continuous at 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousAt_length : \u2200 l : List \u03b1, ContinuousAt List.length l :="}
{"input": "Statement in natural language:\nFor a given element 'a' from set A, if 'g x' is an additive unit, then applying the lift function to 'x' with respect to 'g x' and then applying the 'toMap' function to 'a' is equal to applying 'g' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem AwayMap.lift_eq (hg : IsAddUnit (g x)) (a : A) : F.lift x hg (F.toMap a) = g a :="}
{"input": "Statement in natural language:\nIf the characteristic polynomial of a matrix A splits over the ring R, then the determinant of the matrix A is equal to the product of the roots of the characteristic polynomial of A.\nTranslate the statement in natural language to Lean:", "output": "theorem det_eq_prod_roots_charpoly_of_splits (hAps : A.charpoly.Splits (RingHom.id R)) :\n    A.det = (Matrix.charpoly A).roots.prod :="}
{"input": "Statement in natural language:\nFor any point x in Euclidean space E and any real number r, the open ball centered at x with radius r is equal to the preimage of the open ball in the metric space, centered at the Euclidean image of x with radius r, under the Euclidean mapping.\nTranslate the statement in natural language to Lean:", "output": "theorem ball_eq_preimage (x : E) (r : \u211d) :\n    ball x r = toEuclidean \u207b\u00b9' Metric.ball (toEuclidean x) r :="}
{"input": "Statement in natural language:\nFor any bounded formula \u03c6 in the language L with \u03b1 variables and n+1 bound variables, the theory T considers the universal quantification of \u03c6 and the negation of the existential quantification of the negation of \u03c6 to be semantically equivalent.\nTranslate the statement in natural language to Lean:", "output": "theorem all_semanticallyEquivalent_not_ex_not (\u03c6 : L.BoundedFormula \u03b1 (n + 1)) :\n    T.SemanticallyEquivalent \u03c6.all \u03c6.not.ex.not :="}
{"input": "Statement in natural language:\nIf the maximum element of a finite set 's' of some type '\u03b1' is less than an element 'a' of the same type, then 'a' is not an element of the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_of_max_lt_coe {a : \u03b1} {s : Finset \u03b1} (h : s.max < a) : a \u2209 s :="}
{"input": "Statement in natural language:\nThe non-negative distance between the conjugate of a complex number 'z' and 'z' itself is equal to two times the non-negative absolute value of the imaginary part of 'z'.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_conj_self (z : \u2102) : nndist (conj z) z = 2 * Real.nnabs z.im :="}
{"input": "Statement in natural language:\nFor any additive zero class 'G' and any element 'a' of the multiplicative version of 'G', the application of 'of' function on 'k', 'G', and 'a' is equal to the application of 'single' function on the additive version of 'a' and 1.\nTranslate the statement in natural language to Lean:", "output": "theorem of_apply [AddZeroClass G] (a : Multiplicative G) :\n    of k G a = single (Multiplicative.toAdd a) 1 :="}
{"input": "Statement in natural language:\nFor a given set 's' of type \u03b1, a function 'f' from \u03b1 to \u03b2, and a family of sets 't' indexed by \u03b9, if the function 'f' maps every element of 's' to each set 't i' for all 'i', then the function 'f' also maps every element of 's' to the intersection of all sets 't i'.\nTranslate the statement in natural language to Lean:", "output": "theorem mapsTo_iInter {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, MapsTo f s (t i)) :\n    MapsTo f s (\u22c2 i, t i) :="}
{"input": "Statement in natural language:\nFor a given natural number 'n', if the set of all elements satisfying a property 'p' is finite and 'n' satisfies property 'p', then the count of elements satisfying property 'p' up to 'n' is less than the cardinality of the finite set of all elements satisfying property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem count_lt_card {n : \u2115} (hp : (setOf p).Finite) (hpn : p n) : count p n < hp.toFinset.card :="}
{"input": "Statement in natural language:\nIf a pair (x, y) is in the graph of a linear map f from E to F, then x is in the domain of f.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_domain_of_mem_graph {f : E \u2192\u2097.[R] F} {x : E} {y : F} (h : (x, y) \u2208 f.graph) :\n    x \u2208 f.domain :="}
{"input": "Statement in natural language:\nIn a topological space without a minimum order, given two elements 'a' and 'b' such that 'a' is less than 'b', the frontier (the set of all points that can be approached both from within the set and from outside the set) of the interval from 'a' to 'b' (including 'a' but excluding 'b') is the set containing 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem frontier_Ico [NoMinOrder \u03b1] {a b : \u03b1} (h : a < b) : frontier (Ico a b) = {a, b} :="}
{"input": "Statement in natural language:\nFor a decidable predicate function where a is less than or equal to j and j is less than or equal to b, filtering the universal set with this function results in the closed interval from a to b.\nTranslate the statement in natural language to Lean:", "output": "theorem filter_le_le_eq_Icc [DecidablePred fun j => a \u2264 j \u2227 j \u2264 b] :\n    (univ.filter fun j => a \u2264 j \u2227 j \u2264 b) = Icc a b :="}
{"input": "Statement in natural language:\nA module M over a ring R is Noetherian if and only if the relation \"greater than\" is well-founded on the set of finitely generated submodules of M.\nTranslate the statement in natural language to Lean:", "output": "theorem isNoetherian_iff_fg_wellFounded :\n    IsNoetherian R M \u2194\n      WellFounded\n        ((\u00b7 > \u00b7) : { N : Submodule R M // N.FG } \u2192 { N : Submodule R M // N.FG } \u2192 Prop) :="}
{"input": "Statement in natural language:\nFor any natural numbers k and n, given that k is not equal to 0, 1 is less than n to the power of k if and only if 1 is less than n.\nTranslate the statement in natural language to Lean:", "output": "theorem one_lt_pow_iff {k n : \u2115} (h : 0 \u2260 k) : 1 < n ^ k \u2194 1 < n :="}
{"input": "Statement in natural language:\nFor any three ordinals a, b, and c, if the natural sum of b and a is less than or equal to the natural sum of c and a, then b is less than or equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_nadd_le_nadd_right : \u2200 {a b c}, b \u266f a \u2264 c \u266f a \u2192 b \u2264 c :="}
{"input": "Statement in natural language:\nIf measure \u03bc is absolutely continuous with respect to measure \u03bd, then measure \u03bd is an open positive measure.\nTranslate the statement in natural language to Lean:", "output": "theorem AbsolutelyContinuous.isOpenPosMeasure (h : \u03bc \u226a \u03bd) : IsOpenPosMeasure \u03bd :="}
{"input": "Statement in natural language:\nFor a given function from natural numbers to a type \u03b4, which is an additive commutative monoid, and given natural numbers k, m, and n such that m is less than or equal to n + 1, the sum of the function applied to (n - j) for each j in the interval from k to m (not including m) is equal to the sum of the function applied to j for each j in the interval from (n + 1 - m) to (n + 1 - k) (not including n + 1 - k).\nTranslate the statement in natural language to Lean:", "output": "theorem sum_Ico_reflect {\u03b4 : Type _} [AddCommMonoid \u03b4] (f : \u2115 \u2192 \u03b4) (k : \u2115) {m n : \u2115}\n    (h : m \u2264 n + 1) : (\u2211 j in Ico k m, f (n - j)) = \u2211 j in Ico (n + 1 - m) (n + 1 - k), f j :="}
{"input": "Statement in natural language:\nFor a non-negative real number 'a' and two functions 'g' and 'h' that map to non-negative real numbers, if for all pairs of inputs 'i' and 'j', the product of 'g(i)' and 'h(j)' is less than or equal to 'a', then the product of the supremum of 'g' and the supremum of 'h' is also less than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_mul_iSup_le {a : \u211d\u22650} {g h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 i j, g i * h j \u2264 a) :\n    iSup g * iSup h \u2264 a :="}
{"input": "Statement in natural language:\nFor a simple function 'f' from '\u03b1' to the real numbers, if 'f' is integrable with respect to measure '\u03bc' and 'f' is almost everywhere nonnegative with respect to measure '\u03bc', then the integral of 'f' with respect to '\u03bc' is equal to the real part of the extended nonnegative real integral of 'f' with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_eq_lintegral {f : \u03b1 \u2192\u209b \u211d} (hf : Integrable f \u03bc) (h_pos : 0 \u2264\u1d50[\u03bc] f) :\n    f.integral \u03bc = ENNReal.toReal (\u222b\u207b a, ENNReal.ofReal (f a) \u2202\u03bc) :="}
{"input": "Statement in natural language:\nFor a topological space \u03b1, an open measurable space \u03b1, a normed space over the real numbers \u211d, and a complete space E, given a locally finite measure \u03bc on \u03b1, a point a in \u03b1, and a function f from \u03b1 to E that is continuous at a and strongly measurable at the neighborhood filter of a with respect to \u03bc, if we have a sequence of sets s indexed by \u03b9 that tends to the small sets of the neighborhood of a under a filter li, and a function m from \u03b9 to \u211d defined as the real part of the measure of the sets s, then the function that maps each index i to the integral of f over the set s[i] minus the product of m[i] and the value of f at a, is little o of m with respect to the filter li. This means that the difference between the integral of f over the sets s and the product of m and f(a) becomes negligible compared to m as we approach a under the filter li.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousAt.integral_sub_linear_isLittleO_ae [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1]\n    [NormedSpace \u211d E] [CompleteSpace E] {\u03bc : Measure \u03b1} [IsLocallyFiniteMeasure \u03bc] {a : \u03b1}\n    {f : \u03b1 \u2192 E} (ha : ContinuousAt f a) (hfm : StronglyMeasurableAtFilter f (\ud835\udcdd a) \u03bc) {s : \u03b9 \u2192 Set \u03b1}\n    {li : Filter \u03b9} (hs : Tendsto s li (\ud835\udcdd a).smallSets) (m : \u03b9 \u2192 \u211d := fun i => (\u03bc (s i)).toReal)\n    (hs\u03bc : (fun i => (\u03bc (s i)).toReal) =\u1da0[li] m := by rfl) :\n    (fun i => (\u222b x in s i, f x \u2202\u03bc) - m i \u2022 f a) =o[li] m :="}
{"input": "Statement in natural language:\nFor a given injective function 'f' from type \u03b1 to \u03b2, and for two functions 'l\u2081' and 'l\u2082' from \u03b1 to some type M, the embedding of the domain of 'l\u2081' and 'l\u2082' through 'f' are equal if and only if 'l\u2081' and 'l\u2082' are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem embDomain_inj {f : \u03b1 \u21aa \u03b2} {l\u2081 l\u2082 : \u03b1 \u2192\u2080 M} : embDomain f l\u2081 = embDomain f l\u2082 \u2194 l\u2081 = l\u2082 :="}
{"input": "Statement in natural language:\nFor a block diagonal matrix M, indexed by o, with dimensions m by n and entries in \u03b1, the value at position (ik, jk) is equal to the value at position (ik.2, ik.1, jk.1) in the matrix M indexed by ik.2 if ik.2 equals jk.2, otherwise it is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem blockDiagonal_apply (M : o \u2192 Matrix m n \u03b1) (ik jk) :\n    blockDiagonal M ik jk = if ik.2 = jk.2 then M ik.2 ik.1 jk.1 else 0 :="}
{"input": "Statement in natural language:\nThe set of all elements greater than or equal to a certain value 'a' is bounded below.\nTranslate the statement in natural language to Lean:", "output": "theorem bddBelow_Ici : BddBelow (Ici a) :="}
{"input": "Statement in natural language:\nIf we have a uniformly continuous function 'f' from 'Y' to 'X', and a constant 'c' from set 'M', then the function resulting from scaling 'f' by 'c' is also uniformly continuous. This is under the condition that 'M' and 'X' satisfy the Uniform Continuous Constant Scalar Multiplication property.\nTranslate the statement in natural language to Lean:", "output": "theorem UniformContinuous.const_smul [UniformContinuousConstSMul M X] {f : Y \u2192 X}\n    (hf : UniformContinuous f) (c : M) : UniformContinuous (c \u2022 f) :="}
{"input": "Statement in natural language:\nFor a basis 'b' of type 'Basis \u03b9 R S', given a non-zero element 'x' of type 'S' and an index 'i' of type '\u03b9', the application of 'basisSpanSingleton' function on 'b', 'hx' (which is the proof that 'x' is not zero), and 'i' is equal to the product of 'x' and the 'i'-th element of the basis 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem basisSpanSingleton_apply (b : Basis \u03b9 R S) {x : S} (hx : x \u2260 0) (i : \u03b9) :\n    (basisSpanSingleton b hx i : S) = x * b i :="}
{"input": "Statement in natural language:\nFor any two types \u03b2 and \u03b3, if we have two functions f and g from a type \u03b1 to the partial functions from \u03b2 to \u03b3 and \u03b2 respectively, and if both f and g are continuous, then the function that maps each element of type \u03b1 to the application of the function f(x) to g(x) is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem seq_continuous' {\u03b2 \u03b3 : Type v} (f : \u03b1 \u2192 Part (\u03b2 \u2192 \u03b3)) (g : \u03b1 \u2192 Part \u03b2) (hf : Continuous' f)\n    (hg : Continuous' g) : Continuous' fun x => f x <*> g x :="}
{"input": "Statement in natural language:\nIf a function f has a derivative at a point x, and either a constant c is not equal to zero or the function evaluated at x is not zero, then the derivative of the function that maps x to the constant c raised to the power of f(x) exists at the point x. This derivative is equal to the product of the function evaluated at x, the natural logarithm of the constant c, and the derivative of the function f at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :="}
{"input": "Statement in natural language:\nFor any type N that is a seminormed additive commutative group, any additive subgroup S of M, any normed additive group homomorphism f from M to N that maps all elements of S to 0, and any element m of M, the lift of f to the quotient of M by S at the equivalence class of m under the quotient map is equal to the value of f at m.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_mk {N : Type _} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) (m : M) :\n    lift S f hf (S.normedMk m) = f m :="}
{"input": "Statement in natural language:\nIf c is less than or equal to a and c is less than or equal to b, then the difference of a and c being equal to the difference of b and c implies that a is equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem tsub_left_inj (h1 : c \u2264 a) (h2 : c \u2264 b) : a - c = b - c \u2194 a = b :="}
{"input": "Statement in natural language:\nIf the product comparison of F, A, and B is an isomorphism, then the composition of the inverse of the product comparison of F, A, and B and the mapping of the second product under F is equal to the second product.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) \u226b F.map prod.snd = prod.snd :="}
{"input": "Statement in natural language:\nFor any type 'J' with a preorder and a direction, and a functor 'F' from the opposite of 'J' to some type 'v', if every object 'j' of the opposite of 'J' has a finite 'F' and is nonempty, then there exist nonempty sections of 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_sections_of_finite_inverse_system {J : Type u} [Preorder J] [IsDirected J (\u00b7 \u2264 \u00b7)]\n    (F : J\u1d52\u1d56 \u2964 Type v) [\u2200 j : J\u1d52\u1d56, Finite (F.obj j)] [\u2200 j : J\u1d52\u1d56, Nonempty (F.obj j)] :\n    F.sections.Nonempty :="}
{"input": "Statement in natural language:\nFor any function 'f' that maps each 'i' to a continuous linear equivalence between 'E i' and 'E\u2081 i', the inverse of the composition of 'f' with a continuous linear map equivalence 'G' is equal to the composition of the inverse of 'f' with 'G'.\nTranslate the statement in natural language to Lean:", "output": "theorem compContinuousLinearMapEquivL_symm (f : \u2200 i, E i \u2243L[\ud835\udd5c] E\u2081 i) :\n    (compContinuousLinearMapEquivL G f).symm =\n      compContinuousLinearMapEquivL G fun i : \u03b9 => (f i).symm :="}
{"input": "Statement in natural language:\nFor any three elements x, y, and z in the ring of fractions R[S\u207b\u00b9], the right distribution law holds. That is, the product of the sum of x and y with z is equal to the sum of the product of x with z and the product of y with z.\nTranslate the statement in natural language to Lean:", "output": "theorem right_distrib (x y z : R[S\u207b\u00b9]) : (x + y) * z = x * z + y * z :="}
{"input": "Statement in natural language:\nFor every element 'y' in the multiplicative set 'M', 'y' is a unit under the algebraic mapping from ring 'R' to ring 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_units : \u2200 y : M, IsUnit (algebraMap R S y) :="}
{"input": "Statement in natural language:\nFor any morphisms 'f' from 'W' to 'X' and 'g' from 'X' to 'Y', the composition of 'f' and 'g' tensor the identity on 'Z' is equal to the tensor product of 'f' and the identity on 'Z' composed with the tensor product of 'g' and the identity on 'Z'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_tensor_id (f : W \u27f6 X) (g : X \u27f6 Y) : f \u226b g \u2297 \ud835\udfd9 Z = (f \u2297 \ud835\udfd9 Z) \u226b (g \u2297 \ud835\udfd9 Z) :="}
{"input": "Statement in natural language:\nThe negation of the bottom element (false) in a Heyting algebra is equal to the top element (true).\nTranslate the statement in natural language to Lean:", "output": "theorem hnot_bot : \uffe2(\u22a5 : \u03b1) = \u22a4 :="}
{"input": "Statement in natural language:\nThe inverse of the local equivalence transformation of the smooth manifold with corners, when applied to the model vector space E, is equal to the inverse of the smooth manifold with corners itself.\nTranslate the statement in natural language to Lean:", "output": "theorem toLocalEquiv_coe_symm : (I.toLocalEquiv.symm : E \u2192 H) = I.symm :="}
{"input": "Statement in natural language:\nFor a function 'g' mapping from an arbitrary set '\u03b1' to non-negative real numbers, if 'g' is summable and there exists an element 'i' in '\u03b1' such that 'g(i)' is greater than zero, then the sum of 'g' over all elements in '\u03b1' is also greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_pos {g : \u03b1 \u2192 \u211d\u22650} (hg : Summable g) (i : \u03b1) (hi : 0 < g i) : 0 < \u2211' b, g b :="}
{"input": "Statement in natural language:\nThe derivative of the star of a regular expression P with respect to a symbol a is equal to the product of the derivative of P with respect to a and the star of P.\nTranslate the statement in natural language to Lean:", "output": "theorem deriv_star (P : RegularExpression \u03b1) (a : \u03b1) : deriv P.star a = deriv P a * star P :="}
{"input": "Statement in natural language:\nFor any two ordered sets \u03b1 and \u03b2, given a set t in \u03b2 that is an antichain (a set of elements in which no two elements are comparable) and a function \u03c6 that is an order isomorphism between \u03b1 and \u03b2, the preimage of t under \u03c6 (the set of all elements in \u03b1 that \u03c6 maps to elements in t) is also an antichain.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_iso [LE \u03b1] [LE \u03b2] {t : Set \u03b2} (ht : IsAntichain (\u00b7 \u2264 \u00b7) t) (\u03c6 : \u03b1 \u2243o \u03b2) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 \u207b\u00b9' t) :="}
{"input": "Statement in natural language:\nFor a set I of type \u03b2 and a function S from \u03b2 to a set of type \u03b1, if I is finite, then the set of all elements that are less than or equal to all elements in the union of S i for all i in I is equivalent to the statement that for all i in I, the set of all elements that are less than or equal to all elements in S i.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.bddBelow_biUnion {I : Set \u03b2} {S : \u03b2 \u2192 Set \u03b1} (H : I.Finite) :\n    BddBelow (\u22c3 i \u2208 I, S i) \u2194 \u2200 i \u2208 I, BddBelow (S i) :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'a' and 'b', the multinomial of the universal set with the vector [a, b] is equal to the factorial of (a + b) divided by the product of the factorials of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem multinomial_univ_two (a b : \u2115) :\n    multinomial Finset.univ ![a, b] = (a + b)! / (a ! * b !) :="}
{"input": "Statement in natural language:\nThe integral of a constant function over the unit interval is equal to the constant itself.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_const_on_unit_interval : (\u222b _ in a..a + 1, b) = b :="}
{"input": "Statement in natural language:\nFor a type \u03b1 that is a subsingleton (a type with at most one element) and has a preorder (a binary relation describing an order on \u03b1), the bottom filter (the set of all neighborhoods of the bottom element) is equal to the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem Subsingleton.atBot_eq (\u03b1) [Subsingleton \u03b1] [Preorder \u03b1] : (atBot : Filter \u03b1) = \u22a4 :="}
{"input": "Statement in natural language:\nIn a topological space that is also a Polish space, if a set is open, then the set itself is a Polish space.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.IsOpen.polishSpace {\u03b1 : Type _} [TopologicalSpace \u03b1] [PolishSpace \u03b1] {s : Set \u03b1}\n    (hs : IsOpen s) : PolishSpace s :="}
{"input": "Statement in natural language:\nIf a function 'f' is surjective (meaning that for every element in the target set there is at least one element in the domain that maps to it), then the inverse function of 'f' is a right inverse of 'f'. A right inverse means that if you apply 'f' and then apply its inverse, you get back to where you started.\nTranslate the statement in natural language to Lean:", "output": "theorem rightInverse_invFun (hf : Surjective f) : RightInverse (invFun f) f :="}
{"input": "Statement in natural language:\nIf there is a permutation between two lists l\u2081 and l\u2082 of elements of type \u03b1, then the lists obtained by applying a function f (from \u03b1 to \u03b2) to each element of l\u2081 and l\u2082 are also permutations of each other.\nTranslate the statement in natural language to Lean:", "output": "theorem Perm.map (f : \u03b1 \u2192 \u03b2) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : map f l\u2081 ~ map f l\u2082 :="}
{"input": "Statement in natural language:\nA number 'a' does not belong to the interval that is strictly greater than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_Ioi_self : a \u2209 Ioi a :="}
{"input": "Statement in natural language:\nThe kernel of the function 'inl' (which injects the module M into the direct sum of M and M\u2082) is the trivial submodule, denoted by \u22a5, in the ring R.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_inl : ker (inl R M M\u2082) = \u22a5 :="}
{"input": "Statement in natural language:\nFor two functions 'f' mapping from set \u03b1 to set \u03b2, and 'g' mapping from set \u03b2 to set \u03b3, if 'g' is an inducing function, then the function 'f' is continuous at a point 'x' in set \u03b1 if and only if the composition of 'g' and 'f' is also continuous at the same point 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem Inducing.continuousAt_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) {x : \u03b1} :\n    ContinuousAt f x \u2194 ContinuousAt (g \u2218 f) x :="}
{"input": "Statement in natural language:\nFor any real number p that is greater than or equal to 0 and less than or equal to 1, and for any two non-negative extended real numbers a and b, the power of the sum of a and b to the p is less than or equal to the sum of a to the power of p and b to the power of p.\nTranslate the statement in natural language to Lean:", "output": "theorem rpow_add_le_add_rpow {p : \u211d} (a b : \u211d\u22650\u221e) (hp : 0 \u2264 p) (hp1 : p \u2264 1) :\n    (a + b) ^ p \u2264 a ^ p + b ^ p :="}
{"input": "Statement in natural language:\nFor a given polynomial 'p' over the real numbers, if 'p' is not equal to zero, then the degree of the derivative of 'p' is less than the degree of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_derivative_lt {p : R[X]} (hp : p \u2260 0) : p.derivative.degree < p.degree :="}
{"input": "Statement in natural language:\nIf we have two disjoint sets 's' and 't', and if the function 'f' has a sum 'a' over the set 's' and a sum 'b' over the set 't', then the function 'f' has a sum of 'a + b' over the union of the sets 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasSum.add_disjoint {s t : Set \u03b2} (hs : Disjoint s t) (ha : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a)\n    (hb : HasSum (f \u2218 (\u2191) : t \u2192 \u03b1) b) : HasSum (f \u2218 (\u2191) : (s \u222a t : Set \u03b2) \u2192 \u03b1) (a + b) :="}
{"input": "Statement in natural language:\nFor any basis 'b' of a module 'S' over a ring 'R' indexed by '\u03b9', and any non-trivial ideal 'I' of 'S', there exists another basis 'b'' of 'S', a function 'a' from '\u03b9' to 'R', and a basis 'ab'' of 'I' such that for all 'i' in '\u03b9', the 'i'-th element of 'ab'' when considered as an element of 'S', is equal to the 'i'-th element of 'a' scaled by the 'i'-th element of 'b''. This is known as the Smith normal form.\nTranslate the statement in natural language to Lean:", "output": "theorem Ideal.exists_smith_normal_form (b : Basis \u03b9 R S) (I : Ideal S) (hI : I \u2260 \u22a5) :\n    \u2203 (b' : Basis \u03b9 R S)(a : \u03b9 \u2192 R)(ab' : Basis \u03b9 R I), \u2200 i, (ab' i : S) = a i \u2022 b' i :="}
{"input": "Statement in natural language:\nFor a given type R and a type \u03b1 that has two scalar multiplication operations (one with R and one with the opposite of R), and where R is a central scalar for \u03b1, for any element r of type R and any element a of type \u03b1, the opposite of the result of scalar multiplication of r and a is equal to the result of scalar multiplication of the opposite of r and the opposite of a.\nTranslate the statement in natural language to Lean:", "output": "theorem op_smul_eq_op_smul_op {R : Type _} [SMul R \u03b1] [SMul R\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar R \u03b1]\n    (r : R) (a : \u03b1) : op (r \u2022 a) = op r \u2022 op a :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any boolean 'b', if 'n' equals 0 implies 'b' equals true, then the bits of the bit 'b' appended to 'n' are equal to the boolean 'b' followed by the bits of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem bits_append_bit (n : \u2115) (b : Bool) (hn : n = 0 \u2192 b = true) :\n    (bit b n).bits = b :: n.bits :="}
{"input": "Statement in natural language:\nFor any integer 'i' in the modulo 'n' set, casting 'i' to an integer and then to a real number 'R' is equal to the original 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem int_cast_cast (i : ZMod n) : ((i : \u2124) : R) = i :="}
{"input": "Statement in natural language:\nIf 'x' is an irrational number and 'm' is a natural number, then 'x' is not equal to 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_nat (h : Irrational x) (m : \u2115) : x \u2260 m :="}
{"input": "Statement in natural language:\nFor any two setoids 'r' and 's' of type '\u03b1', 'r' is equal to 's' if and only if for all elements 'a' and 'b', the relation 'Rel' of 'r' between 'a' and 'b' is equivalent to the relation 'Rel' of 's' between 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {r s : Setoid \u03b1} : r = s \u2194 \u2200 a b, r.Rel a b \u2194 s.Rel a b :="}
{"input": "Statement in natural language:\nThe direction of the affine span of a set S is equal to the vector span of the set S in a field K.\nTranslate the statement in natural language to Lean:", "output": "theorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s :="}
{"input": "Statement in natural language:\nThe difference between any set 's' and an empty set is equal to the set 's' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem diff_empty {s : Set \u03b1} : s \\ \u2205 = s :="}
{"input": "Statement in natural language:\nIf a function 'f' approximately linear on a set 's' with a constant 'c' and a continuous linear map 'f' from 'E' to 'F', and either 'E' is a subsingleton or 'c' is less than the inverse of 'N', and 's' is an open set, then the function 'f' when converted to a local homeomorphism is equal to the original function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem toLocalHomeomorph_coe (hf : ApproximatesLinearOn f (f' : E \u2192L[\ud835\udd5c] F) s c)\n    (hc : Subsingleton E \u2228 c < N\u207b\u00b9) (hs : IsOpen s) :\n    (hf.toLocalHomeomorph f s hc hs : E \u2192 F) = f :="}
{"input": "Statement in natural language:\nThe ordinal representation of the number 1 is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem toOrdinal_one : toOrdinal 1 = 1 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', the set of all elements 'b' that are related to 'a' by the relation 'r' is bounded.\nTranslate the statement in natural language to Lean:", "output": "theorem bounded_self (a : \u03b1) : Bounded r { b | r b a } :="}
{"input": "Statement in natural language:\nFor any natural number 'n', casting 'n' as a rational number and then converting it to a Cauchy sequence with respect to the absolute value function, results in the original natural number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofRat_natCast (n : \u2115) : (ofRat n : Cauchy abv) = n :="}
{"input": "Statement in natural language:\nFor a natural number 'b' greater than 1, and any natural numbers 'x' and 'y' such that 'x' is less than 'b' and either 'x' or 'y' is not zero, the digits of 'x + b * y' in base 'b' are the same as the digit 'x' followed by the digits of 'y' in base 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem digits_add (b : \u2115) (h : 1 < b) (x y : \u2115) (hxb : x < b) (hxy : x \u2260 0 \u2228 y \u2260 0) :\n    digits b (x + b * y) = x :: digits b y :="}
{"input": "Statement in natural language:\nIn a preordered set with a least element, given a function 'f' from index set '\u03b9' to '\u03b1' that is directed (i.e., for any two elements in the range of 'f', there is a third element that is greater than or equal to both), and another function 'e' from '\u03b9' to '\u03b2' that is injective (i.e., no two different elements in '\u03b9' map to the same element in '\u03b2'), the function that extends 'f' to '\u03b2' using 'e' and maps any element not in the domain of 'e' to the least element of '\u03b1' is also directed.\nTranslate the statement in natural language to Lean:", "output": "theorem Directed.extend_bot [Preorder \u03b1] [OrderBot \u03b1] {e : \u03b9 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1}\n    (hf : Directed (\u00b7 \u2264 \u00b7) f) (he : Function.Injective e) :\n    Directed (\u00b7 \u2264 \u00b7) (Function.extend e f \u22a5) :="}
{"input": "Statement in natural language:\nFor a given normed additive group homomorphism 'g' from V\u2082 to V\u2083, and two real numbers C\u2081 and C\u2082, if the norm of 'g' is less than or equal to C\u2082 and the norm of 'f' is less than or equal to C\u2081, then the norm of the composition of 'g' and 'f' is less than or equal to the product of C\u2082 and C\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_comp_le_of_le {g : NormedAddGroupHom V\u2082 V\u2083} {C\u2081 C\u2082 : \u211d} (hg : \u2016g\u2016 \u2264 C\u2082)\n    (hf : \u2016f\u2016 \u2264 C\u2081) : \u2016g.comp f\u2016 \u2264 C\u2082 * C\u2081 :="}
{"input": "Statement in natural language:\nFor any two subalgebras S and T of a ring R acting on an algebra A, and any two subalgebras S\u2081 and T\u2081 of the same ring R acting on another algebra B, if S is a subset of T and S\u2081 is a subset of T\u2081, then the product of S and S\u2081 is a subset of the product of T and T\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_mono {S T : Subalgebra R A} {S\u2081 T\u2081 : Subalgebra R B} :\n    S \u2264 T \u2192 S\u2081 \u2264 T\u2081 \u2192 prod S S\u2081 \u2264 prod T T\u2081 :="}
{"input": "Statement in natural language:\nFor a given filter 'l' and a function 'f' from '\u03b1' to complex numbers, and given complex numbers 'a' and 'b', if 'f' tends towards 'b' as 'l' tends towards a neighborhood of 'b', and either 'a' is not equal to 0 or 'b' is not equal to 0, then the function that maps 'x' to 'a' raised to the power of 'f(x)' tends towards 'a' raised to the power of 'b' as 'l' tends towards a neighborhood of 'a' raised to the power of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.const_cpow {l : Filter \u03b1} {f : \u03b1 \u2192 \u2102} {a b : \u2102} (hf : Tendsto f l (\ud835\udcdd b))\n    (h : a \u2260 0 \u2228 b \u2260 0) : Tendsto (fun x => a ^ f x) l (\ud835\udcdd (a ^ b)) :="}
{"input": "Statement in natural language:\nIf a function 'f' is Holder continuous with constants 'C' and 'r' on a set 's', and 't' is a subset of 's', then the Emetric diameter of the image of 't' under 'f' is less than or equal to 'C' times the Emetric diameter of 't' raised to the power of 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem ediam_image_le_of_subset (hf : HolderOnWith C r f s) (ht : t \u2286 s) :\n    EMetric.diam (f '' t) \u2264 (C : \u211d\u22650\u221e) * EMetric.diam t ^ (r : \u211d) :="}
{"input": "Statement in natural language:\nThe function which maps a real number x to the logarithm of x divided by the square root of x is antitone (decreasing) on the set of real numbers x such that e squared is less than or equal to x.\nTranslate the statement in natural language to Lean:", "output": "theorem log_div_sqrt_antitoneOn : AntitoneOn (fun x : \u211d => log x / sqrt x) { x | exp 2 \u2264 x } :="}
{"input": "Statement in natural language:\nIf G is less than or equal to G', F is a presheaf with respect to J, and G' is a sheaf with respect to J, then the sheafification of G with respect to J is less than or equal to G'.\nTranslate the statement in natural language to Lean:", "output": "theorem Subpresheaf.sheafify_le (h : G \u2264 G') (hF : Presieve.IsSheaf J F)\n    (hG' : Presieve.IsSheaf J G'.toPresheaf) : G.sheafify J \u2264 G' :="}
{"input": "Statement in natural language:\nFor any element 'a' in group 'G', the inverse of the left multiplication by 'a' is equivalent to the function that multiplies by the inverse of 'a' on the left.\nTranslate the statement in natural language to Lean:", "output": "theorem mulLeft_symm_apply (a : G) : ((Equiv.mulLeft a).symm : G \u2192 G) = (a\u207b\u00b9 * \u00b7) :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1 and a function 'f' from \u03b2 to \u03b1, the infimum (greatest lower bound) over all options 'o' of \u03b2, where 'o' is eliminated by 'a' and 'f', is equal to the infimum of 'a' and the infimum over all 'b' of the function 'f' applied to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_option_elim (a : \u03b1) (f : \u03b2 \u2192 \u03b1) : (\u2a05 o : Option \u03b2, o.elim a f) = a \u2293 \u2a05 b, f b :="}
{"input": "Statement in natural language:\nFor any commutative ring R and any ring A, with A being an algebra over R, and for any subalgebra S of A, the difference of two elements x and y in S, when coerced to A, is equal to the difference of the coerced elements x and y in A.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sub {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S : Subalgebra R A} (x y : S) : (\u2191(x - y) : A) = \u2191x - \u2191y :="}
{"input": "Statement in natural language:\nFor a permutation 'f' of type '\u03b1', if for all 'x', 'p x' is equivalent to 'p (f x)', and for all 'x', if 'f x' is not equal to 'x' then 'p x' holds, then the permutation of the subtype generated by 'f' and 'h\u2081' is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofSubtype_subtypePerm {f : Perm \u03b1} (h\u2081 : \u2200 x, p x \u2194 p (f x)) (h\u2082 : \u2200 x, f x \u2260 x \u2192 p x) :\n    ofSubtype (subtypePerm f h\u2081) = f :="}
{"input": "Statement in natural language:\nFor any four vertices u, v, u', and v' in a quiver, given that u equals u' and v equals v', for any path p from u to v and any path p' from u' to v', the path p cast from u to v equals the path p' if and only if the path p is heterogeneously equal to the path p'.\nTranslate the statement in natural language to Lean:", "output": "theorem Path.cast_eq_iff_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (p : Path u v)\n    (p' : Path u' v') : p.cast hu hv = p' \u2194 HEq p p' :="}
{"input": "Statement in natural language:\nFor all elements 'a' of a certain set '\u03b1', 'a' divides 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_rfl : \u2200 {a : \u03b1}, a \u2223 a :="}
{"input": "Statement in natural language:\nFor any two elements x and y in a group with zero, if x is a unit (i.e., it has a multiplicative inverse), then the product of the inverse of x and the product of x and y equals y. This essentially means that multiplying by the inverse of x on the left cancels out the multiplication by x.\nTranslate the statement in natural language to Lean:", "output": "theorem inverse_mul_cancel_left (x y : M\u2080) (h : IsUnit x) : inverse x * (x * y) = y :="}
{"input": "Statement in natural language:\nThe image of two sets s and t under a function f is empty if and only if either set s is empty or set t is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem image2_eq_empty_iff : image2 f s t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205 :="}
{"input": "Statement in natural language:\nFor any two non-negative real numbers 'x' and 'y', and any real number 'z' that is not equal to zero, 'x' raised to the power of 'z' is equal to 'y' raised to the power of 'z' if and only if 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem rpow_eq_rpow_iff {x y : \u211d\u22650} {z : \u211d} (hz : z \u2260 0) : x ^ z = y ^ z \u2194 x = y :="}
{"input": "Statement in natural language:\nThe function 'inr', which maps from \u03b2 to the sum of \u03b1 and \u03b2, is a closed embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem closedEmbedding_inr : ClosedEmbedding (inr : \u03b2 \u2192 Sum \u03b1 \u03b2) :="}
{"input": "Statement in natural language:\nThe second number in the Fibonacci sequence is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem fib_two : fib 2 = 1 :="}
{"input": "Statement in natural language:\nIf the cardinality of a set \u03b1 is less than a number n, then the graph G is n-clique-free. This means that there are no complete subgraphs of G with n vertices.\nTranslate the statement in natural language to Lean:", "output": "theorem cliqueFree_of_card_lt [Fintype \u03b1] (hc : card \u03b1 < n) : G.CliqueFree n :="}
{"input": "Statement in natural language:\nFor a given relation 'r' on some type '\u03b1', the quotient set of 'r' is a subsingleton if and only if the equivalence generated by 'r' is the top element (i.e., the whole set).\nTranslate the statement in natural language to Lean:", "output": "theorem Quot.subsingleton_iff (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Subsingleton (Quot r) \u2194 EqvGen r = \u22a4 :="}
{"input": "Statement in natural language:\nFor any two positive natural numbers n and m, n is less than the sum of n and m.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_add_right (n m : \u2115+) : n < n + m :="}
{"input": "Statement in natural language:\nIf for every index 'i', the function 'f' tends from the filter 'x i' to the filter 'y i', then 'f' tends from the infimum of the filters 'x' to the infimum of the filters 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_iInf_iInf {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : \u03b9 \u2192 Filter \u03b2}\n    (h : \u2200 i, Tendsto f (x i) (y i)) : Tendsto f (iInf x) (iInf y) :="}
{"input": "Statement in natural language:\nFor a given box 'I' and a function 'r' that maps from a real-valued function to the open interval of real numbers greater than zero, there exists a tagged prepartition '\u03c0' of 'I' such that '\u03c0' is a partition, '\u03c0' is Henstock (satisfies the Henstock condition), '\u03c0' is subordinate to 'r', and for every box 'J' in '\u03c0', there exists a natural number 'm' such that for all 'i', the difference between the upper and lower bounds of 'J' is equal to the difference between the upper and lower bounds of 'I' divided by 2 to the power of 'm'. Furthermore, the distortion of '\u03c0' is equal to the distortion of 'I'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_taggedPartition_isHenstock_isSubordinate_homothetic (I : Box \u03b9)\n    (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)) :\n    \u2203 \u03c0 : TaggedPrepartition I, \u03c0.IsPartition \u2227 \u03c0.IsHenstock \u2227 \u03c0.IsSubordinate r \u2227\n      (\u2200 J \u2208 \u03c0, \u2203 m : \u2115, \u2200 i, (J : _).upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) \u2227\n        \u03c0.distortion = I.distortion :="}
{"input": "Statement in natural language:\nThe filter generated by the union of two sets, s and t, is equal to the intersection of the filter generated by set s and the filter generated by set t.\nTranslate the statement in natural language to Lean:", "output": "theorem generate_union {s t : Set (Set \u03b1)} :\n    Filter.generate (s \u222a t) = Filter.generate s \u2293 Filter.generate t :="}
{"input": "Statement in natural language:\nThe set of non-zero elements in the difference between function 'f' and function 'g\u2081' is the same as the set of non-zero elements in the difference between function 'f' and function 'g\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem neLocus_sub_left : neLocus (f - g\u2081) (f - g\u2082) = neLocus g\u2081 g\u2082 :="}
{"input": "Statement in natural language:\nIf set t is a subset of the union of sets s and u, and set u is a subset of the union of sets s and t, then the union of sets s and t is equal to the union of sets s and u.\nTranslate the statement in natural language to Lean:", "output": "theorem union_congr_left (ht : t \u2286 s \u222a u) (hu : u \u2286 s \u222a t) : s \u222a t = s \u222a u :="}
{"input": "Statement in natural language:\nA set containing a pair of the same element (a, a) is equal to a set containing just that element a.\nTranslate the statement in natural language to Lean:", "output": "theorem pair_eq_singleton (a : \u03b1) : ({a, a} : Set \u03b1) = {a} :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from vector space 'V' to 'V\u2082', a submodule 'p' of 'V\u2082', and a scalar 'a' from field 'K', the preimage of 'p' under the scalar multiplication of 'f' by 'a' is equal to the greatest lower bound of the preimage of 'p' under 'f', given that 'a' is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_smul' (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V\u2082) (a : K) :\n    p.comap (a \u2022 f) = iInf (fun _ : a \u2260 0 => p.comap f) :="}
{"input": "Statement in natural language:\nFor any two elements 'v' and 'w' of the inner product space 'E', if the inner product of 'v' and 'w' equals zero, then the norm of the difference between 'w' and 'v' is equal to the norm of the sum of 'w' and 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_sub_eq_norm_add {v w : E} (h : \u27eav, w\u27eb = 0) : \u2016w - v\u2016 = \u2016w + v\u2016 :="}
{"input": "Statement in natural language:\nIf a set 's' is separable and 'u' is a subset of 's', then 'u' is also separable.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSeparable.mono {s u : Set \u03b1} (hs : IsSeparable s) (hu : u \u2286 s) : IsSeparable u :="}
{"input": "Statement in natural language:\nA function 'f' has a finite integral with respect to the sum of measures '\u03bc' and '\u03bd' if and only if 'f' has a finite integral with respect to both '\u03bc' and '\u03bd' individually.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFiniteIntegral_add_measure {f : \u03b1 \u2192 \u03b2} :\n    HasFiniteIntegral f (\u03bc + \u03bd) \u2194 HasFiniteIntegral f \u03bc \u2227 HasFiniteIntegral f \u03bd :="}
{"input": "Statement in natural language:\nFor a given set 's' and a function 't' that for every 'i' gives a set of '\u03b1' dependent on '\u03ba i', if 's' is a subset of 't i j' for every 'i' and 'j', then 's' is a subset of the intersection of all 't i j'.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_iInter\u2082 {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b1} (h : \u2200 i j, s \u2286 t i j) :\n    s \u2286 \u22c2 (i) (j), t i j :="}
{"input": "Statement in natural language:\nIf a group G satisfies the Normalizer Condition, then for any prime number p and any Sylow p-subgroup P of G (assuming that the set of all such Sylow p-subgroups is finite), the subgroup P is a normal subgroup of G.\nTranslate the statement in natural language to Lean:", "output": "theorem normal_of_normalizerCondition (hnc : NormalizerCondition G) {p : \u2115} [Fact p.Prime]\n    [Finite (Sylow p G)] (P : Sylow p G) : (\u2191P : Subgroup G).Normal :="}
{"input": "Statement in natural language:\nFor a set 'b' which is a topological basis, and another set 's', 's' is dense if and only if for every element 'o' in 'b', if 'o' is nonempty, then the intersection of 'o' and 's' is also nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem IsTopologicalBasis.dense_iff {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b) {s : Set \u03b1} :\n    Dense s \u2194 \u2200 o \u2208 b, Set.Nonempty o \u2192 (o \u2229 s).Nonempty :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set '\u03b1' to a set 'M' and a finite set 's' of '\u03b1', the infinite product of 'f' over the elements in the set 's' is equal to the finite product of 'f' over the elements in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_mem_coe_finset (f : \u03b1 \u2192 M) (s : Finset \u03b1) :\n    (\u220f\u1da0 i \u2208 (s : Set \u03b1), f i) = \u220f i in s, f i :="}
{"input": "Statement in natural language:\nFor any finite number 'j' within the range 'n', 'j' as a natural number is less than the successor of the index of 'j' in the composition 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_sizeUpTo_index_succ (j : Fin n) : (j : \u2115) < c.sizeUpTo (c.index j).succ :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't', if for every element 'b', there is a Galois connection between 'l\u2081 b' and 'swap u b', and for every element 'a', there is a Galois connection between 'toDual \u2218 l\u2082 a' and 'u a \u2218 ofDual', then the infimum of the image of 'u' over the Cartesian product of 's' and 't' is equal to the result of applying 'u' to the infimum of 's' and the supremum of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_image2_eq_sInf_sSup (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n    (h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\n    sInf (image2 u s t) = u (sInf s) (sSup t) :="}
{"input": "Statement in natural language:\nFor a sequence of sets 's' indexed by natural numbers, if each set in the sequence is measurable, then the limit superior (limsup) of the sequence with respect to the filter at the top is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_limsup {s : \u2115 \u2192 Set \u03b1} (hs : \u2200 n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.limsup s Filter.atTop :="}
{"input": "Statement in natural language:\nThere exists a unique integer 'm' such that the sum of 'b' and 'm' times 'a' is in the open interval between 'c' and 'c + a'. Here, 'a' is a positive number.\nTranslate the statement in natural language to Lean:", "output": "theorem existsUnique_add_zsmul_mem_Ioc {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n    \u2203! m : \u2124, b + m \u2022 a \u2208 Set.Ioc c (c + a) :="}
{"input": "Statement in natural language:\nIf L is algebraic over K and A is algebraic over L, then A is algebraic over K. This is a transitivity property in the context of algebraic extensions.\nTranslate the statement in natural language to Lean:", "output": "theorem isAlgebraic_trans (L_alg : IsAlgebraic K L) (A_alg : IsAlgebraic L A) :\n    IsAlgebraic K A :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from '\u03b9' to 'E', if 'f' is linearly independent, then the Gram-Schmidt process applied to 'f' results in an orthonormal set.\nTranslate the statement in natural language to Lean:", "output": "theorem gramSchmidt_orthonormal {f : \u03b9 \u2192 E} (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    Orthonormal \ud835\udd5c (gramSchmidtNormed \ud835\udd5c f) :="}
{"input": "Statement in natural language:\nIf a set 's' is in the neighborhood of 1 in a topological group, then the product of the set 's' and the singleton set containing 'a' is in the neighborhood of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_singleton_mem_nhds_of_nhds_one (a : \u03b1) (h : s \u2208 \ud835\udcdd (1 : \u03b1)) : s * {a} \u2208 \ud835\udcdd a :="}
{"input": "Statement in natural language:\nFor a finite measure '\u03bc' and two bounded real-valued non-negative functions 'f\u2081' and 'f\u2082', testing '\u03bc' against the sum of 'f\u2081' and 'f\u2082' is equal to the sum of testing '\u03bc' against 'f\u2081' and testing '\u03bc' against 'f\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem testAgainstNN_add (\u03bc : FiniteMeasure \u03a9) (f\u2081 f\u2082 : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.testAgainstNN (f\u2081 + f\u2082) = \u03bc.testAgainstNN f\u2081 + \u03bc.testAgainstNN f\u2082 :="}
{"input": "Statement in natural language:\nFor any non-negative real number 'a' that is not infinity, 'a' is additively left cancellable. This means that for any two real numbers, if adding 'a' to both does not change their equality, then the two numbers were originally equal.\nTranslate the statement in natural language to Lean:", "output": "theorem cancel_of_ne {a : \u211d\u22650\u221e} (h : a \u2260 \u221e) : AddLECancellable a :="}
{"input": "Statement in natural language:\nThe inverse of a function that is within a range is surjective. This means that for every element in the codomain, there is at least one element in the domain that maps to it.\nTranslate the statement in natural language to Lean:", "output": "theorem invOfMemRange_surjective : Function.Surjective hf.invOfMemRange :="}
{"input": "Statement in natural language:\nThe first element of the negation of 'x' is equal to the negation of the first element of 'x'. Here, 'x' is an element of the set 'X q'.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_fst (x : X q) : (-x).1 = -x.1 :="}
{"input": "Statement in natural language:\nThe inverse of the pure function of a is equal to the pure function of the inverse of a.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_pure : (pure a)\u207b\u00b9 = pure a\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any two flows \u03d5\u2081 and \u03d5\u2082 of a dynamical system with time \u03c4 and state space \u03b1, if for all times t and states x, the state at time t under flow \u03d5\u2081 is the same as the state at time t under flow \u03d5\u2082, then the two flows \u03d5\u2081 and \u03d5\u2082 are identical.\nTranslate the statement in natural language to Lean:", "output": "theorem ext : \u2200 {\u03d5\u2081 \u03d5\u2082 : Flow \u03c4 \u03b1}, (\u2200 t x, \u03d5\u2081 t x = \u03d5\u2082 t x) \u2192 \u03d5\u2081 = \u03d5\u2082"}
{"input": "Statement in natural language:\nThe function 'Sum.inr' (which maps from set Y to the disjoint union of sets X and Y) is an isometry. This means that it preserves the distance between points, i.e., the distance between any two points in Y is the same as the distance between their images in the disjoint union of X and Y.\nTranslate the statement in natural language to Lean:", "output": "theorem isometry_inr : Isometry (Sum.inr : Y \u2192 Sum X Y) :="}
{"input": "Statement in natural language:\nThe operator norm of the composition of a continuous linear map 'f' and the continuous linear map corresponding to a linear isometry equivalence 'g' is equal to the operator norm of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem op_norm_comp_linearIsometryEquiv (f : F \u2192SL[\u03c3\u2082\u2083] G) (g : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F) :\n    \u2016f.comp g.toLinearIsometry.toContinuousLinearMap\u2016 = \u2016f\u2016 :="}
{"input": "Statement in natural language:\nFor any morphisms 'f' from 'W' to 'X' and 'g' from 'Y' to 'Z' in a monoidal category, the composition of the tensor product of the identity on 'Y' and 'f', followed by the tensor product of 'g' and the identity on 'X', is equal to the tensor product of 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem id_tensor_comp_tensor_id (f : W \u27f6 X) (g : Y \u27f6 Z) : (\ud835\udfd9 Y \u2297 f) \u226b (g \u2297 \ud835\udfd9 X) = g \u2297 f :="}
{"input": "Statement in natural language:\nFor a probability measure \u03bc and a function f from \u03b1 to E, the average value of f with respect to \u03bc is equal to the integral of f with respect to \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem average_eq_integral [IsProbabilityMeasure \u03bc] (f : \u03b1 \u2192 E) : (\u2a0d x, f x \u2202\u03bc) = \u222b x, f x \u2202\u03bc :="}
{"input": "Statement in natural language:\nIf two multisets 's' and 't' are disjoint, then 't' and 's' are also disjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem Disjoint.symm {s t : Multiset \u03b1} (d : Disjoint s t) : Disjoint t s"}
{"input": "Statement in natural language:\nThe hyperbolic cosine of any real number is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem cosh_pos (x : \u211d) : 0 < Real.cosh x :="}
{"input": "Statement in natural language:\nFor a given subspace 'p' of the real numbers in 'E' and a function 'f' from 'p' to the real numbers, there exists a function 'g' from 'E' to the real numbers such that for all 'x' in 'p', 'g' at 'x' equals 'f' at 'x' and the norm of 'g' equals the norm of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_extension_norm_eq (p : Subspace \u211d E) (f : p \u2192L[\u211d] \u211d) :\n    \u2203 g : E \u2192L[\u211d] \u211d, (\u2200 x : p, g x = f x) \u2227 \u2016g\u2016 = \u2016f\u2016 :="}
{"input": "Statement in natural language:\nFor any function 'f' from a sort '\u03b9' to a type '\u03b1', where '\u03b1' is a conditionally complete linear order with a bottom element, the supremum (least upper bound) of the image of 'f' in the extended real number system (which includes positive infinity) is less than positive infinity if and only if the range of 'f' is bounded above.\nTranslate the statement in natural language to Lean:", "output": "theorem WithTop.iSup_coe_lt_top {\u03b9 : Sort _} {\u03b1 : Type _} [ConditionallyCompleteLinearOrderBot \u03b1]\n    (f : \u03b9 \u2192 \u03b1) : (\u2a06 x, (f x : WithTop \u03b1)) < \u22a4 \u2194 BddAbove (Set.range f) :="}
{"input": "Statement in natural language:\nFor a given list 'l' of type '\u03b4', a function '\u03bc' that assigns a measure to each element 'i', and a condition that each measure '\u03bc i' is sigma-finite, and a function 's' that assigns a set to each element 'i', the measure of the product of the list 'l' and the function '\u03bc' on the product of the set 'l' and the function 's' is equal to the product of the list 'l' mapped with the function that assigns the measure '\u03bc i' to the set 's i'.\nTranslate the statement in natural language to Lean:", "output": "theorem tprod_tprod (l : List \u03b4) (\u03bc : \u2200 i, Measure (\u03c0 i)) [\u2200 i, SigmaFinite (\u03bc i)]\n    (s : \u2200 i, Set (\u03c0 i)) :\n    Measure.tprod l \u03bc (Set.tprod l s) = (l.map fun i => (\u03bc i) (s i)).prod :="}
{"input": "Statement in natural language:\nIf a set 's' in the field 'F' is strictly convex, and if there is a function 'f' from 'E' to 'F' that is a linear map, continuous, and injective, then the preimage of 's' under 'f' is also strictly convex in the field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictConvex.is_linear_preimage {s : Set F} (hs : StrictConvex \ud835\udd5c s) {f : E \u2192 F}\n    (h : IsLinearMap \ud835\udd5c f) (hf : Continuous f) (hfinj : Injective f) :\n    StrictConvex \ud835\udd5c (s.preimage f) :="}
{"input": "Statement in natural language:\nFor a real-valued function 'f' and two real numbers 'a' and 'b', the average value of 'f' over the interval from 'a' to 'b' is equal to the inverse of the difference between 'b' and 'a' times the integral of 'f' over the interval from 'a' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem interval_average_eq (f : \u211d \u2192 E) (a b : \u211d) :\n    (\u2a0d x in a..b, f x) = (b - a)\u207b\u00b9 \u2022 \u222b x in a..b, f x :="}
{"input": "Statement in natural language:\nFor a given filter 'l' of type \u03b1, constants 'b' of type \u03b2 and 'c' of type \u03b3, and a function 'f' from \u03b2 to \u03b3 to \u03b4, mapping 'f' over the germ of 'b' and the germ of 'c' with respect to the filter 'l' is equal to the germ of the function 'f' applied to 'b' and 'c' with respect to the same filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_const (l : Filter \u03b1) (b : \u03b2) (c : \u03b3) (f : \u03b2 \u2192 \u03b3 \u2192 \u03b4) :\n    map\u2082 f (\u2191b : Germ l \u03b2) \u2191c = \u2191(f b c) :="}
{"input": "Statement in natural language:\nIn a semigroup \u03b1, for any elements x and y in \u03b1, the composition of the function that multiplies by x with the function that multiplies by y is the same as the function that multiplies by the product of y and x.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_mul_right [Semigroup \u03b1] (x y : \u03b1) : (\u00b7 * x) \u2218 (\u00b7 * y) = (\u00b7 * (y * x)) :="}
{"input": "Statement in natural language:\nFor any game 'x', the sum of 'x' and its negative '-x' is less than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem add_right_neg_le_zero (x : PGame) : x + -x \u2264 0 :="}
{"input": "Statement in natural language:\nIf for all pairs of elements x and y from a set \u03b1, the function f applied to x is less than or equal to the function f applied to y plus a non-negative real number K times the distance between x and y, then the function f is Lipschitz with constant K.\nTranslate the statement in natural language to Lean:", "output": "theorem of_le_add_mul {f : \u03b1 \u2192 \u211d} (K : \u211d\u22650) (h : \u2200 x y, f x \u2264 f y + K * dist x y) :\n    LipschitzWith K f :="}
{"input": "Statement in natural language:\nFor any two fractional ideals I and J in a ring of fractions S over a ring P, and any two elements i and j from the ring P such that i is in I and j is in J, the product of i and j is in the product of I and J.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_mem_mul {I J : FractionalIdeal S P} {i j : P} (hi : i \u2208 I) (hj : j \u2208 J) :\n    i * j \u2208 I * J :="}
{"input": "Statement in natural language:\nFor any index 'i', 'i' is in the split support of 'l' if and only if the split of 'l' at index 'i' is not zero.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_splitSupport_iff_nonzero (i : \u03b9) : i \u2208 splitSupport l \u2194 split l i \u2260 0 :="}
{"input": "Statement in natural language:\nFor a given signed measure 's' and a measure '\u03bc' in a set '\u03b1', the singular part of the positive part of the Jordan decomposition of 's' is mutually singular with the singular part of the negative part of the Jordan decomposition of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem singularPart_mutuallySingular (s : SignedMeasure \u03b1) (\u03bc : Measure \u03b1) :\n    s.toJordanDecomposition.posPart.singularPart \u03bc \u27c2\u2098\n      s.toJordanDecomposition.negPart.singularPart \u03bc :="}
{"input": "Statement in natural language:\nFor a subgroup N of a group G, if N is normal and a set s is a subset of N, then the normal closure of s is less than or equal to N.\nTranslate the statement in natural language to Lean:", "output": "theorem normalClosure_le_normal {N : Subgroup G} [N.Normal] (h : s \u2286 N) : normalClosure s \u2264 N :="}
{"input": "Statement in natural language:\nFor any two rational numbers q and r, the numerator of (q - r) multiplied by the denominator of q and the denominator of r is equal to the difference of the product of the numerator of q and the denominator of r and the product of the numerator of r and the denominator of q, all multiplied by the denominator of (q - r).\nTranslate the statement in natural language to Lean:", "output": "theorem substr_num_den' (q r : \u211a) :\n    (q - r).num * q.den * r.den = (q.num * r.den - r.num * q.den) * (q - r).den :="}
{"input": "Statement in natural language:\nIf we have a covariant class for addition and less than or equal to, and another covariant class for swapped addition and less than, and if d is not the smallest element, and if a is less than b, and if c is less than or equal to d, then the sum of a and c is less than the sum of b and d.\nTranslate the statement in natural language to Lean:", "output": "theorem add_lt_add_of_lt_of_le [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (hd : d \u2260 \u22a5) (hab : a < b) (hcd : c \u2264 d) :\n    a + c < b + d :="}
{"input": "Statement in natural language:\nFor any hyperreal number 'x' and any real number 'r', if 'x' is a standard part of 'r', then 'x' is also a standard part of the standard part of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSt.isSt_st {x : \u211d*} {r : \u211d} (hxr : IsSt x r) : IsSt x (st x) :="}
{"input": "Statement in natural language:\nFor a certain algebraic structure (specifically a monoid with an order), given that the structure is covariant with respect to multiplication and less than operation, and contravariant with respect to multiplication and less than or equal to operation, if a is less than or equal to c and b is less than or equal to d, then the product of a and b equals the product of c and d if and only if a equals c and b equals d.\nTranslate the statement in natural language to Lean:", "output": "theorem Left.mul_eq_mul_iff_eq_and_eq [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (hac : a \u2264 c) (hbd : b \u2264 d) :\n    a * b = c * d \u2194 a = c \u2227 b = d :="}
{"input": "Statement in natural language:\nA function 'f' is continuously differentiable 'n' times in the Euclidean space if and only if for all 'i', the function that maps 'x' to 'f x i' is also continuously differentiable 'n' times.\nTranslate the statement in natural language to Lean:", "output": "theorem contDiff_euclidean {n : \u2115\u221e} : ContDiff \ud835\udd5c n f \u2194 \u2200 i, ContDiff \ud835\udd5c n fun x => f x i :="}
{"input": "Statement in natural language:\nFor a given type \u03b9, functions f from \u03b9 to \u03b2 and g from \u03b2 to \u03b3, a filter a on \u03b9, and a value b in \u03b2, if g is an open embedding, then the function f tends towards the neighborhood of b under the filter a if and only if the composition of g and f tends towards the neighborhood of g(b) under the same filter a.\nTranslate the statement in natural language to Lean:", "output": "theorem OpenEmbedding.tendsto_nhds_iff {\u03b9 : Type _} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b9} {b : \u03b2}\n    (hg : OpenEmbedding g) : Tendsto f a (\ud835\udcdd b) \u2194 Tendsto (g \u2218 f) a (\ud835\udcdd (g b)) :="}
{"input": "Statement in natural language:\nThe sum of the floor values of two numbers 'a' and 'b' is less than or equal to the floor value of their sum.\nTranslate the statement in natural language to Lean:", "output": "theorem le_floor_add (a b : \u03b1) : \u230aa\u230b + \u230ab\u230b \u2264 \u230aa + b\u230b :="}
{"input": "Statement in natural language:\nA sequence 'u' is a Cauchy sequence if and only if for every 'i' such that property 'p' holds for 'i', there exists a 'N' such that for all 'm' and 'n' greater than or equal to 'N', the pair (u m, u n) belongs to the set 's i'. This is under the condition that the uniformity filter on '\u03b1' has a basis 'p' and 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.HasBasis.cauchySeq_iff {\u03b3} [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} {p : \u03b3 \u2192 Prop}\n    {s : \u03b3 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s) :\n    CauchySeq u \u2194 \u2200 i, p i \u2192 \u2203 N, \u2200 m, N \u2264 m \u2192 \u2200 n, N \u2264 n \u2192 (u m, u n) \u2208 s i :="}
{"input": "Statement in natural language:\nFor any finite set 's' and any function 'f' from 's' to a commutative monoid 'R', the sum of the function values of 'f' over 's' mapped to the left component of the trivial square zero extension of 'R' and 'M' is equal to the sum of the function values of 'f' over 's' individually mapped to the left component of the trivial square zero extension.\nTranslate the statement in natural language to Lean:", "output": "theorem inl_sum {\u03b9} [AddCommMonoid R] [AddCommMonoid M] (s : Finset \u03b9) (f : \u03b9 \u2192 R) :\n    (inl (\u2211 i in s, f i) : tsze R M) = \u2211 i in s, inl (f i) :="}
{"input": "Statement in natural language:\nFor a linear map 'l' from 'M\u2082' to 'M\u2082', the composition of 'l' with the bilinear form created by 'linMulLin' function with 'f' and 'g' as arguments, is equal to the bilinear form created by 'linMulLin' function with the composition of 'f' and 'l' and 'g' as arguments.\nTranslate the statement in natural language to Lean:", "output": "theorem linMulLin_compLeft (l : M\u2082 \u2192\u2097[R\u2082] M\u2082) :\n    (linMulLin f g).compLeft l = linMulLin (f.comp l) g :="}
{"input": "Statement in natural language:\nThe top element of the subsemigroup of M, when considered as a set of M, is equal to the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_top : ((\u22a4 : Subsemigroup M) : Set M) = Set.univ :="}
{"input": "Statement in natural language:\nFor a given element 'a' in a set '\u03b1', if 'a' is less than or equal to zero, then the function of multiplication by 'a' is antitone. An antitone function is one that reverses the order of the elements, meaning if 'b' is less than 'c', then 'a*b' is greater than 'a*c'.\nTranslate the statement in natural language to Lean:", "output": "theorem antitone_mul_left {a : \u03b1} (ha : a \u2264 0) : Antitone ((\u00b7 * \u00b7) a) :="}
{"input": "Statement in natural language:\nFor a set 's' of type \u03b1, the intersection of the source of 'e' and the preimage of the inverse preimage of 's' under 'e' is equal to the intersection of the source of 'e' and 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem source_inter_preimage_inv_preimage (s : Set \u03b1) :\n    e.source \u2229 e \u207b\u00b9' (e.symm \u207b\u00b9' s) = e.source \u2229 s :="}
{"input": "Statement in natural language:\nThe total degree of the zero multivariate polynomial over any ring is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem totalDegree_zero : (0 : MvPolynomial \u03c3 R).totalDegree = 0 :="}
{"input": "Statement in natural language:\nFor any real number 'x' that is greater than or equal to negative half pi and less than or equal to half pi, the cosine of 'x' is equal to the square root of (1 minus the square of the sine of 'x').\nTranslate the statement in natural language to Lean:", "output": "theorem cos_eq_sqrt_one_sub_sin_sq {x : \u211d} (hl : -(\u03c0 / 2) \u2264 x) (hu : x \u2264 \u03c0 / 2) :\n    cos x = sqrt (1 - sin x ^ 2) :="}
{"input": "Statement in natural language:\nFor a function 'u' from a set '\u03b2' to a set '\u03b1' and a point 'a' in '\u03b1', 'u' tends to 'a' at the top if and only if for every positive number '\u03b5', there exists a number 'N' such that for all 'n' greater than or equal to 'N', the distance between 'u(n)' and 'a' is less than '\u03b5'. Here, '\u03b2' is assumed to be nonempty and a semilattice with a supremum operation.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_atTop [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u atTop (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u n) a < \u03b5 :="}
{"input": "Statement in natural language:\nA set 's' is equal to the singleton set containing 'a' if and only if 'a' is an element of 's' and every element 'x' in 's' is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_singleton_iff_unique_mem {s : Finset \u03b1} {a : \u03b1} : s = {a} \u2194 a \u2208 s \u2227 \u2200 x \u2208 s, x = a :="}
{"input": "Statement in natural language:\nIf 'i' is less than 'j' and 'k' is the greatest lower bound of the set of all elements greater than 'i', then 'k' is also the greatest lower bound of the set of all elements that are greater than 'i' and less than or equal to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem isGLB_Ioc_of_isGLB_Ioi {i j k : \u03b9} (hij_lt : i < j) (h : IsGLB (Set.Ioi i) k) :\n    IsGLB (Set.Ioc i j) k :="}
{"input": "Statement in natural language:\nFor a given element 'x' of type 'F \u03b1', 'LiftP' of 'P' applied to 'x' is equivalent to the existence of an element 'u' of type 'F' applied to the subtype of 'P', such that when the subtype value of 'P' is mapped onto 'u', it equals 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem LiftP_def (x : F \u03b1) : LiftP' P x \u2194 \u2203 u : F (Subtype_ P), subtypeVal P <$$> u = x :="}
{"input": "Statement in natural language:\nFor a linear equivalence 'e' between two modules 'M' and 'M\u2082' over a ring 'R', and a submodule 'K' of 'M', the image of 'K' under the map induced by 'e' is equal to the preimage of 'K' under the map induced by the inverse of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_equiv_eq_comap_symm (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (K : Submodule R M) :\n    K.map (e : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) = K.comap (e.symm : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M) :="}
{"input": "Statement in natural language:\nFor any two true lists of any type \u03b1 (denoted as l\u2081 and l\u2082) and any element 'a', if list l\u2081 is a subset of list l\u2082 and 'a' is an element of list l\u2081, then 'a' is also an element of list l\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_of_subset' {a} : \u2200 {l\u2081 l\u2082 : Lists' \u03b1 true} (_ : l\u2081 \u2286 l\u2082) (_ : a \u2208 l\u2081.toList), a \u2208 l\u2082"}
{"input": "Statement in natural language:\nIf r is less than 1, then b is less than the line map of a, b, and r if and only if b is less than a.\nTranslate the statement in natural language to Lean:", "output": "theorem right_lt_lineMap_iff_lt (h : r < 1) : b < lineMap a b r \u2194 b < a :="}
{"input": "Statement in natural language:\nThe determinant of the identity linear equivalence (which maps each element of a module to itself) over a ring is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem det_refl : LinearEquiv.det (LinearEquiv.refl R M) = 1 :="}
{"input": "Statement in natural language:\nFor a given point 'x' in the one-point compactification of a topological space 'X', 'x' is not in the range of the embedding if and only if 'x' is the additional point at infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_range_coe_iff {x : OnePoint X} : x \u2209 range some \u2194 x = \u221e :="}
{"input": "Statement in natural language:\nFor two affine maps, one from P2 to P3 and the other from P1 to P2, the composition of the two maps is equal to the composition of their corresponding functions.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_comp (f : P2 \u2192\u1d43[k] P3) (g : P1 \u2192\u1d43[k] P2) : \u21d1(f.comp g) = f \u2218 g :="}
{"input": "Statement in natural language:\nFor a given constant 'c' and a set 's' that is convex, the function that maps every element in 'E' to 'c' is convex on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem convexOn_const (c : \u03b2) (hs : Convex \ud835\udd5c s) : ConvexOn \ud835\udd5c s fun _ : E => c :="}
{"input": "Statement in natural language:\nFor a zero element in set M and an additive commutative monoid in set N, given a function 'f' mapping from \u03b1 to M, another function 'g' mapping from \u03b1 and M to \u03b2 in N, and an element 'a\u2082' in \u03b2, the sum of 'f' applied to 'g' at 'a\u2082' is equal to the sum of 'f' applied to a function that takes 'a\u2081' and 'b' and maps them to 'g' at 'a\u2081', 'b', and 'a\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_apply [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} {g : \u03b1 \u2192 M \u2192 \u03b2 \u2192\u2080 N} {a\u2082 : \u03b2} :\n    (f.sum g) a\u2082 = f.sum fun a\u2081 b => g a\u2081 b a\u2082 :="}
{"input": "Statement in natural language:\nFor a given Young Diagram \u03bc, if two semistandard Young tableaux T and T' have the same elements at every position (i, j), then T and T' are the same.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {\u03bc : YoungDiagram} {T T' : Ssyt \u03bc} (h : \u2200 i j, T i j = T' i j) : T = T' :="}
{"input": "Statement in natural language:\nFor a given ordered pair 'a' of type alpha and beta, the set of all elements greater than or equal to 'a' is equal to the Cartesian product of the set of all elements greater than or equal to the first element of 'a' and the set of all elements greater than or equal to the second element of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ici_prod_eq (a : \u03b1 \u00d7 \u03b2) : Ici a = Ici a.1 \u00d7\u02e2 Ici a.2 :="}
{"input": "Statement in natural language:\nThe cosine of any integer multiplied by two pi is equal to one.\nTranslate the statement in natural language to Lean:", "output": "theorem cos_int_mul_two_pi (n : \u2124) : cos (n * (2 * \u03c0)) = 1 :="}
{"input": "Statement in natural language:\nIn a pseudometric space that is also a proper space, the thickening of a set E by a non-negative real number \u03b4 is equal to the union of closed balls of radius \u03b4 centered at each point in the closure of E.\nTranslate the statement in natural language to Lean:", "output": "theorem cthickening_eq_biUnion_closedBall {\u03b1 : Type _} [PseudoMetricSpace \u03b1] [ProperSpace \u03b1]\n    (E : Set \u03b1) (h\u03b4 : 0 \u2264 \u03b4) : cthickening \u03b4 E = \u22c3 x \u2208 closure E, closedBall x \u03b4 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type 'WithBot \u03b1', 'a' is not less than 'none'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_lt_none (a : WithBot \u03b1) : \u00ac@LT.lt (WithBot \u03b1) _ a none :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of elements from a ring 'A', the subring generated by adjoining 's' to a ring 'R' is finitely generated.\nTranslate the statement in natural language to Lean:", "output": "theorem fg_adjoin_finset (s : Finset A) : (Algebra.adjoin R (\u2191s : Set A)).FG :="}
{"input": "Statement in natural language:\nFor any two subrings 'p' and 'p'' of a ring 'R', the intersection of 'p' and 'p'' as a subring of 'R' is equal to the intersection of 'p' and 'p'' as sets of 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_inf (p p' : Subring R) : ((p \u2293 p' : Subring R) : Set R) = (p : Set R) \u2229 p' :="}
{"input": "Statement in natural language:\nFor any two finite sets 's' and 't', if 's' is a subset of 't', then if an element 'a' is not in 't', it is also not in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_mono {s t : Finset \u03b1} (h : s \u2286 t) {a : \u03b1} : a \u2209 t \u2192 a \u2209 s :="}
{"input": "Statement in natural language:\nThe mapping of zero from the first module to the second module under the continuous linear map is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_zero' : \u21d1(0 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = 0 :="}
{"input": "Statement in natural language:\nThe embedding of the negation of a real number 'x' into the extended real numbers is equal to the negation of the embedding of 'x' into the extended real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_neg (x : \u211d) : (\u2191(-x) : EReal) = -\u2191x :="}
{"input": "Statement in natural language:\nA local homeomorphism 'e' is in the maximal atlas of a manifold 'M' if and only if for every other local homeomorphism 'e'' in the atlas of 'M', the composition of the inverse of 'e' and 'e'' is in 'G' and the composition of the inverse of 'e'' and 'e' is also in 'G'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_maximalAtlas_iff {e : LocalHomeomorph M H} :\n    e \u2208 G.maximalAtlas M \u2194 \u2200 e' \u2208 atlas H M, e.symm \u226b\u2095 e' \u2208 G \u2227 e'.symm \u226b\u2095 e \u2208 G :="}
{"input": "Statement in natural language:\nA function that maps the sum of two sets (\u03b1 and \u03b2) to two other sets (\u03b3 and \u03b4) is injective if and only if the individual functions that map \u03b1 to \u03b3 and \u03b2 to \u03b4 are both injective.\nTranslate the statement in natural language to Lean:", "output": "theorem map_injective {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Injective (Sum.map f g) \u2194 Injective f \u2227 Injective g :="}
{"input": "Statement in natural language:\nFor a matrix B and a matrix A with a determinant that is a unit (i.e., non-zero), multiplying B by the inverse of A and then by A itself will result in B. This is essentially stating that the multiplication of a matrix by its inverse and then by the matrix itself is a cancellation operation.\nTranslate the statement in natural language to Lean:", "output": "theorem nonsing_inv_mul_cancel_right (B : Matrix m n \u03b1) (h : IsUnit A.det) : B \u2b1d A\u207b\u00b9 \u2b1d A = B :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from '\u03b1' to the sum of '\u03b2' and '\u03b3', and two functions 'g' and 'h' mapping from '\u03b1' to '\u03b2' and '\u03b3' respectively, if 'f', 'g', and 'h' are computable, then the function that maps 'a' to the sum of the cases on 'f(a)', 'g(a)', and 'h(a)' is also computable.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_casesOn {f : \u03b1 \u2192 Sum \u03b2 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192 \u03c3} (hf : Computable f)\n    (hg : Computable\u2082 g) (hh : Computable\u2082 h) :\n    @Computable _ \u03c3 _ _ fun a => Sum.casesOn (f a) (g a) (h a) :="}
{"input": "Statement in natural language:\nFor any two elements x and y in the set S, the sum of x and y, when mapped to the set L, is equal to the sum of the individual mappings of x and y to L.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_add (x y : S) : (\u2191(x + y) : L) = \u2191x + \u2191y :="}
{"input": "Statement in natural language:\nThe sum of the function 'f' over the antidiagonal of 'n + 1' is equal to the value of 'f' at the point '(n + 1, 0)' plus the sum of the function 'f' over the antidiagonal of 'n', where the function 'f' is applied to each point '(p.1, p.2 + 1)'.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_antidiagonal_succ' {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 N} :\n    (\u2211 p in antidiagonal (n + 1), f p) = f (n + 1, 0) + \u2211 p in antidiagonal n, f (p.1, p.2 + 1) :="}
{"input": "Statement in natural language:\nIf you perform a scanl operation (which applies a binary function to a start value and a list, producing a new list) with a function 'f', a starting value 'b', and an empty list, the result will be a list containing only the starting value 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem scanl_nil (b : \u03b2) : scanl f b nil = [b] :="}
{"input": "Statement in natural language:\nFor any natural number 'n', casting 'n' first to the p-adic integers and then to the p-adic rationals results in the original natural number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_nat_cast (n : \u2115) : ((n : \u2124_[p]) : \u211a_[p]) = n :="}
{"input": "Statement in natural language:\nFor a left inverse 'a' of a submonoid 'S' and an element 'b' of a monoid 'M', the element 'a' from the left inverse of 'S' is equal to 'b' if and only if the product of 'a' and 'b' is the identity element '1'.\nTranslate the statement in natural language to Lean:", "output": "theorem fromLeftInv_eq_iff (a : S.leftInv) (b : M) : (S.fromLeftInv a : M) = b \u2194 (a : M) * b = 1 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a certain set '\u03b1', if 'a' is not less than or equal to 'b', then 'b' is less than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_not_le {a b : \u03b1} : \u00aca \u2264 b \u2192 b \u2264 a :="}
{"input": "Statement in natural language:\nFor any element 'a' in a topological group 'H', the function that takes the inverse of each element tends to the neighborhood of 'a' within the set of elements greater than 'a\u207b\u00b9' as it approaches the neighborhood of 'a' within the set of elements less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_inv_nhdsWithin_Ioi_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[>] a\u207b\u00b9) (\ud835\udcdd[<] a) :="}
{"input": "Statement in natural language:\nFor a given additive commutative monoid 'M', a multiset 's' of functions from '\u03b1' to 'M', and an element 'a' of '\u03b1', if 'a' is in the support of the sum of 's', then there exists a function 'f' in 's' such that 'a' is in the support of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_support_multiset_sum [AddCommMonoid M] {s : Multiset (\u03b1 \u2192\u2080 M)} (a : \u03b1) :\n    a \u2208 s.sum.support \u2192 \u2203 f \u2208 s, a \u2208 (f : \u03b1 \u2192\u2080 M).support :="}
{"input": "Statement in natural language:\nFor a linear map 'g' from a module 'M' to another module 'M'' over a ring 'R', and for all elements 'x' in a set 'S' such that 'x' is a unit in the ring of endomorphisms of the module 'M'', the composition of the lift of 'g' with respect to 'S' and 'h', and the linear map from 'S' to 'M', is equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_comp (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) :\n    (lift S g h).comp (mkLinearMap S M) = g :="}
{"input": "Statement in natural language:\nFor any given graph G and vertices u, v, and w, if there is a walk p from u to v and another walk p' from v to w, then the multiset of vertices in the combined walk (p appended with p') is equal to the multiset of vertices in walk p plus the multiset of vertices in walk p', minus the vertex v. This is under the condition that the equality of vertices V is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_support_append' [DecidableEq V] {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = p.support + p'.support - {v} :="}
{"input": "Statement in natural language:\nThe non-empty locus of the difference between function f\u2081 and function g is equal to the non-empty locus of the difference between function f\u2082 and function g, which is the same as the non-empty locus of function f\u2081 and function f\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem neLocus_sub_right : neLocus (f\u2081 - g) (f\u2082 - g) = neLocus f\u2081 f\u2082 :="}
{"input": "Statement in natural language:\nIf the coefficient of polynomial q at the natural trailing degree of polynomial p is not zero, then the trailing degree of polynomial q is less than or equal to the trailing degree of polynomial p.\nTranslate the statement in natural language to Lean:", "output": "theorem trailingDegree_le_trailingDegree (h : coeff q (natTrailingDegree p) \u2260 0) :\n    trailingDegree q \u2264 trailingDegree p :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuous, then the composition of the function 'connectedComponentsLift' with the coercion function (\u2191) applied to 'h' is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.connectedComponentsLift_comp_coe (h : Continuous f) :\n    h.connectedComponentsLift \u2218 (\u2191) = f :="}
{"input": "Statement in natural language:\nFor any natural numbers 'b' and 'p', where 'b' is greater than 0, the integer representation of '(b to the power of p minus 1)' is equal to '(the integer representation of b) to the power of p minus 1'.\nTranslate the statement in natural language to Lean:", "output": "theorem Int.coe_nat_pow_pred (b p : \u2115) (w : 0 < b) : ((b ^ p - 1 : \u2115) : \u2124) = (b : \u2124) ^ p - 1 :="}
{"input": "Statement in natural language:\nFor any real number 'a', subtracting half of 'a' from 'a' is equal to half of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_half (a : R) : a - a / 2 = a / 2 :="}
{"input": "Statement in natural language:\nFor a function 'f' that is an open map and continuous, the preimage of the closure of a set 's' under 'f' is equal to the closure of the preimage of 's' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_closure_eq_closure_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set \u03b2) :\n    f \u207b\u00b9' closure s = closure (f \u207b\u00b9' s) :="}
{"input": "Statement in natural language:\nFor any type \u03b9 and any star-algebra \u03b1, the star of the union of a set of elements indexed by \u03b9 is equal to the union of the stars of the individual sets.\nTranslate the statement in natural language to Lean:", "output": "theorem iUnion_star {\u03b9 : Sort _} [Star \u03b1] (s : \u03b9 \u2192 Set \u03b1) : (\u22c3 i, s i)\u22c6 = \u22c3 i, (s i)\u22c6 :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the cardinality of 'n' is equal to 'n' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem card_nat (n : \u2115) : card.{u} n = n :="}
{"input": "Statement in natural language:\nIf we have a measurable set 's', and two measurable functions 'f' and 'g', then the piecewise function that uses 'f' for elements in 's' and 'g' for elements not in 's' is also measurable. This is under the condition that it is decidable whether an element belongs to 's' or not.\nTranslate the statement in natural language to Lean:", "output": "theorem Measurable.piecewise {_ : DecidablePred (\u00b7 \u2208 s)} (hs : MeasurableSet s)\n    (hf : Measurable f) (hg : Measurable g) : Measurable (piecewise s f g) :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the coe function applied to the range of 'n' in a list is equal to the range of 'n' in a multiset.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_range (n : \u2115) : \u2191(List.range n) = range n :="}
{"input": "Statement in natural language:\nFor a given element 'z' of group 'G', 'z' is in the center of 'G' if and only if for all elements 'g' in 'G', the product of 'g' and 'z' is equal to the product of 'z' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_center_iff {z : G} : z \u2208 center G \u2194 \u2200 g, g * z = z * g :="}
{"input": "Statement in natural language:\nThe application of the identity function in the context of the module M\u2081 over the ring R\u2081 is equivalent to the standard identity function.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_id' : \u21d1(id R\u2081 M\u2081) = _root_.id :="}
{"input": "Statement in natural language:\nThe primitive part of a polynomial p is primitive.\nTranslate the statement in natural language to Lean:", "output": "theorem isPrimitive_primPart (p : R[X]) : p.primPart.IsPrimitive :="}
{"input": "Statement in natural language:\nFor a given set 's' of type \u03b1, the image of the intersection of the source of 'e' and 's' is equal to the intersection of the target of 'e' and the preimage of 's' under the inverse of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_source_inter_eq' (s : Set \u03b1) : e '' (e.source \u2229 s) = e.target \u2229 e.symm \u207b\u00b9' s :="}
{"input": "Statement in natural language:\nFor a given ring homomorphism 'f' from ring 'R' to ring 'S', and given subsemirings 's' of 'R' and 't' of 'S', the image of 's' under 'f' is a subset of 't' if and only if 's' is a subset of the preimage of 't' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_iff_le_comap {f : R \u2192+* S} {s : Subsemiring R} {t : Subsemiring S} :\n    s.map f \u2264 t \u2194 s \u2264 t.comap f :="}
{"input": "Statement in natural language:\nEvaluating the basis divisor of x and y at y equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_basisDivisor_right : eval y (basisDivisor x y) = 0 :="}
{"input": "Statement in natural language:\nIf c is a positive number, then the upper bounds of the set obtained by multiplying each element of set s by c, is equal to the set obtained by multiplying each element of the upper bounds of set s by c.\nTranslate the statement in natural language to Lean:", "output": "theorem upperBounds_smul_of_pos (hc : 0 < c) : upperBounds (c \u2022 s) = c \u2022 upperBounds s :="}
{"input": "Statement in natural language:\nA distance 'd' is less than or equal to the infimum extended distance between a point 'x' and a set 's' if and only if for all points 'y' in the set 's', 'd' is less than or equal to the extended distance between 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_infEdist {d} : d \u2264 infEdist x s \u2194 \u2200 y \u2208 s, d \u2264 edist x y :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'n' and 'p', the product of the ordinal projection of 'n' with respect to 'p' and the ordinal complement of 'n' with respect to 'p' is equal to 'n' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem ord_proj_mul_ord_compl_eq_self (n p : \u2115) : ord_proj[p] n * ord_compl[p] n = n :="}
{"input": "Statement in natural language:\nFor a given semilattice sup structure on \u03b2 and a filter l on \u03b1, if function f\u2081 is eventually less than or equal to function f\u2082 at filter l, and function g\u2081 is eventually less than or equal to function g\u2082 at filter l, then the supremum of f\u2081 and g\u2081 is eventually less than or equal to the supremum of f\u2082 and g\u2082 at filter l.\nTranslate the statement in natural language to Lean:", "output": "theorem EventuallyLE.sup [SemilatticeSup \u03b2] {l : Filter \u03b1} {f\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (hf : f\u2081 \u2264\u1da0[l] f\u2082)\n    (hg : g\u2081 \u2264\u1da0[l] g\u2082) : f\u2081 \u2294 g\u2081 \u2264\u1da0[l] f\u2082 \u2294 g\u2082 :="}
{"input": "Statement in natural language:\nFor any option 'o' of type '\u03b1', converting 'o' from an option to another type and then back to an option results in the original option 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem to_ofOption (o : Option \u03b1) : toOption (ofOption o) = o :="}
{"input": "Statement in natural language:\nFor any pointed map 'f' from type \u0393 to \u0393' and any list 'l' of type \u0393, mapping 'f' over a tape created from 'l' is equivalent to creating a tape from the list obtained by mapping 'f' over 'l'. This holds true given that \u0393 and \u0393' are inhabited types.\nTranslate the statement in natural language to Lean:", "output": "theorem Tape.map_mk\u2081 {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (l : List \u0393) :\n    (Tape.mk\u2081 l).map f = Tape.mk\u2081 (l.map f) :="}
{"input": "Statement in natural language:\nA set 's' is a proper subset of a set 't' if and only if there exists an element 'a' in 't' such that 's' is a subset of 't' with 'a' removed.\nTranslate the statement in natural language to Lean:", "output": "theorem ssubset_iff_exists_subset_erase {s t : Finset \u03b1} : s \u2282 t \u2194 \u2203 a \u2208 t, s \u2286 t.erase a :="}
{"input": "Statement in natural language:\nIf either 'a' is not zero or 'b' is not infinity, and either 'b' is not zero or 'a' is not infinity, then the function that multiplies the elements of a pair of non-negative real numbers tends towards the product of 'a' and 'b' as the pair tends towards ('a', 'b').\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_mul (ha : a \u2260 0 \u2228 b \u2260 \u22a4) (hb : b \u2260 0 \u2228 a \u2260 \u22a4) :\n    Tendsto (fun p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e => p.1 * p.2) (\ud835\udcdd (a, b)) (\ud835\udcdd (a * b)) :="}
{"input": "Statement in natural language:\nThe morphism in the mono factorisation of an image f is equal to the morphism from the image to f.\nTranslate the statement in natural language to Lean:", "output": "theorem image.as_\u03b9 : (Image.monoFactorisation f).m = image.\u03b9 f :="}
{"input": "Statement in natural language:\nFor any two real numbers x and y, where x is less than y, the closed interval from x to y is included in the sets at y of the Vitali family with respect to the volume measure and the real number 1.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_mem_vitaliFamily_at_left {x y : \u211d} (hxy : x < y) :\n    Icc x y \u2208 (vitaliFamily (volume : Measure \u211d) 1).setsAt y :="}
{"input": "Statement in natural language:\nFor a given normed field \ud835\udd5c and a normed space \ud835\udd5c E, for any continuous function f from \u03b1 to E, the function f is almost everywhere equal to the function obtained by applying the toLp operator to f, with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem coeFn_toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] (f : C(\u03b1, E)) :\n    toLp (E := E) p \u03bc \ud835\udd5c f =\u1d50[\u03bc] f :="}
{"input": "Statement in natural language:\nFor any three topological categories X, Y, and S, and any morphisms f from X to S and g from Y to S, the range of the first projection from the pullback of f and g is equal to the set of all elements x in X such that there exists an element y in Y for which f(x) equals g(y).\nTranslate the statement in natural language to Lean:", "output": "theorem pullback_fst_range {X Y S : TopCat} (f : X \u27f6 S) (g : Y \u27f6 S) :\n    Set.range (pullback.fst : pullback f g \u27f6 _) = { x : X | \u2203 y : Y, f x = g y } :="}
{"input": "Statement in natural language:\nIf for every measurable set in a certain space, two finite measures give the same result, then these two finite measures are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_forall_apply_eq (\u03bc \u03bd : FiniteMeasure \u03a9)\n    (h : \u2200 s : Set \u03a9, MeasurableSet s \u2192 \u03bc s = \u03bd s) : \u03bc = \u03bd :="}
{"input": "Statement in natural language:\nFor a given element 'a' of a set '\u03b1', if set 's' is a neighborhood of the element '1' in '\u03b1', then the product of the singleton set containing 'a' and set 's' is a neighborhood of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_mul_mem_nhds_of_nhds_one (a : \u03b1) (h : s \u2208 \ud835\udcdd (1 : \u03b1)) : {a} * s \u2208 \ud835\udcdd a :="}
{"input": "Statement in natural language:\nFor any block diagonal matrix M (where M is a function that for each index i gives a matrix with dimensions determined by functions m' and n' and entries from an arbitrary set \u03b1), if we have two different block indices k and k' (i.e., k \u2260 k'), then the entry of the block diagonal matrix M at the position determined by the pair of the block index and the within-block index (k, i) and (k', j) is zero. This essentially means that blocks corresponding to different indices are disjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem blockDiagonal'_apply_ne (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) {k k'} (i j) (h : k \u2260 k') :\n    blockDiagonal' M \u27e8k, i\u27e9 \u27e8k', j\u27e9 = 0 :="}
{"input": "Statement in natural language:\nA product of two types, \u03b1 and \u03b2, is empty if and only if either \u03b1 is empty or \u03b2 is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem isEmpty_prod {\u03b1 \u03b2 : Type _} : IsEmpty (\u03b1 \u00d7 \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2 :="}
{"input": "Statement in natural language:\nThe norm of an integer square root of 'd' is equal to the product of the integer square root of 'd' and its conjugate.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_eq_mul_conj (n : \u2124\u221ad) : (norm n : \u2124\u221ad) = n * star n :="}
{"input": "Statement in natural language:\nFor any two uniform spaces 'u' and 'v', the uniformity of the infimum (greatest lower bound) of 'u' and 'v' is equal to the infimum of the uniformities of 'u' and 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_uniformity {u v : UniformSpace \u03b1} : \ud835\udce4[u \u2293 v] = \ud835\udce4[u] \u2293 \ud835\udce4[v] :="}
{"input": "Statement in natural language:\nIf a is congruent to b modulo p, then the sum of c and a is congruent to the sum of c and b modulo p.\nTranslate the statement in natural language to Lean:", "output": "theorem add_left (c : \u03b1) (h : a \u2261 b [PMOD p]) : c + a \u2261 c + b [PMOD p] :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the successor function on finite sets ('Fin.succ') is injective. This means that if two different elements in the finite set are mapped to two different elements in the natural numbers set by the successor function, then the original elements were also different.\nTranslate the statement in natural language to Lean:", "output": "theorem succ_injective (n : \u2115) : Injective (@Fin.succ n) :="}
{"input": "Statement in natural language:\nFor a ring homomorphism 'i' from ring 'R' to ring 'S', an element 'x' of 'S' that is invertible, and a polynomial 'f' with coefficients in 'R', the evaluation of the reverse of 'f' at the multiplicative inverse of 'x' under 'i' is zero if and only if the evaluation of 'f' at 'x' under 'i' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eval\u2082_reverse_eq_zero_iff (i : R \u2192+* S) (x : S) [Invertible x] (f : R[X]) :\n    eval\u2082 i (\u215f x) (reverse f) = 0 \u2194 eval\u2082 i x f = 0 :="}
{"input": "Statement in natural language:\nThe \u03c3 (sigma) of the principal realizer of a set s of type \u03b1 is equal to the unit type.\nTranslate the statement in natural language to Lean:", "output": "theorem principal_\u03c3 (s : Set \u03b1) : (Realizer.principal s).\u03c3 = Unit :="}
{"input": "Statement in natural language:\nFor any monoid \u03b2 and any function f from the free monoid of \u03b1 to \u03b2, and for any x in the type t of \u03b1, applying the function f to the result of folding the map with FreeMonoid.of x is equal to folding the map with the composition of f and FreeMonoid.of on x.\nTranslate the statement in natural language to Lean:", "output": "theorem foldMap_hom_free [Monoid \u03b2] (f : FreeMonoid \u03b1 \u2192* \u03b2) (x : t \u03b1) :\n    f (foldMap FreeMonoid.of x) = foldMap (f \u2218 FreeMonoid.of) x :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from '\u03b1' to '\u03b2' and a set 's' of '\u03b1', and if 'f' is continuous at the supremum of 's' and 'f' is an antitone function (meaning it reverses the order), then the value of 'f' at the supremum of 's' is equal to the infimum of the image of 's' under 'f'. This holds true given that the set 's' is nonempty and it is bounded above.\nTranslate the statement in natural language to Lean:", "output": "theorem Antitone.map_csSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sSup s))\n    (Af : Antitone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sInf (f '' s) :="}
{"input": "Statement in natural language:\nFor any point P in M, if P is a left projection of X, then 1 - P is also a left projection of X.\nTranslate the statement in natural language to Lean:", "output": "theorem Lcomplement {P : M} (h : IsLprojection X P) : IsLprojection X (1 - P) :="}
{"input": "Statement in natural language:\nFor any open set Y in the topological space X and any presieve R on Y, the auxiliary presieve of the covering of the presieve R on Y is equal to R itself.\nTranslate the statement in natural language to Lean:", "output": "theorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :\n    presieveOfCoveringAux (coveringOfPresieve Y R) Y = R :="}
{"input": "Statement in natural language:\nFor any type '\u03b1', a property 'Q' on '\u03b1', and two functions 'u' and 'v' from '\u03b1' to 'M P', if for every 'x' that satisfies 'Q', there exist 'a', 'f', and 'f'', such that the destination of 'u x' equals the pair of 'a' and 'f', the destination of 'v x' equals the pair of 'a' and 'f'', and for every 'i', there exists an 'x'' that satisfies 'Q' and 'f i' equals 'u x'' and 'f'' i' equals 'v x'', then for every 'x' that satisfies 'Q', 'u x' equals 'v x'.\nTranslate the statement in natural language to Lean:", "output": "theorem bisim' {\u03b1 : Type _} (Q : \u03b1 \u2192 Prop) (u v : \u03b1 \u2192 M P)\n    (h : \u2200 x, Q x \u2192 \u2203 a f f',\n          M.dest (u x) = \u27e8a, f\u27e9\n          \u2227 M.dest (v x) = \u27e8a, f'\u27e9\n          \u2227 \u2200 i, \u2203 x', Q x' \u2227 f i = u x' \u2227 f' i = v x'\n      ) :\n    \u2200 x, Q x \u2192 u x = v x :="}
{"input": "Statement in natural language:\nIf \u03b9 is unique, then the range of a function f is equal to the set containing the default value of the function f.\nTranslate the statement in natural language to Lean:", "output": "theorem range_unique [h : Unique \u03b9] : range f = {f default} :="}
{"input": "Statement in natural language:\nFor any linear order of type \u03b1, given any two elements x and y of type \u03b1, x is less than y or y is less than x if and only if x is not equal to y.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_or_lt_iff_ne [LinearOrder \u03b1] {x y : \u03b1} : x < y \u2228 y < x \u2194 x \u2260 y :="}
{"input": "Statement in natural language:\nFor a function 'f' from type \u03b1 to type \u03b2 and a partial function 'x' of type \u03b1, binding 'x' to the function 'some' composed with 'f' is equivalent to mapping 'f' over 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem bind_some_eq_map (f : \u03b1 \u2192 \u03b2) (x : Part \u03b1) : x.bind (some \u2218 f) = map f x :="}
{"input": "Statement in natural language:\nThe function which maps a natural number 'n' to the integral from 0 to \u03c0 of sin(x) raised to the power of 'n', is an antitone function. An antitone function is one that decreases or remains constant as its input increases.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_sin_pow_antitone : Antitone fun n : \u2115 => \u222b x in (0)..\u03c0, sin x ^ n :="}
{"input": "Statement in natural language:\nIf a function f has a strict derivative at a point x, then the function obtained by subtracting a constant c from f also has a strict derivative at the same point x, and the derivative is the same as that of the original function.\nTranslate the statement in natural language to Lean:", "output": "theorem HasStrictFDerivAt.sub_const (hf : HasStrictFDerivAt f f' x) (c : F) :\n    HasStrictFDerivAt (fun x => f x - c) f' x :="}
{"input": "Statement in natural language:\nThe square of the cosine of a number x is equal to one half plus the cosine of twice that number divided by two.\nTranslate the statement in natural language to Lean:", "output": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :="}
{"input": "Statement in natural language:\nFor any two elements x and y in the open interval between 0 and 1, the coercion of the product of x and y is equal to the product of x and y in the set of \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mul (x y : Ioo (0 : \u03b1) 1) : \u2191(x * y) = (x * y : \u03b1) :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from an arbitrary type '\u03b1' to real numbers '\u211d', and a real number 'r', the sum of the function 'f' evaluated at 'a' and coerced to a quaternion '\u210d', is equal to the real number 'r' coerced to a quaternion '\u210d', if and only if the sum of the function 'f' is equal to the real number 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasSum_coe {f : \u03b1 \u2192 \u211d} {r : \u211d} : HasSum (fun a => (f a : \u210d)) (\u2191r : \u210d) \u2194 HasSum f r :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from a function 'm' (which itself maps from an index set '\u03b9' to a set 'M') to a set, if we update the function 'm' at index 'i' to be 0, then the value of 'f' at this updated function is 0. This is under the condition that '\u03b9' is a set where equality can be decided.\nTranslate the statement in natural language to Lean:", "output": "theorem map_update_zero [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) : f (update m i 0) = 0 :="}
{"input": "Statement in natural language:\nIf you have a function 'f' that is an injection from type \u03b1 to type \u03b2, then mapping this function over the singleton set containing only 1 will result in a new singleton set containing only the image of 1 under the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_one {f : \u03b1 \u21aa \u03b2} : map f 1 = {f 1} :="}
{"input": "Statement in natural language:\nThe function that creates a singleton set from a given set in Zermelo-Fraenkel set theory is injective. This means that different input sets will always produce different singleton sets.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_injective : Function.Injective (@singleton ZFSet ZFSet _) :="}
{"input": "Statement in natural language:\nThe submatrix of a zero matrix, for any given mapping from set l to set m and set o to set n, is also a zero matrix. This is under the condition that the elements of the matrix are of a type that has a zero element.\nTranslate the statement in natural language to Lean:", "output": "theorem submatrix_zero [Zero \u03b1] :\n    ((0 : Matrix m n \u03b1).submatrix : (l \u2192 m) \u2192 (o \u2192 n) \u2192 Matrix l o \u03b1) = 0 :="}
{"input": "Statement in natural language:\nFor any index 'i', the function that multiplies a given element 'x' at index 'i' and leaves all other elements unchanged is continuous. This is under the assumption that for all indices, there exists a multiplicative identity, and that equality between indices is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_mulSingle [\u2200 i, One (\u03c0 i)] [DecidableEq \u03b9] (i : \u03b9) :\n    Continuous fun x => (Pi.mulSingle i x : \u2200 i, \u03c0 i) :="}
{"input": "Statement in natural language:\nFor a structure M of the sum of two languages L and L', and given that the function sumInl is an expansion on M from L to the sum of L and L', for any natural number n, any function f from the set of functions of L with arity n, and any function x from the finite set of size n to M, the function map of the sum of f and x in the sum of L and L' is equal to the function map of f and x in L.\nTranslate the statement in natural language to Lean:", "output": "theorem funMap_sumInl [(L.sum L').Structure M] [(LHom.sumInl : L \u2192\u1d38 L.sum L').IsExpansionOn M] {n}\n    {f : L.Functions n} {x : Fin n \u2192 M} : @funMap (L.sum L') M _ n (Sum.inl f) x = funMap f x :="}
{"input": "Statement in natural language:\nFor any two morphisms 'f' from the product of 'A' and 'X' to 'Y', and 'g' from 'Y' to 'Y'', the curry of the composition of 'f' and 'g' is equal to the composition of the curry of 'f' and the map of 'g' under the exponential functor.\nTranslate the statement in natural language to Lean:", "output": "theorem curry_natural_right (f : A \u2a2f X \u27f6 Y) (g : Y \u27f6 Y') :\n    curry (f \u226b g) = curry f \u226b (exp _).map g :="}
{"input": "Statement in natural language:\nFor any two ring homomorphisms 'f' and 'g' from a multivariate polynomial ring over 'R' in the variables '\u03c3' to another semiring 'S\u2082', if 'f' and 'g' agree on the coefficients and on the indeterminates, then 'f' and 'g' are equal for any polynomial 'p' in the multivariate polynomial ring.\nTranslate the statement in natural language to Lean:", "output": "theorem hom_eq_hom [Semiring S\u2082] (f g : MvPolynomial \u03c3 R \u2192+* S\u2082) (hC : f.comp C = g.comp C)\n    (hX : \u2200 n : \u03c3, f (X n) = g (X n)) (p : MvPolynomial \u03c3 R) : f p = g p :="}
{"input": "Statement in natural language:\nIn a structure with no maximum order, if 'a' is a successor limit, then 'a' is a minimum.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSuccLimit.isMin_of_noMax [NoMaxOrder \u03b1] (h : IsSuccLimit a) : IsMin a :="}
{"input": "Statement in natural language:\nFor a given element 'b' of type \u03b1 and a multiset 's' of type \u03b1, the fold operation on 'b' and 's' is equal to the foldl operation on 'b' and 's' with the right_comm function applied, which is derived from the commutative property 'hc.comm' and the associative property 'ha.assoc'.\nTranslate the statement in natural language to Lean:", "output": "theorem fold_eq_foldl (b : \u03b1) (s : Multiset \u03b1) :\n    fold op b s = foldl op (right_comm _ hc.comm ha.assoc) b s :="}
{"input": "Statement in natural language:\nIf a function 'f' from 'E' to '\ud835\udd5c' is continuously differentiable up to order 'n' and for all 'x', 'f(x)' is not equal to zero, then the function that maps 'x' to the inverse of 'f(x)' is also continuously differentiable up to order 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiff.inv {f : E \u2192 \ud835\udd5c'} {n} (hf : ContDiff \ud835\udd5c n f) (h : \u2200 x, f x \u2260 0) :\n    ContDiff \ud835\udd5c n fun x => (f x)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any two types R and S, where R is a semiring, S is a commutative ring and S is a domain, and for any function m from R to S, any natural number d, and any set U of elements from R that is finite, the union of the sets of roots of all polynomials f from R[X] (the set of all polynomials with coefficients in R) that have a degree less than or equal to d and all of whose coefficients are in U, when these roots are mapped by m, is also finite.\nTranslate the statement in natural language to Lean:", "output": "theorem bUnion_roots_finite {R S : Type _} [Semiring R] [CommRing S] [IsDomain S] (m : R \u2192+* S)\n    (d : \u2115) {U : Set R} (h : U.Finite) :\n    (\u22c3 (f : R[X]) (_ : f.natDegree \u2264 d \u2227 \u2200 i, f.coeff i \u2208 U),\n        ((f.map m).roots.toFinset.toSet : Set S)).Finite :="}
{"input": "Statement in natural language:\nFor two trivializations e\u2081 and e\u2082 of a fiber bundle with projection function proj, and a point b in the base set of both trivializations, the application of the homeomorphism corresponding to the coordinate change from e\u2081 to e\u2082 is equal to the coordinate change from e\u2081 to e\u2082 at point b.\nTranslate the statement in natural language to Lean:", "output": "theorem coordChangeHomeomorph_coe (e\u2081 e\u2082 : Trivialization F proj) {b : B} (h\u2081 : b \u2208 e\u2081.baseSet)\n    (h\u2082 : b \u2208 e\u2082.baseSet) : \u21d1(e\u2081.coordChangeHomeomorph e\u2082 h\u2081 h\u2082) = e\u2081.coordChange e\u2082 b :="}
{"input": "Statement in natural language:\nFor two functions 'g' mapping from \u03b2 to \u03b3 and 'f' mapping from \u03b1 to \u03b2, if 'g' is an open embedding, then 'f' is an open map if and only if the composition of 'g' and 'f' is an open map.\nTranslate the statement in natural language to Lean:", "output": "theorem OpenEmbedding.isOpenMap_iff {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : OpenEmbedding g) :\n    IsOpenMap f \u2194 IsOpenMap (g \u2218 f) :="}
{"input": "Statement in natural language:\nFor any three natural numbers p, a, and b, if p is not equal to 1, the multiplicity of p in a is less than or equal to the multiplicity of p in b, and a and b are coprime, then the multiplicity of p in a is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem multiplicity_eq_zero_of_coprime {p a b : \u2115} (hp : p \u2260 1)\n    (hle : multiplicity p a \u2264 multiplicity p b) (hab : Nat.coprime a b) : multiplicity p a = 0 :="}
{"input": "Statement in natural language:\nFor any morphism 'a' from object 'X' to object 'Y' in category 'C', the sum of 'a' and its negation equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem add_neg_self {X Y : C} (a : X \u27f6 Y) : a + -a = 0 :="}
{"input": "Statement in natural language:\nIf a category C has colimits of shape J, and there is an equivalence between J and another type J', then the category C also has colimits of shape J'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasColimitsOfShape_of_equivalence {J' : Type u\u2082} [Category.{v\u2082} J'] (e : J \u224c J')\n    [HasColimitsOfShape J C] : HasColimitsOfShape J' C :="}
{"input": "Statement in natural language:\nFor any finite type \u03b1, the set of all unordered pairs of elements from the universal set of \u03b1 is equal to the universal set itself.\nTranslate the statement in natural language to Lean:", "output": "theorem sym2_univ [Fintype \u03b1] : (univ : Finset \u03b1).sym2 = univ :="}
{"input": "Statement in natural language:\nA function 'g' from '\u03b2' to '\u03b3' is continuous with respect to the coinduced topology on '\u03b2' from a topological space '\u03b1' and a topology 't\u2082' on '\u03b3', if and only if the composition of 'g' and 'f' is continuous with respect to the topology 't\u2081' on '\u03b1' and the topology 't\u2082' on '\u03b3'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_coinduced_dom {g : \u03b2 \u2192 \u03b3} {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b3} :\n    Continuous[coinduced f t\u2081, t\u2082] g \u2194 Continuous[t\u2081, t\u2082] (g \u2218 f) :="}
{"input": "Statement in natural language:\nThe first projection function has a strict Frechet derivative at any point in the product space of E and F.\nTranslate the statement in natural language to Lean:", "output": "theorem hasStrictFDerivAt_fst : HasStrictFDerivAt (@Prod.fst E F) (fst \ud835\udd5c E F) p :="}
{"input": "Statement in natural language:\nThe intersection over an empty class or set is the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem sInter_empty : \u22c2\u2080 (\u2205 : Class.{u}) = univ :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a type '\u03b1' and any partial function 'o' of type '\u03b1', if 'a' is in 'o' and 'b' is in 'o', then 'a' must be equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_unique : \u2200 {a b : \u03b1} {o : Part \u03b1}, a \u2208 o \u2192 b \u2208 o \u2192 a = b"}
{"input": "Statement in natural language:\nThe absolute value of a divides the absolute value of b if and only if a divides b.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_dvd_abs (a b : \u03b1) : |a| \u2223 |b| \u2194 a \u2223 b :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps from type \u03b2 to \u03b1, and for a list 'l' of type \u03b2, the property of 'l' being a chain under the relation 'R' after mapping with 'f' is equivalent to 'l' being a chain under the relation 'R' where 'R' is applied to the mapped elements of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem chain'_map (f : \u03b2 \u2192 \u03b1) {l : List \u03b2} :\n    Chain' R (map f l) \u2194 Chain' (fun a b : \u03b2 => R (f a) (f b)) l :="}
{"input": "Statement in natural language:\nThe extension of a function 'f' from '\u03b1' to '\u03b3' through an ultrafilter is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_ultrafilter_extend (f : \u03b1 \u2192 \u03b3) : Continuous (Ultrafilter.extend f) :="}
{"input": "Statement in natural language:\nIn a T2 topological space, if two elements x and y commute, then the exponential of x and the exponential of y also commute.\nTranslate the statement in natural language to Lean:", "output": "theorem Commute.exp [T2Space \ud835\udd38] {x y : \ud835\udd38} (h : Commute x y) : Commute (exp \ud835\udd42 x) (exp \ud835\udd42 y) :="}
{"input": "Statement in natural language:\nIf function 'f' has a local minimum at point 'a' in set 's', and function 'g' is an antitone function (a function that decreases when its input increases), then the composition of 'g' and 'f' (g \u2218 f) has a local maximum at the same point 'a' in the same set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalMinOn.comp_antitone (hf : IsLocalMinOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsLocalMaxOn (g \u2218 f) s a :="}
{"input": "Statement in natural language:\nFor any real number x that is greater than 1 and any real number z that is greater than 0, the result of x raised to the power of z is greater than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem one_lt_rpow {x : \u211d\u22650} {z : \u211d} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z :="}
{"input": "Statement in natural language:\nFor any type \u03b2 that has a measurable space structure, and for any two functions X and Y from \u03a9 to \u03b2, if \u03b2 is a normed division ring and a Borel space, and if X and Y are independent functions with respect to measure \u03bc and both are integrable, then the product of X and Y is also integrable with respect to measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem IndepFun.integrable_mul {\u03b2 : Type _} [MeasurableSpace \u03b2] {X Y : \u03a9 \u2192 \u03b2}\n    [NormedDivisionRing \u03b2] [BorelSpace \u03b2] (hXY : IndepFun X Y \u03bc) (hX : Integrable X \u03bc)\n    (hY : Integrable Y \u03bc) : Integrable (X * Y) \u03bc :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1, a function 'f' from \u03b2 'a' to WType \u03b2, and an element 'i' of \u03b2 'a', the depth of the function 'f' applied to 'i' is less than the depth of the WType constructed from 'a' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem depth_lt_depth_mk (a : \u03b1) (f : \u03b2 a \u2192 WType \u03b2) (i : \u03b2 a) : depth (f i) < depth \u27e8a, f\u27e9 :="}
{"input": "Statement in natural language:\nFor an empty set, the sum of measures is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_of_empty [IsEmpty \u03b9] (\u03bc : \u03b9 \u2192 Measure \u03b1) : sum \u03bc = 0 :="}
{"input": "Statement in natural language:\nThe valuation ring is of integers.\nTranslate the statement in natural language to Lean:", "output": "theorem of_integers : ValuationRing \ud835\udcaa :="}
{"input": "Statement in natural language:\nThe function which maps x to the exponential of negative x tends to 0 as x tends to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_exp_neg_atTop_nhds_0 : Tendsto (fun x => exp (-x)) atTop (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nIf function f has a local minimum at point a in set s and function g also has a local minimum at point a in set s, then the function that is the sum of f and g also has a local minimum at point a in set s.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalMinOn.add (hf : IsLocalMinOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMinOn (fun x => f x + g x) s a :="}
{"input": "Statement in natural language:\nFor an antivarying function pair f and g on a set s, the product of the cardinality of the set s and the sum of the product of f(i) and g(i) for all i in s, is less than or equal to the product of the sum of f(i) for all i in s and the sum of g(i) for all i in s.\nTranslate the statement in natural language to Lean:", "output": "theorem AntivaryOn.card_mul_sum_le_sum_mul_sum (hfg : AntivaryOn f g s) :\n    ((s.card : \u03b1) * \u2211 i in s, f i * g i) \u2264 (\u2211 i in s, f i) * \u2211 i in s, g i :="}
{"input": "Statement in natural language:\nMapping the interval from 'a' to 'b' through the value embedding of finite numbers results in the interval from the value of 'a' to the value of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_valEmbedding_Ico : (Ico a b).map Fin.valEmbedding = Ico \u2191a \u2191b :="}
{"input": "Statement in natural language:\nFor any real number 'a' that is less than -1 and any real number 'c' that is greater than 0, the integral from 'c' to infinity of 't' to the power of 'a' is equal to the negative of 'c' to the power of 'a + 1' divided by 'a + 1'.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_Ioi_rpow_of_lt {a : \u211d} (ha : a < -1) {c : \u211d} (hc : 0 < c) :\n    (\u222b t : \u211d in Ioi c, t ^ a) = -c ^ (a + 1) / (a + 1) :="}
{"input": "Statement in natural language:\n'x specializes to y' if and only if the closure of the set containing 'y' is a subset of the closure of the set containing 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem specializes_iff_closure_subset : x \u2933 y \u2194 closure ({y} : Set X) \u2286 closure {x} :="}
{"input": "Statement in natural language:\nIf sets s and t are disjoint, then the cardinality (or size) of the union of s and t is equal to the sum of the cardinalities of s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem card_disjoint_union (h : Disjoint s t) : card (s \u222a t) = s.card + t.card :="}
{"input": "Statement in natural language:\nFor a normed add commutative group E, if the supremum norm of the difference between a sequence of functions f and a function g tends to 0 as n tends to infinity (with respect to a filter l), then the sequence of functions f converges in measure to the function g.\nTranslate the statement in natural language to Lean:", "output": "theorem tendstoInMeasure_of_tendsto_snorm_top {E} [NormedAddCommGroup E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E}\n    {l : Filter \u03b9} (hfg : Tendsto (fun n => snorm (f n - g) \u221e \u03bc) l (\ud835\udcdd 0)) :\n    TendstoInMeasure \u03bc f l g :="}
{"input": "Statement in natural language:\nFor a measure \u03bd on \u03b2, a function f from \u03b1 to \u03b2, and two functions g and g' from \u03b2 to \u03b4, if f is almost everywhere measurable with respect to \u03bc, g is almost everywhere equal to g' with respect to \u03bd, and the measure of f's image under \u03bc is absolutely continuous with respect to \u03bd, then the composition of g and f is almost everywhere equal to the composition of g' and f with respect to \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_eq_comp' {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4} (hf : AEMeasurable f \u03bc)\n    (h : g =\u1d50[\u03bd] g') (h2 : \u03bc.map f \u226a \u03bd) : g \u2218 f =\u1d50[\u03bc] g' \u2218 f :="}
{"input": "Statement in natural language:\nFor a property 'p' pertaining to elements of a group 'G' and a given element 'x' of 'G' that belongs to the closure of a subset 's' of 'G', if the property 'p' holds for the identity element '1' of the group, and if for every element 'x' in 's' and any element 'y' of 'G', the property 'p' holding for 'y' implies that 'p' holds for the product of 'x' and 'y', and similarly, the property 'p' holding for 'y' implies that 'p' holds for the product of the inverse of 'x' and 'y', then the property 'p' holds for the element 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_induction_left {p : G \u2192 Prop} {x : G} (h : x \u2208 closure s) (H1 : p 1)\n    (Hmul : \u2200 x \u2208 s, \u2200 (y), p y \u2192 p (x * y)) (Hinv : \u2200 x \u2208 s, \u2200 (y), p y \u2192 p (x\u207b\u00b9 * y)) : p x :="}
{"input": "Statement in natural language:\nFor any real number x, x is equal to zero in the extended real number system if and only if x is equal to zero in the real number system.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_eq_zero {x : \u211d} : (x : EReal) = 0 \u2194 x = 0 :="}
{"input": "Statement in natural language:\nFor a prime number p, if for every natural number n, the result of applying the function bind\u2081 to the function f and the Witt polynomial of p and n is equal to the result of applying the function bind\u2081 to the function g and the Witt polynomial of p and n, then the function f is equal to the function g.\nTranslate the statement in natural language to Lean:", "output": "theorem poly_eq_of_wittPolynomial_bind_eq' [Fact p.Prime] (f g : \u2115 \u2192 MvPolynomial (idx \u00d7 \u2115) \u2124)\n    (h : \u2200 n, bind\u2081 f (wittPolynomial p _ n) = bind\u2081 g (wittPolynomial p _ n)) : f = g :="}
{"input": "Statement in natural language:\nIf a function 'f' is antitone (meaning it is decreasing), then the function that maps 'x' to the interval of all real numbers greater than 'f(x)' is monotone (meaning it is either entirely non-increasing or non-decreasing).\nTranslate the statement in natural language to Lean:", "output": "theorem Antitone.Ioi (hf : Antitone f) : Monotone fun x => Ioi (f x) :="}
{"input": "Statement in natural language:\nIf a filter 'l' has a basis consisting of sets that belong to 'l' and satisfy a property 'p', then for any set 'V' that belongs to 'l', 'l' also has a basis consisting of sets that belong to 'l', satisfy the property 'p', and are subsets of 'V'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasBasis.hasBasis_self_subset {p : Set \u03b1 \u2192 Prop} (h : l.HasBasis (fun s => s \u2208 l \u2227 p s) id)\n    {V : Set \u03b1} (hV : V \u2208 l) : l.HasBasis (fun s => s \u2208 l \u2227 p s \u2227 s \u2286 V) id :="}
{"input": "Statement in natural language:\nThe first element of the power of a sequence 's' raised to the 'n' is equal to the first element of 's' raised to the 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_pow : (s ^ n).fst = s.fst ^ n :="}
{"input": "Statement in natural language:\nThe supremum of the product of two sets (s\u2081 and s\u2082) and a set t is equal to the supremum of the product of set s\u2081 and t and the product of set s\u2082 and t.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_prod : (s\u2081 \u2294 s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2294 s\u2082 \u00d7\u02e2 t :="}
{"input": "Statement in natural language:\nA matrix A belongs to the submodule of pair self-adjoint matrices with respect to bilinear forms J and J\u2083 if and only if the matrix A forms an adjoint pair with itself with respect to these bilinear forms.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_pairSelfAdjointMatricesSubmodule' :\n    A \u2208 pairSelfAdjointMatricesSubmodule J J\u2083 \u2194 Matrix.IsAdjointPair J J\u2083 A A :="}
{"input": "Statement in natural language:\nIf a certain number 'a' is less than 1, then 'a' is less than its own inverse.\nTranslate the statement in natural language to Lean:", "output": "theorem Right.self_lt_inv (h : a < 1) : a < a\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any two Cauchy sequences f and g over a field with an absolute value function, the function of their product sequence is equal to the product of the functions of f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mul (f g : CauSeq \u03b2 abv) : \u21d1(f * g) = (f : \u2115 \u2192 \u03b2) * g :="}
{"input": "Statement in natural language:\nFor a sigma-finite measure '\u03bc' and a measurable set 's', the measure of the intersection of 's' and the measurable representative of set 't' under '\u03bc' is equal to the measure of the intersection of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem measure_toMeasurable_inter_of_sigmaFinite [SigmaFinite \u03bc] {s : Set \u03b1} (hs : MeasurableSet s)\n    (t : Set \u03b1) : \u03bc (toMeasurable \u03bc t \u2229 s) = \u03bc (t \u2229 s) :="}
{"input": "Statement in natural language:\nIf a function f has a derivative f' within a set s at a point x, and another function g has a derivative g' within the same set s at the same point x, and if the value of function f at point x is greater than 0, then the function that is the result of raising f(x) to the power of g(x) has a derivative within set s at point x. This derivative is equal to the sum of two terms: the first term is the product of g(x), f(x) raised to the power of (g(x) - 1), and the derivative of f, and the second term is the product of f(x) raised to the power of g(x), the natural logarithm of f(x), and the derivative of g.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivWithinAt.rpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h : 0 < f x) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') s x :="}
{"input": "Statement in natural language:\nFor any two elements 'x' and 'y' of a type '\u03b1', 'x' is not a duplicate in the singleton list containing only 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_duplicate_singleton (x y : \u03b1) : \u00acx \u2208+ [y] :="}
{"input": "Statement in natural language:\nThere exists a two-pointing structure on a set \u03b1 if and only if \u03b1 is a nontrivial set.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_two_pointing_iff : Nonempty (TwoPointing \u03b1) \u2194 Nontrivial \u03b1 :="}
{"input": "Statement in natural language:\nFor a given submodule 'p' of a module 'M' over a ring 'R', the image of 'p' under a linear map 'e' from 'M' to another module 'M\u2082' over a ring 'R\u2082' is equal to the preimage of 'p' under the inverse of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_eq_comap {p : Submodule R M} :\n    (p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : Submodule R\u2082 M\u2082) = p.comap (e.symm : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) :="}
{"input": "Statement in natural language:\nFor a set C of subsets of \u03b1, a sequence B of subsets of \u03b1, given that the smallest sigma-algebra containing C equals the given sigma-algebra, C is a pi-system, the union of all subsets in the sequence B equals the universal set, every subset in the sequence B is in C, the measure of every subset in the sequence B is not infinite, and the measure of every subset in C is equal under measures \u03bc and \u03bd, then \u03bc equals \u03bd.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_of_generateFrom_of_iUnion (C : Set (Set \u03b1)) (B : \u2115 \u2192 Set \u03b1) (hA : \u2039_\u203a = generateFrom C)\n    (hC : IsPiSystem C) (h1B : (\u22c3 i, B i) = univ) (h2B : \u2200 i, B i \u2208 C) (h\u03bcB : \u2200 i, \u03bc (B i) \u2260 \u221e)\n    (h_eq : \u2200 s \u2208 C, \u03bc s = \u03bd s) : \u03bc = \u03bd :="}
{"input": "Statement in natural language:\nThe inverse of the isomorphism that preserves the pullback, when composed with the mapping of the pullback's first projection under a functor G, is equal to the first projection of the pullback.\nTranslate the statement in natural language to Lean:", "output": "theorem PreservesPullback.iso_inv_fst :\n    (PreservesPullback.iso G f g).inv \u226b G.map pullback.fst = pullback.fst :="}
{"input": "Statement in natural language:\nThere exists a nonempty limit of a fork of a certain type if and only if for every element 'y' of type 'Y', if 'g y' equals 'h y', then there exists a unique 'x' of type 'X' such that 'f x' equals 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem type_equalizer_iff_unique :\n    Nonempty (IsLimit (Fork.of\u03b9 _ w)) \u2194 \u2200 y : Y, g y = h y \u2192 \u2203! x : X, f x = y :="}
{"input": "Statement in natural language:\nIf the index of a subgroup H is 2, then the product of any element a in the group G with itself is an element of the subgroup H.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_self_mem_of_index_two (h : H.index = 2) (a : G) : a * a \u2208 H :="}
{"input": "Statement in natural language:\nThe product of 's' and 't' equals one if and only if there exist 'a' and 'b' such that 's' equals 'a' and 't' equals 'b', and the product of 'a' and 'b' equals one.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_eq_one_iff : s * t = 1 \u2194 \u2203 a b, s = pure a \u2227 t = pure b \u2227 a * b = 1 :="}
{"input": "Statement in natural language:\nIn a non-associative ring R, for any elements n and r of R, the product of the quantity \"bit1 n\" (which represents 2n + 1) and r is equal to twice the product of n and r, plus r.\nTranslate the statement in natural language to Lean:", "output": "theorem bit1_mul [NonAssocRing R] {n r : R} : bit1 n * r = (2 : \u2124) \u2022 (n * r) + r :="}
{"input": "Statement in natural language:\nFor an isometry 'h' between two metric spaces '\u03b1' and '\u03b2', the range of 'h' is equal to the entire space '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_eq_univ (h : \u03b1 \u2243\u1d62 \u03b2) : range h = univ :="}
{"input": "Statement in natural language:\nFor a given type \u03b9 and a function f from \u03b9 to an ordinal, the supremum of f equals zero if and only if for all i, f(i) equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_eq_zero_iff {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} :\n    sup.{_, v} f = 0 \u2194 \u2200 i, f i = 0 :="}
{"input": "Statement in natural language:\nFor a measurable space '\u03b1' and a set 'E' that is both countable and a measurable singleton class, if 'f' and 'g' are measurable functions from '\u03b1' to 'E', then the set of all 'x' in '\u03b1' for which 'f(x)' equals 'g(x)' is a measurable set.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_eq_fun_of_countable {m : MeasurableSpace \u03b1} {E} [MeasurableSpace E]\n    [MeasurableSingletonClass E] [Countable E] {f g : \u03b1 \u2192 E} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { x | f x = g x } :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2' that is injective, the image of 's' under 'f' is a subset of the image of 't' under 'f' if and only if 's' is a subset of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_subset_image_iff {f : \u03b1 \u2192 \u03b2} (hf : Injective f) : f '' s \u2286 f '' t \u2194 s \u2286 t :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type '\u03b1', if 's' is intersecting, then for any element 'a' in 's', the complement of 'a' is not in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Intersecting.not_compl_mem {s : Set \u03b1} (hs : s.Intersecting) {a : \u03b1} (ha : a \u2208 s) :\n    a\u1d9c \u2209 s :="}
{"input": "Statement in natural language:\nIf 'a' is an extreme point for function 'f' on set 's', then if 'a' is a minimum point for 'f' on 's' implies a proposition 'p', and if 'a' is a maximum point for 'f' on 's' also implies the same proposition 'p', then the proposition 'p' is true.\nTranslate the statement in natural language to Lean:", "output": "theorem IsExtrOn.elim {p : Prop} : IsExtrOn f s a \u2192 (IsMinOn f s a \u2192 p) \u2192 (IsMaxOn f s a \u2192 p) \u2192 p :="}
{"input": "Statement in natural language:\nThe ordinal representation of zero is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem toOrdinal_zero : toOrdinal 0 = 0 :="}
{"input": "Statement in natural language:\nThe function to convert a non-negative extended real number to a non-negative real number, when applied to any non-negative extended real number, results in the original non-negative extended real number.\nTranslate the statement in natural language to Lean:", "output": "theorem toNNReal_coe : (r : \u211d\u22650\u221e).toNNReal = r :="}
{"input": "Statement in natural language:\nFor a given type \u03b1 and two linear orders A and B on \u03b1, if for all elements x and y of type \u03b1, the order relation \"less than or equal to\" under A is equivalent to the order relation \"less than or equal to\" under B, then A and B are the same linear order.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearOrder.ext {\u03b1} {A B : LinearOrder \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) : A = B :="}
{"input": "Statement in natural language:\nIf we have a Noetherian ring 'R' and a module 'N' over 'R', and if 'f' is an injective linear map from module 'M' to 'N', then the module 'M' is finite over the ring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.of_injective [IsNoetherian R N] (f : M \u2192\u2097[R] N) (hf : Function.Injective f) :\n    Finite R M :="}
{"input": "Statement in natural language:\nIf we have two functions, one from \u03b1 to \u03b2 and the other from \u03b2 to \u03b1, such that the second function is continuous and is both a left and right inverse of the first function, then the first function is an open map. An open map is a function between two topological spaces that maps open sets to open sets.\nTranslate the statement in natural language to Lean:", "output": "theorem of_inverse {f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1} (h : Continuous f') (l_inv : LeftInverse f f')\n    (r_inv : RightInverse f f') : IsOpenMap f :="}
{"input": "Statement in natural language:\nFor a bilinear form B (a linear map from a function n to R to another linear map from a function m to R to R), converting this bilinear form to a matrix using the function 'LinearMap.toMatrix\u2082' and then converting it back to a linear map using the function 'Matrix.toLinearMap\u2082' will yield the original bilinear form B.\nTranslate the statement in natural language to Lean:", "output": "theorem Matrix.toLinearMap\u2082'_toMatrix' (B : (n \u2192 R) \u2192\u2097[R] (m \u2192 R) \u2192\u2097[R] R) :\n    Matrix.toLinearMap\u2082' (LinearMap.toMatrix\u2082' B) = B :="}
{"input": "Statement in natural language:\nFor any type K that is a commutative ring, a domain, and has characteristic zero, and for any element \u03b6 of K and positive natural number n such that \u03b6 is a primitive root of n, there exists a unique polynomial P with integer coefficients such that when we map P to K using the ring homomorphism from integers to K, we get the nth cyclotomic polynomial in K.\nTranslate the statement in natural language to Lean:", "output": "theorem unique_int_coeff_of_cycl {K : Type _} [CommRing K] [IsDomain K] [CharZero K] {\u03b6 : K}\n    {n : \u2115+} (h : IsPrimitiveRoot \u03b6 n) :\n    \u2203! P : \u2124[X], map (Int.castRingHom K) P = cyclotomic' n K :="}
{"input": "Statement in natural language:\nA pair 'x' belongs to the target of 'e' if and only if the first element of 'x' belongs to the base set of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_target {x : B \u00d7 F} : x \u2208 e.target \u2194 x.1 \u2208 e.baseSet :="}
{"input": "Statement in natural language:\nA graph G is not n-clique-free if and only if there exists a subgraph of G that is a complete graph with n vertices.\nTranslate the statement in natural language to Lean:", "output": "theorem not_cliqueFree_iff (n : \u2115) : \u00acG.CliqueFree n \u2194 Nonempty ((\u22a4 : SimpleGraph (Fin n)) \u21aag G) :="}
{"input": "Statement in natural language:\nFor any functions x and y from an index set to a set of real numbers \u03b1, and for any index i\u2080 and real number m in \u03b1, the set of all functions that for each index i return a real number strictly between x(i) and the updated value of y at index i\u2080 with m, is disjoint from the set of all functions that for each index i return a real number strictly between the updated value of x at index i\u2080 with m and y(i).\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_pi_univ_Ioc_update_left_right {x y : \u2200 i, \u03b1 i} {i\u2080 : \u03b9} {m : \u03b1 i\u2080} :\n    Disjoint (pi univ fun i \u21a6 Ioc (x i) (update y i\u2080 m i))\n    (pi univ fun i \u21a6 Ioc (update x i\u2080 m i) (y i)) :="}
{"input": "Statement in natural language:\nIn the context of a pseudometric space with elements of type \u03b2, for a given set t of type \u03b2, a function f from \u03b1 to \u03b2, and elements a and b, the function f tends towards the neighborhood within set s of a and the neighborhood within set t of b if and only if for every positive number \u03b5, there exists a positive number \u03b4 such that for every element x of type \u03b1, if x is in set s and the distance between x and a is less than \u03b4, then the function of x is in set t and the distance between the function of x and b is less than \u03b5.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_nhdsWithin_nhdsWithin [PseudoMetricSpace \u03b2] {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} {a b} :\n    Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd[t] b) \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, x \u2208 s \u2192 dist x a < \u03b4 \u2192 f x \u2208 t \u2227 dist (f x) b < \u03b5 :="}
{"input": "Statement in natural language:\nIf a divides the difference of b and c, then a divides b if and only if a divides c.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_iff_dvd_of_dvd_sub (h : a \u2223 b - c) : a \u2223 b \u2194 a \u2223 c :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and x of a set \u03b1, x is in the interval (a, b] if and only if a is less than x and x is less than or equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_Ioc {a b x : \u03b1} : x \u2208 Ioc a b \u2194 a < x \u2227 x \u2264 b :="}
{"input": "Statement in natural language:\nIf an affine subspace s\u2081 is parallel to another affine subspace s\u2082, then s\u2082 is also parallel to s\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem Parallel.symm {s\u2081 s\u2082 : AffineSubspace k P} (h : s\u2081 \u2225 s\u2082) : s\u2082 \u2225 s\u2081 :="}
{"input": "Statement in natural language:\nFor any morphism 'a' from object X to object Y in category C, the sum of the negative of 'a' and 'a' itself equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_add_self {X Y : C} (a : X \u27f6 Y) : -a + a = 0 :="}
{"input": "Statement in natural language:\nFor any two nonempty sets 's' and 't', the Hausdorff distance between 's' and 't' is less than or equal to the diameter of the union of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem hausdorffEdist_le_ediam (hs : s.Nonempty) (ht : t.Nonempty) :\n    hausdorffEdist s t \u2264 diam (s \u222a t) :="}
{"input": "Statement in natural language:\nFor a strictly increasing function 'f' from a linearly ordered set '\u03b1' to a preordered set '\u03b2' with a greatest element, if the image of an element 'a' under 'f' is the greatest element of '\u03b2', then any element 'x' in '\u03b1' is less than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictMono.maximal_preimage_top [LinearOrder \u03b1] [Preorder \u03b2] [OrderTop \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (H : StrictMono f) {a} (h_top : f a = \u22a4) (x : \u03b1) : x \u2264 a :="}
{"input": "Statement in natural language:\nThe intersection over all sets in the preimage filter of a function 'f' and a filter 'F' is equal to the intersection of the preimage of all sets 'U' in the filter 'F' under the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem sInter_comap_sets (f : \u03b1 \u2192 \u03b2) (F : Filter \u03b2) : \u22c2\u2080 (comap f F).sets = \u22c2 U \u2208 F, f \u207b\u00b9' U :="}
{"input": "Statement in natural language:\nFor a partial recursive function 'f' from '\u03b1' to '\u03c3', the function 'f' is partial recursive if and only if the function that maps each element 'a' to the option 'some' of the result of 'f(a)' is also partial recursive.\nTranslate the statement in natural language to Lean:", "output": "theorem option_some_iff {f : \u03b1 \u2192. \u03c3} : (Partrec fun a => (f a).map Option.some) \u2194 Partrec f :="}
{"input": "Statement in natural language:\nThe span of the range of the Gram-Schmidt process applied to a function f is equal to the span of the range of the function f itself. This is in the context of inner product spaces over a field \ud835\udd5c and a function f mapping from an index set \u03b9 to a vector space E.\nTranslate the statement in natural language to Lean:", "output": "theorem span_gramSchmidt (f : \u03b9 \u2192 E) : span \ud835\udd5c (range (gramSchmidt \ud835\udd5c f)) = span \ud835\udd5c (range f) :="}
{"input": "Statement in natural language:\nFor any natural number 'n', and for any 'j' in the finite set of 'n+2' elements and 'i' in the finite set of 'n+1' elements, if 'j' is equal to the successor of 'i' when cast to a finite set, then the composition of the face map '\u03b4' at 'j' and the degeneracy map '\u03c3' at 'i' is equal to the identity morphism in the Simplex Category of '[n]'.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03b4_comp_\u03c3_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    \u03b4 j \u226b \u03c3 i = \ud835\udfd9 ([n] : SimplexCategory) :="}
{"input": "Statement in natural language:\nThe function which takes a natural number 'k' and maps it to the difference between the logarithm of 'k+1' and the logarithm of 'k', tends to 0 as 'k' tends to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_log_nat_add_one_sub_log : Tendsto (fun k : \u2115 => log (k + 1) - log k) atTop (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nFor a given constant 'b' of type '\u03b2', 'b' is a local minimum on set 's' at point 'a'. This is true because 'b' is constant and does not change, hence it is always the minimum at any point in the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isLocalMinOn_const {b : \u03b2} : IsLocalMinOn (fun _ => b) s a :="}
{"input": "Statement in natural language:\nFor two ring homomorphisms `f` and `g` from the quotient rings `R/I` to `A/J` and `A/J` to `B/L` respectively, if both `f` and `g` are surjective, then the composition of the ideal factor functions of `f` and `g` is equal to the ideal factor function of the composition of `g` and `f`.\nTranslate the statement in natural language to Lean:", "output": "theorem idealFactorsFunOfQuotHom_comp {f : R \u29f8 I \u2192+* A \u29f8 J} {g : A \u29f8 J \u2192+* B \u29f8 L}\n    (hf : Function.Surjective f) (hg : Function.Surjective g) :\n    (idealFactorsFunOfQuotHom hg).comp (idealFactorsFunOfQuotHom hf) =\n      idealFactorsFunOfQuotHom (show Function.Surjective (g.comp f) from hg.comp hf) :="}
{"input": "Statement in natural language:\nThere exists a property 'p' of a dependent pair (a, \u03b2 a) if and only if there exist elements 'a' and 'b' such that the property 'p' holds for the pair (a, b).\nTranslate the statement in natural language to Lean:", "output": "theorem \u00abexists\u00bb {p : (\u03a3'a, \u03b2 a) \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 a b, p \u27e8a, b\u27e9 :="}
{"input": "Statement in natural language:\n\"u is little o of v at limit point l\" if and only if there exists a function \u03c6 from \u03b1 to \ud835\udd5c such that \u03c6 tends to 0 at limit point l, and u is eventually equal to \u03c6 times v at limit point l.\nTranslate the statement in natural language to Lean:", "output": "theorem isLittleO_iff_exists_eq_mul :\n    u =o[l] v \u2194 \u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c)(_h\u03c6 : Tendsto \u03c6 l (\ud835\udcdd 0)), u =\u1da0[l] \u03c6 * v :="}
{"input": "Statement in natural language:\nIf the sets 's' and 't' are disjoint (i.e., they have no elements in common) and both are finite, then the product of the function 'f' over the union of 's' and 't' is equal to the product of the function 'f' over 's' times the product of the function 'f' over 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_mem_union (hst : Disjoint s t) (hs : s.Finite) (ht : t.Finite) :\n    (\u220f\u1da0 i \u2208 s \u222a t, f i) = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i :="}
{"input": "Statement in natural language:\nThe length of a list, after concatenating it with an element 'a', is equal to the successor of the original length of the list. This means that adding an element to a list increases its length by one.\nTranslate the statement in natural language to Lean:", "output": "theorem length_concat' (a : \u03b1) (l : List \u03b1) : length (concat l a) = succ (length l) :="}
{"input": "Statement in natural language:\nThe normalized factors of zero, in the context of a unique factorization domain, are equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem normalizedFactors_zero : normalizedFactors (0 : \u03b1) = 0 :="}
{"input": "Statement in natural language:\nFor any elements 'x' and 'y' of a set 'S', there exists an element 'c' in 'S' such that the product of 'c' and the product of the second element of the section of the function 'f.mk' applied to 'x' and 'y' and 'x' is equal to the product of 'c' and the product of 'y' and the first element of the section of the function 'f.mk' applied to 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_of_sec_mk' (x) (y : S) :\n    \u2203 c : S, \u2191c * (\u2191(f.sec <| f.mk' x y).2 * x) = c * (y * (f.sec <| f.mk' x y).1) :="}
{"input": "Statement in natural language:\nIf a function 'f' has an extreme value at a point 'a' in a set 's', and if another function 'g' is monotone, then the composition of 'g' and 'f' also has an extreme value at the same point 'a' in the same set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsExtrOn.comp_mono (hf : IsExtrOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsExtrOn (g \u2218 f) s a :="}
{"input": "Statement in natural language:\nThe function f is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous : Continuous f :="}
{"input": "Statement in natural language:\nFor any natural number 'n', if for all 'm' less than or equal to 'n', 'P m' is not true, then 'n' is less than the first natural number for which 'P' is true.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_find (n : \u2115) (h : \u2200 m \u2264 n, \u00acP m) : (n : PartENat) < find P :="}
{"input": "Statement in natural language:\nFor any two elements x and y, x minus y is in the kernel of a function f if and only if the function of x equals the function of y.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_mem_ker_iff {x y} : x - y \u2208 ker f \u2194 f x = f y :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from object X to Y, which has a kernel, and a monomorphism 'h' from Y to Z, the kernel subobject of the composition of 'f' and 'h' is equal to the kernel subobject of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem kernelSubobject_comp_mono (f : X \u27f6 Y) [HasKernel f] {Z : C} (h : Y \u27f6 Z) [Mono h] :\n    kernelSubobject (f \u226b h) = kernelSubobject f :="}
{"input": "Statement in natural language:\nFor any two numbers 'a' and 'b' that are not infinity, 'a' is less than or equal to 'b' when converted to non-negative real numbers if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem toNNReal_le_toNNReal (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : a.toNNReal \u2264 b.toNNReal \u2194 a \u2264 b :="}
{"input": "Statement in natural language:\nFor a polynomial function 'f' over the ring 'R', a natural number 'n', another natural number 'm' and a constant 'c' from the ring 'R' where 'm' is not equal to zero, 'n' divides the evaluation of 'c' in the 'm'-th derivative of the 'n'-th power of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_iterate_derivative_pow (f : R[X]) (n : \u2115) {m : \u2115} (c : R) (hm : m \u2260 0) :\n    (n : R) \u2223 eval c ((derivative^[m]) (f ^ n)) :="}
{"input": "Statement in natural language:\nFor a non-zero natural number 'n', given a finite sequence 'p' of length 'n + 1', an element 'i' of another finite sequence of length 'n', and a condition 'h' that 'i' is greater than 0, the successor of 'i' in the sequence 'p' is also greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem succAbove_pos [NeZero n] (p : Fin (n + 1)) (i : Fin n) (h : 0 < i) : 0 < p.succAbove i :="}
{"input": "Statement in natural language:\nIf there exists a multiset 's' such that the map of a polynomial 'f' over a field 'K' is equal to the leading coefficient of 'f' times the product of the map of 's' where each element 'a' in 'L' is subtracted from 'X', then 'f' splits over 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem splits_of_exists_multiset {f : K[X]} {s : Multiset L}\n    (hs : f.map i = C (i f.leadingCoeff) * (s.map fun a : L => X - C a).prod) : Splits i f :="}
{"input": "Statement in natural language:\nIf function f has a local minimum at a point a, then the function that maps x to the negative of f(x) has a local maximum at the same point a.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalMin.neg (hf : IsLocalMin f a) : IsLocalMax (fun x => -f x) a :="}
{"input": "Statement in natural language:\nFor any comonad G in category C and any object X in C, the composition of the duplication map of G at X and the counit map of G at the image of X under G is equal to the identity map at the image of X under G.\nTranslate the statement in natural language to Lean:", "output": "theorem Comonad.left_counit (G : Comonad C) (X : C) :\n    G.\u03b4.app X \u226b G.\u03b5.app ((G : C \u2964 C).obj X) = \ud835\udfd9 ((G : C \u2964 C).obj X) :="}
{"input": "Statement in natural language:\nFor any type '\u03b1' and any type 'S', if there is an equivalence between '\u03b1' and 'S', then '\u03b1' is a small type in the context of 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem Small.mk' {\u03b1 : Type v} {S : Type w} (e : \u03b1 \u2243 S) : Small.{w} \u03b1 :="}
{"input": "Statement in natural language:\nFor any natural number 'm', the localization of 'm' over 1 in a multiplicative set 'M' is equal to 'm' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_nat_cast (m : \u2115) : (mk m 1 : Localization M) = m :="}
{"input": "Statement in natural language:\nFor any types \u03a9 and \u03b9, given a filter L on \u03b9, a measurable space on \u03a9, a pseudo emetric space on \u03a9, an open measurable space on \u03a9, a probability measure \u03bc on \u03a9, and a function \u03bcs from \u03b9 to the set of probability measures on \u03a9 that tends to \u03bc with respect to the filter L, if F is a closed set in \u03a9, then the limit superior of the measures of F under the sequence of probability measures \u03bcs with respect to the filter L is less than or equal to the measure of F under the probability measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem ProbabilityMeasure.limsup_measure_closed_le_of_tendsto {\u03a9 \u03b9 : Type _} {L : Filter \u03b9}\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9] {\u03bc : ProbabilityMeasure \u03a9}\n    {\u03bcs : \u03b9 \u2192 ProbabilityMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs L (\ud835\udcdd \u03bc)) {F : Set \u03a9}\n    (F_closed : IsClosed F) : (L.limsup fun i => (\u03bcs i : Measure \u03a9) F) \u2264 (\u03bc : Measure \u03a9) F :="}
{"input": "Statement in natural language:\nIf a function 'f' is antitone (decreasing) on a set 's' and 's' is a convex set in a field '\ud835\udd5c', then for any value 'r' in the codomain '\u03b2', the set of all 'x' in 's' for which 'f(x)' is less than 'r' is also a convex set in '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem AntitoneOn.convex_lt (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x < r }) :="}
{"input": "Statement in natural language:\nFor any zero ring R, the function that maps any element of a set M to the trivial square zero extension of R and M, specifically to the right component, is an embedding. This means that the function preserves the structure of M when it is mapped into the trivial square zero extension.\nTranslate the statement in natural language to Lean:", "output": "theorem embedding_inr [Zero R] : Embedding (inr : M \u2192 tsze R M) :="}
{"input": "Statement in natural language:\nFor a non-zero polynomial 'p' and a real number 'x', the root multiplicity of 'x' in 'p' is greater than zero if and only if 'x' is a root of the polynomial 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem rootMultiplicity_pos {p : R[X]} (hp : p \u2260 0) {x : R} :\n    0 < rootMultiplicity x p \u2194 IsRoot p x :="}
{"input": "Statement in natural language:\nIf a function f has a derivative f' within a set s at a point x, and the value of the function f at x is not equal to zero, then the derivative within the set s at the point x of the function that takes y to the logarithm of f(y) is equal to the derivative of f divided by the value of f at x.\nTranslate the statement in natural language to Lean:", "output": "theorem HasDerivWithinAt.log (hf : HasDerivWithinAt f f' s x) (hx : f x \u2260 0) :\n    HasDerivWithinAt (fun y => log (f y)) (f' / f x) s x :="}
{"input": "Statement in natural language:\nIf set t is almost everywhere equal to the universal set with respect to measure \u03bc, then the intersection of sets s and t is almost everywhere equal to set s with respect to the same measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_ae_eq_left_of_ae_eq_univ (h : t =\u1d50[\u03bc] univ) : (s \u2229 t : Set \u03b1) =\u1d50[\u03bc] s :="}
{"input": "Statement in natural language:\nIf you look up an element 'a' in a list 's' after erasing 'a' from 's', you will get 'none'. This is because 'a' no longer exists in the list 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem lookup_erase (a) (s : AList \u03b2) : lookup a (erase a s) = none :="}
{"input": "Statement in natural language:\nUnder the conditions of an open positive measure and a normed field and space, the function 'toLp' mapping from bounded continuous functions to Lp spaces is injective. This means that if two different bounded continuous functions are input into 'toLp', the outputs in the Lp space will also be different.\nTranslate the statement in natural language to Lean:", "output": "theorem toLp_injective [\u03bc.IsOpenPosMeasure] [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    Function.Injective (\u21d1(toLp p \u03bc \ud835\udd5c : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc)) :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any two elements 'i' and 'j' of the finite sets of size 'n+3' and 'n+2' respectively, if 'j+1' is less than 'i', then the composition of the morphism '\u03b4' at 'i' and the morphism '\u03c3' at 'j' is equal to the composition of the morphism '\u03c3' at 'j' (cast to be less than 'i+1' because 'j+1' is less than 'i') and the morphism '\u03b4' at the predecessor of 'i' (assuming 'i' is not less than zero, which contradicts the assumption that 'j+1' is less than 'i').\nTranslate the statement in natural language to Lean:", "output": "theorem \u03b4_comp_\u03c3_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    \u03b4 i \u226b \u03c3 j = \u03c3 (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) \u226b\n      \u03b4 (i.pred fun hi => by simp only [Fin.not_lt_zero, hi] at H) :="}
{"input": "Statement in natural language:\nFor any prime number 'p' and any non-zero element 'a' of the integers modulo 'p', 'a' raised to the power of 'p' minus one equals one.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_card_sub_one_eq_one {p : \u2115} [Fact p.Prime] {a : ZMod p} (ha : a \u2260 0) :\n    a ^ (p - 1) = 1 :="}
{"input": "Statement in natural language:\nFor a bijective function 'e' from set \u03b1 to set \u03b2, if both 'e' and its inverse 'e.symm' are measurable, then the measure-preserving transformation that 'e' induces has a symmetric transformation that is induced by 'e.symm', with the measurability conditions reversed.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_mk (e : \u03b1 \u2243 \u03b2) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    (\u27e8e, h1, h2\u27e9 : \u03b1 \u2243\u1d50 \u03b2).symm = \u27e8e.symm, h2, h1\u27e9 :="}
{"input": "Statement in natural language:\nFor a given finite set 's' and an element 'a', erasing 'a' from 's' is equivalent to the difference of 's' and the set containing 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_eq (s : Finset \u03b1) (a : \u03b1) : s.erase a = s \\ {a} :="}
{"input": "Statement in natural language:\nFor any Karoubi-enriched simplicial object P, the composition of the inverse of the N\u2082\u0393\u2082 functor applied to P and the N\u2082 map of the natural transformation from \u0393\u2082N\u2082 applied to P, is equal to the identity on the N\u2082 functor applied to P.\nTranslate the statement in natural language to Lean:", "output": "theorem identity_N\u2082_objectwise (P : Karoubi (SimplicialObject C)) :\n  (N\u2082\u0393\u2082.inv.app (N\u2082.obj P) : N\u2082.obj P \u27f6 N\u2082.obj (\u0393\u2082.obj (N\u2082.obj P))) \u226b N\u2082.map (\u0393\u2082N\u2082.natTrans.app P) =\n    \ud835\udfd9 (N\u2082.obj P) :="}
{"input": "Statement in natural language:\nApplying the \"reduce\" function twice to a list \"L\" is equivalent to applying it once.\nTranslate the statement in natural language to Lean:", "output": "theorem reduce.idem : reduce (reduce L) = reduce L :="}
{"input": "Statement in natural language:\nFor a given Sylow p-subgroup P of a group G and a subgroup H of G, if P is a subset of H, then for any element h in H, the action of h on the subtype of P with respect to H is equal to the subtype of the action of h on P with respect to the condition that the action of h on P is a subset of H.\nTranslate the statement in natural language to Lean:", "output": "theorem Sylow.smul_subtype {P : Sylow p G} {H : Subgroup G} (hP : \u2191P \u2264 H) (h : H) :\n    h \u2022 P.subtype hP = (h \u2022 P).subtype (Sylow.smul_le hP h) :="}
{"input": "Statement in natural language:\nFor any two elements 'x' and 'y', the first component of the lift of 'f' applied to the tensor product of 'x' and 'y' is equal to 'f' applied to 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift.tmul' (x y) : (lift f).1 (x \u2297\u209c y) = f x y :="}
{"input": "Statement in natural language:\nFor any element 'x' in a field extension 'L' of a field 'K', given that 'L' is a finite-dimensional extension of 'K' and 'x' is integral over 'K', the natural degree of the minimal polynomial of 'x' over 'K' is less than or equal to the finite rank of 'L' over 'K'.\nTranslate the statement in natural language to Lean:", "output": "theorem minpoly.natDegree_le {x : L} [FiniteDimensional K L] (hx : IsIntegral K x) :\n    (minpoly K x).natDegree \u2264 finrank K L :="}
{"input": "Statement in natural language:\nFor any two order-embedding functions 'f' from 'r' to 's' and 'g' from 's' to 't', the composition of 'f' and 'g' is equal to the transitive closure of 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_trans (f : r \u21aar s) (g : s \u21aar t) : (f.trans g) = g \u2218 f :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't' in an additive monoid '\u03b1' that also forms a star-additive monoid, the star of the sum of 's' and 't' is equal to the sum of the star of 's' and the star of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem star_add [AddMonoid \u03b1] [StarAddMonoid \u03b1] (s t : Set \u03b1) : (s + t)\u22c6 = s\u22c6 + t\u22c6 :="}
{"input": "Statement in natural language:\nFor all integers 'n' and for all integers 'i' in the set of integers modulo 'n', casting 'i' to an integer modulo 'n' is equal to 'i' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_id : \u2200 (n) (i : ZMod n), (ZMod.cast i : ZMod n) = i"}
{"input": "Statement in natural language:\nFor a given Henstock partition \u03c0 and a function x from \u03b9 to real numbers, the cardinality of the set of boxes in \u03c0 that are tagged with x is less than or equal to 2 raised to the power of the cardinality of \u03b9. This is under the condition that \u03b9 is a finite type.\nTranslate the statement in natural language to Lean:", "output": "theorem IsHenstock.card_filter_tag_eq_le [Fintype \u03b9] (h : \u03c0.IsHenstock) (x : \u03b9 \u2192 \u211d) :\n    (\u03c0.boxes.filter fun J => \u03c0.tag J = x).card \u2264 2 ^ Fintype.card \u03b9 :="}
{"input": "Statement in natural language:\nFor any function 'f' from 'F', the preimage of the top element in the non-unital subsemiring 'S' under 'f' is the top element in the non-unital subsemiring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_top (f : F) : comap f (\u22a4 : NonUnitalSubsemiring S) = (\u22a4 : NonUnitalSubsemiring R) :="}
{"input": "Statement in natural language:\nThe inverse of the dual of a supremum-preserving homomorphism, when applied to the identity function, is equal to the identity function on the supremum-preserving homomorphism on a type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_dual_id : sSupHom.dual.symm (sInfHom.id _) = sSupHom.id \u03b1 :="}
{"input": "Statement in natural language:\nThe relation 'r' is well-founded on the singleton set containing 'a' in the set of '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem wellFoundedOn_singleton : WellFoundedOn ({a} : Set \u03b1) r :="}
{"input": "Statement in natural language:\nFor a measure \u03bd that is left multiplication invariant and a function f from a group G to the non-negative extended real numbers that is almost everywhere measurable with respect to the product measure of \u03bc and \u03bd, the double integral of f over y and x, where the function f takes the product of y and x and the inverse of x as arguments, is equal to the double integral of f over x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem lintegral_lintegral_mul_inv [IsMulLeftInvariant \u03bd] (f : G \u2192 G \u2192 \u211d\u22650\u221e)\n    (hf : AEMeasurable (uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b x, \u222b\u207b y, f (y * x) x\u207b\u00b9 \u2202\u03bd \u2202\u03bc) = \u222b\u207b x, \u222b\u207b y, f x y \u2202\u03bd \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor a given type E, which is a normed additive commutative group and a normed space over the real numbers, and is also a measurable space, a Borel space, and has finite dimension over the real numbers, and given a measure \u03bc on E which is an additive Haar measure, and a function f from E to F that is integrable with respect to \u03bc, and a real number R that is not equal to zero, the function that maps x to f of R times x is also integrable with respect to \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem Integrable.comp_smul {E : Type _} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional \u211d E] {\u03bc : Measure E} [IsAddHaarMeasure \u03bc]\n    {f : E \u2192 F} (hf : Integrable f \u03bc) {R : \u211d} (hR : R \u2260 0) : Integrable (fun x => f (R \u2022 x)) \u03bc :="}
{"input": "Statement in natural language:\nFor any element 'b' of type '\u03b2', there exists an element 'a' of type '\u03b1' such that 'b' equals 'l a' if and only if 'b' equals 'l' of 'u b'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_eq_l (b : \u03b2) : (\u2203 a : \u03b1, b = l a) \u2194 b = l (u b) :="}
{"input": "Statement in natural language:\nFor a given element 'b' of type \u03b1, the result of the function 'toIcoMod' with parameters 'hp', 0, and 'b' is an element of the set of all numbers from 0 (inclusive) to 'p' (exclusive).\nTranslate the statement in natural language to Lean:", "output": "theorem toIcoMod_mem_Ico' (b : \u03b1) : toIcoMod hp 0 b \u2208 Set.Ico 0 p :="}
{"input": "Statement in natural language:\nAn element 'x' belongs to the core of a set 's' with respect to a relation 'r' if and only if for all elements 'y', if 'r' relates 'x' and 'y', then 'y' belongs to the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_core (x : \u03b1) (s : Set \u03b2) : x \u2208 r.core s \u2194 \u2200 y, r x y \u2192 y \u2208 s :="}
{"input": "Statement in natural language:\nIf function 'f' satisfies the Holder condition with constants 'C' and 'r', and 'r' is greater than zero, then the function 'f' is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous (hf : HolderWith C r f) (h0 : 0 < r) : Continuous f :="}
{"input": "Statement in natural language:\nFor a given real number r that is greater than or equal to zero, if for every element x in set s there exists an element y in set t such that the distance between x and y is less than or equal to r, and for every element x in set t there exists an element y in set s such that the distance between x and y is less than or equal to r, then the Hausdorff distance between set s and set t is less than or equal to r.\nTranslate the statement in natural language to Lean:", "output": "theorem hausdorffDist_le_of_mem_dist {r : \u211d} (hr : 0 \u2264 r) (H1 : \u2200 x \u2208 s, \u2203 y \u2208 t, dist x y \u2264 r)\n    (H2 : \u2200 x \u2208 t, \u2203 y \u2208 s, dist x y \u2264 r) : hausdorffDist s t \u2264 r :="}
{"input": "Statement in natural language:\nFor a Cauchy sequence 'f' of a certain type '\u03b2' with a valuation 'abv', and for any natural numbers 'n' and 'i', the 'i'-th term of the sequence 'f' raised to the power 'n' is equal to the 'i'-th term of 'f' raised to the power 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_apply (f : CauSeq \u03b2 abv) (n i : \u2115) : (f ^ n) i = f i ^ n :="}
{"input": "Statement in natural language:\nFor a given type G which is a commutative group, and given sets s and t of G, and a given element x of G, x is in the closure of the union of s and t if and only if there exists an element y in the closure of s and an element z in the closure of t such that the product of y and z equals x.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_closure_union_iff {G : Type _} [CommGroup G] {s t : Set G} {x : G} :\n    x \u2208 closure (s \u222a t) \u2194 \u2203 y \u2208 closure s, \u2203 z \u2208 closure t, y * z = x :="}
{"input": "Statement in natural language:\nThe Frobenius endomorphism of a negative element in a ring is equal to the negative of the Frobenius endomorphism of the element itself.\nTranslate the statement in natural language to Lean:", "output": "theorem frobenius_neg : frobenius R p (-x) = -frobenius R p x :="}
{"input": "Statement in natural language:\nFor any element 'r' of ring 'R', if 'r' is not equal to zero, then the constant Hahn series of 'r' is also not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem C_ne_zero {r : R} (h : r \u2260 0) : (C r : HahnSeries \u0393 R) \u2260 0 :="}
{"input": "Statement in natural language:\nFor any rational number 'r' in a division ring 'R' that also has a star operation, the star of the cast of 'r' to 'R' is equal to 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem star_ratCast [DivisionRing R] [StarRing R] (r : \u211a) : star (r : R) = r :="}
{"input": "Statement in natural language:\nThe composition of the function 'f' with the range of 'f' under the quotient map is equal to zero. Here, 'f' is a linear map from 'M' to 'M\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_mkQ_comp (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : f.range.mkQ.comp f = 0 :="}
{"input": "Statement in natural language:\nFor any objects X\u2081, X\u2082, Y\u2081, Y\u2082, U\u2081, U\u2082, V\u2081, V\u2082 in a category C, and any morphisms f\u2081 from X\u2081 to Y\u2081, f\u2082 from X\u2082 to Y\u2082, g\u2081 from U\u2081 to V\u2081, and g\u2082 from U\u2082 to V\u2082, the composition of the tensor product of f\u2081, f\u2082, g\u2081, and g\u2082 with the associator tensor_\u03bc at (Y\u2081, Y\u2082) and (V\u2081, V\u2082) is equal to the composition of the associator tensor_\u03bc at (X\u2081, X\u2082) and (U\u2081, U\u2082) with the tensor product of f\u2081, g\u2081, f\u2082, and g\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem tensor_\u03bc_natural {X\u2081 X\u2082 Y\u2081 Y\u2082 U\u2081 U\u2082 V\u2081 V\u2082 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2082 : X\u2082 \u27f6 Y\u2082) (g\u2081 : U\u2081 \u27f6 V\u2081)\n    (g\u2082 : U\u2082 \u27f6 V\u2082) :\n    ((f\u2081 \u2297 f\u2082) \u2297 g\u2081 \u2297 g\u2082) \u226b tensor_\u03bc C (Y\u2081, Y\u2082) (V\u2081, V\u2082) =\n      tensor_\u03bc C (X\u2081, X\u2082) (U\u2081, U\u2082) \u226b ((f\u2081 \u2297 g\u2081) \u2297 f\u2082 \u2297 g\u2082) :="}
{"input": "Statement in natural language:\nThe range of the subtype of a submonoid 's' is equal to 's' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem range_subtype (s : Submonoid M) : mrange s.subtype = s :="}
{"input": "Statement in natural language:\nIf you map a function 'f' over two lists, where the first list is empty and the second list is 'bs', the result will be a pair. The first element of the pair is the list 'bs' mapped with the function 'f' applied to 'none', and the second element of the pair is an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082Right'_nil_left : map\u2082Right' f [] bs = (bs.map (f none), []) :="}
{"input": "Statement in natural language:\nFor all sets 's' indexed by 'i' and for any index 'i', the intersection over all 'i' of set 's' is a subset of set 's' at index 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInter_subset : \u2200 (s : \u03b9 \u2192 Set \u03b2) (i : \u03b9), (\u22c2 i, s i) \u2286 s i :="}
{"input": "Statement in natural language:\nIf function f is disjoint from function h, and function g is also disjoint from function h, then the product of functions f and g is also disjoint from function h.\nTranslate the statement in natural language to Lean:", "output": "theorem Disjoint.mul_left (H1 : Disjoint f h) (H2 : Disjoint g h) : Disjoint (f * g) h :="}
{"input": "Statement in natural language:\nFor all natural numbers n and m, if the double of n equals the double of m, then n equals m.\nTranslate the statement in natural language to Lean:", "output": "theorem bit0_inj : \u2200 {n m : \u2115}, bit0 n = bit0 m \u2192 n = m"}
{"input": "Statement in natural language:\nFor a non-unital algebra homomorphism 'f' from 'A' to 'B' over a ring 'R', the image of the sum of 'x' and 'y' under 'f' is equal to the sum of the images of 'x' and 'y' under 'f'. This means that 'f' preserves the addition operation.\nTranslate the statement in natural language to Lean:", "output": "theorem map_add (f : A \u2192\u2099\u2090[R] B) (x y : A) : f (x + y) = f x + f y :="}
{"input": "Statement in natural language:\nThe linear projection of an index 'i' in the context of affine maps is equivalent to the linear projection of the same index 'i' in the context of linear maps.\nTranslate the statement in natural language to Lean:", "output": "theorem proj_linear (i : \u03b9) : (@proj k _ \u03b9 V P _ _ _ i).linear = @LinearMap.proj k \u03b9 _ V _ _ i :="}
{"input": "Statement in natural language:\nIf the next element or a default value in a list is not equal to the default value, then the element is in the list.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_of_nextOr_ne {xs : List \u03b1} {x d : \u03b1} (h : nextOr xs x d \u2260 d) : x \u2208 xs :="}
{"input": "Statement in natural language:\nThe function 'toDual', which maps a point from a set \u03b1 to its dual set \u03b1\u1d52\u1d48, is an open map. An open map is a function between two topological spaces that maps open sets to open sets.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpenMap_toDual : IsOpenMap (toDual : \u03b1 \u2192 \u03b1\u1d52\u1d48) :="}
{"input": "Statement in natural language:\nThe homomorphism of the isomorphism from the coequalizer of a function to itself is equal to the description of the coequalizer with the identity morphism on Y, simplified.\nTranslate the statement in natural language to Lean:", "output": "theorem coequalizer.isoTargetOfSelf_hom :\n    (coequalizer.isoTargetOfSelf f).hom = coequalizer.desc (\ud835\udfd9 Y) (by simp) :="}
{"input": "Statement in natural language:\nFor two order-preserving bijections 'f' and 'g' from a preordered set 'r' to another preordered set 's', 'f' is equal to 'g' if and only if 'f' and 'g' map every element 'x' in 'r' to the same element in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {f g : r \u2243r s} : f = g \u2194 \u2200 x, f x = g x :="}
{"input": "Statement in natural language:\nFor any subsemiring S of a ring R and any element x in S, the application of the algebra map from S to R on x equals x itself.\nTranslate the statement in natural language to Lean:", "output": "theorem algebraMap_ofSubsemiring_apply (S : Subsemiring R) (x : S) : algebraMap S R x = x :="}
{"input": "Statement in natural language:\n'not a is less than or equal to b' if and only if 'b and a are codisjoint'.\nTranslate the statement in natural language to Lean:", "output": "theorem hnot_le_iff_codisjoint_left : \uffe2a \u2264 b \u2194 Codisjoint b a :="}
{"input": "Statement in natural language:\nFor a given applicative transformation '\u03b7' from 'F' to 'G', and for any type '\u03b1', if 'x' and 'y' are equal in the context of 'F \u03b1', then the transformation of 'x' by '\u03b7' is equal to the transformation of 'y' by '\u03b7'. This is proven by the equality 'h' of 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem congr_arg (\u03b7 : ApplicativeTransformation F G) {\u03b1 : Type u} {x y : F \u03b1}\n    (h : x = y) : \u03b7 x = \u03b7 y :="}
{"input": "Statement in natural language:\nThe image of the function that adds a constant 'a' to a variable 'x', when applied to the set of all real numbers less than 'b', is equal to the set of all real numbers less than 'a + b'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_const_add_Iio : (fun x => a + x) '' Iio b = Iio (a + b) :="}
{"input": "Statement in natural language:\nA set 's' is connected in the product topology of a sigma type if and only if there exists an index 'i' and a set 't' such that 't' is connected and 's' is the image of 't' under the function that sends each element of 't' to the pair consisting of 'i' and that element.\nTranslate the statement in natural language to Lean:", "output": "theorem Sigma.isConnected_iff [\u2200 i, TopologicalSpace (\u03c0 i)] {s : Set (\u03a3i, \u03c0 i)} :\n    IsConnected s \u2194 \u2203 i t, IsConnected t \u2227 s = Sigma.mk i '' t :="}
{"input": "Statement in natural language:\nThe hyperbolic sine function is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_sinh : Continuous sinh :="}
{"input": "Statement in natural language:\nThe function 'toSubsemigroup', which maps a non-unital subsemiring of R to a subsemigroup of R, is monotone.\nTranslate the statement in natural language to Lean:", "output": "theorem toSubsemigroup_mono : Monotone (toSubsemigroup : NonUnitalSubsemiring R \u2192 Subsemigroup R) :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'n' and 'm' within the WithBot structure, the sum of 'n' and 'm' equals one if and only if either 'n' equals zero and 'm' equals one, or 'n' equals one and 'm' equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem add_eq_one_iff {n m : WithBot \u2115} : n + m = 1 \u2194 n = 0 \u2227 m = 1 \u2228 n = 1 \u2227 m = 0 :="}
{"input": "Statement in natural language:\nFor a given block diagonal matrix 'M' (where 'M' is a function that for each index 'i' gives a matrix with dimensions determined by 'm' and 'n' and entries in '\u03b1'), the entry at position \u27e8k, i\u27e9 and \u27e8k', j\u27e9 in the block diagonal matrix is equal to the entry at position 'i' and 'j' in the 'k'-th matrix if 'k' equals 'k' (with 'j' being appropriately type-casted), otherwise it is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem blockDiagonal'_apply' (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (k i k' j) :\n    blockDiagonal' M \u27e8k, i\u27e9 \u27e8k', j\u27e9 =\n      if h : k = k' then M k i (cast (congr_arg n' h.symm) j) else 0 :="}
{"input": "Statement in natural language:\nIf 'i' is a right adjoint and the unit of the right adjoint 'i' applied to 'A' is an isomorphism, then 'A' is in the essential image of 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_essImage_of_unit_isIso [IsRightAdjoint i] (A : C)\n    [IsIso ((ofRightAdjoint i).unit.app A)] : A \u2208 i.essImage :="}
{"input": "Statement in natural language:\nFor a set 's' of elements of type 'H', an element 'x' of type 'H', a function 'f' from 'H' to 'H'', and a local homeomorphism 'e'' of type 'H'' to 'H'', if 'e'' is an element of 'G'', the function 'f' is continuous within 's' at 'x', and the image of 'x' under 'f' is in the source of 'e'', then the property 'P' holds for the composition of 'e'' and 'f' at 's' and 'x' if and only if the property 'P' holds for 'f' at 's' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem left_invariance {s : Set H} {x : H} {f : H \u2192 H'} {e' : LocalHomeomorph H' H'}\n    (he' : e' \u2208 G') (hfs : ContinuousWithinAt f s x) (hxe' : f x \u2208 e'.source) :\n    P (e' \u2218 f) s x \u2194 P f s x :="}
{"input": "Statement in natural language:\nFor a given type \u03b1 with defined zero and one, and a decidable equality on n, the matrix representation of the bottom partial equivalence relation (PEquiv) between m and n is a zero matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem toMatrix_bot [DecidableEq n] [Zero \u03b1] [One \u03b1] :\n    ((\u22a5 : PEquiv m n).toMatrix : Matrix m n \u03b1) = 0 :="}
{"input": "Statement in natural language:\nFor any element 'x' from a set 'A', the algebraic closure of the set 'R' with the singleton set containing 'x' is equal to the range of the algebraic evaluation map applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Algebra.adjoin_singleton_eq_range_aeval (x : A) :\n    Algebra.adjoin R {x} = (Polynomial.aeval x).range :="}
{"input": "Statement in natural language:\nIf a function 'f' is locally integrable with respect to a measure '\u03bc', and if 'k' is a compact set, then the function 'f' is integrable on the set 'k' with respect to the measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem LocallyIntegrable.integrableOn_isCompact {k : Set X} (hf : LocallyIntegrable f \u03bc)\n    (hk : IsCompact k) : IntegrableOn f k \u03bc :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type '\u03b1' and a partial function 'o' of type '\u03b1', 'o' is equal to 'some a' if and only if 'a' is an element of 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_some_iff {a : \u03b1} {o : Part \u03b1} : o = some a \u2194 a \u2208 o :="}
{"input": "Statement in natural language:\nFor a given set 't' of Lie algebra 'L', if set 's' is a subset of 't', then the Lie span of 's' is less than or equal to the Lie span of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem lieSpan_mono {t : Set L} (h : s \u2286 t) : lieSpan R L s \u2264 lieSpan R L t :="}
{"input": "Statement in natural language:\nFor a given set 's' of type '\u03b1', if 's' is connected, then 's' is a connected space.\nTranslate the statement in natural language to Lean:", "output": "theorem Subtype.connectedSpace {s : Set \u03b1} (h : IsConnected s) : ConnectedSpace s where"}
{"input": "Statement in natural language:\nFor all natural numbers 'n', if the leading coefficient of a polynomial 'p' raised to the power of 'n' is not equal to zero, then the degree of the polynomial 'p' raised to the power of 'n' is equal to 'n' times the degree of the polynomial 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_pow' : \u2200 {n : \u2115}, leadingCoeff p ^ n \u2260 0 \u2192 degree (p ^ n) = n \u2022 degree p"}
{"input": "Statement in natural language:\nFor a property 'p' that applies to an element '\u03b1', a function 'f' that applies to all elements 'a' for which property 'p' holds, a list 'l' of elements '\u03b1', and a proof 'H' that property 'p' holds for all elements 'a' in list 'l', the partial map of function 'f' over list 'l' with proof 'H' is equal to the partial map of function 'f' over list 'l' with proof 'H'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (l : List \u03b1) (H : \u2200 a \u2208 l, p a) :\n    pmap f l H = l.pmap f H :="}
{"input": "Statement in natural language:\nIf a property P lifts at a point x for a function g, and a set s is in the neighborhood of x, then the property P lifts within the set s at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem liftPropWithinAt_of_liftPropAt_of_mem_nhds (h : LiftPropAt P g x) (hs : s \u2208 \ud835\udcdd x) :\n    LiftPropWithinAt P g s x :="}
{"input": "Statement in natural language:\nIf a set 's' of any type '\u03b1' and a finite set 't' of the same type are given, where 't' is nonempty and is a subset of 's', and for any two elements 'a' and 'b' in 's', the infimum of 'a' and 'b' is also in 's', then the infimum of the finite set 't' is in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_closed_of_inf_closed {s : Set \u03b1} (t : Finset \u03b1) (htne : t.Nonempty) (h_subset : \u2191t \u2286 s)\n    (h : \u2200 (a) (_ : a \u2208 s) (b) (_ : b \u2208 s), a \u2293 b \u2208 s) : t.inf id \u2208 s :="}
{"input": "Statement in natural language:\nFor a given function 'f', a set 's' of indices, a function 'c' mapping each index to a scalar, and a function 'm' mapping each index to a vector, the value of 'f' at the point obtained by scaling each vector in 's' by its corresponding scalar is equal to the product of the scalars times the value of 'f' at the original point. This holds true if the decision on whether an index is in 's' is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem map_piecewise_smul [DecidableEq \u03b9] (c : \u03b9 \u2192 R) (m : \u2200 i, M\u2081 i) (s : Finset \u03b9) :\n    f (s.piecewise (fun i => c i \u2022 m i) m) = (\u220f i in s, c i) \u2022 f m :="}
{"input": "Statement in natural language:\nThe bottom element in the order of functions from \u03b1 to \u03b2 is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_continuous : Continuous (\u22a5 : \u03b1 \u2192o \u03b2) :="}
{"input": "Statement in natural language:\nThe essential supremum of the limit inferior of a function sequence is less than or equal to the limit inferior of the essential supremum of the function sequence. This theorem holds for any countable and linearly ordered index set.\nTranslate the statement in natural language to Lean:", "output": "theorem essSup_liminf_le {\u03b9} [Countable \u03b9] [LinearOrder \u03b9] (f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    essSup (fun x => atTop.liminf fun n => f n x) \u03bc \u2264\n      atTop.liminf fun n => essSup (fun x => f n x) \u03bc :="}
{"input": "Statement in natural language:\nFor any set 't' of 'I' such that every pair of elements in 't' are coprime when mapped through 's', and for any 'i' in 't' where 's i' divides 'z', the product of 's x' for all 'x' in 't' divides 'z'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finset.prod_dvd_of_coprime :\n    \u2200 (_ : (t : Set I).Pairwise (IsCoprime on s)) (_ : \u2200 i \u2208 t, s i \u2223 z), (\u220f x in t, s x) \u2223 z :="}
{"input": "Statement in natural language:\nIf 's' is an upper set, then the set resulting from dividing 's' by 't' is also an upper set.\nTranslate the statement in natural language to Lean:", "output": "theorem IsUpperSet.div_right (hs : IsUpperSet s) : IsUpperSet (s / t) :="}
{"input": "Statement in natural language:\nFor any function 'f' from '\u03b1' to '\u03b2' to '\u03b2', and any element 'b' of type '\u03b2', if the function 'f' applied to any element 'a' and 'b' always equals 'b', then for any list 'l' of type '\u03b1', the right fold of the function 'f' over the list 'l' with the initial accumulator 'b' is always 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem foldr_fixed' {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {b : \u03b2} (hf : \u2200 a, f a b = b) : \u2200 l : List \u03b1, foldr f b l = b"}
{"input": "Statement in natural language:\nFor a uniform space isomorphism 'h' between '\u03b1' and '\u03b2', the composition of 'h' and its inverse 'h.symm' is the identity function. This means that if you apply 'h' to transform from '\u03b1' to '\u03b2', and then apply 'h.symm' to transform back from '\u03b2' to '\u03b1', you end up with the original element in '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem self_comp_symm (h : \u03b1 \u2243\u1d64 \u03b2) : (h : \u03b1 \u2192 \u03b2) \u2218 h.symm = id :="}
{"input": "Statement in natural language:\nA morphism 'f' in category 'C' is an epimorphism if and only if 'f' is an Epi.\nTranslate the statement in natural language to Lean:", "output": "theorem epimorphisms.iff : (epimorphisms C) f \u2194 Epi f :="}
{"input": "Statement in natural language:\nFor any ordinal number 'i' that is less than the last step of a given property 'p', and for any natural number 'N' such that the satellite configuration of '\u03b1', 'N', and 'p.\u03c4' is empty, the color of 'i' in property 'p' is less than 'N'.\nTranslate the statement in natural language to Lean:", "output": "theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : \u2115}\n    (hN : IsEmpty (SatelliteConfig \u03b1 N p.\u03c4)) : p.color i < N :="}
{"input": "Statement in natural language:\nThe image of a set 's' under the half-open interval function 'Iio' forms a Pi System.\nTranslate the statement in natural language to Lean:", "output": "theorem isPiSystem_image_Iio (s : Set \u03b1) : IsPiSystem (Iio '' s) :="}
{"input": "Statement in natural language:\nFor a given element 'a' in a semilattice structure '\u03b1', the filter at bottom is equal to the comap (the inverse image of a function) of the function that maps elements from the interval (-\u221e, a) to '\u03b1', at the filter at bottom.\nTranslate the statement in natural language to Lean:", "output": "theorem atBot_Iio_eq [SemilatticeInf \u03b1] (a : \u03b1) : atBot = comap ((\u2191) : Iio a \u2192 \u03b1) atBot :="}
{"input": "Statement in natural language:\nThe function f is Big O of g at negative infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigO_bot : f =O[\u22a5] g :="}
{"input": "Statement in natural language:\n'S' is in the dense cover of 'X' if and only if for all 'Y' with a morphism 'f' from 'Y' to 'X', there exists a 'Z' with a morphism 'g' from 'Z' to 'Y' such that 'S' is in the composition of 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem dense_covering : S \u2208 dense X \u2194 \u2200 {Y} (f : Y \u27f6 X), \u2203 (Z : _)(g : Z \u27f6 Y), S (g \u226b f) :="}
{"input": "Statement in natural language:\nIf for all x and y, the function f evaluated at x is less than or equal to the function f evaluated at y plus the distance between x and y, then the function f is Lipschitz continuous with a Lipschitz constant of 1.\nTranslate the statement in natural language to Lean:", "output": "theorem of_le_add {f : \u03b1 \u2192 \u211d} (h : \u2200 x y, f x \u2264 f y + dist x y) : LipschitzWith 1 f :="}
{"input": "Statement in natural language:\nFor any element 'y' in the prime spectrum of 'S', the ideal associated with the image of 'y' under the function 'f' is equal to the image of the ideal associated with 'y' under the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_asIdeal (y : PrimeSpectrum S) : (comap f y).asIdeal = Ideal.comap f y.asIdeal :="}
{"input": "Statement in natural language:\nFor any function 'f' from an index 'i' and a value '\u03ba i' to '\u03b1', the lower adjoint of the supremum (or least upper bound) over 'i' and 'j' of 'f i j' is equal to the supremum over 'i' and 'j' of the lower adjoint of 'f i j'.\nTranslate the statement in natural language to Lean:", "output": "theorem l_iSup\u2082 {f : \u2200 i, \u03ba i \u2192 \u03b1} : l (\u2a06 (i) (j), f i j) = \u2a06 (i) (j), l (f i j) :="}
{"input": "Statement in natural language:\nFor any set 's' of elements of type '\u03b1', any element 'a' of type '\u03b1', and any filter 'f' of type '\u03b1', if 'a' is in the lower bounds of 's', 's' is in 'f', and the intersection of 'f' and the neighborhood of 'a' is not the bottom element, then 'a' is the greatest lower bound of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isGLB_of_mem_nhds :\n    \u2200 {s : Set \u03b1} {a : \u03b1} {f : Filter \u03b1}, a \u2208 lowerBounds s \u2192 s \u2208 f \u2192 NeBot (f \u2293 \ud835\udcdd a) \u2192 IsGLB s a :="}
{"input": "Statement in natural language:\nIf 'u' and 'v' are measurable sets, 's' is less than or equal to zero on 'u' and 'v', and 's' of the symmetric difference of 'u' and 'v' is zero, then 's' of the difference of 'u' and 'v' is zero and 's' of the difference of 'v' and 'u' is also zero.\nTranslate the statement in natural language to Lean:", "output": "theorem of_diff_eq_zero_of_symmDiff_eq_zero_negative (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hsu : s \u2264[u] 0) (hsv : s \u2264[v] 0) (hs : s (u \u2206 v) = 0) : s (u \\ v) = 0 \u2227 s (v \\ u) = 0 :="}
{"input": "Statement in natural language:\nFor any real number x, the floor of the difference between the function f at x and x itself is less than or equal to the translation number of the function f.\nTranslate the statement in natural language to Lean:", "output": "theorem floor_sub_le_translationNumber (x : \u211d) : \u2191\u230af x - x\u230b \u2264 \u03c4 f :="}
{"input": "Statement in natural language:\nFor any element x from the model M, x is an element of the top elementary substructure of M.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_top (x : M) : x \u2208 (\u22a4 : L.ElementarySubstructure M) :="}
{"input": "Statement in natural language:\nFor any two elements x\u2081 and x\u2082 from the trivial square zero extension of two additive structures R and M, the first component of the sum of x\u2081 and x\u2082 is equal to the sum of the first components of x\u2081 and x\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_add [Add R] [Add M] (x\u2081 x\u2082 : tsze R M) : (x\u2081 + x\u2082).fst = x\u2081.fst + x\u2082.fst :="}
{"input": "Statement in natural language:\nThe finite product of the function 'f' over the set 's' is equal to the finite product of the 'mulIndicator' of 's' and 'f' over all elements 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_mem_def (s : Set \u03b1) (f : \u03b1 \u2192 M) : (\u220f\u1da0 a \u2208 s, f a) = \u220f\u1da0 a, mulIndicator s f a :="}
{"input": "Statement in natural language:\nFor a given type \u03b1, if \u03b1 has decidable equality (i.e., for any two elements of \u03b1, it can be decided whether they are equal or not), and for any two elements a and b of \u03b1 such that a is not equal to b, then the decision procedure for equality of a and b results in 'isFalse' with the proof of inequality.\nTranslate the statement in natural language to Lean:", "output": "theorem decidableEq_inr_neg {\u03b1 : Sort u} [h : DecidableEq \u03b1] {a b : \u03b1}\n    (n : a \u2260 b) : h a b = isFalse n :="}
{"input": "Statement in natural language:\nFor a measure \u03bc on a set \u03b1, where \u03bc is sigma-finite, and a function f from \u03b1 to the set of real numbers, given a set s in \u03b1 such that for every x in s and for every positive \u03b4, the intersection of f(x) and the open interval from 0 to \u03b4 is nonempty, and a function R from \u03b1 to the real numbers such that for every x in s, R(x) is positive, there exists a set t in \u03b1 and a function r from \u03b1 to the real numbers such that t is countable, t is a subset of s, for every x in t, r(x) is in the intersection of f(x) and the open interval from 0 to R(x), the measure of the set difference between s and the union of the closed balls centered at x with radius r(x) for all x in t is zero, and the closed balls centered at x with radius r(x) for all x in t are pairwise disjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_disjoint_closedBall_covering_ae (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (f : \u03b1 \u2192 Set \u211d)\n    (s : Set \u03b1) (hf : \u2200 x \u2208 s, \u2200 \u03b4 > 0, (f x \u2229 Ioo 0 \u03b4).Nonempty) (R : \u03b1 \u2192 \u211d)\n    (hR : \u2200 x \u2208 s, 0 < R x) :\n    \u2203 (t : Set \u03b1) (r : \u03b1 \u2192 \u211d), t.Countable \u2227 t \u2286 s \u2227\n      (\u2200 x \u2208 t, r x \u2208 f x \u2229 Ioo 0 (R x)) \u2227 \u03bc (s \\ \u22c3 x \u2208 t, closedBall x (r x)) = 0 \u2227\n        t.PairwiseDisjoint fun x => closedBall x (r x) :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'n' and 'i', if 'i' is less than 'n + 2' and 'i' is also less than 'n + 1', then casting 'i' with the proof that 'i' is less than 'n + 2' to a predecessor will yield the same result as the pair of 'i' and the proof that 'i' is less than 'n + 1'.\nTranslate the statement in natural language to Lean:", "output": "theorem castPred_mk' (n i : \u2115) (h\u2081 : i < n + 2) (h\u2082 : i < n + 1) : castPred \u27e8i, h\u2081\u27e9 = \u27e8i, h\u2082\u27e9 :="}
{"input": "Statement in natural language:\nFor any non-empty list of elements of a certain type (where the type has at least one element), the list obtained by prepending the first element of the original list to the tail of the original list is equal to the original list itself.\nTranslate the statement in natural language to Lean:", "output": "theorem cons_head!_tail [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 []) : head! l :: tail l = l :="}
{"input": "Statement in natural language:\nFor a periodic function 'f' with period 'c' in an additive commutative group '\u03b1', the function value at any integer multiple of 'c' added to 'x' is equal to the function value at 'x'. This essentially means that the function 'f' repeats its values every 'c' steps.\nTranslate the statement in natural language to Lean:", "output": "theorem Periodic.map_vadd_zmultiples [AddCommGroup \u03b1] (hf : Periodic f c)\n    (a : AddSubgroup.zmultiples c) (x : \u03b1) : f (a +\u1d65 x) = f x :="}
{"input": "Statement in natural language:\nFor a given function 'f' from '\u03b1' to '\u03b2' that is an ordered monoid homomorphism with zero, if we construct an ordered monoid with zero homomorphism using 'f' and a proof 'h', it is equal to the original function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_coe (f : \u03b1 \u2192*\u2080o \u03b2) (h) : OrderMonoidWithZeroHom.mk (f : \u03b1 \u2192*\u2080 \u03b2) h = f :="}
{"input": "Statement in natural language:\nIf for a function 'f' that maps from '\u03b1' to '\u03b2', for all 'x' and 'y' in list 'l', if 'f' of 'x' equals 'f' of 'y' then 'x' equals 'y', and if the list 'l' has no duplicates, then the list resulting from mapping 'f' over 'l' also has no duplicates.\nTranslate the statement in natural language to Lean:", "output": "theorem Nodup.map_on {f : \u03b1 \u2192 \u03b2} (H : \u2200 x \u2208 l, \u2200 y \u2208 l, f x = f y \u2192 x = y) (d : Nodup l) :\n    (map f l).Nodup :="}
{"input": "Statement in natural language:\nIf a set of vectors v is linearly independent in a vector space M over a field R, and if there is a linear map f from M to another vector space M' such that the kernel of f is trivial (only contains the zero vector), then the set of vectors obtained by applying f to each vector in v (denoted by f \u2218 v) is also linearly independent in M'.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearIndependent.map' (hv : LinearIndependent R v) (f : M \u2192\u2097[R] M')\n    (hf_inj : LinearMap.ker f = \u22a5) : LinearIndependent R (f \u2218 v) :="}
{"input": "Statement in natural language:\nIf 'a' is a predecessor limit, then 'a' is a maximum.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPredLimit.isMax (h : IsPredLimit a) : IsMax a :="}
{"input": "Statement in natural language:\nA function 'f' from a set 'G' to a set 'E' is differentiable within a set 's' at a point 'x' if and only if the composition of the function 'f' with an isomorphism 'iso' is also differentiable within the set 's' at the point 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_differentiableWithinAt_iff {f : G \u2192 E} {s : Set G} {x : G} :\n    DifferentiableWithinAt \ud835\udd5c (iso \u2218 f) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x :="}
{"input": "Statement in natural language:\nFor any normed additive commutative group E, which is also a normed space over the real numbers and a complete space, and for any function f from \u03b2 to E, any measure \u03bc on \u03b2, and any element a from \u03b1, the integral of f with respect to the constant kernel of \u03b1, \u03bc, and a is equal to the integral of f with respect to \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_const {E : Type _} [NormedAddCommGroup E] [NormedSpace \u211d E] [CompleteSpace E]\n    {f : \u03b2 \u2192 E} {\u03bc : Measure \u03b2} {a : \u03b1} : (\u222b x, f x \u2202kernel.const \u03b1 \u03bc a) = \u222b x, f x \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor a given ordinal 'o' that is a limit, a cardinal 'c', the aleph function of 'o' is less than or equal to 'c' if and only if for all ordinals 'o'' less than 'o', the aleph function of 'o'' is less than or equal to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem aleph'_le_of_limit {o : Ordinal} (l : o.IsLimit) {c} :\n    aleph' o \u2264 c \u2194 \u2200 o' < o, aleph' o' \u2264 c :="}
{"input": "Statement in natural language:\nThe product of the roots of a polynomial, each subtracted from the variable X, is a monic polynomial.\nTranslate the statement in natural language to Lean:", "output": "theorem monic_prod_multiset_X_sub_C : Monic (p.roots.map fun a => X - C a).prod :="}
{"input": "Statement in natural language:\nFor any two disjoint sets s and t, where t is a measurable set, the measure restricted to the union of s and t is equal to the sum of the measure restricted to s and the measure restricted to t.\nTranslate the statement in natural language to Lean:", "output": "theorem restrict_union (h : Disjoint s t) (ht : MeasurableSet t) :\n    \u03bc.restrict (s \u222a t) = \u03bc.restrict s + \u03bc.restrict t :="}
{"input": "Statement in natural language:\nIf a function is surjective, then the preimage function (comap) is strictly monotonically increasing.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_strictMono_of_surjective : StrictMono (comap f) :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from object 'X' to object 'Y' that is monic (i.e., left-cancellable), the object resulting from mapping 'f' to the top element is equal to the subobject created by 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_top (f : X \u27f6 Y) [Mono f] : (map f).obj \u22a4 = Subobject.mk f :="}
{"input": "Statement in natural language:\nFor any element 'a' of a group 'M' and any two natural numbers 'm' and 'n', 'a' raised to the power 'm' commutes with 'a' raised to the power 'n'. This means that the order in which these operations are performed does not change the result.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_pow_self (a : M) (m n : \u2115) : Commute (a ^ m) (a ^ n) :="}
{"input": "Statement in natural language:\nFor any list 'l' of elements of type '\u03b1' and any permutation 'f' of type '\u03b1', if for all 'x' such that 'f' of 'x' is not equal to 'x', 'x' is in 'l', then 'f' is in the permutations of list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_permsOfList_of_mem {l : List \u03b1} {f : Perm \u03b1} (h : \u2200 x, f x \u2260 x \u2192 x \u2208 l) :\n    f \u2208 permsOfList l :="}
{"input": "Statement in natural language:\nFor a given type M that forms a commutative monoid, and given elements k, l, m, n of some index set I, and elements u, v of M such that u is not equal to 1 and v is not equal to 1, the function that multiplies the element at index k by u and the function that multiplies the element at index l by v, when composed, are equal to the function that multiplies the element at index m by u and the function that multiplies the element at index n by v if and only if either k equals m and l equals n, or u equals v and k equals n and l equals m, or the product of u and v equals 1 and k equals l and m equals n.\nTranslate the statement in natural language to Lean:", "output": "theorem Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle {M : Type _} [CommMonoid M]\n    {k l m n : I} {u v : M} (hu : u \u2260 1) (hv : v \u2260 1) :\n    (mulSingle k u : I \u2192 M) * mulSingle l v = mulSingle m u * mulSingle n v \u2194\n      k = m \u2227 l = n \u2228 u = v \u2227 k = n \u2227 l = m \u2228 u * v = 1 \u2227 k = l \u2227 m = n :="}
{"input": "Statement in natural language:\nFor any element 'a' of type \u03b1, applying the greatest element (top element) of the type InfTopHom \u03b1 \u03b2 to 'a' results in the greatest element (top element).\nTranslate the statement in natural language to Lean:", "output": "theorem top_apply (a : \u03b1) : (\u22a4 : InfTopHom \u03b1 \u03b2) a = \u22a4 :="}
{"input": "Statement in natural language:\nThe thickening of the closure of a set 's' by a non-negative real number '\u03b4' is equal to the thickening of the set 's' by the same non-negative real number '\u03b4'.\nTranslate the statement in natural language to Lean:", "output": "theorem thickening_closure : thickening \u03b4 (closure s) = thickening \u03b4 s :="}
{"input": "Statement in natural language:\nIf set s\u2081 is a subset of set s\u2082, then the scalar multiplication of set s\u2081 and set t is a subset of the scalar multiplication of set s\u2082 and set t.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_subset_smul_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u2022 t \u2286 s\u2082 \u2022 t :="}
{"input": "Statement in natural language:\nFor any ideal 'I' of a ring 'R', and any ring homomorphism 'f' from 'R' to another ring 'S' such that 'f' maps every element 'a' of 'I' to zero, the lift of the equivalence class of 'a' under 'I' by 'f' is equal to the image of 'a' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_mk (I : Ideal R) (f : R \u2192+* S) (H : \u2200 a : R, a \u2208 I \u2192 f a = 0) :\n    lift I f H (mk I a) = f a :="}
{"input": "Statement in natural language:\nFor any two propositions 'p' and 'q', and any two functions 'f\u2081' from 'p' to a set of '\u03b1' and 'f\u2082' from 'q' to a set of '\u03b1', if 'p' is equivalent to 'q' and for all 'x', 'f\u2081' applied to the result of applying the reverse implication of 'pq' to 'x' is equal to 'f\u2082' applied to 'x', then the intersection over 'f\u2081' is equal to the intersection over 'f\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInter_congr_Prop {p q : Prop} {f\u2081 : p \u2192 Set \u03b1} {f\u2082 : q \u2192 Set \u03b1} (pq : p \u2194 q)\n    (f : \u2200 x, f\u2081 (pq.mpr x) = f\u2082 x) : iInter f\u2081 = iInter f\u2082 :="}
{"input": "Statement in natural language:\nUpdating the value at index i of x with a is less than x if and only if a is less than the value at index i of x.\nTranslate the statement in natural language to Lean:", "output": "theorem update_lt_self_iff : update x i a < x \u2194 a < x i :="}
{"input": "Statement in natural language:\nAleph null (\u2135\u2080) is regular.\nTranslate the statement in natural language to Lean:", "output": "theorem isRegular_aleph0 : IsRegular \u2135\u2080 :="}
{"input": "Statement in natural language:\nIf an element 'a' is in list 'l' and the maximum value of list 'l' is 'm', then 'm' is not less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_lt_maximum_of_mem : a \u2208 l \u2192 (maximum l : WithBot \u03b1) = m \u2192 \u00acm < a :="}
{"input": "Statement in natural language:\nFor any two elements 'm' and 'm'' in 'N', the coercion of the sum of 'm' and 'm'' to 'M' is equal to the sum of the coercion of 'm' to 'M' and the coercion of 'm'' to 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_add (m m' : N) : (\u2191(m + m') : M) = (m : M) + (m' : M) :="}
{"input": "Statement in natural language:\nFor any three linear maps 'f', 'g', and 'h' from a module 'M' to a ring 'R', the linear multiplication of 'f' with the sum of 'g' and 'h' is equal to the sum of the linear multiplication of 'f' with 'g' and the linear multiplication of 'f' with 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem linMulLin_add (f g h : M \u2192\u2097[R] R) : linMulLin f (g + h) = linMulLin f g + linMulLin f h :="}
{"input": "Statement in natural language:\nFor a vector 'v' of elements of type '\u03b1' with 'n' elements, an element 'a'' is in the list formed by adding 'a' to the front of 'v' if and only if 'a'' is equal to 'a' or 'a'' is in the list formed from 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_cons_iff (v : Vector \u03b1 n) : a' \u2208 (a ::\u1d65 v).toList \u2194 a' = a \u2228 a' \u2208 v.toList :="}
{"input": "Statement in natural language:\nIf a set 'c' is a partition of a set of elements of type '\u03b1', and 's' is an element of 'c', then 's' is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_of_mem_partition {c : Set (Set \u03b1)} (hc : IsPartition c) {s} (h : s \u2208 c) :\n    s.Nonempty :="}
{"input": "Statement in natural language:\nIf a is a root of polynomial p, then p is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_zero_of_mem_roots (h : a \u2208 p.roots) : p \u2260 0 :="}
{"input": "Statement in natural language:\nFor any function 'f', any index 'i', any scalar 'c', and any element 'x' from the module 'M\u2081 i', the value of 'f' at the point where 'm' is updated at 'i' with 'c' times 'x' is equal to 'c' times the value of 'f' at the point where 'm' is updated at 'i' with 'x'. This is under the condition that the equality of indices '\u03b9' is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem map_smul [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (c : R) (x : M\u2081 i) :\n    f (update m i (c \u2022 x)) = c \u2022 f (update m i x) :="}
{"input": "Statement in natural language:\nIf c is less than or equal to b, then the union of the set of all real numbers less than b and the set of all real numbers greater than or equal to c and less than d is equal to the set of all real numbers less than the maximum of b and d.\nTranslate the statement in natural language to Lean:", "output": "theorem Iio_union_Ico' (h\u2081 : c \u2264 b) : Iio b \u222a Ico c d = Iio (max b d) :="}
{"input": "Statement in natural language:\nFor any Young diagram \u03bc and any semistandard Young tableau T of \u03bc, if we have two natural numbers j1 and j2 such that j1 is less than j2, and the pair (i, j2) is in \u03bc, then the value at position (i, j1) in the tableau T is less than or equal to the value at position (i, j2) in the same tableau. This is essentially saying that the values in each row of the tableau are non-decreasing.\nTranslate the statement in natural language to Lean:", "output": "theorem row_weak {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i j1 j2 : \u2115} (hj : j1 < j2)\n    (hcell : (i, j2) \u2208 \u03bc) : T i j1 \u2264 T i j2 :="}
{"input": "Statement in natural language:\nIf a function 'f' is differentiable on a set 's' over a field '\ud835\udd5c', then the function obtained by multiplying 'f' by a constant 'c' is also differentiable on the same set 's' over the field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableOn.const_smul (h : DifferentiableOn \ud835\udd5c f s) (c : R) :\n    DifferentiableOn \ud835\udd5c (fun y => c \u2022 f y) s :="}
{"input": "Statement in natural language:\nFor any object X in a category C, the object resulting from applying the left associative tensor operation to X is equal to the tensor product of X's first component and the first component of X's second component, tensor product with the second component of X's second component.\nTranslate the statement in natural language to Lean:", "output": "theorem leftAssocTensor_obj (X) : (leftAssocTensor C).obj X = (X.1 \u2297 X.2.1) \u2297 X.2.2 :="}
{"input": "Statement in natural language:\nFor any two submodules 'p' and 'q' of a module 'M' over a ring 'R', if 'p' is a subset of 'q', then the range of the function 'ofLe' applied to 'h' (which represents the inclusion of 'p' in 'q') is equal to the preimage of 'p' under the subtype function of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_ofLe (p q : Submodule R M) (h : p \u2264 q) : range (ofLe h) = comap q.subtype p :="}
{"input": "Statement in natural language:\nA function f has a Taylor series up to order (n + 1) on a set s if and only if the following conditions are met:\n\n1. The function f has a Taylor series up to order n on the set s.\n2. For every x in the set s, the n-th derivative of the function p at x exists within the set s.\n3. The (n + 1)-th term of the function p is continuous on the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFTaylorSeriesUpToOn_succ_iff_left {n : \u2115} :\n    HasFTaylorSeriesUpToOn (n + 1) f p s \u2194\n      HasFTaylorSeriesUpToOn n f p s \u2227\n        (\u2200 x \u2208 s, HasFDerivWithinAt (fun y => p y n) (p x n.succ).curryLeft s x) \u2227\n          ContinuousOn (fun x => p x (n + 1)) s :="}
{"input": "Statement in natural language:\nFor any complex number x, raising x to the power of 2 (also considered as a complex number) is equal to raising x to the power of 2 (considered as a natural number).\nTranslate the statement in natural language to Lean:", "output": "theorem cpow_two (x : \u2102) : x ^ (2 : \u2102) = HPow.hPow x (2 : \u2115) :="}
{"input": "Statement in natural language:\nFor a functor 'F' from 'J' to 'C' and a cocone 'c' of 'F', if 'c' is a colimit, then the description of the cocone morphism from 'c' to any cocone 's' of 'F' is equal to the initial object mapped to the equivalence between the colimit of the cocone and the initial object, under the assumption that 'c' is a colimit.\nTranslate the statement in natural language to Lean:", "output": "theorem IsColimit.descCoconeMorphism_eq_isInitial_to {F : J \u2964 C} {c : Cocone F} (hc : IsColimit c)\n    (s : Cocone F) :\n    hc.descCoconeMorphism s = IsInitial.to (Cocone.isColimitEquivIsInitial _ hc) _ :="}
{"input": "Statement in natural language:\nIf x is congruent to y modulo U, and y is congruent to z modulo U, then x is congruent to z modulo U. This is the transitivity property in the context of modular arithmetic.\nTranslate the statement in natural language to Lean:", "output": "theorem trans (hxy : x \u2261 y [SMOD U]) (hyz : y \u2261 z [SMOD U]) : x \u2261 z [SMOD U] :="}
{"input": "Statement in natural language:\nThe natural number equivalent of the 'mod' function applied to 'n' and 'd' is equal to the remainder of 'n' divided by 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem mod'_to_nat (n d) : (mod' n d : \u2115) = n % d :="}
{"input": "Statement in natural language:\nFor a given ideal I of a ring \u03b1, if I is prime, then for any element r of \u03b1 and any natural number n greater than 0, r to the power of n is in I if and only if r is in I.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPrime.pow_mem_iff_mem {I : Ideal \u03b1} (hI : I.IsPrime) {r : \u03b1} (n : \u2115) (hn : 0 < n) :\n    r ^ n \u2208 I \u2194 r \u2208 I :="}
{"input": "Statement in natural language:\nThe lower bounds of the set of all elements greater than a certain value 'a' are equivalent to the set of all elements less than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem lowerBounds_Ioi {a : \u03b3} : lowerBounds (Ioi a) = Iic a :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'm' and 'n', if 'n' is odd and 'm' divides 'n', then 'm' cannot be equal to 2.\nTranslate the statement in natural language to Lean:", "output": "theorem Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 :="}
{"input": "Statement in natural language:\nFor a filter 'f' of type \u03b1, a function 'g' that maps a set of type \u03b1 to a filter of type \u03b2, and a filter 'h' of type \u03b2, 'h' is less than or equal to the lift of 'f' by 'g' if and only if for all sets 's' in 'f', 'h' is less than or equal to 'g' of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_lift {f : Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} {h : Filter \u03b2} :\n    h \u2264 f.lift g \u2194 \u2200 s \u2208 f, h \u2264 g s :="}
{"input": "Statement in natural language:\nFor any types R, S, and S' with commutative ring structures, and any algebra structures on S and S' over R, given a submonoid M of R, a function f from S to S' that is an R-algebra homomorphism, and three conditions: \n1. For every element x in M, the image of x under the algebra map from R to S' is a unit.\n2. For every element y, there exists an element x in the product of S and M such that the scalar multiplication of the second component of x and y equals the image of the first component of x under f.\n3. For every element x, if the image of x under f is zero, then there exists an element m in M such that the scalar multiplication of m and x is zero.\nThen, the linear map associated with f is a localized module over M.\nTranslate the statement in natural language to Lean:", "output": "theorem mkOfAlgebra {R S S' : Type _} [CommRing R] [CommRing S] [CommRing S'] [Algebra R S]\n    [Algebra R S'] (M : Submonoid R) (f : S \u2192\u2090[R] S') (h\u2081 : \u2200 x \u2208 M, IsUnit (algebraMap R S' x))\n    (h\u2082 : \u2200 y, \u2203 x : S \u00d7 M, x.2 \u2022 y = f x.1) (h\u2083 : \u2200 x, f x = 0 \u2192 \u2203 m : M, m \u2022 x = 0) :\n    IsLocalizedModule M f.toLinearMap :="}
{"input": "Statement in natural language:\nSubtracting infinity from a measure results in zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_top : \u03bc - \u22a4 = 0 :="}
{"input": "Statement in natural language:\nFor a given set P, which is a left projection of a normed space X, and any element Q from the normed space M, the product of the complement of P and Q is equal to the difference between Q and the product of P and Q.\nTranslate the statement in natural language to Lean:", "output": "theorem compl_mul {P : { P : M // IsLprojection X P }} {Q : M} : \u2191(P\u1d9c) * Q = Q - \u2191P * Q :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', where '\u03b2' is an extended metric space, the set of all 'x' such that 'f' is continuous at 'x' is a measurable set.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_of_continuousAt {\u03b2} [EMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    MeasurableSet { x | ContinuousAt f x } :="}
{"input": "Statement in natural language:\nThe degree of the sum of a list of polynomials is less than or equal to the maximum degree of the polynomials in the list.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_list_sum_le (l : List S[X]) : degree l.sum \u2264 (l.map natDegree).maximum :="}
{"input": "Statement in natural language:\nFor a bilinear form B over a ring R\u2082, the matrix representation of B with respect to the standard basis is equal to the matrix representation of B itself.\nTranslate the statement in natural language to Lean:", "output": "theorem BilinForm.toMatrixAux_stdBasis (B : BilinForm R\u2082 (n \u2192 R\u2082)) :\n    -- porting note: had to hint the base ring even though it should be clear from context...\n    BilinForm.toMatrixAux (R\u2082 := R\u2082) (fun j => stdBasis R\u2082 (fun _ => R\u2082) j 1) B =\n      BilinForm.toMatrix' B :="}
{"input": "Statement in natural language:\nThe degree of the sum of two polynomials p and q is less than or equal to the maximum of the degrees of p and q.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_add_le (p q : R[X]) : degree (p + q) \u2264 max (degree p) (degree q) :="}
{"input": "Statement in natural language:\nFor any three integers a, b, and c, where c is greater than 0, the condition of a divided by c being less than b is equivalent to the condition of a being less than the product of b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem ediv_lt_iff_lt_mul {a b c : \u2124} (H : 0 < c) : a / c < b \u2194 a < b * c :="}
{"input": "Statement in natural language:\nFor any element 'a' of a ring 'R' and any natural number 'n', the root multiplicity of 'a' in the polynomial ((X - C a) ^ n) is 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem rootMultiplicity_X_sub_C_pow (a : R) (n : \u2115) : rootMultiplicity a ((X - C a) ^ n) = n :="}
{"input": "Statement in natural language:\nIn a T2 space (also known as a Hausdorff space), for any compact exhaustion (a sequence of compact subsets whose union is the whole space) denoted by K, the nth subset in the sequence is a closed set.\nTranslate the statement in natural language to Lean:", "output": "theorem CompactExhaustion.isClosed [T2Space \u03b1] (K : CompactExhaustion \u03b1) (n : \u2115) : IsClosed (K n) :="}
{"input": "Statement in natural language:\nFor a given box 'I' and an index 'i', the non-negative distance between the lower and upper bounds of the box is less than or equal to the distortion of the box multiplied by the non-negative distance between the lower and upper bounds at index 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_le_distortion_mul (I : Box \u03b9) (i : \u03b9) :\n    nndist I.lower I.upper \u2264 I.distortion * nndist (I.lower i) (I.upper i) :="}
{"input": "Statement in natural language:\nThe range of the argument function (arg) is the interval from negative pi to pi, not including negative pi but including pi.\nTranslate the statement in natural language to Lean:", "output": "theorem range_arg : Set.range arg = Set.Ioc (-\u03c0) \u03c0 :="}
{"input": "Statement in natural language:\nFor a given type N with a structure L, and a function f mapping from M to N, if a substructure s of M is compactly generated (CG), then the image of s under the function f is also compactly generated.\nTranslate the statement in natural language to Lean:", "output": "theorem CG.map {N : Type _} [L.Structure N] (f : M \u2192[L] N) {s : L.Substructure M} (hs : s.CG) :\n    (s.map f).CG :="}
{"input": "Statement in natural language:\nThe function 'f' is strictly monotonically increasing on the set 's' if and only if the function 'f' is strictly monotonically increasing for all elements 'a' in the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem strictMonoOn_iff_strictMono : StrictMonoOn f s \u2194\n    StrictMono fun a : s => f a :="}
{"input": "Statement in natural language:\nFor a given matrix A, the kernel of the linear map resulting from the multiplication of the conjugate transpose of A with A itself is equal to the kernel of the linear map resulting from the multiplication of the vector with A.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_mulVecLin_conjTranspose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (A\u1d34 \u2b1d A).mulVecLin = LinearMap.ker (mulVecLin A) :="}
{"input": "Statement in natural language:\nIf 'f' is a group homomorphism and 'g' is also a group homomorphism, then the composition of 'g' and 'f' (g \u2218 f) is also a group homomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem comp (hf : IsGroupHom f) {\u03b3} [Group \u03b3] {g : \u03b2 \u2192 \u03b3} (hg : IsGroupHom g) :\n    IsGroupHom (g \u2218 f) :="}
{"input": "Statement in natural language:\nFor any index 'i' within the length of a sequence of ones of length 'n', if the block function of the sequence at index 'i' is greater than 0, then the embedding of the sequence at index 'i' with a pair consisting of 0 and the condition is equal to a pair consisting of 'i' and the condition that 'i' is less than the length of the sequence of ones of length 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ones_embedding (i : Fin (ones n).length) (h : 0 < (ones n).blocksFun i) :\n    (ones n).embedding i \u27e80, h\u27e9 = \u27e8i, lt_of_lt_of_le i.2 (ones n).length_le\u27e9 :="}
{"input": "Statement in natural language:\nFor a unit 'a' and elements 'x' and 'y' of a monoid 'M', if 'a' semi-conjugates 'x' to 'y', then the inverse of 'a' semi-conjugates 'y' to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem units_inv_symm_left {a : M\u02e3} {x y : M} (h : SemiconjBy (\u2191a) x y) : SemiconjBy (\u2191a\u207b\u00b9) y x :="}
{"input": "Statement in natural language:\nFor a non-unital non-associative semiring R and a given element 'a' of R and a list 'l' of elements of R, if for every element 'b' in the list 'l', 'a' and 'b' commute, then 'a' commutes with the sum of the list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem list_sum_right [NonUnitalNonAssocSemiring R] (a : R) (l : List R)\n    (h : \u2200 b \u2208 l, Commute a b) : Commute a l.sum :="}
{"input": "Statement in natural language:\nFor a set 's' of type \u03b1 and an element 'x' of type \u03b2, 'x' is the least upper bound of the image of 's' under function 'f' if and only if the inverse of 'x' under function 'f' is the least upper bound of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isLUB_image {s : Set \u03b1} {x : \u03b2} : IsLUB (f '' s) x \u2194 IsLUB s (f.symm x) :="}
{"input": "Statement in natural language:\nFor any integer 'n', the opposite operation applied to 'n' cast as an element of an arbitrary type '\u03b1' (which is capable of integer casting) is equal to 'n' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem unop_intCast [IntCast \u03b1] (n : \u2124) : unop (n : \u03b1\u1d50\u1d52\u1d56) = n :="}
{"input": "Statement in natural language:\n'a' is not less than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem not_lt_zero' : \u00aca < 0 :="}
{"input": "Statement in natural language:\nThe set resulting from the addition of sets 's' and 't', multiplied by set 'u', is a subset of the set resulting from the addition of the sets 's' multiplied by 'u' and 't' multiplied by 'u'.\nTranslate the statement in natural language to Lean:", "output": "theorem add_mul_subset : (s + t) * u \u2286 s * u + t * u :="}
{"input": "Statement in natural language:\nFor a function 'f' from set 'E', for any two elements 'x' and 'y' from set '\u03b1', 'f' applied to 'x' equals 'f' applied to 'y' if and only if 'x' equals 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_eq_iff_eq (f : E) {x y : \u03b1} : f x = f y \u2194 x = y :="}
{"input": "Statement in natural language:\nN is a p-group with the minimum prime factor of the cardinality of N in the field of finite group theory.\nTranslate the statement in natural language to Lean:", "output": "theorem step6 : IsPGroup (Fintype.card N).minFac N :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type \u03b1, and given elements 'a' and 'l'' of type \u03b1, where 'l'' is less than 'a', 's' is in the neighborhood within the set of elements less than or equal to 'a' if and only if there exists an element 'l' in the open interval from negative infinity to 'a' such that the closed interval from 'l' to 'a' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset' {a l' : \u03b1} {s : Set \u03b1} (hl' : l' < a) :\n    s \u2208 \ud835\udcdd[\u2264] a \u2194 \u2203 l \u2208 Iio a, Ioc l a \u2286 s :="}
{"input": "Statement in natural language:\nFor a ring isomorphism 'e' from ring 'R' to ring 'S', and for any two elements 'x' and 'y' of ring 'R', the image of the product 'x * y' under 'e' is equal to the product of the images of 'x' and 'y' under 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_mul (e : R \u2243+* S) (x y : R) : e (x * y) = e x * e y :="}
{"input": "Statement in natural language:\nFor any types S and F, where S is a semiring and F is a class of additive monoid homomorphisms from polynomials over R to polynomials over S, and for any homomorphism \u03c6, polynomial p, natural number k, and function fu from natural numbers to natural numbers, if the following conditions are met:\n\n1. For any natural number n, if n is less than or equal to k, then fu(n) equals 0.\n2. For any natural numbers n and m, if n is greater than or equal to k and n is less than m, then fu(n) is less than fu(m).\n3. For any polynomial f, if the degree of f is less than k, then \u03c6(f) equals 0.\n4. For any natural number n and any non-zero coefficient c, the degree of \u03c6 applied to the monomial with degree n and coefficient c equals fu(n).\n\nThen, the degree of \u03c6 applied to the polynomial p equals fu of the degree of p.\nTranslate the statement in natural language to Lean:", "output": "theorem mono_map_natDegree_eq {S F : Type _} [Semiring S] [AddMonoidHomClass F R[X] S[X]] {\u03c6 : F}\n    {p : R[X]} (k : \u2115) (fu : \u2115 \u2192 \u2115) (fu0 : \u2200 {n}, n \u2264 k \u2192 fu n = 0)\n    (fc : \u2200 {n m}, k \u2264 n \u2192 n < m \u2192 fu n < fu m) (\u03c6_k : \u2200 {f : R[X]}, f.natDegree < k \u2192 \u03c6 f = 0)\n    (\u03c6_mon_nat : \u2200 n c, c \u2260 0 \u2192 (\u03c6 (monomial n c)).natDegree = fu n) :\n    (\u03c6 p).natDegree = fu p.natDegree :="}
{"input": "Statement in natural language:\nThe finite rank of a vector space V over a field K is equal to one if and only if there exists a basis for V indexed by a unique type \u03b9.\nTranslate the statement in natural language to Lean:", "output": "theorem finrank_eq_one_iff (\u03b9 : Type _) [Unique \u03b9] : finrank K V = 1 \u2194 Nonempty (Basis \u03b9 K V) :="}
{"input": "Statement in natural language:\nFor a product monoidal category, the second component of the morphism given by the left unitor on a product object X is equal to the morphism given by the left unitor on the second component of X.\nTranslate the statement in natural language to Lean:", "output": "theorem prodMonoidal_leftUnitor_hom_snd (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03bb_ X).hom : \ud835\udfd9_ _ \u2297 X \u27f6 X).2 = (\u03bb_ X.2).hom :="}
{"input": "Statement in natural language:\nThe inverse of the function 'toBoolAlg' for a given \u03b1 is equal to the function 'ofBoolAlg'.\nTranslate the statement in natural language to Lean:", "output": "theorem toBoolAlg_symm_eq : (@toBoolAlg \u03b1).symm = ofBoolAlg :="}
{"input": "Statement in natural language:\nThe tangent of negative x is equal to the negative of the tangent of x.\nTranslate the statement in natural language to Lean:", "output": "theorem tan_neg : tan (-x) = -tan x :="}
{"input": "Statement in natural language:\nFor a topological add group M and two continuous linear maps f\u2081 and f\u2082 between M and M\u2082 such that f\u2082 is a right inverse of f\u2081, the projection of x (an element of the kernel of f\u2081) onto the kernel of f\u2081 using the right inverse f\u2082 is equal to x itself.\nTranslate the statement in natural language to Lean:", "output": "theorem projKerOfRightInverse_apply_idem [TopologicalAddGroup M] (f\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082)\n    (f\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M) (h : Function.RightInverse f\u2082 f\u2081) (x : LinearMap.ker f\u2081) :\n    f\u2081.projKerOfRightInverse f\u2082 h x = x :="}
{"input": "Statement in natural language:\nFor any two sets s and t, the difference between set s and the intersection of sets t and s is equal to the difference between set s and set t.\nTranslate the statement in natural language to Lean:", "output": "theorem diff_inter_self_eq_diff {s t : Set \u03b1} : s \\ (t \u2229 s) = s \\ t :="}
{"input": "Statement in natural language:\nFor any three ordinals a, b, and c, the natural sum of a and b equals the natural sum of a and c if and only if b equals c. This means that the natural sum operation has the left cancellation property.\nTranslate the statement in natural language to Lean:", "output": "theorem nadd_left_cancel_iff : \u2200 {a b c}, a \u266f b = a \u266f c \u2194 b = c :="}
{"input": "Statement in natural language:\nFor a surjective ring homomorphism \u03c4\u2081\u2082, given a function 'f' from field 'F' and a submodule 'p' of ring 'R' and module 'M', the map of 'f' over 'p' is less than or equal to the range of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {p : Submodule R M} : map f p \u2264 range f :="}
{"input": "Statement in natural language:\nFor any types \u03b4, \u03be, \u03c9, \u03c9', functions f, g, f', g', matrices A, B, D, and an equivalence \u03c6 such that \u03c6 applied to the result of g applied to the result of f applied to any elements a, b, and d is equal to f' applied to a and g' applied to b and d, the result of reindexing the Kronecker product of g applied to the Kronecker product of f applied to A and B and D using the product association equivalence and then applying \u03c6 is equal to the Kronecker product of f' applied to A and the Kronecker product of g' applied to B and D.\nTranslate the statement in natural language to Lean:", "output": "theorem kroneckerMap_assoc {\u03b4 \u03be \u03c9 \u03c9' : Type _} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4 \u2192 \u03c9) (f' : \u03b1 \u2192 \u03be \u2192 \u03c9')\n    (g' : \u03b2 \u2192 \u03b4 \u2192 \u03be) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (D : Matrix q r \u03b4) (\u03c6 : \u03c9 \u2243 \u03c9')\n    (h\u03c6 : \u2200 a b d, \u03c6 (g (f a b) d) = f' a (g' b d)) :\n    (reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)).trans (Equiv.mapMatrix \u03c6)\n        (kroneckerMap g (kroneckerMap f A B) D) =\n      kroneckerMap f' A (kroneckerMap g' B D) :="}
{"input": "Statement in natural language:\nFor any two angles \u03b8 and \u03c8, if the sum of twice \u03b8 and twice \u03c8 equals \u03c0, then the tangent of \u03c8 is the reciprocal of the tangent of \u03b8.\nTranslate the statement in natural language to Lean:", "output": "theorem tan_eq_inv_of_two_nsmul_add_two_nsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2115) \u2022 \u03b8 + (2 : \u2115) \u2022 \u03c8 = \u03c0) : tan \u03c8 = (tan \u03b8)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any finite set 's' of elements of any type '\u03b1', and any function 'f' from '\u03b1' to the real numbers that does not map any element of 's' to zero, the logarithm of the product of the function values over all elements in 's' is equal to the sum of the logarithms of the function values over all elements in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem log_prod {\u03b1 : Type _} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d) (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    log (\u220f i in s, f i) = \u2211 i in s, log (f i) :="}
{"input": "Statement in natural language:\nThe frontier of a set 's' is closed.\nTranslate the statement in natural language to Lean:", "output": "theorem isClosed_frontier {s : Set \u03b1} : IsClosed (frontier s) :="}
{"input": "Statement in natural language:\nFor a polynomial 'p' over a ring 'R' that has no zero divisors, a natural number 'n' is in the support of the derivative of 'p' if and only if 'n + 1' is in the support of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_support_derivative [NoZeroSMulDivisors \u2115 R] (p : R[X]) (n : \u2115) :\n    n \u2208 (derivative p).support \u2194 n + 1 \u2208 p.support :="}
{"input": "Statement in natural language:\nIf a set 's' is nonempty, then 's' equals the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_univ_of_nonempty {s : Set \u03b1} : s.Nonempty \u2192 s = univ :="}
{"input": "Statement in natural language:\nAn element 'r' from a ring 'A' is integral over a ring 'R' if and only if there exists a finite set 's' of 'R' such that 'r' is integral over the subring generated by the closure of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isIntegral_iff_isIntegral_closure_finite {r : A} :\n    IsIntegral R r \u2194 \u2203 s : Set R, s.Finite \u2227 IsIntegral (Subring.closure s) r :="}
{"input": "Statement in natural language:\nFor a given source 'e' that equals the universal set and a structure groupoid 'G' that is closed under restriction, the singleton charted space of 'e' has a groupoid structure with respect to 'G'.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_hasGroupoid (h : e.source = Set.univ) (G : StructureGroupoid H)\n    [ClosedUnderRestriction G] : @HasGroupoid _ _ _ _ (e.singletonChartedSpace h) G :="}
{"input": "Statement in natural language:\nFor any countable index set \u03b9 and any function \u03bc from \u03b9 to the outer measures on \u03b1, the trim of the supremum (least upper bound) of \u03bc over all i in \u03b9 is equal to the supremum of the trim of \u03bc for each i in \u03b9.\nTranslate the statement in natural language to Lean:", "output": "theorem trim_iSup {\u03b9} [Countable \u03b9] (\u03bc : \u03b9 \u2192 OuterMeasure \u03b1) :\n  trim (\u2a06 i, \u03bc i) = \u2a06 i, trim (\u03bc i) :="}
{"input": "Statement in natural language:\nThe cardinality of the set of all elements satisfying a property p in a finite set of size n+1 is equal to the cardinality of the set of all elements satisfying the property p in the successor set, plus 1 if the property p holds for the first element, and equal to the cardinality of the successor set otherwise. This is assuming that it is decidable whether or not an element satisfies the property p.\nTranslate the statement in natural language to Lean:", "output": "theorem card_filter_univ_succ (p : Fin (n + 1) \u2192 Prop) [DecidablePred p] :\n    (univ.filter p).card =\n    if p 0 then (univ.filter (p \u2218 Fin.succ)).card + 1 else (univ.filter (p \u2218 Fin.succ)).card :="}
{"input": "Statement in natural language:\nFor a given integral element 'x' in a field 'A', the coefficient of the minimal polynomial of 'x' at position 0 is equal to 0 if and only if 'x' is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_zero_eq_zero (hx : IsIntegral A x) : coeff (minpoly A x) 0 = 0 \u2194 x = 0 :="}
{"input": "Statement in natural language:\nIf we have a supremum operation on a set L and this operation is continuous, then for any two continuous functions f and g from a set X to L, the function that maps each element of X to the supremum of the images of that element under f and g is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.sup [Sup L] [ContinuousSup L] {f g : X \u2192 L} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun x => f x \u2294 g x :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from a set '\u03b1' to two different sets 'R' and 'M' respectively, where 'R' and 'M' both have a zero element and 'R' and 'M' have a multiplication operation with zero, and no multiplication of non-zero elements in 'R' and 'M' results in zero, the support of the scalar multiplication of 'f' and 'g' is equal to the intersection of the support of 'f' and the support of 'g'. Here, the support of a function is the set of points where the function is non-zero.\nTranslate the statement in natural language to Lean:", "output": "theorem support_smul [Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] (f : \u03b1 \u2192 R)\n    (g : \u03b1 \u2192 M) : support (f \u2022 g) = support f \u2229 support g :="}
{"input": "Statement in natural language:\nFor a set s of type \u03b2 and a set S of type \u03b1, s is less than or equal to S if and only if s is a subset of S.\nTranslate the statement in natural language to Lean:", "output": "theorem le_iff_subset (s : Set \u03b2) (S : \u03b1) : l s \u2264 S \u2194 s \u2286 S :="}
{"input": "Statement in natural language:\nFor any two vectors u and v in an inner product space E, v is orthogonal to the subspace generated by u if and only if the inner product of u and v is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_orthogonal_singleton_iff_inner_right {u v : E} : v \u2208 (\ud835\udd5c \u2219 u)\u15ee \u2194 \u27eau, v\u27eb = 0 :="}
{"input": "Statement in natural language:\nFor any vertices u, v, w, and t in a graph G, and any walks p from u to v and p' from v to w, t is in the tail of the support of the appended walk (p appended with p') if and only if t is in the tail of the support of walk p or t is in the tail of the support of walk p'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_tail_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t \u2208 (p.append p').support.tail \u2194 t \u2208 p.support.tail \u2228 t \u2208 p'.support.tail :="}
{"input": "Statement in natural language:\nFor any index 'i', if every 'i' has an additive zero class structure for '\u03b2 i' and '\u03b3' is an additive commutative monoid, then for any additive homomorphism 'f' from '\u03b2 i' to '\u03b3', the composition of 'liftAddHom' applied to 'f' and 'singleAddHom' applied to '\u03b2' and 'i' is equal to 'f i'.\nTranslate the statement in natural language to Lean:", "output": "theorem liftAddHom_comp_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (f : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (i : \u03b9) : (liftAddHom (\u03b2 := \u03b2) f).comp (singleAddHom \u03b2 i) = f i :="}
{"input": "Statement in natural language:\nZero is not a member of the normalized factors of any element 'x' in a unique factorization domain.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_not_mem_normalizedFactors (x : \u03b1) : (0 : \u03b1) \u2209 normalizedFactors x :="}
{"input": "Statement in natural language:\nFor any object 'X', the object resulting from applying the 'inverseAssociator' to the 'inr' of the 'inr' of 'X' in the categories C, D, and E, is equal to the 'inr' of 'X'.\nTranslate the statement in natural language to Lean:", "output": "theorem inverseAssociator_obj_inr_inr (X) : (inverseAssociator C D E).obj (inr (inr X)) = inr X :="}
{"input": "Statement in natural language:\nAn empty finite map is disjoint with any given finite map 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_empty (x : Finmap \u03b2) : Disjoint \u2205 x :="}
{"input": "Statement in natural language:\nIf a divides b and b divides a, then a is equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_antisymm : a \u2223 b \u2192 b \u2223 a \u2192 a = b :="}
{"input": "Statement in natural language:\nIf 'a' is not equal to zero, then the scalar multiplication of 'a' with the intersection of sets 's' and 't' is equal to the intersection of the scalar multiplication of 'a' with set 's' and the scalar multiplication of 'a' with set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_set_inter\u2080 (ha : a \u2260 0) : a \u2022 (s \u2229 t) = a \u2022 s \u2229 a \u2022 t :="}
{"input": "Statement in natural language:\nFor a given order preserving ring homomorphism 'f' from \u03b1 to \u03b2, and a function 'f'' from \u03b1 to \u03b2 such that 'f'' is equal to 'f', the application of the copy of 'f' with 'f'' and 'h' is equal to 'f''.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_copy (f : \u03b1 \u2192+*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f' :="}
{"input": "Statement in natural language:\nFor any list of elements of type \u03b1 and any function from natural numbers to \u03b2, mapping the function over the indices of the list is equivalent to enumerating the list and then mapping the uncurried version of the function over the enumeration.\nTranslate the statement in natural language to Lean:", "output": "theorem mapIdx_eq_enum_map (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) :\n    l.mapIdx f = l.enum.map (Function.uncurry f) :="}
{"input": "Statement in natural language:\nFor any property 'p' pertaining to natural ordinals, for any ordinal 'i', if for all ordinals 'j', the property 'p' holds for all ordinals 'k' less than 'j', then the property 'p' also holds for 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem induction {p : NatOrdinal \u2192 Prop} : \u2200 (i) (_ : \u2200 j, (\u2200 k, k < j \u2192 p k) \u2192 p j), p i :="}
{"input": "Statement in natural language:\nIf a list 'l' is a sublist of an empty list, then 'l' must be an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_nil_of_sublist_nil {l : List \u03b1} (s : l <+ []) : l = [] :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', and given sets 's' and 't' of '\u03b1', and an element 'x' of '\u03b1' such that 't' is in the neighborhood of 'x' within 's', the function 'f' is continuous at 'x' within the intersection of 's' and 't' if and only if the function 'f' is continuous at 'x' within 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousWithinAt_inter' {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1} (h : t \u2208 \ud835\udcdd[s] x) :\n    ContinuousWithinAt f (s \u2229 t) x \u2194 ContinuousWithinAt f s x :="}
{"input": "Statement in natural language:\nThe division of 'a' by 'b' equals 'a' if and only if 'b' equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem div_eq_self : a / b = a \u2194 b = 1 :="}
{"input": "Statement in natural language:\nFor any list 'l' of elements of type '\u03b1', inserting an element 'a' in an ordered manner into 'l' results in a list that is a permutation of the list obtained by simply adding 'a' to the front of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem perm_orderedInsert (a) : \u2200 l : List \u03b1, orderedInsert r a l ~ a :: l"}
{"input": "Statement in natural language:\nFor any natural numbers m and n, the Ackermann function of m and (n + 1) is less than or equal to the Ackermann function of (m + 1) and n.\nTranslate the statement in natural language to Lean:", "output": "theorem ack_succ_right_le_ack_succ_left (m n : \u2115) : ack m (n + 1) \u2264 ack (m + 1) n :="}
{"input": "Statement in natural language:\nIn a linear order of any type \u03b1, the comparison of two elements 'a' and 'b' is equivalent to the comparison of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem cmp_compares [LinearOrder \u03b1] (a b : \u03b1) : (cmp a b).Compares a b :="}
{"input": "Statement in natural language:\nFor any three multisets s, t, and u, the intersection of s with the sum of t and u is equal to the intersection of the sum of s and u with the sum of t and u.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_add_distrib (s t u : Multiset \u03b1) : s \u2229 t + u = (s + u) \u2229 (t + u) :="}
{"input": "Statement in natural language:\nFor a property P and a bounded formula \u03c6, if \u03c6 is a quantifier-free formula (IsQF \u03c6), and the following conditions are met:\n\n- P holds for the bottom element of the bounded formulas (hf)\n- For any bounded formula \u03c8, if \u03c8 is atomic, then P holds for \u03c8 (ha)\n- For any two bounded formulas \u03c6\u2081 and \u03c6\u2082, if P holds for both \u03c6\u2081 and \u03c6\u2082, then P also holds for the infimum (greatest lower bound) of \u03c6\u2081 and \u03c6\u2082 (hinf)\n- For any bounded formula \u03c6, if P holds for \u03c6, then P also holds for the negation of \u03c6 (hnot)\n- For any two bounded formulas \u03c6\u2081 and \u03c6\u2082, if \u03c6\u2081 and \u03c6\u2082 are semantically equivalent (i.e., they have the same meaning), then P holds for \u03c6\u2081 if and only if P holds for \u03c6\u2082 (hse)\n\nThen, P holds for \u03c6. This is a form of structural induction on quantifier-free formulas.\nTranslate the statement in natural language to Lean:", "output": "theorem IsQF.induction_on_inf_not {P : L.BoundedFormula \u03b1 n \u2192 Prop} {\u03c6 : L.BoundedFormula \u03b1 n}\n    (h : IsQF \u03c6) (hf : P (\u22a5 : L.BoundedFormula \u03b1 n))\n    (ha : \u2200 \u03c8 : L.BoundedFormula \u03b1 n, IsAtomic \u03c8 \u2192 P \u03c8)\n    (hinf : \u2200 {\u03c6\u2081 \u03c6\u2082}, P \u03c6\u2081 \u2192 P \u03c6\u2082 \u2192 P (\u03c6\u2081 \u2293 \u03c6\u2082)) (hnot : \u2200 {\u03c6}, P \u03c6 \u2192 P \u03c6.not)\n    (hse :\n      \u2200 {\u03c6\u2081 \u03c6\u2082 : L.BoundedFormula \u03b1 n}, Theory.SemanticallyEquivalent \u2205 \u03c6\u2081 \u03c6\u2082 \u2192 (P \u03c6\u2081 \u2194 P \u03c6\u2082)) :\n    P \u03c6 :="}
{"input": "Statement in natural language:\nThe function 'bit0' (which doubles a number in the field R) is injective. This means that each element in the field R maps to a unique element in the field R under the 'bit0' function.\nTranslate the statement in natural language to Lean:", "output": "theorem bit0_injective : Function.Injective (bit0 : R \u2192 R) :="}
{"input": "Statement in natural language:\nFor any direct sum 'f' indexed over '\u03b9' with values in 'M', converting 'f' to an AddMonoidAlgebra and then back to a DirectSum results in the original direct sum 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem DirectSum.toAddMonoidAlgebra_toDirectSum (f : \u2a01 _ : \u03b9, M) :\n    f.toAddMonoidAlgebra.toDirectSum = f :="}
{"input": "Statement in natural language:\nFor any natural numbers m and n, shifting m to the left by n places and adding 1 is equal to multiplying m plus 1 by 2 raised to the power of n.\nTranslate the statement in natural language to Lean:", "output": "theorem shiftl'_tt_eq_mul_pow (m) : \u2200 n, shiftl' true m n + 1 = (m + 1) * 2 ^ n"}
{"input": "Statement in natural language:\nFor an open set U in the topological space \u03b1, U is an open set in the set of all subsets of \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen (U : Opens \u03b1) : IsOpen (U : Set \u03b1) :="}
{"input": "Statement in natural language:\nFor any natural number 'n', 'n' is odd if and only if 'n' modulo 4 equals 1 or 'n' modulo 4 equals 3.\nTranslate the statement in natural language to Lean:", "output": "theorem odd_mod_four_iff {n : \u2115} : n % 2 = 1 \u2194 n % 4 = 1 \u2228 n % 4 = 3 :="}
{"input": "Statement in natural language:\nFor a group G that is closed under restriction, the property of being a local structomorph within a given point is a local invariant property under G.\nTranslate the statement in natural language to Lean:", "output": "theorem isLocalStructomorphWithinAt_localInvariantProp [ClosedUnderRestriction G] :\n    LocalInvariantProp G G (IsLocalStructomorphWithinAt G) :="}
{"input": "Statement in natural language:\nFor any element 'x' in the prime spectrum of 'S', the ideal of the inverse image under the symmetric product map of 'x' included in the sum on the right, is equal to the product of the top element and the ideal of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem primeSpectrumProd_symm_inr_asIdeal (x : PrimeSpectrum S) :\n    ((primeSpectrumProd R S).symm <| Sum.inr x).asIdeal = Ideal.prod \u22a4 x.asIdeal :="}
{"input": "Statement in natural language:\nFor two locally constant functions 'f' and 'g' from 'X' to 'Y', 'f' is equal to 'g' if and only if for all 'x', 'f(x)' is equal to 'g(x)'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {f g : LocallyConstant X Y} : f = g \u2194 \u2200 x, f x = g x :="}
{"input": "Statement in natural language:\nFor a property 'q' pertaining to elements of set '\u03b2', if we filter the Cartesian product of sets 's' and 't' based on whether the second element of each pair satisfies 'q', it is equivalent to taking the Cartesian product of set 's' and the filtered set 't' (filtered based on 'q'). This is true when 'q' is a decidable predicate.\nTranslate the statement in natural language to Lean:", "output": "theorem filter_product_right (q : \u03b2 \u2192 Prop) [DecidablePred q] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => q x.2) = s \u00d7\u02e2 t.filter q :="}
{"input": "Statement in natural language:\nThe inverse of the pullback diagonal map identity isomorphism composed with the first pullback equals the first pullback composed with the function f.\nTranslate the statement in natural language to Lean:", "output": "theorem pullbackDiagonalMapIdIso_inv_fst :\n    (pullbackDiagonalMapIdIso f g i).inv \u226b pullback.fst = pullback.fst \u226b f :="}
{"input": "Statement in natural language:\nFor any type K that is a field, and any function f from F to K, if s is a subfield of F, then the image of s under f is a subfield of K.\nTranslate the statement in natural language to Lean:", "output": "theorem Image.isSubfield {K : Type _} [Field K] (f : F \u2192+* K) {s : Set F} (hs : IsSubfield s) :\n    IsSubfield (f '' s) :="}
{"input": "Statement in natural language:\nFor an array 'arr' of elements of type \u03b1, a natural number 'n', and a function 'm' from finite numbers less than 'n' to \u03b2, if 'arr' and 'f' agree on 'm', then for any natural number 'k' equal to 'n + 1', any element 'x', and any function 'm'' from finite numbers less than 'k' to \u03b2, if 'm'' agrees with 'm' for all finite numbers less than 'n' and 'f' applied to 'x' equals 'm'' applied to 'n', then 'arr' with 'x' pushed onto it and 'f' agree on 'm''.\nTranslate the statement in natural language to Lean:", "output": "theorem push {arr : Array \u03b1} {n} {m : Fin n \u2192 \u03b2} (H : Agrees arr f m)\n  (k) (hk : k = n + 1) (x) (m' : Fin k \u2192 \u03b2)\n  (hm\u2081 : \u2200 (i : Fin k) (h : i < n), m' i = m \u27e8i, h\u27e9)\n  (hm\u2082 : \u2200 (h : n < k), f x = m' \u27e8n, h\u27e9) : Agrees (arr.push x) f m' :="}
{"input": "Statement in natural language:\nIf the difference between b and a is additively left cancellable and a is less than or equal to b, then subtracting the difference of b and a from b equals a.\nTranslate the statement in natural language to Lean:", "output": "theorem tsub_tsub_cancel_of_le (hba : AddLECancellable (b - a)) (h : a \u2264 b) :\n    b - (b - a) = a :="}
{"input": "Statement in natural language:\nFor any integer z and any vector v, the constant vector addition of the vector z times v is equal to the constant vector addition of v raised to the power of z.\nTranslate the statement in natural language to Lean:", "output": "theorem constVAdd_zsmul (z : \u2124) (v : V\u2081) : constVAdd k P\u2081 (z \u2022 v) = constVAdd k P\u2081 v ^ z :="}
{"input": "Statement in natural language:\nFor any monoid M and any element u of the opposite of the group of units of M, the opposite of the application of the inverse of the operation equivalence to u is equal to the opposite of the unop of u in M.\nTranslate the statement in natural language to Lean:", "output": "theorem Units.coe_opEquiv_symm {M} [Monoid M] (u : M\u02e3\u1d50\u1d52\u1d56) :\n    (Units.opEquiv.symm u : M\u1d50\u1d52\u1d56) = op (u.unop : M) :="}
{"input": "Statement in natural language:\nFor a function 'f' and an interval 'Ioo a b' where 'a' is less than 'b', the function 'f' tends to a limit 'l' at negative infinity if and only if 'f' tends to the limit 'l' in the neighborhood of 'a' that is greater than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_comp_coe_Ioo_atBot (h : a < b) :\n    Tendsto (fun x : Ioo a b => f x) atBot l \u2194 Tendsto f (\ud835\udcdd[>] a) l :="}
{"input": "Statement in natural language:\nFor a given subspace 'p' of a normed field 'F' and a continuous linear map 'f' from 'p' to '\ud835\udd5c', there exists a continuous linear map 'g' from 'F' to '\ud835\udd5c' such that for all 'x' in 'p', 'g' at 'x' equals 'f' at 'x' and the norm of 'g' equals the norm of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_extension_norm_eq (p : Subspace \ud835\udd5c F) (f : p \u2192L[\ud835\udd5c] \ud835\udd5c) :\n    \u2203 g : F \u2192L[\ud835\udd5c] \ud835\udd5c, (\u2200 x : p, g x = f x) \u2227 \u2016g\u2016 = \u2016f\u2016 :="}
{"input": "Statement in natural language:\nThe product of (X - C (f i)) for each i in a finite set s is separable if and only if for all x and y in s, if f x equals f y then x equals y.\nTranslate the statement in natural language to Lean:", "output": "theorem separable_prod_X_sub_C_iff' {\u03b9 : Sort _} {f : \u03b9 \u2192 F} {s : Finset \u03b9} :\n    (\u220f i in s, (X - C (f i))).Separable \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, f x = f y \u2192 x = y :="}
{"input": "Statement in natural language:\nFor any finite set 's' of type '\u03b9' and any function 'f' from '\u03b9' to a finite set of type '\u03b1', if 's' is pairwise disjoint with respect to 'f' and for every element 'i' in 's', 'f(i)' is nonempty, then the cardinality of 's' is less than or equal to the cardinality of the bi-union of 's' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_le_card_biUnion {s : Finset \u03b9} {f : \u03b9 \u2192 Finset \u03b1} (hs : (s : Set \u03b9).PairwiseDisjoint f)\n    (hf : \u2200 i \u2208 s, (f i).Nonempty) : s.card \u2264 (s.biUnion f).card :="}
{"input": "Statement in natural language:\nFor a given type \u03b9, a set s of type \u03b9, a function f from \u03b9 to \u03b1, and an element a of type \u03b1, if the set s is nonempty and the image of the set s under the function f is bounded above, then the supremum of the set of all f(i) for i in s is less than or equal to a if and only if for all i in the set s, f(i) is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem ciSup_set_le_iff {\u03b9 : Type _} {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hs : s.Nonempty)\n    (hf : BddAbove (f '' s)) : (\u2a06 i : s, f i) \u2264 a \u2194 \u2200 i \u2208 s, f i \u2264 a :="}
{"input": "Statement in natural language:\nFor every real number 'r', the real part of 'r' when it is considered as an element of 'K' is equal to 'r' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem ofReal_re : \u2200 r : \u211d, re (r : K) = r :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set '\u03b1', 'a' is equal to 'b' if and only if the dual of 'a' is equal to the dual of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem toDual_inj {a b : \u03b1} : toDual a = toDual b \u2194 a = b :="}
{"input": "Statement in natural language:\nIf function 'f' is continuous and function 'g' is continuous, then the function that multiplies the output of 'f' by the output of 'g' for each input 'x' is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x \u2022 g x :="}
{"input": "Statement in natural language:\nThe powerset of zero, for any given type \u03b1, is equal to the set containing zero.\nTranslate the statement in natural language to Lean:", "output": "theorem powerset_zero : @powerset \u03b1 0 = {0} :="}
{"input": "Statement in natural language:\nA number resulting from the division of an integer 'm' by 'x' is irrational if and only if 'm' is not equal to zero and 'x' is irrational.\nTranslate the statement in natural language to Lean:", "output": "theorem irrational_int_div_iff : Irrational (m / x) \u2194 m \u2260 0 \u2227 Irrational x :="}
{"input": "Statement in natural language:\nThe function that maps x to its inverse is differentiable at x if and only if x is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableAt_inv : DifferentiableAt \ud835\udd5c (fun x => x\u207b\u00b9) x \u2194 x \u2260 0 :="}
{"input": "Statement in natural language:\nIf we have an additive monoid structure and continuous addition on \u03b2, and if functions 'f' and 'g' are almost everywhere finitely strongly measurable with respect to measure '\u03bc', then the sum of these functions 'f + g' is also almost everywhere finitely strongly measurable with respect to the same measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem add [AddMonoid \u03b2] [ContinuousAdd \u03b2] (hf : AEFinStronglyMeasurable f \u03bc)\n    (hg : AEFinStronglyMeasurable g \u03bc) : AEFinStronglyMeasurable (f + g) \u03bc :="}
{"input": "Statement in natural language:\nFor any two real numbers x and y, the inner product of (x - y) with itself is equal to the inner product of x with itself minus twice the inner product of x and y, plus the inner product of y with itself.\nTranslate the statement in natural language to Lean:", "output": "theorem real_inner_sub_sub_self (x y : F) :\n    \u27eax - y, x - y\u27eb_\u211d = \u27eax, x\u27eb_\u211d - 2 * \u27eax, y\u27eb_\u211d + \u27eay, y\u27eb_\u211d :="}
{"input": "Statement in natural language:\nIf 'f' is a cycle (i.e., a permutation that moves each element of a set to the position of another specific element in the set), and 'f' does not map 'x' to itself and 'f' does not map 'y' to itself, then 'x' and 'y' are in the same cycle under the permutation 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCycle.sameCycle (hf : IsCycle f) (hx : f x \u2260 x) (hy : f y \u2260 y) :\n    SameCycle f x y :="}
{"input": "Statement in natural language:\nIf points a, b, c, and d are cospherical (i.e., they all lie on the same sphere), and the angles at point p between a and b, and between c and d, are both equal to pi (180 degrees), then the product of the distance from a to p and the distance from b to p is equal to the product of the distance from c to p and the distance from d to p.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_pi {a b c d p : P}\n    (h : Cospherical ({a, b, c, d} : Set P)) (hapb : \u2220 a p b = \u03c0) (hcpd : \u2220 c p d = \u03c0) :\n    dist a p * dist b p = dist c p * dist d p :="}
{"input": "Statement in natural language:\nIf 's' is a lower set, 'x' is in the closure of 's', and '\u03b4' is greater than 0, then there exists a 'y' such that the closed ball centered at 'y' with radius '\u03b4 / 4' is a subset of the closed ball centered at 'x' with radius '\u03b4' and the closed ball centered at 'y' with radius '\u03b4 / 4' is a subset of the interior of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLowerSet.exists_subset_ball (hs : IsLowerSet s) (hx : x \u2208 closure s) (h\u03b4 : 0 < \u03b4) :\n    \u2203 y, closedBall y (\u03b4 / 4) \u2286 closedBall x \u03b4 \u2227 closedBall y (\u03b4 / 4) \u2286 interior s :="}
{"input": "Statement in natural language:\nFor a transitive and trichotomous relation 'r' on a set '\u03b1', if 'a' is related to 'b' and 'c' is not related to 'b', then 'a' is related to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem trans_trichotomous_right [IsTrans \u03b1 r] [IsTrichotomous \u03b1 r] {a b c : \u03b1} :\n    r a b \u2192 \u00acr c b \u2192 r a c :="}
{"input": "Statement in natural language:\nIf a function 'f' from 'X' to 'n' to 'R' has a sum 'a', then the sum of the function that maps 'x' to the diagonal of 'f(x)' is the diagonal of 'a'. This is under the condition that 'n' is a decidable equality.\nTranslate the statement in natural language to Lean:", "output": "theorem HasSum.matrix_diagonal [DecidableEq n] {f : X \u2192 n \u2192 R} {a : n \u2192 R} (hf : HasSum f a) :\n    HasSum (fun x => diagonal (f x)) (diagonal a) :="}
{"input": "Statement in natural language:\nFor any two non-zero fractional ideals I and J in a field K over a ring R\u2081\u2070, the division of I by J is equal to the fractional ideal generated by the division of I by J, given that the division is non-zero.\nTranslate the statement in natural language to Lean:", "output": "theorem div_nonzero {I J : FractionalIdeal R\u2081\u2070 K} (h : J \u2260 0) :\n    I / J = \u27e8I / J, fractional_div_of_nonzero h\u27e9 :="}
{"input": "Statement in natural language:\nFor a nontrivial algebraic structure A, the spectrum of 0 in A is equal to the set containing only 0.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_eq [Nontrivial A] : \u03c3 (0 : A) = {0} :="}
{"input": "Statement in natural language:\nFor a functor F from category C to category D and for any object X, the application of the morphism associated with the left unitor on F to X is equal to the morphism associated with the left unitor on the object obtained by applying F to X.\nTranslate the statement in natural language to Lean:", "output": "theorem leftUnitor_hom_app {F : C \u2964 D} {X} :\n    ((\u03bb_ F).hom : \ud835\udfd9_ _ \u2297 F \u27f6 F).app X = (\u03bb_ (F.obj X)).hom :="}
{"input": "Statement in natural language:\nFor a given torsion group 'tG' of 'G' and an element 'a' of 'G', the inverse of the torsion multiplication equivalence of 'tG' applied to 'a' is equal to the pair consisting of the inverse of the top equivalence applied to 'a' and 'tG' applied to an unspecified argument.\nTranslate the statement in natural language to Lean:", "output": "theorem torsionMulEquiv_symm_apply_coe (tG : IsTorsion G) (a : G) :\n    tG.torsionMulEquiv.symm a = \u27e8Submonoid.topEquiv.symm a, tG _\u27e9 :="}
{"input": "Statement in natural language:\nIf a function F, which maps from a set X to a set \u03b1, tends to a function f under a filter l, and if F is equicontinuous, then the function f is continuous. This is under the condition that the filter l is not the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.continuous_of_equicontinuous_at {l : Filter \u03b9} [l.NeBot] {F : \u03b9 \u2192 X \u2192 \u03b1}\n    {f : X \u2192 \u03b1} (h\u2081 : Tendsto F l (\ud835\udcdd f)) (h\u2082 : Equicontinuous F) : Continuous f :="}
{"input": "Statement in natural language:\nFor any element 'a' of type \u03b1 and any symmetric sequence 's' of type \u03b1 with 'n' elements, 'a' is an element of the sequence that results from prepending 'a' to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_cons_self (a : \u03b1) (s : Sym \u03b1 n) : a \u2208 a ::\u209b s :="}
{"input": "Statement in natural language:\nThe disjoint sum of a finite set 's' and an empty finite set is equal to the mapping of set 's' through the left-inclusive embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem disjSum_empty : s.disjSum (\u2205 : Finset \u03b2) = s.map Embedding.inl :="}
{"input": "Statement in natural language:\nThe evaluation of an empty list in machine M is equal to the start state of machine M.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_nil : M.eval [] = M.start :="}
{"input": "Statement in natural language:\nIn the context of a topological space and a linear order that also has an order topology, for a given element 'a' such that there exists an element 'l' which is less than 'a', the neighborhood within the set of elements less than or equal to 'a' has a basis consisting of the set of elements 'l' less than 'a' and the corresponding open interval from 'l' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem nhdsWithin_Iic_basis' [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] {a : \u03b1}\n    (ha : \u2203 l, l < a) : (\ud835\udcdd[\u2264] a).HasBasis (fun l => l < a) fun l => Ioc l a :="}
{"input": "Statement in natural language:\nIf a set 's' supports an element 'b' under a group action 'G', then the set 's' acted upon by an element 'g' of the group 'H' supports the element 'b' acted upon by the same element 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem Supports.smul (g : H) (h : Supports G s b) : Supports G (g \u2022 s) (g \u2022 b) :="}
{"input": "Statement in natural language:\nIf a function 'f' from a pair of types '\u03b1' and '\u03b2' to a type '\u03b3' is measurable when it is uncurried, then for any given element 'x' of type '\u03b1', the function 'f' with 'x' as its first argument is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem Measurable.of_uncurry_left {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : Measurable (uncurry f)) {x : \u03b1} :\n    Measurable (f x) :="}
{"input": "Statement in natural language:\nFor a function 'f' from group G to group H, which is a group homomorphism, the function 'f' is injective if and only if the kernel of 'f' is the trivial group of G.\nTranslate the statement in natural language to Lean:", "output": "theorem injective_iff_trivial_ker {f : G \u2192 H} (hf : IsGroupHom f) :\n    Function.Injective f \u2194 ker f = trivial G :="}
{"input": "Statement in natural language:\nIf a function 'f' from \u03b1 to \u03b2 is continuous on interval I, and the value of 'f' at 0 is equal to the value of 'f' at 1, then the composition of 'f' and the fractional part function is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousOn.comp_fract'' {f : \u03b1 \u2192 \u03b2} (h : ContinuousOn f I) (hf : f 0 = f 1) :\n    Continuous (f \u2218 fract) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set, the interval from 'a' to 'b' in the division ring, when 'a' is increased by 'p', is equal to the original interval from 'a' to 'b' minus 1. Here, 'p' is a prime number and 'hp' is a proof that 'p' is prime.\nTranslate the statement in natural language to Lean:", "output": "theorem toIcoDiv_add_left' (a b : \u03b1) : toIcoDiv hp (p + a) b = toIcoDiv hp a b - 1 :="}
{"input": "Statement in natural language:\nFor any function 'x' from an index set '\u03b9' to a set '\u03b2 i', and any index 'i' in '\u03b9', given that for all indices 'i'' in '\u03b9' it is decidable whether 'i'' is in the set containing only 'i', the piecewise function of 'x' at 'i', where 'x' is replaced by 'x.erase i' outside of the set containing only 'i', is equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem piecewise_single_erase (x : \u03a0\u2080 i, \u03b2 i) (i : \u03b9)\n    [\u2200 i' : \u03b9, Decidable <| (i' \u2208 ({i} : Set \u03b9))] : -- Porting note: added Decidable hypothesis\n    (single i (x i)).piecewise (x.erase i) {i} = x :="}
{"input": "Statement in natural language:\nFor any element 'a' in group 'G', the function that divides 'x' by 'a' is an open map. An open map is a function between two topological spaces that maps open sets to open sets.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpenMap_div_right (a : G) : IsOpenMap fun x => x / a :="}
{"input": "Statement in natural language:\nFor any ring \u03b1, for all elements 'a' of \u03b1 and for all natural numbers 'n', if 'a' is a natural number 'n', then 'a' is an integer of the natural number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsNat.to_isInt {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsNat a n \u2192 IsInt a (.ofNat n)"}
{"input": "Statement in natural language:\nFor any three elements x, y, and z from a set M, the bilinear form of x with the sum of y and z is equal to the sum of the bilinear form of x with y and the bilinear form of x with z.\nTranslate the statement in natural language to Lean:", "output": "theorem add_right (x y z : M) : B x (y + z) = B x y + B x z :="}
{"input": "Statement in natural language:\nThe signed measure derived from a measure is always greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_le_toSignedMeasure : 0 \u2264 \u03bc.toSignedMeasure :="}
{"input": "Statement in natural language:\nIf there is a homeomorphism between two topological spaces \u03b1 and \u03b2, then the function h is an open embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem openEmbedding (h : \u03b1 \u2243\u209c \u03b2) : OpenEmbedding h :="}
{"input": "Statement in natural language:\nIn the context of two uniform spaces \u03b1 and \u03b2, the uniformity of the product space (\u03b1 \u00d7 \u03b2) is equal to the comap (the preimage under a function) of the product of the uniformities of \u03b1 and \u03b2, where the function is defined as taking a pair of pairs from (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 and mapping it to a pair of pairs in \u03b1 \u00d7 \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem uniformity_prod_eq_comap_prod [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    \ud835\udce4 (\u03b1 \u00d7 \u03b2) =\n      comap (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (\ud835\udce4 \u03b1 \u00d7\u02e2 \ud835\udce4 \u03b2) :="}
{"input": "Statement in natural language:\nIf you take the first 'n' elements from a stream 'xs' and then drop the last element, it is equivalent to taking the first 'n-1' elements from the same stream 'xs'.\nTranslate the statement in natural language to Lean:", "output": "theorem dropLast_take : (Stream'.take n xs).dropLast = Stream'.take (n-1) xs :="}
{"input": "Statement in natural language:\nFor a real-valued function 'f' that is differentiable, given a constant 'C' such that the derivative of 'f' at any point 'x' is less than 'C', for any two real numbers 'x' and 'y' where 'x' is less than 'y', the difference between the function values at 'y' and 'x' is less than 'C' times the difference between 'y' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_sub_lt_mul_sub_of_deriv_lt {f : \u211d \u2192 \u211d} (hf : Differentiable \u211d f) {C}\n    (lt_hf' : \u2200 x, deriv f x < C) \u2983x y\u2984 (hxy : x < y) : f y - f x < C * (y - x) :="}
{"input": "Statement in natural language:\nFor any object X in category C, the mapping of the right unitor of X under functor F is equal to the composition of the inverse of the multiplication of F applied to X and the identity of C, the tensor product of the identity of the object of F applied to X and the inverse of the unit of F, and the homomorphism of the right unitor of the object of F applied to X.\nTranslate the statement in natural language to Lean:", "output": "theorem map_rightUnitor (X : C) :\n    F.map (\u03c1_ X).hom = inv (F.\u03bc X (\ud835\udfd9_ C)) \u226b (\ud835\udfd9 (F.obj X) \u2297 inv F.\u03b5) \u226b (\u03c1_ (F.obj X)).hom :="}
{"input": "Statement in natural language:\nFor a set S of elements in group G, if S is a neighborhood of the identity element 1, then the set of inverses of S is also a neighborhood of the identity element 1.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_mem_nhds_one {S : Set G} (hS : S \u2208 (\ud835\udcdd 1 : Filter G)) : S\u207b\u00b9 \u2208 \ud835\udcdd (1 : G) :="}
{"input": "Statement in natural language:\nFor any given relation 'r' on a type '\u03b1', the function 'Quot.mk r' (which creates the quotient set by the relation 'r') is surjective. This means that for every element in the codomain, there is at least one element in the domain that maps to it.\nTranslate the statement in natural language to Lean:", "output": "theorem surjective_quot_mk (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Function.Surjective (Quot.mk r) :="}
{"input": "Statement in natural language:\nIf we have a function 'f' that maps from the set of natural numbers to a set '\u03b1', then 'f' is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_from_nat {f : \u2115 \u2192 \u03b1} : Measurable f :="}
{"input": "Statement in natural language:\nThe preimage of a set 't' under the function 'liftCover S f hf hS' is equal to the union over all 'i' of the image of the preimage of 't' under 'f i'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_liftCover (t : Set \u03b2) : liftCover S f hf hS \u207b\u00b9' t = \u22c3 i, (\u2191) '' (f i \u207b\u00b9' t) :="}
{"input": "Statement in natural language:\nIn the context of group theory, for a given permutation 'f' that is a cycle in a finite set '\u03b2', there exists a natural number 'k' greater than 1 such that the 'k'-th power of 'f' equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCycle.exists_pow_eq_one [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) :\n    \u2203 (k : \u2115) (_ : 1 < k), f ^ k = 1 :="}
{"input": "Statement in natural language:\nVectors x and y are on the same ray if and only if the norm of the difference between x and y is equal to the absolute value of the difference between the norms of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem sameRay_iff_norm_sub : SameRay \u211d x y \u2194 \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| :="}
{"input": "Statement in natural language:\nIf two functions 'f' and 'g' from 'V\u2081' to 'V\u2082' are equal, then 'f' is indeed equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_inj (H : (f : V\u2081 \u2192 V\u2082) = g) : f = g :="}
{"input": "Statement in natural language:\nFor any element 'd' in a set '\u03b1' that has a defined 'one' element, the 'unbot' function applied to the 'one' element of the 'WithBot \u03b1' set with 'd' as a default value, will always return the 'one' element.\nTranslate the statement in natural language to Lean:", "output": "theorem unbot_one' [One \u03b1] (d : \u03b1) : (1 : WithBot \u03b1).unbot' d = 1 :="}
{"input": "Statement in natural language:\nIn the context of a positive-multiplication-monotone algebraic structure, if the product of 'a' and 'b' is less than or equal to 'c', and 'a' is greater than or equal to 1, and 'b' is non-negative, then 'b' is less than or equal to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_mul_le_of_one_le_nonneg_right [MulPosMono \u03b1] (h : a * b \u2264 c) (ha : 1 \u2264 a)\n    (hb : 0 \u2264 b) : b \u2264 c :="}
{"input": "Statement in natural language:\nFor a given filter 'f' of type \u03b1, and two filters 'g\u2081' and 'g\u2082' of type \u03b2, if 'g\u2081' is less than or equal to 'g\u2082', then the product of 'f' and 'g\u2081' is less than or equal to the product of 'f' and 'g\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_mono_right (f : Filter \u03b1) {g\u2081 g\u2082 : Filter \u03b2} (hf : g\u2081 \u2264 g\u2082) : f \u00d7\u02e2 g\u2081 \u2264 f \u00d7\u02e2 g\u2082 :="}
{"input": "Statement in natural language:\nFor a rational number 'r' in the p-adic numbers, if the norm of 'r' is less than or equal to 1, then the norm of the difference between 'r' and the modular part of 'r' with respect to 'p' in the p-adic integers is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_sub_modPart (h : \u2016(r : \u211a_[p])\u2016 \u2264 1) : \u2016(\u27e8r, h\u27e9 - modPart p r : \u2124_[p])\u2016 < 1 :="}
{"input": "Statement in natural language:\nFor a sigma-finite measure \u03bc, given two measurable functions f and g from \u03b1 to the set of non-negative extended real numbers, if for every measurable set s with finite measure, the integral of f over s with respect to \u03bc equals the integral of g over s with respect to \u03bc, then f is almost everywhere equal to g with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_eq_of_forall_set_lintegral_eq_of_sigmaFinite [SigmaFinite \u03bc] {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : Measurable f) (hg : Measurable g)\n    (h : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 (\u222b\u207b x in s, f x \u2202\u03bc) = \u222b\u207b x in s, g x \u2202\u03bc) : f =\u1d50[\u03bc] g :="}
{"input": "Statement in natural language:\nA formula \u03c6 in the language L is satisfied by a theory T if and only if for every model M of the theory T and every valuation v from the set \u03b1 to the model M, the formula \u03c6 is realized under the valuation v.\nTranslate the statement in natural language to Lean:", "output": "theorem models_formula_iff {\u03c6 : L.Formula \u03b1} :\n    T \u22a8\u1d47 \u03c6 \u2194 \u2200 (M : ModelType.{u, v, max u v} T) (v : \u03b1 \u2192 M), \u03c6.Realize v :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, a set s of binary relations from \u03b1 to \u03b2, and any elements a of type \u03b1 and b of type \u03b2, the greatest lower bound (infimum) of the set s applied to a and b is true if and only if for all binary relations r from \u03b1 to \u03b2 that are in the set s, r applied to a and b is true.\nTranslate the statement in natural language to Lean:", "output": "theorem binary_relation_sInf_iff {\u03b1 \u03b2 : Type _} (s : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)) {a : \u03b1} {b : \u03b2} :\n    sInf s a b \u2194 \u2200 r : \u03b1 \u2192 \u03b2 \u2192 Prop, r \u2208 s \u2192 r a b :="}
{"input": "Statement in natural language:\nFor any given element 'a' of the SignType, 'a' is less than 1 if and only if 'a' is less than or equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_one_iff {a : SignType} : a < 1 \u2194 a \u2264 0 :="}
{"input": "Statement in natural language:\nFor a given natural number 'n', the element 'x' is in the support of permutation 'p' if and only if the 'n'-th power of 'p' applied to 'x' is in the list of 'p' applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_apply_mem_toList_iff_mem_support {n : \u2115} : (p ^ n) x \u2208 p.toList x \u2194 x \u2208 p.support :="}
{"input": "Statement in natural language:\nFor any two integers x and y, the product of the pair (x, y) and its conjugate in the ring of integers extended by the square root of d, is equal to the difference of the square of x and the product of d and the square of y.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_star {x y : \u2124} : (\u27e8x, y\u27e9 * star \u27e8x, y\u27e9 : \u2124\u221ad) = x * x - d * y * y :="}
{"input": "Statement in natural language:\nFor a given polynomial 'p' (which is not equal to zero), a real number 'a', and a natural number 'n', the root multiplicity of 'a' in 'p' is less than or equal to 'n' if and only if the polynomial '(X - a) to the power of (n + 1)' does not divide 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem rootMultiplicity_le_iff {p : R[X]} (p0 : p \u2260 0) (a : R) (n : \u2115) :\n    rootMultiplicity a p \u2264 n \u2194 \u00ac(X - C a) ^ (n + 1) \u2223 p :="}
{"input": "Statement in natural language:\nFor any type \u03b9 and any function f from \u03b9 to a cardinal number, the lift of the sum of the function f is equal to the sum of the lift of the function f applied to each element in \u03b9.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_sum {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal.{v}) :\n    Cardinal.lift.{w} (Cardinal.sum f) = Cardinal.sum fun i => Cardinal.lift.{w} (f i) :="}
{"input": "Statement in natural language:\nIf a function 'f' is differentiable within a set 's' at a point 'x', and if 'f\u2081' equals 'f' on a subset 't' of 's' (with 'f\u2081' also equal to 'f' at 'x'), and if 't' has the unique differential property at 'x', then the derivative of 'f\u2081' within 't' at 'x' is equal to the derivative of 'f' within 's' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableWithinAt.fderivWithin_congr_mono (h : DifferentiableWithinAt \ud835\udd5c f s x)\n    (hs : EqOn f\u2081 f t) (hx : f\u2081 x = f x) (hxt : UniqueDiffWithinAt \ud835\udd5c t x) (h\u2081 : t \u2286 s) :\n    fderivWithin \ud835\udd5c f\u2081 t x = fderivWithin \ud835\udd5c f s x :="}
{"input": "Statement in natural language:\nFor a given number \u03b6 in ring R and a positive integer k, \u03b6 is a member of the primitive roots of k in R if and only if \u03b6 is a primitive root of k.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_primitiveRoots {\u03b6 : R} (h0 : 0 < k) : \u03b6 \u2208 primitiveRoots k R \u2194 IsPrimitiveRoot \u03b6 k :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' for which a property 'p' holds, the smallest natural number that satisfies the property 'p' is less than or equal to 'n'. This is under the condition that there exists at least one natural number that satisfies the property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem find_le {h : \u2203 n, p n} (hn : p n) : Nat.find h \u2264 n :="}
{"input": "Statement in natural language:\nA set of submodules 'p' is independent if and only if for all 'i', for all 'x' in 'p i', and for all 'v' in the direct sum of the submodules, if the linear sum of the erased 'i' from 'v' equals 'x', then 'x' must be zero.\nTranslate the statement in natural language to Lean:", "output": "theorem independent_iff_forall_dfinsupp (p : \u03b9 \u2192 Submodule R N) :\n    Independent p \u2194\n      \u2200 (i) (x : p i) (v : \u03a0\u2080 i : \u03b9, \u21a5(p i)),\n        lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) (fun i => (p i).subtype) (erase i v) = x \u2192 x = 0 :="}
{"input": "Statement in natural language:\nA function 'f' from '\u03b1' to '\u03b2' is bijective if and only if for every 'b' in '\u03b2', there exists a unique 'a' in '\u03b1' such that 'f' of 'a' equals 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem bijective_iff_existsUnique (f : \u03b1 \u2192 \u03b2) : Bijective f \u2194 \u2200 b : \u03b2, \u2203! a : \u03b1, f a = b :="}
{"input": "Statement in natural language:\nIn a T2 (Hausdorff) space, if two functions f and g from a set \u03b2 to the space \u03b1 converge to points a and b respectively under a filter l, and if it frequently happens that f(x) equals g(x) for some x in the filter l, then a must equal b.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_nhds_unique_of_frequently_eq [T2Space \u03b1] {f g : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a b : \u03b1}\n    (ha : Tendsto f l (\ud835\udcdd a)) (hb : Tendsto g l (\ud835\udcdd b)) (hfg : \u2203\u1da0 x in l, f x = g x) : a = b :="}
{"input": "Statement in natural language:\nThe inverse function of adding a constant vector to a point 'p' is equivalent to the function that subtracts the point 'p' from another point 'p''.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_vaddConst_symm (p : P) : \u21d1(vaddConst p).symm = fun p' => p' -\u1d65 p :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from type \u03b1 to type \u03b2, which is injective, and a set 's' of type \u03b1, such that the image of 's' under 'f' is a subsingleton, then 's' itself is a subsingleton.\nTranslate the statement in natural language to Lean:", "output": "theorem subsingleton_of_image {\u03b1 \u03b2 : Type _} {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (s : Set \u03b1)\n    (hs : (f '' s).Subsingleton) : s.Subsingleton :="}
{"input": "Statement in natural language:\nFor a given multiset 's' of elements of type '\u03b1', a commutative operation 'comm', and an element 'y' of type '\u03b1', if for every element 'x' in 's', 'y' commutes with 'x', then 'y' commutes with the noncommutative product of 's' under the operation 'comm'.\nTranslate the statement in natural language to Lean:", "output": "theorem noncommProd_commute (s : Multiset \u03b1) (comm) (y : \u03b1) (h : \u2200 x \u2208 s, Commute y x) :\n    Commute y (s.noncommProd comm) :="}
{"input": "Statement in natural language:\nFor any index 'i' and any two elements 'x' and 'y' from the set 'E' indexed by 'i', the distance between the pair (i, x) and the pair (i, y) is equal to the distance between 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_same (i : \u03b9) (x y : E i) : dist (Sigma.mk i x) \u27e8i, y\u27e9 = dist x y :="}
{"input": "Statement in natural language:\nThe smooth transition of 0 is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem zero : smoothTransition 0 = 0 :="}
{"input": "Statement in natural language:\nFor a given real number C that is greater than or equal to zero, and for any function f, if the norm of f(m) is less than or equal to C times the product of the norms of m(i) for all i, then for any two functions m\u2081 and m\u2082, the norm of the difference between f(m\u2081) and f(m\u2082) is less than or equal to C times the sum over i of the product over j of a certain quantity. This quantity is the norm of the difference between m\u2081(i) and m\u2082(i) if j equals i, and the maximum of the norms of m\u2081(j) and m\u2082(j) otherwise.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_image_sub_le_of_bound' [DecidableEq \u03b9] {C : \u211d} (hC : 0 \u2264 C)\n    (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) (m\u2081 m\u2082 : \u2200 i, E i) :\n    \u2016f m\u2081 - f m\u2082\u2016 \u2264 C * \u2211 i, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016 :="}
{"input": "Statement in natural language:\nIf set s is a subset of set u, and set u is disjoint from set t, then set s is also disjoint from set t.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_of_subset_left (h : s \u2286 u) (d : Disjoint u t) : Disjoint s t :="}
{"input": "Statement in natural language:\nFor any three natural numbers a, b, and c, the remainder of a divided by the product of b and c, all divided by b, is equal to the remainder of a divided by b.\nTranslate the statement in natural language to Lean:", "output": "theorem mod_mul_right_mod (a b c : \u2115) : a % (b * c) % b = a % b :="}
{"input": "Statement in natural language:\nFor any two games x and y, x is less than or equal to y if and only if for every possible left move in x, the resulting game is not a right option of y, and for every possible right move in y, the resulting game is not a left option of x.\nTranslate the statement in natural language to Lean:", "output": "theorem le_iff_forall_lf {x y : PGame} :\n    x \u2264 y \u2194 (\u2200 i, x.moveLeft i \u29cf y) \u2227 \u2200 j, x \u29cf y.moveRight j :="}
{"input": "Statement in natural language:\nFor any prime number 'p' and natural numbers 'n', 'k', and 'b', if 'k' is less than or equal to 'n' and the logarithm base 'p' of 'n' is less than 'b', then the multiplicity of 'p' in the binomial coefficient 'choose n k' is equal to the number of elements in the set of integers from 1 to 'b' (excluding 'b') for which 'p' to the power of the element is less than or equal to the remainder of 'k' divided by 'p' to the power of the element plus the remainder of 'n' minus 'k' divided by 'p' to the power of the element.\nTranslate the statement in natural language to Lean:", "output": "theorem multiplicity_choose {p n k b : \u2115} (hp : p.Prime) (hkn : k \u2264 n) (hnb : log p n < b) :\n    multiplicity p (choose n k) =\n      ((Ico 1 b).filter fun i => p ^ i \u2264 k % p ^ i + (n - k) % p ^ i).card :="}
{"input": "Statement in natural language:\nIf we split the list \"as\" based on a predicate \"p\", then join the resulting list with the list obtained by filtering \"as\" with \"p\", mapping each element to a singleton list, and appending an empty list at the end, using the concatenation operation, we get back the original list \"as\".\nTranslate the statement in natural language to Lean:", "output": "theorem splitOnP_spec (as : List \u03b1) :\n    join (zipWith (\u00b7 ++ \u00b7) (splitOnP p as) (((as.filter p).map fun x => [x]) ++ [[]])) = as :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1, an element 'm' of type M, and a function 'f' from \u03b1 to M, if the pair (a, m) is in the graph of the function 'f', then the value of the function 'f' at 'a' is 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_eq_of_mem_graph {a : \u03b1} {m : M} {f : \u03b1 \u2192\u2080 M} (h : (a, m) \u2208 f.graph) : f a = m :="}
{"input": "Statement in natural language:\nFor a given p-adic sequence 'f' that is not equivalent to 0, and for any two natural numbers 'v1' and 'v3', the p-adic norm of the value of 'f' at its stationary point is equal to the p-adic norm of the value of 'f' at the maximum of 'v1', the stationary point of 'f', and 'v3'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_index_left {f : PadicSeq p} (hf : \u00acf \u2248 0) (v1 v3 : \u2115) :\n    padicNorm p (f (stationaryPoint hf)) =\n    padicNorm p (f (max v1 (max (stationaryPoint hf) v3))) :="}
{"input": "Statement in natural language:\nFor two split simplicial objects S\u2081 and S\u2082 in a category C, if two morphisms (\u03a6\u2081 and \u03a6\u2082) from S\u2081 to S\u2082 have the same function on every natural number n, then the two morphisms are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem Hom.ext {S\u2081 S\u2082 : Split C} (\u03a6\u2081 \u03a6\u2082 : Hom S\u2081 S\u2082) (h : \u2200 n : \u2115, \u03a6\u2081.f n = \u03a6\u2082.f n) : \u03a6\u2081 = \u03a6\u2082 :="}
{"input": "Statement in natural language:\nFor a probability measure \u03bc, and a function m from index set \u03b9 to measurable spaces, if for all i, m(i) is less than or equal to m0, and m and \u03bc are independent, then for any two sets S and T from the index set \u03b9 that are disjoint, the supremum of m(i) for i in S is independent of the supremum of m(i) for i in T with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem indep_iSup_of_disjoint [IsProbabilityMeasure \u03bc] {m : \u03b9 \u2192 MeasurableSpace \u03a9}\n    (h_le : \u2200 i, m i \u2264 m0) (h_indep : iIndep m \u03bc) {S T : Set \u03b9} (hST : Disjoint S T) :\n    Indep (\u2a06 i \u2208 S, m i) (\u2a06 i \u2208 T, m i) \u03bc :="}
{"input": "Statement in natural language:\nFor any object 'G' in category 'C', 'G' is a codetector if and only if 'G' is a detector.\nTranslate the statement in natural language to Lean:", "output": "theorem isCodetector_op_iff (G : C) : IsCodetector (op G) \u2194 IsDetector G :="}
{"input": "Statement in natural language:\nIf an element 'x' is of finite order, then the order of 'x' is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem orderOf_pos' (h : IsOfFinOrder x) : 0 < orderOf x :="}
{"input": "Statement in natural language:\nFor a given order relation that is decidable, a value 'x' of type '\u03b1', and a valid tree 't', erasing 'x' from 't' results in a valid tree.\nTranslate the statement in natural language to Lean:", "output": "theorem erase.valid [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) {t} (h : Valid t) : Valid (erase x t) :="}
{"input": "Statement in natural language:\nThe imaginary part of the hyperbolic tangent of a real number x is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem tanh_ofReal_im (x : \u211d) : (tanh x).im = 0 :="}
{"input": "Statement in natural language:\nFor any given stream 's' of any type '\u03b1', when you zip together the initial elements of 's' and the tail elements of 's' using the 'appendStream' function, the result is a constant stream of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem zip_inits_tails (s : Stream' \u03b1) : zip appendStream' (inits s) (tails s) = const s :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' and a finite set 's', the cardinality (or size) of the powerset of 's' with length 'n' is equal to the binomial coefficient of the cardinality of 's' and 'n'. This is a combinatorial principle stating the number of ways to choose 'n' elements from a set of size 'card s'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_powersetLen (n : \u2115) (s : Finset \u03b1) : card (powersetLen n s) = Nat.choose (card s) n :="}
{"input": "Statement in natural language:\nThe range of a homomorphism \u03c6 from algebra A to algebra B, when considered as a set of elements in B, is equal to the set of all possible outputs of \u03c6.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_range (\u03c6 : A \u2192\u2090[R] B) : (\u03c6.range : Set B) = Set.range \u03c6 :="}
{"input": "Statement in natural language:\nFor any element 'a' in a ring 'A', rescaling the variable 'X' by 'a' is equivalent to multiplying the constant 'a' in ring 'A' with 'X'.\nTranslate the statement in natural language to Lean:", "output": "theorem rescale_X (a : A) : rescale a X = C A a * X :="}
{"input": "Statement in natural language:\nThe range of the identity function for any set \u03b1 is the entire set \u03b1 itself.\nTranslate the statement in natural language to Lean:", "output": "theorem range_id : range (@id \u03b1) = univ :="}
{"input": "Statement in natural language:\nFor a set B of sets of \u03b2, if B is a subset of the power set of the range of a function f, then the preimage of f is injective on B.\nTranslate the statement in natural language to Lean:", "output": "theorem injOn_preimage {B : Set (Set \u03b2)} (hB : B \u2286 \ud835\udcab range f) : InjOn (preimage f) B :="}
{"input": "Statement in natural language:\nIf we have two functions `f` and `g` from real numbers to some normed spaces `E` and `F` respectively, and three real numbers `a`, `b`, and `c` such that `a` is not equal to `b` and `c` is in the closed interval from `a` to `b`. If `f` is differentiable at almost every point in the neighborhood of `c` within the interval from `a` to `b` excluding `c`, and the norm of `f` tends to infinity as we approach `c` within the same neighborhood, and the derivative of `f` is big O of `g` within the same neighborhood, then `g` is not interval integrable over the interval from `a` to `b` with respect to the Lebesgue measure.\nTranslate the statement in natural language to Lean:", "output": "theorem not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_within_diff_singleton\n    {f : \u211d \u2192 E} {g : \u211d \u2192 F} {a b c : \u211d} (hne : a \u2260 b) (hc : c \u2208 [[a, b]])\n    (h_deriv : \u2200\u1da0 x in \ud835\udcdd[[[a, b]] \\ {c}] c, DifferentiableAt \u211d f x)\n    (h_infty : Tendsto (fun x => \u2016f x\u2016) (\ud835\udcdd[[[a, b]] \\ {c}] c) atTop)\n    (hg : deriv f =O[\ud835\udcdd[[[a, b]] \\ {c}] c] g) : \u00acIntervalIntegrable g volume a b :="}
{"input": "Statement in natural language:\nIf we have a uniform space \u03b2 and two functions f and g from \u03b2 to \u03b1 that are uniformly continuous, then the function that maps each element b in \u03b2 to the distance between f(b) and g(b) is also uniformly continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem UniformContinuous.dist [UniformSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun b => dist (f b) (g b) :="}
{"input": "Statement in natural language:\nThe symmetry of the removal of None from an equivalence 'e' is equal to the removal of None from the symmetry of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem removeNone_symm : (removeNone e).symm = removeNone e.symm :="}
{"input": "Statement in natural language:\nIf we have two types \ud835\udd5c\u2081 and \ud835\udd5c\u2082 that are normed fields, with \ud835\udd5c\u2081 being nontrivially normed, and a ring homomorphism \u03c3\u2081\u2082 from \ud835\udd5c\u2081 to \ud835\udd5c\u2082. Also, we have two types M\u2081 and M\u2082, where M\u2081 is a seminormed additive commutative group and M\u2082 is an additive commutative group, a module over \ud835\udd5c\u2082, a uniform space, a uniform additive group, a T2 space, and a complete space. Given a filter l on \u03b9 that is not bottom, a function F from \u03b9 to the space of continuous linear maps from M\u2081 to M\u2082, and a continuous linear map f from M\u2081 to M\u2082. If F tends to f with respect to the filter l and for almost all i in l, F(i) is a compact operator, then f is a compact operator.\nTranslate the statement in natural language to Lean:", "output": "theorem isCompactOperator_of_tendsto {\u03b9 \ud835\udd5c\u2081 \ud835\udd5c\u2082 : Type _} [NontriviallyNormedField \ud835\udd5c\u2081]\n    [NormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c\u2081 \u2192+* \ud835\udd5c\u2082} {M\u2081 M\u2082 : Type _} [SeminormedAddCommGroup M\u2081]\n    [AddCommGroup M\u2082] [NormedSpace \ud835\udd5c\u2081 M\u2081] [Module \ud835\udd5c\u2082 M\u2082] [UniformSpace M\u2082] [UniformAddGroup M\u2082]\n    [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] [T2Space M\u2082] [CompleteSpace M\u2082] {l : Filter \u03b9} [l.NeBot]\n    {F : \u03b9 \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} {f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (hf : Tendsto F l (\ud835\udcdd f))\n    (hF : \u2200\u1da0 i in l, IsCompactOperator (F i)) : IsCompactOperator f :="}
{"input": "Statement in natural language:\nThe span over a ring R of the union of two sets M, s and t, is equal to the superset of the span over R of s and the span over R of t.\nTranslate the statement in natural language to Lean:", "output": "theorem span_union (s t : Set M) : span R (s \u222a t) = span R s \u2294 span R t :="}
{"input": "Statement in natural language:\nFor any index 'i' and any element 'a' from the indexed set '\u03b1', the image of the interval (a, 1] under the function 'Pi.mulSingle i' is equal to the interval (Pi.mulSingle i a, 1].\nTranslate the statement in natural language to Lean:", "output": "theorem image_mulSingle_Ioc_left (i : \u03b9) (a : \u03b1 i) :\n    Pi.mulSingle i '' Ioc a 1 = Ioc (Pi.mulSingle i a) 1 :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set '\u03b1' to itself, if 'f' is right order continuous, then the 'n'-th iteration of 'f' is also right order continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : RightOrdContinuous f) (n : \u2115) :\n    RightOrdContinuous (f^[n]) :="}
{"input": "Statement in natural language:\nThe closure of the universal set, under a language L in a model M, is equal to the top element or the whole set.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_univ : closure L (univ : Set M) = \u22a4 :="}
{"input": "Statement in natural language:\nIf a list 'l' is pairwise with respect to two relations 'R' and 'S', then 'l' is also pairwise with respect to a new relation that is the conjunction of 'R' and 'S'. In other words, for any two elements 'a' and 'b' in the list, both 'R a b' and 'S a b' hold true.\nTranslate the statement in natural language to Lean:", "output": "theorem Pairwise.and (hR : l.Pairwise R) (hS : l.Pairwise S) :\n    l.Pairwise fun a b => R a b \u2227 S a b :="}
{"input": "Statement in natural language:\nThere exists an element 'a' not in set 's' such that when 'a' is inserted into 's', it equals set 't' if and only if set 's' is a subset of set 't' and the cardinality of set 's' plus one equals the cardinality of set 't'. This is under the condition that set 's' is finite.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_eq_insert_iff_ncard (hs : s.Finite := by toFinite_tac) :\n    (\u2203 (a : \u03b1) (_ : a \u2209 s), insert a s = t) \u2194 s \u2286 t \u2227 s.ncard + 1 = t.ncard :="}
{"input": "Statement in natural language:\nFor a nontrivial ring R, the natural degree of the polynomial (X + C r) raised to the power of n is equal to n. Here, X is a variable, C r is a constant term, and n is a natural number.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_pow_X_add_C [Nontrivial R] (n : \u2115) (r : R) : ((X + C r) ^ n).natDegree = n :="}
{"input": "Statement in natural language:\nIf p is a positive non-zero natural number and the characteristic of the ring R is p, then it is a fact that p is a prime number.\nTranslate the statement in natural language to Lean:", "output": "theorem char_is_prime_of_pos (p : \u2115) [NeZero p] [CharP R p] : Fact p.Prime :="}
{"input": "Statement in natural language:\nFor any given element 'a' and list 'l', the left fold operation with function 'f' and initial value 'a' on list 'l' is equal to the right fold operation with the flipped function 'f', initial value 'a' and list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem foldl_eq_foldr' : \u2200 a l, foldl f a l = foldr (flip f) a l"}
{"input": "Statement in natural language:\nFor a given set 's' of a topological space, if 's' is a G-delta set and dense, and 't' is a countable set of indices, then for any function 'f' that maps each index in 't' to a closed set in the topological space, if 's' is a subset of the union of all these closed sets, then the union of the interiors of these closed sets is also dense.\nTranslate the statement in natural language to Lean:", "output": "theorem IsG\u03b4.dense_biUnion_interior_of_closed {t : Set \u03b9} {s : Set \u03b1} (hs : IsG\u03b4 s) (hd : Dense s)\n    (ht : t.Countable) {f : \u03b9 \u2192 Set \u03b1} (hc : \u2200 i \u2208 t, IsClosed (f i)) (hU : s \u2286 \u22c3 i \u2208 t, f i) :\n    Dense (\u22c3 i \u2208 t, interior (f i)) :="}
{"input": "Statement in natural language:\nFor any three elements 'a', 'b', and 'x' of a ring 'R', if 'a' and 'b' are coprime (i.e., their greatest common divisor is 1), and 'x' divides both 'a' and 'b', then 'x' is a unit (i.e., it has a multiplicative inverse in the ring 'R').\nTranslate the statement in natural language to Lean:", "output": "theorem IsCoprime.isUnit_of_dvd' {a b x : R} (h : IsCoprime a b) (ha : x \u2223 a) (hb : x \u2223 b) :\n    IsUnit x :="}
{"input": "Statement in natural language:\nIf we have a set S of subsets of \u03b2 that forms a Pi System, and a function f from \u03b1 to \u03b2, then the preimage under f of the set S also forms a Pi System.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPiSystem.comap {\u03b1 \u03b2} {S : Set (Set \u03b2)} (h_pi : IsPiSystem S) (f : \u03b1 \u2192 \u03b2) :\n    IsPiSystem { s : Set \u03b1 | \u2203 t \u2208 S, f \u207b\u00b9' t = s } :="}
{"input": "Statement in natural language:\nIf function 'f' is an isometry, then 'f' is an embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem embedding (hf : Isometry f) : Embedding f :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from 'E' to 'F', if 'f' maps 0 to 0 and 'f' maps the midpoint of 'x' and 'y' in 'R' to the midpoint of 'f(x)' and 'f(y)' in 'R'', then applying the function 'ofMapMidpoint' with parameters 'R', 'R'', 'f', 'h0', and 'hm' to any point is equivalent to applying the function 'f' to that point.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_ofMapMidpoint (f : E \u2192 F) (h0 : f 0 = 0)\n    (hm : \u2200 x y, f (midpoint R x y) = midpoint R' (f x) (f y)) :\n    \u21d1(ofMapMidpoint R R' f h0 hm) = f :="}
{"input": "Statement in natural language:\nThe swapping of two elements x and y is equivalent to the identity function if and only if x is equal to y.\nTranslate the statement in natural language to Lean:", "output": "theorem swap_eq_refl_iff {x y : \u03b1} : swap x y = Equiv.refl _ \u2194 x = y :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set, if 'a' is not less than 'b', then 'a' is equal to 'b' or 'b' is less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_or_lt_of_not_lt {a b : \u03b1} (h : \u00aca < b) : a = b \u2228 b < a :="}
{"input": "Statement in natural language:\nFor any affine subspace E of a normed space P\u2081 over a field \ud835\udd5c, given that E is nonempty and \u03c6 is an affine isometry from P\u2081 to another normed space P\u2082, for any point x in the image of E under the affine map of \u03c6, applying \u03c6 to the inverse of the isometry equivalence map of E under \u03c6 at x gives back x.\nTranslate the statement in natural language to Lean:", "output": "theorem isometryEquivMap.apply_symm_apply {E : AffineSubspace \ud835\udd5c P\u2081} [Nonempty E] {\u03c6 : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082}\n    (x : E.map \u03c6.toAffineMap) : \u03c6 ((E.isometryEquivMap \u03c6).symm x) = x :="}
{"input": "Statement in natural language:\nFor a given type '\u03b1' in a pseudo metric space, a set containing a single element 'x' is open if and only if there exists a positive number '\u03b5' such that for all 'y', if the distance between 'y' and 'x' is less than '\u03b5', then 'y' equals 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen_singleton_iff {\u03b1 : Type _} [PseudoMetricSpace \u03b1] {x : \u03b1} :\n    IsOpen ({x} : Set \u03b1) \u2194 \u2203 \u03b5 > 0, \u2200 y, dist y x < \u03b5 \u2192 y = x :="}
{"input": "Statement in natural language:\nThe integral of a function f, where the variable x ranges from a to b and is shifted by a constant d (i.e., f(d + x)), is equal to the integral of the function f, where the variable x ranges from d + a to d + b.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_comp_add_left (d) :\n    (\u222b x in a..b, f (d + x)) = \u222b x in d + a..d + b, f x :="}
{"input": "Statement in natural language:\nThe square of the norm of the negation of a quaternion is equal to the square of the norm of the quaternion itself.\nTranslate the statement in natural language to Lean:", "output": "theorem normSq_neg : normSq (-a) = normSq a :="}
{"input": "Statement in natural language:\nFor any two elements 'a\u2081' and 'a\u2082' of type \u03b1 and any two elements 'b\u2081' and 'b\u2082' of type \u03b2, 'b\u2081' is in the singleton set of 'a\u2082' and 'b\u2082' at 'a\u2081' if and only if 'a\u2081' is equal to 'a\u2082' and 'b\u2081' is equal to 'b\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_single_iff (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) : b\u2081 \u2208 single a\u2082 b\u2082 a\u2081 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 :="}
{"input": "Statement in natural language:\nFor a scalar 'a' and a vector 'x', the quadratic form of the scaled vector 'a \u2022 x' is equal to the product of 'a' squared and the quadratic form of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_smul (a : R) (x : M) : Q (a \u2022 x) = a * a * Q x :="}
{"input": "Statement in natural language:\nFor a measurable space \u03b2, a measure \u03bd on \u03b2, and a function g from \u03b1 to \u03b2, if g preserves the measure \u03bc under \u03bd and g is a measurable embedding, then for any function f from \u03b2 to non-negative extended real numbers, the integral of f composed with g with respect to \u03bc is equal to the integral of f with respect to \u03bd.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasurePreserving.lintegral_comp_emb {mb : MeasurableSpace \u03b2} {\u03bd : Measure \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (hg : MeasurePreserving g \u03bc \u03bd) (hge : MeasurableEmbedding g) (f : \u03b2 \u2192 \u211d\u22650\u221e) :\n    (\u222b\u207b a, f (g a) \u2202\u03bc) = \u222b\u207b b, f b \u2202\u03bd :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type '\u03b1 i', the preimage of 's' under the evaluation function at 'i' is equal to the Cartesian product of the universal set with the update function applied to 'i' and 's'. This holds true when '\u03b9' is a decidable equality.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_preimage [DecidableEq \u03b9] {s : Set (\u03b1 i)} :\n    eval i \u207b\u00b9' s = pi univ (update (fun i => univ) i s) :="}
{"input": "Statement in natural language:\nFor a given set 's' of type '\u03b1', if 'P s' holds true, then the measure 'm' of 's' under the condition 'h' is less than or equal to the extended measure 'm' of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_extend {s : \u03b1} (h : P s) : m s h \u2264 extend m s :="}
{"input": "Statement in natural language:\nFor a function 'f' from 'X' to 'Y', the following conditions are equivalent:\n\n1. 'f' is locally constant.\n2. For all 'x', eventually in the neighborhood of 'x', 'f' of 'x'' equals 'f' of 'x'.\n3. For all 'x', the set of 'x'' such that 'f' of 'x'' equals 'f' of 'x' is open.\n4. For all 'y', the preimage of the set containing 'y' under 'f' is open.\n5. For all 'x', there exists an open set 'U' containing 'x' such that for all 'x'' in 'U', 'f' of 'x'' equals 'f' of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem tfae (f : X \u2192 Y) :\n    TFAE [IsLocallyConstant f,\n      \u2200 x, \u2200\u1da0 x' in \ud835\udcdd x, f x' = f x,\n      \u2200 x, IsOpen { x' | f x' = f x },\n      \u2200 y, IsOpen (f \u207b\u00b9' {y}),\n      \u2200 x, \u2203 U : Set X, IsOpen U \u2227 x \u2208 U \u2227 \u2200 x' \u2208 U, f x' = f x] :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any function 'a' from a finite set of size 'n' to \u03b1, repeating 'a' once is equivalent to applying 'a' after casting the product of one and any element to the same type.\nTranslate the statement in natural language to Lean:", "output": "theorem repeat_one {\u03b1 : Type _} (a : Fin n \u2192 \u03b1) : Fin.repeat 1 a = a \u2218 cast (one_mul _) :="}
{"input": "Statement in natural language:\nFor any subgroup H of a group G, the quotient of the trivial subgroup of G by the set of elements in H is equal to the quotient group of G by H.\nTranslate the statement in natural language to Lean:", "output": "theorem left_bot_eq_left_quot (H : Subgroup G) :\n    Quotient (\u22a5 : Subgroup G).1 (H : Set G) = (G \u29f8 H) :="}
{"input": "Statement in natural language:\nFor a function 'm' mapping from a pair of types '\u03b1' and '\u03b2' to a type '\u03b3', and filters 'f' and 'g' on types '\u03b1' and '\u03b2' respectively, the map of 'm' over the product of 'f' and 'g' is equal to the map of a function that takes two arguments 'a' and 'b' and applies 'm' to the pair '(a, b)', over 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_prod_eq_map\u2082' (m : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    Filter.map m (f \u00d7\u02e2 g) = map\u2082 (fun a b => m (a, b)) f g :="}
{"input": "Statement in natural language:\nFor any type M that is a monoid and any element x of M, if x raised to the power of m equals 1 and x raised to the power of n equals 1, then x raised to the power of the greatest common divisor of m and n also equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_gcd_eq_one {M : Type _} [Monoid M] (x : M) {m n : \u2115} (hm : x ^ m = 1) (hn : x ^ n = 1) :\n    x ^ m.gcd n = 1 :="}
{"input": "Statement in natural language:\nFunction 'f' is an epimorphism if and only if the range of 'f' is equal to the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem epi_iff_range_eq_top : Epi f \u2194 f.range = \u22a4 :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' and a given 'i' which is a finite number less than the successor of 'n', if we apply the inverse of the equivalence created by the injective function 'castSucc' to the pair consisting of 'i' and 'hi', and then cast it to a natural number, we get 'i' back. This is under the condition that 'castSucc' is injective, meaning it maps distinct inputs to distinct outputs.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_of_injective_castSucc_symm {n : \u2115} (i : Fin n.succ) (hi) :\n    ((Equiv.ofInjective castSucc (castSucc_injective _)).symm \u27e8i, hi\u27e9 : \u2115) = i :="}
{"input": "Statement in natural language:\nFor a list \"l\u2081\" of elements of type \u03b1 and a function \"l\u2082\" that maps each element \"a\" to a list of type \u03c3 a, the sigma operation on the multiset derived from \"l\u2081\" and the function \"l\u2082\" is equal to the sigma operation on \"l\u2081\" and \"l\u2082\".\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sigma (l\u2081 : List \u03b1) (l\u2082 : \u2200 a, List (\u03c3 a)) :\n    (@Multiset.sigma \u03b1 \u03c3 l\u2081 fun a => l\u2082 a) = l\u2081.sigma l\u2082 :="}
{"input": "Statement in natural language:\nThe integral of the zero function (a function that assigns zero to every input) over any measure space is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_zero : integral (0 : \u03b1 \u2192\u2081[\u03bc] E) = 0 :="}
{"input": "Statement in natural language:\nThe tensor product is a base change for the ring S, with the tensor product being constructed from the rings R and S, the module M, and the number 1.\nTranslate the statement in natural language to Lean:", "output": "theorem TensorProduct.isBaseChange : IsBaseChange S (TensorProduct.mk R S M 1) :="}
{"input": "Statement in natural language:\nFor any pair 'x' from the sets B and F, if 'x' is in the target of 'e', then applying 'e' to the inverse of 'x' under the local homeomorphism 'e' gives back 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_symm_apply {x : B \u00d7 F} (hx : x \u2208 e.target) : e (e.toLocalHomeomorph.symm x) = x :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, if both \u03b1 and \u03b2 are infinite, then the cardinality of the product of \u03b1 and \u03b2 is equal to the maximum of the cardinalities of \u03b1 and \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_mk_eq_max {\u03b1 \u03b2 : Type _} [Infinite \u03b1] [Infinite \u03b2] : (#\u03b1) * (#\u03b2) = max (#\u03b1) (#\u03b2) :="}
{"input": "Statement in natural language:\nFor a function 'f' that is differentiable on the fourth quadrant (where real part is positive and imaginary part is negative), if there exists a real number 'c' less than 2 and a real number 'B' such that 'f' is asymptotically equivalent to the function 'expR (B * abs z ^ c)' when 'z' approaches infinity in the fourth quadrant, and if for all real numbers 'x', the norm of 'f x' is less than or equal to 'C' when 'x' is nonnegative, and the norm of 'f (x * I)' is less than or equal to 'C' when 'x' is nonpositive, then for any complex number 'z' with nonnegative real part and nonpositive imaginary part, the norm of 'f z' is less than or equal to 'C'.\nTranslate the statement in natural language to Lean:", "output": "theorem quadrant_IV (hd : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Iio 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 \u2016f x\u2016 \u2264 C) (him : \u2200 x : \u211d, x \u2264 0 \u2192 \u2016f (x * I)\u2016 \u2264 C) (hz_re : 0 \u2264 z.re)\n    (hz_im : z.im \u2264 0) : \u2016f z\u2016 \u2264 C :="}
{"input": "Statement in natural language:\nFor any vector 'v' of type '\u03b1' with a size of 'n + 1', the list representation of 'v' cannot be empty.\nTranslate the statement in natural language to Lean:", "output": "theorem empty_toList_eq_ff (v : Vector \u03b1 (n + 1)) : v.toList.isEmpty = false :="}
{"input": "Statement in natural language:\nFor any two polynomials p and q from the ring R[X], the application of the ring homomorphism composition with q to p is equal to the composition of p and q.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_compRingHom_apply (p q : R[X]) : (compRingHom q : R[X] \u2192 R[X]) p = comp p q :="}
{"input": "Statement in natural language:\nFor a given set 't' of type \u03b2, where 0 is not an element of 't', 't' is in the almost everywhere filter of the map of the indicator function of 's' with respect to 'f' if and only if the measure of the union of the preimage of 't' under 'f' and the complement of 's' is 0. This is under the condition that \u03b2 is a zero type.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_map_indicator_ae_iff_of_zero_nmem [Zero \u03b2] {t : Set \u03b2} (ht : (0 : \u03b2) \u2209 t) :\n    t \u2208 Filter.map (s.indicator f) \u03bc.ae \u2194 \u03bc ((f \u207b\u00b9' t)\u1d9c \u222a s\u1d9c) = 0 :="}
{"input": "Statement in natural language:\nIf an ideal I is finitely generated, then the Rees algebra of I is also finitely generated.\nTranslate the statement in natural language to Lean:", "output": "theorem reesAlgebra.fg (hI : I.FG) : (reesAlgebra I).FG :="}
{"input": "Statement in natural language:\nFor any element 'a' from set 'A' and any element 'r' from set 'R', the difference between the singleton set containing 'r' and the spectrum of 'a' is equal to the spectrum of the difference between the algebraic representation of 'r' and 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_sub_eq (a : A) (r : R) : {r} - \u03c3 a = \u03c3 (\u2191\u2090 r - a) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', and given sets 's' in '\u03b1' and 't' in '\u03b2', if the function 'f' is continuous on 's' and 's' is an open set, then the intersection of 's' and the preimage of the interior of 't' under 'f' is a subset of the intersection of 's' and the interior of the preimage of 't' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousOn.preimage_interior_subset_interior_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : ContinuousOn f s) (hs : IsOpen s) : s \u2229 f \u207b\u00b9' interior t \u2286 s \u2229 interior (f \u207b\u00b9' t) :="}
{"input": "Statement in natural language:\nIf for all x in a set s of real numbers, the function f is interval integrable over the interval from a to x, and if the function f is continuous, then the function that maps u to the integral of f from a to u is differentiable on the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableOn_integral_of_continuous {s : Set \u211d}\n    (hintg : \u2200 x \u2208 s, IntervalIntegrable f volume a x) (hcont : Continuous f) :\n    DifferentiableOn \u211d (fun u => \u222b x in a..u, f x) s :="}
{"input": "Statement in natural language:\nFor a given multiset 'm' of a commutative monoid '\u03b1', the product of the elements in 'm' is equal to the product of the elements in the enumerated finite set derived from 'm'. Each element in the enumerated finite set is a pair, and we are taking the product of the first element of each pair.\nTranslate the statement in natural language to Lean:", "output": "theorem Multiset.prod_eq_prod_toEnumFinset [CommMonoid \u03b1] (m : Multiset \u03b1) :\n    m.prod = \u220f x in m.toEnumFinset, x.1 :="}
{"input": "Statement in natural language:\nFor any type R, if you scale the element y of the type PUnit by r (an element of R), the result will be the unit element.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_eq {R : Type _} (y : PUnit) (r : R) : r \u2022 y = unit :="}
{"input": "Statement in natural language:\nThe norm of the integral of a function f is less than or equal to the norm of the function f itself.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_integral_le_norm (f : \u03b1 \u2192\u2081\u209b[\u03bc] E) : \u2016integral f\u2016 \u2264 \u2016f\u2016 :="}
{"input": "Statement in natural language:\nFor any two complex numbers x and y, x raised to the power of y equals zero if and only if x equals zero and y does not equal zero.\nTranslate the statement in natural language to Lean:", "output": "theorem cpow_eq_zero_iff (x y : \u2102) : x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0 :="}
{"input": "Statement in natural language:\nFor a measure space \u03bc, a real number p greater than or equal to 1, and a Banach space E, the range of the function 'toLpHom' applied to p and \u03bc, when considered as an additive subgroup of the Lp space of E, p, and \u03bc, is equal to the set of bounded continuous functions in the Lp space of E, p, and \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem range_toLpHom [Fact (1 \u2264 p)] :\n    ((toLpHom p \u03bc).range : AddSubgroup (Lp E p \u03bc)) =\n      MeasureTheory.Lp.boundedContinuousFunction E p \u03bc :="}
{"input": "Statement in natural language:\nFor any functions f and g, the measure of the product of the half-open intervals from f(i) to g(i) over all i (denoted by pi univ fun i => Ico (f i) (g i)) is almost everywhere equal to the measure of the closed intervals from f to g (denoted by Icc f g) under the product measure.\nTranslate the statement in natural language to Lean:", "output": "theorem univ_pi_Ico_ae_eq_Icc {f g : \u2200 i, \u03b1 i} :\n    (pi univ fun i => Ico (f i) (g i)) =\u1d50[Measure.pi \u03bc] Icc f g :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type '\u03b1' and a given element 'a' of type '\u03b1', 's' is in the neighborhood within the set of elements greater than 'a' if and only if there exists an element 'u' in the set of elements greater than 'a' such that the open interval between 'a' and 'u' is a subset of 's'. This is under the condition that there is no maximum order for the elements of type '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset [NoMaxOrder \u03b1] {a : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd[>] a \u2194 \u2203 u \u2208 Ioi a, Ioo a u \u2286 s :="}
{"input": "Statement in natural language:\nIf \u03c6 is homogeneous of degree n and \u03c8 is also homogeneous of degree n, then the sum of \u03c6 and \u03c8 is also homogeneous of degree n.\nTranslate the statement in natural language to Lean:", "output": "theorem add (h\u03c6 : IsHomogeneous \u03c6 n) (h\u03c8 : IsHomogeneous \u03c8 n) : IsHomogeneous (\u03c6 + \u03c8) n :="}
{"input": "Statement in natural language:\nA set 's' is bounded if and only if there exists a real number 'C' such that 'C' is greater than or equal to 'c' and for all elements 'x' and 'y' in the set 's', the distance between 'x' and 'y' is less than or equal to 'C'.\nTranslate the statement in natural language to Lean:", "output": "theorem isBounded_iff_exists_ge {s : Set \u03b1} (c : \u211d) :\n    IsBounded s \u2194 \u2203 C, c \u2264 C \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 dist x y \u2264 C :="}
{"input": "Statement in natural language:\nIf a topological space F is path-connected and x is an element of F, then F is a subset of the path component of x.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPathConnected.subset_pathComponent (h : IsPathConnected F) (x_in : x \u2208 F) :\n    F \u2286 pathComponent x :="}
{"input": "Statement in natural language:\nFor any given element 'a' and any given set 's' of elements of type '\u03b1', if 'a' is not an element of 's', then the difference between the set obtained by inserting 'a' into 's' and 's' itself is a set containing only 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem insert_diff_eq_singleton {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s) : insert a s \\ s = {a} :="}
{"input": "Statement in natural language:\nRational number 'p' is equal to rational number 'q' if and only if the numerator of 'p' is equal to the numerator of 'q' and the denominator of 'p' is equal to the denominator of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_num_den_iff : p = q \u2194 p.num = q.num \u2227 p.den = q.den :="}
{"input": "Statement in natural language:\nFor any two natural numbers m and n, the square of the maximum of m and n plus the minimum of m and n is less than or equal to the pair of m and n.\nTranslate the statement in natural language to Lean:", "output": "theorem max_sq_add_min_le_pair (m n : \u2115) : max m n ^ 2 + min m n \u2264 pair m n :="}
{"input": "Statement in natural language:\nThe maximum element of a set 's', given that 's' is non-empty, is an element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem max'_mem : s.max' H \u2208 s :="}
{"input": "Statement in natural language:\nFor a constant function c, given that p is not equal to 0 and p is not equal to infinity, the seminorm of the function is equal to the product of the non-negative real number norm of c and the measure of the entire set raised to the power of the reciprocal of the real number representation of p.\nTranslate the statement in natural language to Lean:", "output": "theorem snorm_const' (c : F) (h0 : p \u2260 0) (h_top : p \u2260 \u221e) :\n    snorm (fun _ : \u03b1 => c) p \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * \u03bc Set.univ ^ (1 / ENNReal.toReal p) :="}
{"input": "Statement in natural language:\nIn a preordered topological space with an order-closed topology, if a function 'f' is monotone on a set 's', 'a' is the least upper bound of 's', 's' is nonempty, and 'f' tends to 'b' in the neighborhood of 'a' restricted to 's', then 'b' is the least upper bound of the image of 's' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLUB.isLUB_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3] {f : \u03b1 \u2192 \u03b3}\n    {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : MonotoneOn f s) (ha : IsLUB s a) (hs : s.Nonempty)\n    (hb : Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b)) : IsLUB (f '' s) b :="}
{"input": "Statement in natural language:\nThe norm of the inverse of a given element 'a' in set 'E' is equal to the norm of 'a' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_inv' (a : E) : \u2016a\u207b\u00b9\u2016 = \u2016a\u2016 :="}
{"input": "Statement in natural language:\nFor a given function r from a set \u03b9 to the real numbers \u211d, if for every x, the set of i such that x is in the open ball centered at c(i) with radius r(i) is finite, and the union of all such balls equals the entire set (universe), then there exists another function r' from \u03b9 to \u211d such that the union of all balls centered at c(i) with radius r'(i) also equals the entire set, and for every i, r'(i) is less than r(i).\nTranslate the statement in natural language to Lean:", "output": "theorem exists_iUnion_ball_eq_radius_lt {r : \u03b9 \u2192 \u211d} (uf : \u2200 x, { i | x \u2208 ball (c i) (r i) }.Finite)\n    (uU : (\u22c3 i, ball (c i) (r i)) = univ) :\n    \u2203 r' : \u03b9 \u2192 \u211d, (\u22c3 i, ball (c i) (r' i)) = univ \u2227 \u2200 i, r' i < r i :="}
{"input": "Statement in natural language:\nThe frontier of the preimage of a set 's' under the function 're' is equal to the preimage of the frontier of 's' under the function 're'.\nTranslate the statement in natural language to Lean:", "output": "theorem frontier_preimage_re (s : Set \u211d) : frontier (re \u207b\u00b9' s) = re \u207b\u00b9' frontier s :="}
{"input": "Statement in natural language:\nThe integral from a to b of the function sin(x) raised to the power of m times cos(x) raised to the power of (2n + 1) is equal to the integral from sin(a) to sin(b) of the function u raised to the power of m times (1 - u^2) raised to the power of n.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_sin_pow_mul_cos_pow_odd (m n : \u2115) :\n    (\u222b x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) = \u222b u in sin a..sin b, u^m * (\u21911 - u ^ 2) ^ n :="}
{"input": "Statement in natural language:\nFor any real number x, x is strictly between 1 and 0 if and only if x is in the open interval from 0 to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem sbtw_one_zero_iff {x : R} : Sbtw R 1 x 0 \u2194 x \u2208 Set.Ioo (0 : R) 1 :="}
{"input": "Statement in natural language:\nThe cardinality (or size) of the set obtained by converting a list to a finset (a finite set with no duplicate elements) is less than or equal to the length of the original list.\nTranslate the statement in natural language to Lean:", "output": "theorem List.toFinset_card_le : l.toFinset.card \u2264 l.length :="}
{"input": "Statement in natural language:\nFor any natural numbers q, n, and a, where n equals a plus q, the homotopy h\u03c3' from X indexed by n to X indexed by n plus 1 is equal to negative one raised to the power of a times the suspension map of X at a, where a is less than or equal to n. This is proven by the symmetric introduction of the equality between n and a plus q.\nTranslate the statement in natural language to Lean:", "output": "theorem h\u03c3'_eq' {q n a : \u2115} (ha : n = a + q) :\n    (h\u03c3' q n (n + 1) rfl : X _[n] \u27f6 X _[n + 1]) =\n      (-1 : \u2124) ^ a \u2022 X.\u03c3 \u27e8a, Nat.lt_succ_iff.mpr (Nat.le.intro (Eq.symm ha))\u27e9 :="}
{"input": "Statement in natural language:\nFor any unit 'a' and any element 'b' in a group, the product of 'a' and the product of the inverse of 'a' and 'b' is equal to 'b'. This essentially means that multiplying by a unit and its inverse cancels out, leaving just 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_inv_cancel_left (a : \u03b1\u02e3) (b : \u03b1) : (a : \u03b1) * (\u2191a\u207b\u00b9 * b) = b :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to 'E' that belongs to 'Lp' space, the extended distance from 'f' to 'Lp' zero is equal to the 'p'-norm of 'f' with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem edist_toLp_zero (f : \u03b1 \u2192 E) (hf : Mem\u2112p f p \u03bc) : edist (hf.toLp f) 0 = snorm f p \u03bc :="}
{"input": "Statement in natural language:\nFor all ordinals 'a' and 'b', the natural sum of 'a' and 'b' is equal to the natural sum of 'b' and 'a'. This is the commutative property of natural addition for ordinals.\nTranslate the statement in natural language to Lean:", "output": "theorem nadd_comm : \u2200 a b, a \u266f b = b \u266f a"}
{"input": "Statement in natural language:\nThe multiplication indicator function of a universal set for any function f is equal to the function f itself.\nTranslate the statement in natural language to Lean:", "output": "theorem mulIndicator_univ (f : \u03b1 \u2192 M) : mulIndicator (univ : Set \u03b1) f = f :="}
{"input": "Statement in natural language:\nThe complex logarithm function is continuous at a given complex number 'x', provided that the real part of 'x' is greater than zero or the imaginary part of 'x' is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousAt_clog {x : \u2102} (h : 0 < x.re \u2228 x.im \u2260 0) : ContinuousAt log x :="}
{"input": "Statement in natural language:\nIf 'x' and 'y' are periodic points of a function 'f' with the same period 'n', and 'n' is greater than 0, then if the function applied to 'x' equals the function applied to 'y', 'x' must equal 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_apply_eq_same (hx : IsPeriodicPt f n x) (hy : IsPeriodicPt f n y) (hn : 0 < n)\n    (h : f x = f y) : x = y :="}
{"input": "Statement in natural language:\nThe hyperbolic cosine of the absolute value of x is equal to the hyperbolic cosine of x.\nTranslate the statement in natural language to Lean:", "output": "theorem cosh_abs : cosh (|x|) = cosh x :="}
{"input": "Statement in natural language:\nFor any natural number 'k' and any real number 'b' that is greater than zero, the function 'x to the power of k' is little-o of the function 'exponential of b times x' at positive infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem isLittleO_pow_exp_pos_mul_atTop (k : \u2115) {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => x ^ k) =o[atTop] fun x => exp (b * x) :="}
{"input": "Statement in natural language:\nFor any function 'f' from '\u03b9' to '\u03b4 \u2192 \u03b1', if every 'f i' is measurable, and for any function 's' from '\u03b9'' to the set of '\u03b9' with a countable basis 'u' that satisfies property 'p', if every 's i' is countable, then the function that maps 'x' to the limit inferior of 'f i x' as 'i' approaches 'u' is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_liminf' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {u : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hu : u.HasCountableBasis p s) (hs : \u2200 i, (s i).Countable) :\n    Measurable fun x => liminf (fun i => f i x) u :="}
{"input": "Statement in natural language:\nThe norm of the norm of a vector z (when the norm is considered as an element of the field of real or complex numbers) is equal to the norm of the vector z itself.\nTranslate the statement in natural language to Lean:", "output": "theorem IsROrC.norm_coe_norm {z : E} : \u2016(\u2016z\u2016 : \ud835\udd5c)\u2016 = \u2016z\u2016 :="}
{"input": "Statement in natural language:\nA function 'f' from '\u03b1' to '\u03b2' tends to the supremum of a sequence of filters 'x' towards a filter 'y' if and only if for all 'i', the function 'f' tends to the 'i'-th filter of 'x' towards 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_iSup {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : Filter \u03b2} :\n    Tendsto f (\u2a06 i, x i) y \u2194 \u2200 i, Tendsto f (x i) y :="}
{"input": "Statement in natural language:\nFor any point 'x' in the prime spectrum of a ring 'R', 'x' specializes to the closed point of 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem specializes_closedPoint (x : PrimeSpectrum R) : x \u2933 closedPoint R :="}
{"input": "Statement in natural language:\nThe set of all functions from a universal set to a set t is nonempty if and only if for every element i, the set t(i) is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem univ_pi_nonempty_iff : (pi univ t).Nonempty \u2194 \u2200 i, (t i).Nonempty :="}
{"input": "Statement in natural language:\nFor a real number 'i' such that the square of 'i' equals -1, and a special orthogonal matrix 'A' of size 'p' by 'q', the application of the special orthogonal indefinite equivalence on 'A' results in a matrix that is equal to the product of the inverse of the special orthogonal matrix 'Pso' of size 'p' by 'q' with 'i', 'A', and 'Pso' of size 'p' by 'q' with 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem soIndefiniteEquiv_apply {i : R} (hi : i * i = -1) (A : so' p q R) :\n    (soIndefiniteEquiv p q R hi A : Matrix (Sum p q) (Sum p q) R) =\n      (Pso p q R i)\u207b\u00b9 \u2b1d (A : Matrix (Sum p q) (Sum p q) R) \u2b1d Pso p q R i :="}
{"input": "Statement in natural language:\nIf a set 's' has unique differentiability at a point 'x', and if the function 'f' has derivatives 'f'' and 'f\u2081'' within the set 's' at the point 'x', then 'f'' and 'f\u2081'' are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem UniqueDiffWithinAt.eq_deriv (s : Set \ud835\udd5c) (H : UniqueDiffWithinAt \ud835\udd5c s x)\n    (h : HasDerivWithinAt f f' s x) (h\u2081 : HasDerivWithinAt f f\u2081' s x) : f' = f\u2081' :="}
{"input": "Statement in natural language:\nIf 't' is an element of the parts of 'P', then the cardinality of 't' subtracted by the bi-union of the parts of 'P' equitabilised by 'h' that are subsets of 't', is less than or equal to 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_parts_equitabilise_subset_le :\n    t \u2208 P.parts \u2192 (t \\ ((P.equitabilise h).parts.filter fun u => u \u2286 t).biUnion id).card \u2264 m :="}
{"input": "Statement in natural language:\nFor a given polynomial 'p' in the ring of polynomials 'R[X]' and a scalar 's' in the ring 'R', if 'p' is not equal to zero, then the result of scaling the roots of 'p' by 's' is also not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem scaleRoots_ne_zero {p : R[X]} (hp : p \u2260 0) (s : R) : scaleRoots p s \u2260 0 :="}
{"input": "Statement in natural language:\nFor a given type F, if H is a group and there is a monoid homomorphism from H to G defined by F, then the topology induced by F on H forms a topological group.\nTranslate the statement in natural language to Lean:", "output": "theorem topologicalGroup_induced {F : Type _} [Group H] [MonoidHomClass F H G] (f : F) :\n    @TopologicalGroup H (induced f \u2039_\u203a) _ :="}
{"input": "Statement in natural language:\nThe support of a multivariate polynomial p is empty if and only if the polynomial p is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem support_eq_empty {p : MvPolynomial \u03c3 R} : p.support = \u2205 \u2194 p = 0 :="}
{"input": "Statement in natural language:\nFor a set 's' and a natural number 'n', where the membership of elements in 's' can be decided, the application of the order embedding of the set 's' to 'n' is equal to the subtype of 's' derived from 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem orderEmbeddingOfSet_apply [DecidablePred (\u00b7 \u2208 s)] {n : \u2115} :\n    orderEmbeddingOfSet s n = Subtype.ofNat s n :="}
{"input": "Statement in natural language:\nThe function f'' is Big O of g'' at the point x if and only if when g'' at x equals zero, f'' at x also equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigO_pure {x} : f'' =O[pure x] g'' \u2194 g'' x = 0 \u2192 f'' x = 0 :="}
{"input": "Statement in natural language:\nThe function 'f' is continuously differentiable on the set 's' for all orders of differentiation if and only if for every natural number 'n', 'f' is 'n'-times continuously differentiable on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem contDiffOn_top : ContDiffOn \ud835\udd5c \u221e f s \u2194 \u2200 n : \u2115, ContDiffOn \ud835\udd5c n f s :="}
{"input": "Statement in natural language:\nFor a continuous monoid homomorphism from A to B, the composition with any continuous monoid homomorphism from B to C is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_comp_left (f : ContinuousMonoidHom A B) :\n    Continuous fun g : ContinuousMonoidHom B C => g.comp f :="}
{"input": "Statement in natural language:\nIf 'a' and 'b' are codisjoint, then the Heyting implication of 'a' and the infimum (greatest lower bound) of 'a' and 'b' is equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Codisjoint.himp_inf_cancel_right (h : Codisjoint a b) : a \u21e8 a \u2293 b = b :="}
{"input": "Statement in natural language:\nFor any left subtree 'l', node 'x', and right subtree 'r', if 'l' is balanced, 'r' is balanced, 'l' has a defined size, and 'r' has a defined size, and if either there exists a 'l'' such that the size of 'l'' is greater than the size of 'l' and the size of 'l'' and 'r' are balanced, or there exists a 'r'' such that the size of 'r'' is greater than the size of 'r' and the size of 'l' and 'r'' are balanced, then the result of balancing 'l', 'x', and 'r' to the right is equal to the result of a general balance operation on 'l', 'x', and 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem balanceR_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r)\n    (H : (\u2203 l', Raised (size l) l' \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised r' (size r) \u2227 BalancedSz (size l) r') :\n    @balanceR \u03b1 l x r = balance' l x r :="}
{"input": "Statement in natural language:\nFor any object X in category C, the composition of the inverse of the right unitor on X and the morphism part of the braiding on X and the identity object of C is equal to the inverse of the left unitor on X.\nTranslate the statement in natural language to Lean:", "output": "theorem rightUnitor_inv_braiding (X : C) : (\u03c1_ X).inv \u226b (\u03b2_ X (\ud835\udfd9_ C)).hom = (\u03bb_ X).inv :="}
{"input": "Statement in natural language:\nThe preimage under the identity function of a topological space X to itself is the identity function.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_id : @comap X X Z _ _ id = id :="}
{"input": "Statement in natural language:\nThe scalar multiplication operation in the module M\u2081 over the ring R is continuous with respect to the topology induced by the function f on the set u.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousSMul_induced : @ContinuousSMul R M\u2081 _ u (t.induced f) :="}
{"input": "Statement in natural language:\nFor a given point 'x' in a scalar field '\ud835\udd5c', if 'x' is uniquely differentiable within a set 's', then the first iterated derivative of a function 'f' within the set 's' at point 'x' is equal to the derivative of the function 'f' within the set 's' at point 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem iteratedDerivWithin_one {x : \ud835\udd5c} (h : UniqueDiffWithinAt \ud835\udd5c s x) :\n    iteratedDerivWithin 1 f s x = derivWithin f s x :="}
{"input": "Statement in natural language:\nThe sum of a singleton set for each element in a finite set is equal to the value of the finite set itself.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_multiset_singleton (s : Finset \u03b1) : (s.sum fun x => {x}) = s.val :="}
{"input": "Statement in natural language:\nFor any polynomial 'p', there exists another polynomial 'q' such that the product of the polynomial 'q' and the product of the roots of 'p' subtracted from 'X' is equal to 'p'. Additionally, the sum of the number of roots of 'p' and the degree of 'q' is equal to the degree of 'p'. Lastly, the polynomial 'q' has no roots.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_prod_multiset_X_sub_C_mul (p : R[X]) :\n    \u2203 q,\n      (p.roots.map fun a => X - C a).prod * q = p \u2227\n        Multiset.card p.roots + q.natDegree = p.natDegree \u2227 q.roots = 0 :="}
{"input": "Statement in natural language:\nFor a compact set 's' and any set 't', if for every element 'x' in 's', the neighborhood of 'x' contains boxes of 't', then the neighborhood of 's' also contains boxes of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem nhdsContainBoxes_of_compact {s : Set \u03b1} (hs : IsCompact s) (t : Set \u03b2)\n    (H : \u2200 x \u2208 s, NhdsContainBoxes ({x} : Set \u03b1) t) : NhdsContainBoxes s t :="}
{"input": "Statement in natural language:\nIf a path 'p' from point 'a' to point 'b' has a length of zero, then point 'a' is equal to point 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_length_zero (p : Path a b) (hzero : p.length = 0) : a = b :="}
{"input": "Statement in natural language:\nIf a function 'f' has a Taylor series up to 'n' represented by 'p' on a set 's', and another function 'g' has a Taylor series up to 'n' represented by 'q' on the same set 's', then the function that maps 'y' to the pair '(f(y), g(y))' has a Taylor series up to 'n' on 's', represented by the function that maps 'y' and 'k' to the pair '(p(y, k), q(y, k))'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFTaylorSeriesUpToOn.prod (hf : HasFTaylorSeriesUpToOn n f p s) {g : E \u2192 G}\n    {q : E \u2192 FormalMultilinearSeries \ud835\udd5c E G} (hg : HasFTaylorSeriesUpToOn n g q s) :\n    HasFTaylorSeriesUpToOn n (fun y => (f y, g y)) (fun y k => (p y k).prod (q y k)) s :="}
{"input": "Statement in natural language:\nThe function 'iso' has a Frechet derivative within the set 's' at the point 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFDerivWithinAt : HasFDerivWithinAt iso (iso : E \u2192L[\ud835\udd5c] F) s x :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'n' and 'm', if the successor of 'n' is less than or equal to the successor of 'm', then the cast of this inequality to a less than or equal to relation with 0 is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem castLE_zero {n m : \u2115} (h : n.succ \u2264 m.succ) : castLE h 0 = 0 :="}
{"input": "Statement in natural language:\nFor any given element 'x' of a set '\u03b1', there exists an 'i' such that the fixed point of function 'f' at 'x' is less than or equal to the approximation of function 'f' at 'i' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_fix_le_approx (x : \u03b1) : \u2203 i, Part.fix f x \u2264 approx f i x :="}
{"input": "Statement in natural language:\nIf a relation 'r' on a set '\u03b1' is total, then the swapped relation (where the order of elements in each pair is reversed) is also total.\nTranslate the statement in natural language to Lean:", "output": "theorem IsTotal.swap (r) [IsTotal \u03b1 r] : IsTotal \u03b1 (swap r) :="}
{"input": "Statement in natural language:\nFor a given property P that applies to all pairs of elements a and b in a set \u03b1, where there is a reflexive transitive relation r between a and b, if the following conditions are met:\n\n1. The property P holds for any element a in relation to itself.\n2. The property P holds for any pair of elements a and b where the relation r directly applies.\n3. The property P holds for any three elements a, b, and c where there is a reflexive transitive relation r from a to b and from b to c, and if P holds for the relations from a to b and from b to c, then P also holds for the transitive relation from a to c.\n\nThen the property P holds for the reflexive transitive relation r between any two elements a and b. This is a form of transitive induction.\nTranslate the statement in natural language to Lean:", "output": "theorem trans_induction_on {P : \u2200 {a b : \u03b1}, ReflTransGen r a b \u2192 Prop} {a b : \u03b1}\n    (h : ReflTransGen r a b) (ih\u2081 : \u2200 a, @P a a refl) (ih\u2082 : \u2200 {a b} (h : r a b), P (single h))\n    (ih\u2083 : \u2200 {a b c} (h\u2081 : ReflTransGen r a b) (h\u2082 : ReflTransGen r b c), P h\u2081 \u2192 P h\u2082 \u2192\n     P (h\u2081.trans h\u2082)) : P h :="}
{"input": "Statement in natural language:\nFor any functor F from category J to the functor category K\u2964C, and any objects j in J and k in K, the composition of the morphism given by the isomorphism from the limit object of F evaluated at k and the projection at j from the limit of F composed with the evaluation at k, is equal to the application of the projection at j from the limit of F at k. This is under the assumption that the category C has limits of shape J.\nTranslate the statement in natural language to Lean:", "output": "theorem limitObjIsoLimitCompEvaluation_hom_\u03c0 [HasLimitsOfShape J C] (F : J \u2964 K \u2964 C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).hom \u226b limit.\u03c0 (F \u22d9 (evaluation K C).obj k) j =\n      (limit.\u03c0 F j).app k :="}
{"input": "Statement in natural language:\nThe image of the universal set under the function that maps each element of a set 's' to the corresponding element in the set '\u03b1' is equal to the set 's' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_image_univ (s : Set \u03b1) : ((\u2191) : s \u2192 \u03b1) '' Set.univ = s :="}
{"input": "Statement in natural language:\nIf we have three preordered sets \u03b1, \u03b2, and \u03b3, and two functions 'g' from \u03b2 to \u03b3 and 'f' from \u03b1 to \u03b2, along with two sets 's' of \u03b1 and 't' of \u03b2. If 'g' is strictly monotonically increasing on 't', 'f' is strictly monotonically increasing on 's', and 'f' maps 's' to 't', then the composition of 'g' and 'f' is strictly monotonically increasing on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictMonoOn.comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    {t : Set \u03b2} (hg : StrictMonoOn g t) (hf : StrictMonoOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g \u2218 f) s :="}
{"input": "Statement in natural language:\nFor a set P of projections on a normed space X, the complement of P (denoted as P\u1d9c) is equal to the difference between the identity element (1) in the space M and the set P itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_compl (P : { P : M // IsLprojection X P }) : \u2191(P\u1d9c) = (1 : M) - \u2191P :="}
{"input": "Statement in natural language:\nThe infimum (greatest lower bound) of the product of p and q\u2081 and the product of p' and q\u2081' is equal to the product of the infimum of p and p' and the infimum of q\u2081 and q\u2081'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_inf_prod : prod p q\u2081 \u2293 prod p' q\u2081' = prod (p \u2293 p') (q\u2081 \u2293 q\u2081') :="}
{"input": "Statement in natural language:\nThe second element (b) of the flipped version of a pair (u) is equal to the first element (a) of the original pair (u).\nTranslate the statement in natural language to Lean:", "output": "theorem flip_b : (flip u).b = u.a :="}
{"input": "Statement in natural language:\nFor any function 'f' from type \u03b1 to \u03b2, the composition of the identity function and 'f' is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem left_id (f : \u03b1 \u2192 \u03b2) : id \u2218 f = f :="}
{"input": "Statement in natural language:\nIf 'b' is a unit (an element with a multiplicative inverse) in a given algebraic structure, then for any element 'a' in the same structure, the result of multiplying 'a' by 'b' and then dividing by 'b' is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_div_cancel (h : IsUnit b) (a : \u03b1) : a * b / b = a :="}
{"input": "Statement in natural language:\nFor a given filter basis B of a set \u03b1, if a set U is an element of B, then U is also an element of the filter of B.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_filter_of_mem (B : FilterBasis \u03b1) {U : Set \u03b1} : U \u2208 B \u2192 U \u2208 B.filter :="}
{"input": "Statement in natural language:\nFor a functor H from category J to the functor category K to C, given that category C has limits of shape J, and given objects k in K and W in C, and morphisms f and g from W to the limit object of H at k, if for all objects j in J, the composition of f and the projection of the limit of H at j applied to k equals the composition of g and the projection of the limit of H at j applied to k, then f equals g.\nTranslate the statement in natural language to Lean:", "output": "theorem limit_obj_ext {H : J \u2964 K \u2964 C} [HasLimitsOfShape J C] {k : K} {W : C}\n    {f g : W \u27f6 (limit H).obj k}\n    (w : \u2200 j, f \u226b (Limits.limit.\u03c0 H j).app k = g \u226b (Limits.limit.\u03c0 H j).app k) : f = g :="}
{"input": "Statement in natural language:\nThe function 'iso' is differentiable on the set 's' in the field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableOn : DifferentiableOn \ud835\udd5c iso s :="}
{"input": "Statement in natural language:\nFor a compact space \u03b1, the function F tends to locally uniformly if and only if the function F tends to uniformly at p.\nTranslate the statement in natural language to Lean:", "output": "theorem tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace [CompactSpace \u03b1] :\n    TendstoLocallyUniformly F f p \u2194 TendstoUniformly F f p :="}
{"input": "Statement in natural language:\nFor any unit \u03b3 in the multiplicative group of non-zero elements of \u0393\u2080, the set of elements less than \u03b3 is in the neighborhood of 0 in \u0393\u2080.\nTranslate the statement in natural language to Lean:", "output": "theorem nhds_zero_of_units (\u03b3 : \u0393\u2080\u02e3) : Iio \u2191\u03b3 \u2208 \ud835\udcdd (0 : \u0393\u2080) :="}
{"input": "Statement in natural language:\nFor any two elements x and y in a Lie algebra L, the application of the adjoint representation of x to y is equal to the Lie bracket of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem LieAlgebra.ad_apply (x y : L) : LieAlgebra.ad R L x y = \u2045x, y\u2046 :="}
{"input": "Statement in natural language:\nFor a given element 'x' from the set 'S', 'x' is algebraic over the field 'K' if and only if 'x' (considered as an element of the set 'L') is algebraic over the field 'K'.\nTranslate the statement in natural language to Lean:", "output": "theorem isAlgebraic_iff {x : S} : IsAlgebraic K x \u2194 IsAlgebraic K (x : L) :="}
{"input": "Statement in natural language:\nFor a given filter 'f' of type \u03b1, and propositions 'p' which is a function of \u03b1, and 'q', the proposition that 'for all elements x in the filter f, if p(x) then q' is equivalent to the proposition 'if there exists an element x in the filter f such that p(x), then q'.\nTranslate the statement in natural language to Lean:", "output": "theorem eventually_imp_distrib_right {f : Filter \u03b1} {p : \u03b1 \u2192 Prop} {q : Prop} :\n    (\u2200\u1da0 x in f, p x \u2192 q) \u2194 (\u2203\u1da0 x in f, p x) \u2192 q :="}
{"input": "Statement in natural language:\nA set 's' is in the sequential map of filter 'f' and filter 'g' with a function 'm' if and only if there exist sets 't' and 'u' such that 't' is in 'g', 'u' is in 'f', and for all elements 'x' in 'u' and all elements 'y' in 't', the result of applying function 'm' to 'x' and 'y' is in set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_map_seq_iff {f : Filter \u03b1} {g : Filter \u03b2} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b3} :\n    s \u2208 (f.map m).seq g \u2194 \u2203 t u, t \u2208 g \u2227 u \u2208 f \u2227 \u2200 x \u2208 u, \u2200 y \u2208 t, m x y \u2208 s :="}
{"input": "Statement in natural language:\nFor any three sheafed spaces X, Y, and Z in a category C, and any morphisms \u03b1 from X to Y and \u03b2 from Y to Z, and any open set U, the composition of \u03b1 and \u03b2 applied to the opposite of U is equal to \u03b2 applied to the opposite of U composed with \u03b1 applied to the opposite of the object in the category of open sets mapped by \u03b2's base.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_c_app' {X Y Z : SheafedSpace C} (\u03b1 : X \u27f6 Y) (\u03b2 : Y \u27f6 Z) (U) :\n    (\u03b1 \u226b \u03b2).c.app (op U) = \u03b2.c.app (op U) \u226b \u03b1.c.app (op ((Opens.map \u03b2.base).obj U)) :="}
{"input": "Statement in natural language:\nFor any two elements x' and y' of the weak dual of a normed space over a field \ud835\udd5c and a vector space E, the function toNormedDual applied to x' equals toNormedDual applied to y' if and only if x' equals y'.\nTranslate the statement in natural language to Lean:", "output": "theorem toNormedDual_eq_iff (x' y' : WeakDual \ud835\udd5c E) : toNormedDual x' = toNormedDual y' \u2194 x' = y' :="}
{"input": "Statement in natural language:\nFor a sequence of functions 'f' from a nonempty semilattice '\u03b9' to the space of 'p'-integrable functions 'Lp E p \u03bc', the sequence is Cauchy if and only if the sequence of norms of the difference between the functions at each pair of points in '\u03b9' tends to zero as the pair goes to infinity. This is under the condition that 'p' is greater than or equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem cauchySeq_Lp_iff_cauchySeq_\u2112p {\u03b9} [Nonempty \u03b9] [SemilatticeSup \u03b9] [hp : Fact (1 \u2264 p)]\n    (f : \u03b9 \u2192 Lp E p \u03bc) :\n    CauchySeq f \u2194 Tendsto (fun n : \u03b9 \u00d7 \u03b9 => snorm (\u21d1(f n.fst) - \u21d1(f n.snd)) p \u03bc) atTop (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' in the Boolean algebra 'AsBoolAlg \u03b1', the Boolean algebra of their infimum (greatest lower bound) is equal to the product of the Boolean algebras of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofBoolAlg_inf (a b : AsBoolAlg \u03b1) : ofBoolAlg (a \u2293 b) = ofBoolAlg a * ofBoolAlg b :="}
{"input": "Statement in natural language:\nFor any affine map 'f' from PE to PF and any function 'g' from k to PE, the slope of the composition of 'f' and 'g' at points 'a' and 'b' is equal to the linear transformation of 'f' applied to the slope of 'g' at points 'a' and 'b'. Here, F and PF are types with an additive commutative group structure and a module structure over a field k, and F is also an affine torsor over PF.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineMap.slope_comp {F PF : Type _} [AddCommGroup F] [Module k F] [AddTorsor F PF]\n    (f : PE \u2192\u1d43[k] PF) (g : k \u2192 PE) (a b : k) : slope (f \u2218 g) a b = f.linear (slope g a b) :="}
{"input": "Statement in natural language:\nThe thickening of a singleton set by a real number \u03b4 is equal to the open ball centered at x with radius \u03b4.\nTranslate the statement in natural language to Lean:", "output": "theorem thickening_singleton (\u03b4 : \u211d) (x : X) : thickening \u03b4 ({x} : Set X) = ball x \u03b4 :="}
{"input": "Statement in natural language:\nFor any two subgroups H and K of a group G, if H is a subset of or equal to K, then the normal core of H is a subset of or equal to the normal core of K.\nTranslate the statement in natural language to Lean:", "output": "theorem normalCore_mono {H K : Subgroup G} (h : H \u2264 K) : H.normalCore \u2264 K.normalCore :="}
{"input": "Statement in natural language:\nFor any integer 'n' and any elements 'x' and 'y' of an additive commutative group '\u03b1', if the scalar multiplication of 'n' and 'x' equals 'y', then the scalar multiplication of 'n' and 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem unfold_zsmul {\u03b1} [AddCommGroup \u03b1] (n : \u2124) (x y : \u03b1)\n    (h : smulg n x = y) : n \u2022 x = y :="}
{"input": "Statement in natural language:\nFor a given monoid R, an add monoid M, and a distributive multiplication action of R on M, for any element r of R and any function f from \u03b9 to M, the transformation of the scalar multiplication of r and f to a decidable function is equal to the scalar multiplication of r and the transformation of f to a decidable function.\nTranslate the statement in natural language to Lean:", "output": "theorem toDfinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] (r : R) (f : \u03b9 \u2192\u2080 M) :\n    (r \u2022 f).toDfinsupp = r \u2022 f.toDfinsupp :="}
{"input": "Statement in natural language:\nFor any two polynomials p and q, the product of q and the quotient of p divided by q, plus the remainder of p divided by q, equals p. This is essentially the polynomial version of the division algorithm.\nTranslate the statement in natural language to Lean:", "output": "theorem quotient_mul_add_remainder_eq_aux (p q : R[X]) : q * div p q + mod p q = p :="}
{"input": "Statement in natural language:\nFor a property 'p' that applies to multisets of type \u03b1, and a natural number 'n', if for every multiset 't\u2081', the property 'p' holds for all multisets 't\u2082' with a cardinality less than or equal to 'n' and 't\u2081' is less than 't\u2082', then the property 'p' also holds for 't\u2081' with a cardinality less than or equal to 'n'. Given a multiset 's', the strong downward induction of 'H' on 's' is equal to 'H' applied to 's' with the function that applies the strong downward induction of 'H' to all multisets less than 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem strongDownwardInduction_eq {p : Multiset \u03b1 \u2192 Sort _} {n : \u2115}\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Multiset \u03b1}, card t\u2082 \u2264 n \u2192 t\u2081 < t\u2082 \u2192 p t\u2082) \u2192 card t\u2081 \u2264 n \u2192 p t\u2081)\n    (s : Multiset \u03b1) :\n    strongDownwardInduction H s = H s fun ht _hst => strongDownwardInduction H _ ht :="}
{"input": "Statement in natural language:\n'a' is disjoint with the intersection of 'b' and 'c' if and only if 'b' is disjoint with the intersection of 'a' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_left_comm : Disjoint a (b \u2293 c) \u2194 Disjoint b (a \u2293 c) :="}
{"input": "Statement in natural language:\nFor a natural number 'n' and a prime number 'p', the factorization of 'n' with respect to 'p' is equal to the p-adic valuation of 'n' with respect to 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem factorization_def (n : \u2115) {p : \u2115} (pp : p.Prime) : n.factorization p = padicValNat p n :="}
{"input": "Statement in natural language:\nFor a given function 'f' which is a bijective function from a set '\u03b1' to a subset 'p', and a given permutation 'g' on the set '\u03b1', the support of the extension of 'g' to the domain of 'f' is equal to the image of the support of 'g' under the embedding induced by 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem support_extend_domain (f : \u03b1 \u2243 Subtype p) {g : Perm \u03b1} :\n    support (g.extendDomain f) = g.support.map f.asEmbedding :="}
{"input": "Statement in natural language:\n'b' is less than the product of the inverse of 'a' and 'c' if and only if the product of 'a' and 'b' is less than 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_inv_mul_iff_mul_lt : b < a\u207b\u00b9 * c \u2194 a * b < c :="}
{"input": "Statement in natural language:\nThe dual of the symmetric difference of 'a' and 'b' is equivalent to the symmetric difference of the dual of 'a' and the dual of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem toDual_symmDiff : toDual (a \u2206 b) = toDual a \u21d4 toDual b :="}
{"input": "Statement in natural language:\nA real number 'x' subtracted by an integer 'm' is irrational if and only if 'x' itself is irrational.\nTranslate the statement in natural language to Lean:", "output": "theorem irrational_sub_int_iff : Irrational (x - m) \u2194 Irrational x :="}
{"input": "Statement in natural language:\nFor a given index 'i' that is an element of a set 's', and a function 'w' from index set '\u03b9' to a field 'k' such that the sum of 'w' over 's' equals 1, the coordinate of 'i' in the affine combination of 'b' with coefficients 'w' is equal to 'w i'.\nTranslate the statement in natural language to Lean:", "output": "theorem coord_apply_combination_of_mem (hi : i \u2208 s) {w : \u03b9 \u2192 k} (hw : s.sum w = 1) :\n    b.coord i (s.affineCombination k b w) = w i :="}
{"input": "Statement in natural language:\nThe diameter of a set is equal to zero if and only if the set is a subsingleton.\nTranslate the statement in natural language to Lean:", "output": "theorem diam_eq_zero_iff : diam s = 0 \u2194 s.Subsingleton :="}
{"input": "Statement in natural language:\nA function 'f' from '\u03b1' to '\u03b2' is continuous at a point 'x' within the set 's' excluding 'x', if and only if the function 'f' is continuous at the point 'x' within the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousWithinAt_diff_self {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt f (s \\ {x}) x \u2194 ContinuousWithinAt f s x :="}
{"input": "Statement in natural language:\nIf a set 's' is both open and closed (i.e., it is clopen), then 's' is open.\nTranslate the statement in natural language to Lean:", "output": "theorem IsClopen.isOpen (hs : IsClopen s) : IsOpen s :="}
{"input": "Statement in natural language:\nFor any two morphisms 'f' and 'g' from object 'X' to object 'Y' in category 'C', the mapping of the difference of 'f' and 'g' is equal to the difference of the mappings of 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_sub {X Y : C} {f g : X \u27f6 Y} : F.map (f - g) = F.map f - F.map g :="}
{"input": "Statement in natural language:\nFor a power series \u03c6 over a ring R and a partially extended natural number n, if the coefficient of \u03c6 at every natural number i less than n is zero, then n is less than or equal to the order of \u03c6.\nTranslate the statement in natural language to Lean:", "output": "theorem le_order (\u03c6 : PowerSeries R) (n : PartENat) (h : \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0) :\n    n \u2264 order \u03c6 :="}
{"input": "Statement in natural language:\n'X' is prime in the power series of 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem X_prime : Prime (X : PowerSeries R) :="}
{"input": "Statement in natural language:\n'b' is in the open ball centered at 'a' with radius 'r' if and only if the norm of 'b' divided by 'a' is less than 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_ball_iff_norm'' : b \u2208 ball a r \u2194 \u2016b / a\u2016 < r :="}
{"input": "Statement in natural language:\nFor a set \ud835\udca2 in the opposite category of C, \ud835\udca2 is coseparating if and only if \ud835\udca2 is separating.\nTranslate the statement in natural language to Lean:", "output": "theorem isCoseparating_unop_iff (\ud835\udca2 : Set C\u1d52\u1d56) : IsCoseparating \ud835\udca2.unop \u2194 IsSeparating \ud835\udca2 :="}
{"input": "Statement in natural language:\nFor any ordered set \u03b1, the least element of the universal set (which includes all elements of \u03b1) is the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem isLeast_univ [OrderBot \u03b1] : IsLeast (univ : Set \u03b1) \u22a5 :="}
{"input": "Statement in natural language:\nFor a function 'f' that is a bijective (one-to-one and onto) mapping from set \u03b1 to set \u03b2, and for any two elements 'x' and 'y' in set \u03b1, 'f' maps 'x' to the same element as 'y' if and only if 'x' equals 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_eq_iff_eq (f : \u03b1 \u2243 \u03b2) {x y : \u03b1} : f x = f y \u2194 x = y :="}
{"input": "Statement in natural language:\nFor any two elements x and y in a ring R, x is coprime to -y if and only if x is coprime to y.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_right_iff (x y : R) : IsCoprime x (-y) \u2194 IsCoprime x y :="}
{"input": "Statement in natural language:\nFor any given element 'x' of the finite set of size 'n + 1', the function 'succAbove x' is injective. This means that the function 'succAbove x' assigns a unique value to each element in its domain, such that no two different elements in the domain map to the same value in the range.\nTranslate the statement in natural language to Lean:", "output": "theorem succAbove_right_injective {x : Fin (n + 1)} : Injective (succAbove x) :="}
{"input": "Statement in natural language:\nFor a function M mapping from \u039b to Stmt\u2082, a finite set S of \u039b, and two statements q\u2081 and q\u2082, if q\u2081 is an element of the statements of q\u2082, then if some statement q\u2082 is an element of the statements of M in set S, some statement q\u2081 is also an element of the statements of M in set S.\nTranslate the statement in natural language to Lean:", "output": "theorem stmts_trans {M : \u039b \u2192 Stmt\u2082} {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2082} (h\u2081 : q\u2081 \u2208 stmts\u2081 q\u2082) :\n    some q\u2082 \u2208 stmts M S \u2192 some q\u2081 \u2208 stmts M S :="}
{"input": "Statement in natural language:\nFor an additive functor 'F' from category 'C' to category 'D', the object of the functor obtained by applying the 'ofExact' function to 'F' is the same as the object of 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem AdditiveFunctor.ofExact_obj_fst (F : C \u2964\u2091 D) :\n    ((AdditiveFunctor.ofExact C D).obj F).obj = F.obj :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set '\u03b1' to 'M' and a subset 's' of '\u03b1', if the intersection of 's' and the multiplicative support of 'f' is infinite, then the infinite product of 'f' over all elements in 's' equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_mem_eq_one_of_infinite {f : \u03b1 \u2192 M} {s : Set \u03b1} (hs : (s \u2229 mulSupport f).Infinite) :\n    (\u220f\u1da0 i \u2208 s, f i) = 1 :="}
{"input": "Statement in natural language:\nIn a commutative monoid with zero, for any elements p and q, if p is not a unit and p divides q in a way that q is not a unit, then q is not irreducible.\nTranslate the statement in natural language to Lean:", "output": "theorem not_irreducible_of_not_unit_dvdNotUnit [CommMonoidWithZero \u03b1] {p q : \u03b1} (hp : \u00acIsUnit p)\n    (h : DvdNotUnit p q) : \u00acIrreducible q :="}
{"input": "Statement in natural language:\nThe interval from a to b is equal to the subtype of the interval from a to b, where a is a type of \u03b1, under the condition p.\nTranslate the statement in natural language to Lean:", "output": "theorem subtype_Ioo_eq : Ioo a b = (Ioo (a : \u03b1) b).subtype p :="}
{"input": "Statement in natural language:\nThe function 'mk'' is surjective when applied to the uncurried function from the product of M and S to M'. In other words, for every element in the codomain M', there exists an element in the domain (M \u00d7 S) such that the function maps this element to the given element in the codomain.\nTranslate the statement in natural language to Lean:", "output": "theorem mk'_surjective : Function.Surjective (Function.uncurry <| mk' f : M \u00d7 S \u2192 M') :="}
{"input": "Statement in natural language:\nFor any element 'a', if 'a' is not a maximum element, then 'C' applies to the successor of 'a'. Also, for any element 'a', if 'a' is a successor limit, then 'C' applies to 'a'. Given an element 'b' that is not a maximum, the successor limit recursion on 'b' is equal to the application of 'C' to 'b' under the condition that 'b' is not a maximum.\nTranslate the statement in natural language to Lean:", "output": "theorem isSuccLimitRecOn_succ' (hs : \u2200 a, \u00acIsMax a \u2192 C (succ a)) (hl : \u2200 a, IsSuccLimit a \u2192 C a)\n    {b : \u03b1} (hb : \u00acIsMax b) : @isSuccLimitRecOn \u03b1 _ _ C (succ b) hs hl = hs b hb :="}
{"input": "Statement in natural language:\nFor any type '\u03b1' that is small in the 'v' universe, the cardinality of the lift of the shrink of '\u03b1' in the maximum of the 'u' and 'w' universes is equal to the cardinality of the lift of '\u03b1' in the maximum of the 'v' and 'w' universes.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_mk_shrink (\u03b1 : Type u) [Small.{v} \u03b1] :\n    Cardinal.lift.{max u w} (#Shrink.{v} \u03b1) = Cardinal.lift.{max v w} (#\u03b1) :=\n-- Porting note: Added .{v,u,w} universe hint below"}
{"input": "Statement in natural language:\nFor any two integers i and j, the least common multiple of i and j is equal to the least common multiple of j and i. This is essentially saying that the order in which the numbers are presented does not affect the outcome of the least common multiple.\nTranslate the statement in natural language to Lean:", "output": "theorem lcm_comm (i j : \u2124) : lcm i j = lcm j i :="}
{"input": "Statement in natural language:\nFor a given type '\u03b1' with a topological space, a measurable space, a second countable topology, a linear order, an order topology, and a Borel space, and given two measures '\u03bc' and '\u03bd' on this type '\u03b1' (with '\u03bc' being a finite measure), if for all 'a' the measure '\u03bc' of the interval from 'a' to infinity is equal to the measure '\u03bd' of the same interval, then the measures '\u03bc' and '\u03bd' are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_of_Ici {\u03b1 : Type _} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Ici a) = \u03bd (Ici a)) : \u03bc = \u03bd :="}
{"input": "Statement in natural language:\nIf 'X' is a simple object in a category 'C', 'f' is an epimorphism from 'X' to 'Y', and 'f' is not equal to zero, then 'f' is an isomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem isIso_of_epi_of_nonzero {X Y : C} [Simple X] {f : X \u27f6 Y} [Epi f] (w : f \u2260 0) : IsIso f :="}
{"input": "Statement in natural language:\nFor a property 'p' pertaining to a pair of elements from sets '\u03b1' and '\u03b2', and a set 's' of '\u03b2', the property 'p' holds eventually for all pairs in the product of a filter 'f' and the principal filter of 's' if and only if the property 'p' holds eventually for all elements 'x' in the filter 'f' such that for all elements 'y' in 's', the property 'p' holds for the pair (x, y).\nTranslate the statement in natural language to Lean:", "output": "theorem eventually_prod_principal_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} {s : Set \u03b2} :\n    (\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in f \u00d7\u02e2 \ud835\udcdf s, p x) \u2194 \u2200\u1da0 x : \u03b1 in f, \u2200 y : \u03b2, y \u2208 s \u2192 p (x, y) :="}
{"input": "Statement in natural language:\nFor any finite set 'a' of elements of type \u03b1, if the cardinalities of sets 'u' and 'v' are equal, then the cardinality of the set obtained by compressing 'a' with 'u' and 'v' is equal to the cardinality of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_compress (huv : u.card = v.card) (a : Finset \u03b1) : (compress u v a).card = a.card :="}
{"input": "Statement in natural language:\nThe cycle of 1 for any element x is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleOf_one (x : \u03b1) : cycleOf 1 x = 1 :="}
{"input": "Statement in natural language:\nFor any four Cauchy sequences a\u2081, b\u2081, a\u2082, b\u2082, if a\u2081 is equivalent to a\u2082 and b\u2081 is equivalent to b\u2082, then the infimum (greatest lower bound) of a\u2081 and b\u2081 is equivalent to the infimum of a\u2082 and b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_equiv_inf {a\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs} (ha : a\u2081 \u2248 a\u2082) (hb : b\u2081 \u2248 b\u2082) :\n    a\u2081 \u2293 b\u2081 \u2248 a\u2082 \u2293 b\u2082 :="}
{"input": "Statement in natural language:\nFor a given point x\u2080 in the set \u03b1, the function that takes a pair of elements from set \u03b2 and divides the second element by the first one, tends to 1 when the pair of elements is close to the image of x\u2080 under a certain function e. This is under the condition that the pair of elements is taken from the preimage of the neighborhood of the pair (x\u2080, x\u2080) under the function that maps a pair of elements from \u03b2 to a pair of their images under the function e.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_div_comap_self (x\u2080 : \u03b1) :\n    Tendsto (fun t : \u03b2 \u00d7 \u03b2 => t.2 / t.1) ((comap fun p : \u03b2 \u00d7 \u03b2 => (e p.1, e p.2)) <| \ud835\udcdd (x\u2080, x\u2080))\n      (\ud835\udcdd 1) :="}
{"input": "Statement in natural language:\nFor any partially ordered set \u03b1, the top element of the dual of the \"with top\" construction of \u03b1 is equal to the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem toDualBotEquiv_top [LE \u03b1] : WithTop.toDualBotEquiv (\u22a4 : WithTop \u03b1\u1d52\u1d48) = \u22a4 :="}
{"input": "Statement in natural language:\nFor all ordinal numbers 'a', and for any two ordinal numbers 'b' and 'c', the natural sum of 'a' and 'b' is less than the natural sum of 'a' and 'c' if and only if 'b' is less than 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem nadd_lt_nadd_iff_left : \u2200 (a) {b c}, a \u266f b < a \u266f c \u2194 b < c :="}
{"input": "Statement in natural language:\nFor a given commutative semiring S\u2082, a ring homomorphism 'f' from R to S\u2081, a function 'g' from \u03c3 to S\u2081, and a ring homomorphism '\u03c6' from S\u2081 to S\u2082, the composition of '\u03c6' with the evaluation homomorphism of 'f' and 'g' is equal to the evaluation homomorphism of the composition of '\u03c6' and 'f', and the function that maps each element 'i' to the image of 'g(i)' under '\u03c6'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_eval\u2082Hom [CommSemiring S\u2082] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (\u03c6 : S\u2081 \u2192+* S\u2082) :\n    \u03c6.comp (eval\u2082Hom f g) = eval\u2082Hom (\u03c6.comp f) fun i => \u03c6 (g i) :="}
{"input": "Statement in natural language:\nFor any three indices k\u2082, k\u2081, and k\u2080 in a chain complex, given the relations r\u2082\u2081 between k\u2082 and k\u2081, and r\u2081\u2080 between k\u2081 and k\u2080, and a map 'hom' from the chain complex C to D, the map at index k\u2081 of the null-homotopic map of 'hom' is equal to the composition of the differential from k\u2081 to k\u2080 in C and the map from k\u2080 to k\u2081 in 'hom', added to the composition of the map from k\u2081 to k\u2082 in 'hom' and the differential from k\u2082 to k\u2081 in D.\nTranslate the statement in natural language to Lean:", "output": "theorem nullHomotopicMap_f {k\u2082 k\u2081 k\u2080 : \u03b9} (r\u2082\u2081 : c.Rel k\u2082 k\u2081) (r\u2081\u2080 : c.Rel k\u2081 k\u2080)\n    (hom : \u2200 i j, C.X i \u27f6 D.X j) :\n    (nullHomotopicMap hom).f k\u2081 = C.d k\u2081 k\u2080 \u226b hom k\u2080 k\u2081 + hom k\u2081 k\u2082 \u226b D.d k\u2082 k\u2081 :="}
{"input": "Statement in natural language:\nThe set of complex numbers \"z\" that form a circle is equal to the set of complex numbers \"z\" whose absolute value is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem circle_def : \u2191circle = { z : \u2102 | abs z = 1 } :="}
{"input": "Statement in natural language:\nIf functions 'f' and 'g' are both finitely measurable supported with respect to measure '\u03bc', then the pair of 'f' and 'g' is also finitely measurable supported with respect to the same measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem pair {g : \u03b1 \u2192\u209b \u03b3} (hf : f.FinMeasSupp \u03bc) (hg : g.FinMeasSupp \u03bc) :\n    (pair f g).FinMeasSupp \u03bc :="}
{"input": "Statement in natural language:\nFor a group with zero '\u03b1' and any two elements 'a' and 'b' from '\u03b1', 'a' is conjugate to 'b' if and only if there exists an element 'c' from '\u03b1' such that 'c' is not zero and the product of 'c', 'a', and the inverse of 'c' equals 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem isConj_iff\u2080 [GroupWithZero \u03b1] {a b : \u03b1} : IsConj a b \u2194 \u2203 c : \u03b1, c \u2260 0 \u2227 c * a * c\u207b\u00b9 = b :="}
{"input": "Statement in natural language:\nFor a given relation 'r' on a type '\u03b1', and for any two elements 'n' and 'm' of type '\u03b1', if for every 'i' in the open-closed interval from 'n' to 'm', the relation 'r' holds between the predecessor of 'i' and 'i', and if 'n' is less than or equal to 'm', then the reflexive transitive closure of the relation 'r' holds between 'n' and 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem reflTransGen_of_pred_of_le (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ioc n m, r (pred i) i)\n    (hmn : n \u2264 m) : ReflTransGen r n m :="}
{"input": "Statement in natural language:\nFor a function 'f' that is an order isomorphism from 'r' to 's', the function obtained by applying 'toFun' to 'f' is the same as the function 'f' when it is considered as a function from '\u03b1' to '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_fn_toFun (f : r \u2192r s) : f.toFun = (f : \u03b1 \u2192 \u03b2) :="}
{"input": "Statement in natural language:\nFor any two ordinals 'o' and 'b', where 'b' is greater than 1, if 'b' raised to the power of 'o' is a principal ordinal under multiplication, then 'o' is a principal ordinal under addition.\nTranslate the statement in natural language to Lean:", "output": "theorem principal_add_of_principal_mul_opow {o b : Ordinal} (hb : 1 < b)\n    (ho : Principal (\u00b7 * \u00b7) (b^o)) : Principal (\u00b7 + \u00b7) o :="}
{"input": "Statement in natural language:\nIn a NoMaxOrder (a total order without a maximum element), the union of all sets of elements less than each element in the set is equal to the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem iUnion_Iio [NoMaxOrder \u03b1] : (\u22c3 a : \u03b1, Iio a) = univ :="}
{"input": "Statement in natural language:\nFor any two conditionally complete lattices \u03b2 and \u03b3, a filter \u03b1, a function u from \u03b1 to \u03b2, and an order isomorphism g from \u03b2 to \u03b3, if the function u is bounded and co-bounded under the filter f, and the function g composed with u is also bounded and co-bounded under the filter f, then the order isomorphism g applied to the limit inferior of the function u under the filter f is equal to the limit inferior of the function g composed with u under the filter f.\nTranslate the statement in natural language to Lean:", "output": "theorem OrderIso.liminf_apply {\u03b3} [ConditionallyCompleteLattice \u03b2] [ConditionallyCompleteLattice \u03b3]\n    {f : Filter \u03b1} {u : \u03b1 \u2192 \u03b2} (g : \u03b2 \u2243o \u03b3)\n    (hu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) fun x => g (u x) := by isBoundedDefault) :\n    g (liminf u f) = liminf (fun x => g (u x)) f :="}
{"input": "Statement in natural language:\nIf for some real number C and a sequence of functions F from \u03b9 to lp E \u221e, the norm of Fk is less than or equal to C for all sufficiently large k (in the limit), and if the sequence of functions F converges to a function f in the neighborhood of f, then the norm of f(a) is less than or equal to C for any a in \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_apply_le_of_tendsto {C : \u211d} {F : \u03b9 \u2192 lp E \u221e} (hCF : \u2200\u1da0 k in l, \u2016F k\u2016 \u2264 C)\n    {f : \u2200 a, E a} (hf : Tendsto (id fun i => F i : \u03b9 \u2192 \u2200 a, E a) l (\ud835\udcdd f)) (a : \u03b1) : \u2016f a\u2016 \u2264 C :="}
{"input": "Statement in natural language:\nThe linear map obtained by restricting scalars in an isometry is equal to the linear map obtained by directly restricting scalars.\nTranslate the statement in natural language to Lean:", "output": "theorem restrictScalarsIsometry_toLinearMap :\n    (restrictScalarsIsometry \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'').toLinearMap = restrictScalars\u2097 \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'' :="}
{"input": "Statement in natural language:\nIf a function f has a local minimum at a point a, and if all values of f in the neighborhood of a are greater than zero, then the reciprocal of the function f has a local maximum at the same point a.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalMin.inv {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (h1 : IsLocalMin f a) (h2 : \u2200\u1da0 z in \ud835\udcdd a, 0 < f z) :\n    IsLocalMax f\u207b\u00b9 a :="}
{"input": "Statement in natural language:\nTwice the cosine of a number x is equal to the sum of the exponential of the product of x and the imaginary unit, and the exponential of the product of negative x and the imaginary unit.\nTranslate the statement in natural language to Lean:", "output": "theorem two_cos : 2 * cos x = exp (x * I) + exp (-x * I) :="}
{"input": "Statement in natural language:\nA number 'q - x' is irrational if and only if the number 'x' is irrational.\nTranslate the statement in natural language to Lean:", "output": "theorem irrational_rat_sub_iff : Irrational (q - x) \u2194 Irrational x :="}
{"input": "Statement in natural language:\nThe closure of the union of a set, indexed by \u03b9, is equal to the supremum of the closures of each individual set in the index.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set R) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i) :="}
{"input": "Statement in natural language:\nFor any nonempty type \u03b1 with a preorder and a direction, and any finite type \u03b2, if there is a function from \u03b2 to \u03b1, then the set of all values that the function can take (the range of the function) has a lower bound.\nTranslate the statement in natural language to Lean:", "output": "theorem Fintype.bddBelow_range [Nonempty \u03b1] [Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {\u03b2 : Type _}\n    [Fintype \u03b2] (f : \u03b2 \u2192 \u03b1) : BddBelow (Set.range f) :="}
{"input": "Statement in natural language:\nThe non-negative norm of the right scalar multiplication of a linear map 'c' and a linear function 'f' is equal to the product of the non-negative norms of 'c' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem nnnorm_smulRight_apply (c : E \u2192L[\ud835\udd5c] \ud835\udd5c) (f : F\u2097) : \u2016smulRight c f\u2016\u208a = \u2016c\u2016\u208a * \u2016f\u2016\u208a :="}
{"input": "Statement in natural language:\nFor any two lists 'L' and 'L'' of elements from a left cancelable monoid 'M', if the lengths of 'L' and 'L'' are equal and the product of the first 'i' elements of 'L' is equal to the product of the first 'i' elements of 'L'' for all 'i' less than or equal to the length of 'L', then 'L' is equal to 'L''.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_prod_take_eq [LeftCancelMonoid M] {L L' : List M} (h : L.length = L'.length)\n    (h' : \u2200 i \u2264 L.length, (L.take i).prod = (L'.take i).prod) : L = L' :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of elements of type \u03b1 and a natural number 'k', if the cardinality of 's' is 'k', and there exists an order embedding 'f' from 'k' to \u03b1 such that for all 'x', 'f' of 'x' is an element of 's', then 'f' is equal to the order embedding of 's' into 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem orderEmbOfFin_unique' {s : Finset \u03b1} {k : \u2115} (h : s.card = k) {f : Fin k \u21aao \u03b1}\n    (hfs : \u2200 x, f x \u2208 s) : f = s.orderEmbOfFin h :="}
{"input": "Statement in natural language:\nThe sum of any number and itself, divided by two, equals the original number.\nTranslate the statement in natural language to Lean:", "output": "theorem add_self_div_two (a : \u03b1) : (a + a) / 2 = a :="}
{"input": "Statement in natural language:\nFor a vector 'v' and a point 'x', the non-negative distance between 'x' and the sum of 'v' and 'x' is equal to the non-negative norm of 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_vadd_right (v : V) (x : P) : nndist x (v +\u1d65 x) = \u2016v\u2016\u208a :="}
{"input": "Statement in natural language:\nFor a natural number 'n' such that 'n' modulo 2 equals 1, and for a non-zero element 'a' of the integers modulo 'n', 'a' is not equal to its negation.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_neg_self (n : \u2115) [hn : Fact ((n : \u2115) % 2 = 1)] {a : ZMod n} (ha : a \u2260 0) : a \u2260 -a :="}
{"input": "Statement in natural language:\nIf the sequence of the absolute values of the sum of a function 'f' over a range 'm' is a Cauchy sequence, then the sequence of the sum of the function 'f' over the same range 'm' is also a Cauchy sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem isCauSeq_series_of_abv_isCauSeq {f : \u2115 \u2192 \u03b2} :\n    (IsCauSeq abs fun m => \u2211 n in range m, abv (f n)) \u2192 IsCauSeq abv fun m => \u2211 n in range m, f n :="}
{"input": "Statement in natural language:\nFor any types M and R, where M is a monoid and R is a non-unital non-associative ring, and there is a distributive multiplication action of M on R, given an element k of M such that for all elements x of R, if k times x equals 0 then x equals 0, if k times a equals k times b for any elements a and b of R, then a equals b.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_cancel_of_non_zero_divisor {M R : Type _} [Monoid M] [NonUnitalNonAssocRing R]\n    [DistribMulAction M R] (k : M) (h : \u2200 x : R, k \u2022 x = 0 \u2192 x = 0) {a b : R} (h' : k \u2022 a = k \u2022 b) :\n    a = b :="}
{"input": "Statement in natural language:\nIf a set 's' is measurable, and for every open set 'u' containing 'x\u2080', the function '\u03c6' tends to 0 uniformly on the set difference 's \\ u', and almost everywhere in 'l', the integral of '\u03c6' over 's' equals 1, and if 'g' is integrable on 's' and continuous within 's' at 'x\u2080', then almost everywhere in 'l', the function '\u03c6' times 'g' is integrable on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem integrableOn_peak_smul_of_integrableOn_of_continuousWithinAt (hs : MeasurableSet s)\n    (hl\u03c6 : \u2200 u : Set \u03b1, IsOpen u \u2192 x\u2080 \u2208 u \u2192 TendstoUniformlyOn \u03c6 0 l (s \\ u))\n    (hi\u03c6 : \u2200\u1da0 i in l, (\u222b x in s, \u03c6 i x \u2202\u03bc) = 1) (hmg : IntegrableOn g s \u03bc)\n    (hcg : ContinuousWithinAt g s x\u2080) : \u2200\u1da0 i in l, IntegrableOn (fun x => \u03c6 i x \u2022 g x) s \u03bc :="}
{"input": "Statement in natural language:\nFor any ordinal number 'o' that is greater than zero, the enumeration of the set of all elements less than zero (which is an empty set) is equal to the bottom element of the set. This is under the condition that the order of the elements in the set is determined by the function 'outOrderBotOfPos' applied to 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem enum_zero_eq_bot {o : Ordinal} (ho : 0 < o) :\n    enum (\u00b7 < \u00b7) 0 (by rwa [type_lt]) =\n      haveI H := outOrderBotOfPos ho\n      \u22a5 :="}
{"input": "Statement in natural language:\nFor a nonempty set 's' of type \u03b2, and a function 'f' from \u03b1 to \u03b2, if 's' is a subset of the range of 'f', then the preimage of 's' under 'f' is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem Nonempty.preimage' {s : Set \u03b2} (hs : s.Nonempty) {f : \u03b1 \u2192 \u03b2} (hf : s \u2286 Set.range f) :\n    (f \u207b\u00b9' s).Nonempty :="}
{"input": "Statement in natural language:\nThe cardinality (or size) of the cycle type of a permutation \u03c3 is greater than 0 if and only if \u03c3 is not equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem card_cycleType_pos {\u03c3 : Perm \u03b1} : 0 < Multiset.card \u03c3.cycleType \u2194 \u03c3 \u2260 1 :="}
{"input": "Statement in natural language:\nFor a given non-negative number \u03b5 and a positive number \u03b4 in a normed space E, the \u03b5-thickening of the ball with center x and radius \u03b4 is equal to the closed ball with center x and radius \u03b5 + \u03b4.\nTranslate the statement in natural language to Lean:", "output": "theorem cthickening_ball (h\u03b5 : 0 \u2264 \u03b5) (h\u03b4 : 0 < \u03b4) (x : E) :\n    cthickening \u03b5 (ball x \u03b4) = closedBall x (\u03b5 + \u03b4) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to 'M' and a set 's' of '\u03b1', 's' is disjoint from the multiplicative support of 'f' if and only if 'f' equals 1 on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_mulSupport_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : Disjoint s (mulSupport f) \u2194 EqOn f 1 s :="}
{"input": "Statement in natural language:\nIf \"a\" is covered by \"b\" (denoted as a \u22d6 b), then \"a\" is less than \"b\".\nTranslate the statement in natural language to Lean:", "output": "theorem Covby.lt (h : a \u22d6 b) : a < b :="}
{"input": "Statement in natural language:\nFor any three units (invertible elements) a, x, and y in a multiplicative monoid M, if a semi-conjugates x and y, then a, considered as an element of M, also semi-conjugates x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem units_val {a x y : M\u02e3} (h : SemiconjBy a x y) : SemiconjBy (a : M) x y :="}
{"input": "Statement in natural language:\nThe image of the open segment between points b and c under the function that adds a to each point is equal to the open segment between the points a+b and a+c.\nTranslate the statement in natural language to Lean:", "output": "theorem openSegment_translate_image (a b c : E) :\n    (fun x => a + x) '' openSegment \ud835\udd5c b c = openSegment \ud835\udd5c (a + b) (a + c) :="}
{"input": "Statement in natural language:\nA point 'y' is on the sphere with center 'x' and radius '\u03b5' if and only if the distance from 'y' to 'x' is '\u03b5'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_sphere : y \u2208 sphere x \u03b5 \u2194 dist y x = \u03b5 :="}
{"input": "Statement in natural language:\nFor a locally compact, sigma-compact, T2 space X, given a function \u03b9 from X to some type u, a predicate p on pairs (x, \u03b9 x), and a function B from pairs (x, \u03b9 x) to sets of X, such that for each x in X, the neighborhood of x has a basis given by the sets B(x, \u03b9 x) for which p(x, \u03b9 x) holds, then there exists a type \u03b1, a function c from \u03b1 to X, and a function r from \u03b1 to \u03b9(c \u03b1), such that for each a in \u03b1, p(c a, r a) holds, the union of the sets B(c a, r a) for all a in \u03b1 equals the entire space X, and the collection of sets B(c a, r a) for all a in \u03b1 is locally finite.\nTranslate the statement in natural language to Lean:", "output": "theorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis [LocallyCompactSpace X]\n    [SigmaCompactSpace X] [T2Space X] {\u03b9 : X \u2192 Type u} {p : \u2200 x, \u03b9 x \u2192 Prop} {B : \u2200 x, \u03b9 x \u2192 Set X}\n    (hB : \u2200 x, (\ud835\udcdd x).HasBasis (p x) (B x)) :\n    \u2203 (\u03b1 : Type v) (c : \u03b1 \u2192 X) (r : \u2200 a, \u03b9 (c a)),\n      (\u2200 a, p (c a) (r a)) \u2227 (\u22c3 a, B (c a) (r a)) = univ \u2227 LocallyFinite fun a \u21a6 B (c a) (r a) :="}
{"input": "Statement in natural language:\nThe conversion of zero from the ring of polynomials over R to a finite support function equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinsupp_zero : (0 : R[X]).toFinsupp = 0 :="}
{"input": "Statement in natural language:\nFor a given function 'f' from type \u03b1 to \u03b2, a multiset 's' of type \u03b1, and an element 'x' of type \u03b1, if the function 'f' is injective (meaning it maps distinct elements of its domain to distinct elements of its codomain), then the count of the image of 'x' under 'f' in the multiset obtained by mapping 's' under 'f' is equal to the count of 'x' in the original multiset 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem count_map_eq_count' [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) (hf : Function.Injective f)\n    (x : \u03b1) : (s.map f).count (f x) = s.count x :="}
{"input": "Statement in natural language:\nFor any elements 'a' of type \u03b1 and 'b' of type \u03b2, applying the constant function (which maps every element of type \u03b1 to the same element 'b' of type \u03b2) to 'a' results in 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem const_apply' (a : \u03b1) (b : \u03b2) : (const \u03b1 b : \u03b1 \u2192 \u03b2) a = b :="}
{"input": "Statement in natural language:\nIn a nontrivial normed space, a sphere with center at a point 'x' and radius 'r' is nonempty if and only if the radius 'r' is greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem NormedSpace.sphere_nonempty [Nontrivial E] {x : E} {r : \u211d} :\n    (sphere x r).Nonempty \u2194 0 \u2264 r :="}
{"input": "Statement in natural language:\nFor a multivariate polynomial 'f' over a finite set of size 'n + 1' and a ring 'R', if 'f' is not equal to zero, then the degree of the polynomial obtained by applying the 'finSuccEquiv' function to 'f' is equal to the degree of 'f' with respect to the variable 0.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} (h : f \u2260 0) :\n    (finSuccEquiv R n f).degree = degreeOf 0 f :="}
{"input": "Statement in natural language:\nFor a given element 'a' in an ordered set '\u03b1', if 'b' is the greatest lower bound of the set of all elements greater than 'a', then 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_glb_Ioi (a : \u03b1) (hb : IsGLB (Ioi a) b) : a \u2264 b :="}
{"input": "Statement in natural language:\nThe function 'toLinearMap', which maps from an unspecified type to a linear map from A\u2081 to A\u2082 over a ring R, is injective. This means that different inputs to 'toLinearMap' will always produce different outputs.\nTranslate the statement in natural language to Lean:", "output": "theorem toLinearMap_injective : Function.Injective (toLinearMap : _ \u2192 A\u2081 \u2192\u2097[R] A\u2082) :="}
{"input": "Statement in natural language:\nFor any two submodules 'p' and 'p'' of a module 'M' over a ring 'R', 'p' and 'p'' are disjoint if and only if for any element 'x' in 'p' and any element 'y' in 'p'', if 'x' equals 'y' then 'x' equals zero in 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_def' {p p' : Submodule R M} :\n    Disjoint p p' \u2194 \u2200 x \u2208 p, \u2200 y \u2208 p', x = y \u2192 x = (0 : M) :="}
{"input": "Statement in natural language:\nIf a function 'f' is periodic with period 'c' in the context of an additive commutative monoid '\u03b1', a division semiring '\u03b3', and a module '\u03b3 \u03b1', then the function 'f' applied to the scalar multiplication of 'a' and 'x' is also periodic with period being the scalar multiplication of the inverse of 'a' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem Periodic.const_smul\u2080 [AddCommMonoid \u03b1] [DivisionSemiring \u03b3] [Module \u03b3 \u03b1]\n    (h : Periodic f c) (a : \u03b3) : Periodic (fun x => f (a \u2022 x)) (a\u207b\u00b9 \u2022 c) :="}
{"input": "Statement in natural language:\nThe coercion of a vector space is equal to the function that coerces an element from one type to another.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_ofVectorSpace : \u21d1(ofVectorSpace K V) = ((\u2191) : _ \u2192 _ ) :="}
{"input": "Statement in natural language:\nIf function 'f' has a right inverse 'f'' on set 't', and 'f'' maps set 't' to set 's', then 'f' is surjective from set 's' to set 't'. This means that for every element in set 't', there is at least one element in set 's' that 'f' maps to it.\nTranslate the statement in natural language to Lean:", "output": "theorem RightInvOn.surjOn (hf : RightInvOn f' f t) (hf' : MapsTo f' t s) : SurjOn f s t :="}
{"input": "Statement in natural language:\nFor any polynomial 'f' over a ring 'R', the degree of the reversed polynomial is less than or equal to the degree of the original polynomial.\nTranslate the statement in natural language to Lean:", "output": "theorem reverse_natDegree_le (f : R[X]) : f.reverse.natDegree \u2264 f.natDegree :="}
{"input": "Statement in natural language:\nThe preimage of the mapping of a morphism 'f' from object 'X' to object 'Y' under a functor 'F' is equal to the morphism 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_map (f : X \u27f6 Y) : F.preimage (F.map f) = f :="}
{"input": "Statement in natural language:\nIf E' is a subsingleton, then f' is Big O of g' at l.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigO_of_subsingleton [Subsingleton E'] : f' =O[l] g' :="}
{"input": "Statement in natural language:\nFor any four matrices A, B, C, and D, where A is a matrix of size n by l, B is a matrix of size n by m, C is a matrix of size o by l, and D is a matrix of size o by m, if we first form a block matrix from A, B, C, and D, and then extract the bottom right block from this block matrix, we will get back the original matrix D.\nTranslate the statement in natural language to Lean:", "output": "theorem toBlocks_fromBlocks\u2082\u2082 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D).toBlocks\u2082\u2082 = D :="}
{"input": "Statement in natural language:\nFor any function 'f' that maps from type \u03b1 to type \u03b2, if you apply 'f' to an empty list (nil), the result will also be an empty list (nil).\nTranslate the statement in natural language to Lean:", "output": "theorem map_nil {\u03b2 : Type _} (f : \u03b1 \u2192 \u03b2) : map f nil = nil :="}
{"input": "Statement in natural language:\nGiven a decidable equality on 'l' and a function 'f' that maps 'X' to a matrix with varying dimensions 'm' and 'n' over a ring 'R', and given a matrix 'a' with the same varying dimensions, if the function 'f' has a sum 'a', then the sum of the block diagonal of the function 'f' is the block diagonal of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasSum.matrix_blockDiagonal' [DecidableEq l] {f : X \u2192 \u2200 i, Matrix (m' i) (n' i) R}\n    {a : \u2200 i, Matrix (m' i) (n' i) R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiagonal' (f x)) (blockDiagonal' a) :="}
{"input": "Statement in natural language:\nFor a type M and a type X, where X is a pseudo emetric space and there is a scalar multiplication operation defined on M and X, and this scalar multiplication is isometric, then the scalar multiplication of any element c of type M is an isometry.\nTranslate the statement in natural language to Lean:", "output": "theorem isometry_smul {M : Type u} (X : Type w) [PseudoEMetricSpace X] [SMul M X]\n    [IsometricSMul M X] (c : M) : Isometry (c \u2022 \u00b7 : X \u2192 X) :="}
{"input": "Statement in natural language:\nIf 'f' is a minimum filter at 'a' with respect to 'l' and 'g' is also a minimum filter at 'a' with respect to 'l', then the function that adds the outputs of 'f' and 'g' is also a minimum filter at 'a' with respect to 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsMinFilter.add (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x + g x) l a :="}
{"input": "Statement in natural language:\nFor any given elements 'a' from set \u03b1 and 'b' from set \u03b2, 'a' is a member of the stabilizer of 'b' if and only if the group action of 'a' on 'b' results in 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_stabilizer_iff {b : \u03b2} {a : \u03b1} : a \u2208 stabilizer \u03b1 b \u2194 a \u2022 b = b :="}
{"input": "Statement in natural language:\nFor a given constant 'b' of type \u03b2, a set 's' of type \u03b1, and an element 'x' of type \u03b1, the function that maps every element of type \u03b1 to 'b' is continuous within the set 's' at the point 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousWithinAt_const {b : \u03b2} {s : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt (fun _ : \u03b1 => b) s x :="}
{"input": "Statement in natural language:\nIf we have two continuous functions, one from \u03b1 to \u03b2 and another from \u03b3 to \u03b4, then the sum map of these two functions is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.map f g) :="}
{"input": "Statement in natural language:\nFor a function 'v' mapping from 'm' to '\u03b1', a scalar 'x' of type '\u03b1', and a function 'w' mapping from the finite set 'n' to '\u03b1', the multiplication of the vector 'v' and the vector constructed by 'x' and 'w' is equal to a function 'i' that maps the scalar multiplication of 'v i' and the vector constructed by 'x' and 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem vecMulVec_cons (v : m' \u2192 \u03b1) (x : \u03b1) (w : Fin n \u2192 \u03b1) :\n    vecMulVec v (vecCons x w) = fun i => v i \u2022 vecCons x w :="}
{"input": "Statement in natural language:\nFor a measurable singleton class and a finite type, the function from \u03b1 to non-negative extended real numbers, the Lebesgue integral of the function with respect to the measure \u03bc is equal to the sum of the function evaluated at x times the measure of the set containing x.\nTranslate the statement in natural language to Lean:", "output": "theorem lintegral_fintype [MeasurableSingletonClass \u03b1] [Fintype \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (\u222b\u207b x, f x \u2202\u03bc) = \u2211 x, f x * \u03bc {x} :="}
{"input": "Statement in natural language:\nFor any hyperreal number 'x' that is not infinite, 'x' is the standard part of the supremum of the set of all real numbers 'y' such that 'y' as a hyperreal number is less than 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem isSt_sSup {x : \u211d*} (hni : \u00acInfinite x) : IsSt x (sSup { y : \u211d | (y : \u211d*) < x }) :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' and a finite number 'i' within the range of 'n', if the successor of 'n' is equal to the successor of another natural number 'n'', then casting 'n' to 'n'' for the successor of 'i' is equal to the successor of the casting of 'i' from 'n' to 'n''.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_succ_eq {n' : \u2115} (i : Fin n) (h : n.succ = n'.succ) :\n    cast h i.succ = (cast (Nat.succ.inj h) i).succ :="}
{"input": "Statement in natural language:\nFor any three objects X, Y, Z in category C, and morphisms f from X to Y and g from X to Z, the object obtained by applying the functor 'span' to f and g and then applying the object function to 'WalkingSpan.left' is equal to Y.\nTranslate the statement in natural language to Lean:", "output": "theorem span_left {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.left = Y :="}
{"input": "Statement in natural language:\nThe function 'f' has a derivative 'f'' at a point 'x' with respect to a filter 'L' if and only if the function defined by 'f(x') - f(x) - (x' - x) * f'' is little o of the function defined by 'x' - x with respect to the filter 'L'. Here, 'little o' notation is used to describe limiting behavior of functions.\nTranslate the statement in natural language to Lean:", "output": "theorem hasDerivAtFilter_iff_isLittleO :\n    HasDerivAtFilter f f' x L \u2194 (fun x' : \ud835\udd5c => f x' - f x - (x' - x) \u2022 f') =o[L] fun x' => x' - x :="}
{"input": "Statement in natural language:\nFor a bilinear map 'f' from a module 'M' to a module 'N' to a module 'P', and for submodules 'p' of 'M' and 'q' of 'N', mapping 'f.flip' from 'q' to 'p' is the same as mapping 'f' from 'p' to 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_flip (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q : Submodule R N) :\n    map\u2082 f.flip q p = map\u2082 f p q :="}
{"input": "Statement in natural language:\nFor any subgroup H of a group G, if H is normal, then for any element h in H, the value of the conjugation action of h under the group of multiplicative automorphisms is equal to the conjugation of h.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.MulAut.conjNormal_val {H : Subgroup G} [H.Normal] {h : H} :\n    MulAut.conjNormal \u2191h = MulAut.conj h :="}
{"input": "Statement in natural language:\nFor a simple function 'f' mapping from '\u03b1' to '\u03b2', the value of the function 'f' at any point 'x' in '\u03b1' is included in the range of the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_range_self (f : \u03b1 \u2192\u209b \u03b2) (x : \u03b1) : f x \u2208 f.range :="}
{"input": "Statement in natural language:\nFor any function 'f' mapping from '\u03b9' to 'E', for all 'j' and 'i' such that 'i' is less than or equal to 'j', the Gram-Schmidt process applied to 'f' at 'i' is in the span of 'f' over the set of all 'j' less than or equal to a given 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem gramSchmidt_mem_span (f : \u03b9 \u2192 E) :\n    \u2200 {j i}, i \u2264 j \u2192 gramSchmidt \ud835\udd5c f i \u2208 span \ud835\udd5c (f '' Set.Iic j) :="}
{"input": "Statement in natural language:\nFor any ideals J of ring R and I of ring S, and any ring homomorphism f from R to S such that J is a subset of the preimage of I under f, for any element x of R, the image of the equivalence class of x under the quotient map induced by I and f is the equivalence class of the image of x under f.\nTranslate the statement in natural language to Lean:", "output": "theorem quotientMap_mk {J : Ideal R} {I : Ideal S} {f : R \u2192+* S} {H : J \u2264 I.comap f} {x : R} :\n    quotientMap I f H (Quotient.mk J x) = Quotient.mk I (f x) :="}
{"input": "Statement in natural language:\nFor a given type \u03b1 which forms a group, and a multiplication action that is distributive over the group G, for any element g of \u03b1 and any Sylow p-subgroup P of G, the scalar multiplication of g and P is equal to the scalar multiplication of g and the subgroup P of G.\nTranslate the statement in natural language to Lean:", "output": "theorem Sylow.pointwise_smul_def {\u03b1 : Type _} [Group \u03b1] [MulDistribMulAction \u03b1 G] {g : \u03b1}\n    {P : Sylow p G} : \u2191(g \u2022 P) = g \u2022 (P : Subgroup G) :="}
{"input": "Statement in natural language:\nFor a given index 'b' and a value 'a', the infinite sum of the function 'Pi.single b a' (which gives 'a' at index 'b' and zero elsewhere) is 'a'. This is under the condition that equality is decidable for the index set '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasSum_pi_single [DecidableEq \u03b2] (b : \u03b2) (a : \u03b1) : HasSum (Pi.single b a) a :="}
{"input": "Statement in natural language:\nFor a set 's' and a set 't' in the neighborhood of a point 'a', the intersection of 's' and 't' is also in the neighborhood of 'a' within the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_mem_nhdsWithin (s : Set \u03b1) {t : Set \u03b1} {a : \u03b1} (h : t \u2208 \ud835\udcdd a) : s \u2229 t \u2208 \ud835\udcdd[s] a :="}
{"input": "Statement in natural language:\nFor a given element 'g' of group 'G' and a given Sylow 'p' subgroup 'P' of 'G', 'g' multiplied by 'P' equals 'P' if and only if 'g' is an element of the normalizer of 'P' in the subgroup 'G'.\nTranslate the statement in natural language to Lean:", "output": "theorem Sylow.smul_eq_iff_mem_normalizer {g : G} {P : Sylow p G} :\n    g \u2022 P = P \u2194 g \u2208 (P : Subgroup G).normalizer :="}
{"input": "Statement in natural language:\nIn the context of category theory, given a category C with zero morphisms, for any objects X and Y in C and any subobject P of Y, P factors through the zero morphism from X to Y.\nTranslate the statement in natural language to Lean:", "output": "theorem factors_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y} : P.Factors (0 : X \u27f6 Y) :="}
{"input": "Statement in natural language:\nThe preimage function of 'f' is surjective if and only if 'f' is injective.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_surjective : Surjective (preimage f) \u2194 Injective f :="}
{"input": "Statement in natural language:\nFor any given set 's', element 'a', and proof 'h' that 'a' is not in 's', the set that results from adding 'a' to 's' is equal to the set that results from inserting 'a' into 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_cons {a s h} : (@cons \u03b1 a s h : Set \u03b1) = insert a (s : Set \u03b1) :="}
{"input": "Statement in natural language:\nIf a function f has a strict derivative f' at a point x, and a function g has a strict derivative g' at the same point x, then the function that is the sum of f and g has a strict derivative at point x that is the sum of f' and g'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasStrictFDerivAt.add (hf : HasStrictFDerivAt f f' x)\n    (hg : HasStrictFDerivAt g g' x) : HasStrictFDerivAt (fun y => f y + g y) (f' + g') x :="}
{"input": "Statement in natural language:\nA function 'f' from a set '\u03b1' to a pseudometric space '\u03b2' is uniformly continuous if and only if for every positive number '\u03b5', there exists a positive number '\u03b4' such that for all elements 'a' and 'b' in '\u03b1', if the distance between 'a' and 'b' is less than '\u03b4', then the distance between 'f(a)' and 'f(b)' is less than '\u03b5'.\nTranslate the statement in natural language to Lean:", "output": "theorem uniformContinuous_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b1}, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5 :="}
{"input": "Statement in natural language:\nThe valuation map of a ring, when composed with the identity map of the ring, is equal to the original valuation map.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_id : v.comap (RingHom.id R) = v :="}
{"input": "Statement in natural language:\nFor any point 'x' in a topological space '\u03b1', 'x' is a generic point of the closure of the set containing only 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem isGenericPoint_closure {x : \u03b1} : IsGenericPoint x (closure ({x} : Set \u03b1)) :="}
{"input": "Statement in natural language:\nFor any three integers a, b, and c that satisfy Fermat's Last Theorem for n=4 (represented by Fermat42 a b c), there exists a minimal solution a0, b0, and c0.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_minimal {a b c : \u2124} (h : Fermat42 a b c) : \u2203 a0 b0 c0, Minimal a0 b0 c0 :="}
{"input": "Statement in natural language:\nA filter 'l' has a basis defined by a predicate 'p' and a set 's' if and only if for every set 't' that belongs to the filter 'l', there exists an 'i' such that 'p i' is true and 's i' is a subset of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasBasis_iff : l.HasBasis p s \u2194 \u2200 t, t \u2208 l \u2194 \u2203 i, p i \u2227 s i \u2286 t :="}
{"input": "Statement in natural language:\nFor any elements 'a' from set \u03b1 and 'b' from set \u03b2, applying the constant function 'const' with respect to set \u03b1 and element 'b' to 'a' will always yield 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem const_apply (a : \u03b1) (b : \u03b2) : (const \u03b1 b) a = b :="}
{"input": "Statement in natural language:\nThe center of a monoid M, when considered as a subsemigroup, is equal to the center of the semigroup M.\nTranslate the statement in natural language to Lean:", "output": "theorem center_toSubsemigroup : (center M).toSubsemigroup = Subsemigroup.center M :="}
{"input": "Statement in natural language:\nFor a type \u03b1 that is a subsingleton (a set with at most one element), any order-preserving function from \u03b1 to \u03b1 is equal to the identity function on \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem orderHom_eq_id [Subsingleton \u03b1] (g : \u03b1 \u2192o \u03b1) : g = OrderHom.id :="}
{"input": "Statement in natural language:\nFor any type V that is a normed additive commutative group and is nontrivial, the norm of the identity function on V is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_id {V : Type _} [NormedAddCommGroup V] [Nontrivial V] : \u2016id V\u2016 = 1 :="}
{"input": "Statement in natural language:\nThe lift of 1 is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_one : lift 1 = 1 :="}
{"input": "Statement in natural language:\nFor a nonempty set 's', the image of a function that ignores its first argument and returns its second, when applied to sets 's' and 't', is equal to set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem image2_right (h : s.Nonempty) : image2 (fun _ y => y) s t = t :="}
{"input": "Statement in natural language:\nFor a natural number 'k' such that 'k' is less than or equal to the cardinality of '\u03c3', the coefficient of 'k' in the product of polynomials (each of which is the sum of a variable and the multivariate polynomial of a variable from '\u03c3') is equal to the elementary symmetric function of '\u03c3' over 'R' with the argument being the difference between the cardinality of '\u03c3' and 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem MvPolynomial.prod_X_add_C_coeff (k : \u2115) (h : k \u2264 card \u03c3) :\n    (\u220f i : \u03c3, (Polynomial.X + Polynomial.C (MvPolynomial.X i)) : Polynomial _).coeff k =\n    MvPolynomial.esymm \u03c3 R (card \u03c3 - k) :="}
{"input": "Statement in natural language:\nThe arctan function is differentiable at any real number x.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableAt_arctan (x : \u211d) : DifferentiableAt \u211d arctan x :="}
{"input": "Statement in natural language:\nFor a function 'f' that is bounded under almost everywhere measure '\u03bc', for almost every 'y' with respect to measure '\u03bc', 'f(y)' is less than or equal to the essential supremum of 'f' with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_le_essSup\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u2200\u1d50 y \u2202\u03bc, f y \u2264 essSup f \u03bc :="}
{"input": "Statement in natural language:\nThe root multiplicity of a polynomial 'X - C x' at a point 'x' in the ring 'R' is 1. This means that 'x' is a root of the polynomial 'X - C x' exactly once.\nTranslate the statement in natural language to Lean:", "output": "theorem rootMultiplicity_X_sub_C_self {x : R} : rootMultiplicity x (X - C x) = 1 :="}
{"input": "Statement in natural language:\nFor any measurable space '\u03b1', any real number 'c', and any measure '\u03bc' on '\u03b1', the measure obtained by scaling '\u03bc' by 'c' is the same as scaling the measure '\u03bc' by 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_smul {_m : MeasurableSpace \u03b1} (c : R) (\u03bc : Measure \u03b1) : \u21d1(c \u2022 \u03bc) = c \u2022 \u21d1\u03bc :="}
{"input": "Statement in natural language:\nFor any two objects X and Y in a category C, the morphism 'biprod.inl' from X to the biproduct of X and Y is an isomorphism if and only if Y is a zero object.\nTranslate the statement in natural language to Lean:", "output": "theorem Biprod.isIso_inl_iff_isZero (X Y : C) : IsIso (biprod.inl : X \u27f6 X \u229e Y) \u2194 IsZero Y :="}
{"input": "Statement in natural language:\nA function 'f' is differentiable within the intersection of sets 's' and 't' at a point 'x' if and only if the function 'f' is differentiable within the set 's' at the point 'x', given that 't' is a neighborhood of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableWithinAt_inter (ht : t \u2208 \ud835\udcdd x) :\n    DifferentiableWithinAt \ud835\udd5c f (s \u2229 t) x \u2194 DifferentiableWithinAt \ud835\udd5c f s x :="}
{"input": "Statement in natural language:\nIf 'f' is a morphism from structured arrow 'A' to structured arrow 'B' and the right component of 'f' is an epimorphism, then 'f' itself is an epimorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem epi_of_epi_right {A B : StructuredArrow S T} (f : A \u27f6 B) [h : Epi f.right] : Epi f :="}
{"input": "Statement in natural language:\nThe second projection function in the context of rings R and S is equivalent to the standard second projection function for ordered pairs.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_snd : \u21d1(snd R S) = Prod.snd :="}
{"input": "Statement in natural language:\nFor a given congruence relation 'd' on 'N' and a property 'C' that applies to the quotient of 'c' and 'd', if for every 'x' in 'M' and 'y' in 'N' the property 'C' holds, then the property 'C' also holds for 'p' and 'q', where 'p' is a quotient of 'c' and 'q' is a quotient of 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem induction_on\u2082 {d : Con N} {C : c.Quotient \u2192 d.Quotient \u2192 Prop} (p : c.Quotient)\n    (q : d.Quotient) (H : \u2200 (x : M) (y : N), C x y) : C p q :="}
{"input": "Statement in natural language:\nFor any element 'a' of a group with zero, '0' is equal to the inverse of 'a' if and only if '0' is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_eq_inv {a : G\u2080} : 0 = a\u207b\u00b9 \u2194 0 = a :="}
{"input": "Statement in natural language:\nThe monomial of the sum of a finite function 's' and a single instance of 'n' and 'e' times 'a' is equal to the monomial of 's' times 'a' multiplied by 'X' to the power of 'n' times 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem monomial_add_single : monomial (s + Finsupp.single n e) a = monomial s a * X n ^ e :="}
{"input": "Statement in natural language:\nIf function f is continuous and function g is continuous, then the composition of g and f (g composed with f) is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_comp (hfc : Continuous f) (hgc : Continuous g) : Continuous (g.comp f) :="}
{"input": "Statement in natural language:\nFor any two points p1 and p2, the affine isometry of the vector difference between p1 and p2 is equal to the vector difference between the affine isometry of p1 and the affine isometry of p2.\nTranslate the statement in natural language to Lean:", "output": "theorem map_vsub (p1 p2 : P) : f.linearIsometry (p1 -\u1d65 p2) = f p1 -\u1d65 f p2 :="}
{"input": "Statement in natural language:\nFor a finite set 's' of indices and a function 'f' that maps each index to a set, if each set 'f b' for 'b' in 's' is null measurable with respect to a measure '\u03bc', then the intersection of all such sets 'f b' is also null measurable with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Finset.nullMeasurableSet_biInter {f : \u03b9 \u2192 Set \u03b1} (s : Finset \u03b9)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c2 b \u2208 s, f b) \u03bc :="}
{"input": "Statement in natural language:\nFor a given set S of elements of type A, the subsemigroup obtained by taking the closure of S under addition is equal to the subsemigroup obtained by taking the closure of the preimage of S under the function that converts multiplicative operations to additive operations.\nTranslate the statement in natural language to Lean:", "output": "theorem AddSubsemigroup.toSubsemigroup_closure (S : Set A) :\n    AddSubsemigroup.toSubsemigroup (AddSubsemigroup.closure S) =\n      Subsemigroup.closure (Multiplicative.toAdd \u207b\u00b9' S) :="}
{"input": "Statement in natural language:\nFor a function 'g' that maps from type \u03b2 to \u03b3, a function 'f' that maps from type \u03b1 and \u03b3 to \u03b1, a value 'a' of type \u03b1, and a list 'l' of type \u03b2, folding the list 'l' with function 'f' and initial value 'a' after mapping 'g' over 'l' is the same as folding 'l' with a function that applies 'f' to 'x' and 'g' to 'y', with 'a' as the initial value.\nTranslate the statement in natural language to Lean:", "output": "theorem foldl_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b3 \u2192 \u03b1) (a : \u03b1) (l : t \u03b2) :\n    foldl f a (g <$> l) = foldl (fun x y => f x (g y)) a l :="}
{"input": "Statement in natural language:\nFor a set 's' of complex numbers, a function 'f' from complex numbers to 'E', and a complex number 'z', if 'f' is differentiable on 's' and 's' is in the neighborhood of 'z', then 'f' is analytic at 'z'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.DifferentiableOn.analyticAt {s : Set \u2102} {f : \u2102 \u2192 E} {z : \u2102}\n    (hd : DifferentiableOn \u2102 f s) (hz : s \u2208 \ud835\udcdd z) : AnalyticAt \u2102 f z :="}
{"input": "Statement in natural language:\nFor any four objects W, X, Y, Z in a category C, given that W and X have a binary coproduct and Y and Z also have a binary coproduct, for any morphisms f from W to Y and g from X to Z, the composition of the inclusion of the right component into the coproduct followed by the map induced by f and g on the coproducts is equal to the composition of g with the inclusion of the right component into the coproduct.\nTranslate the statement in natural language to Lean:", "output": "theorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : coprod.inr \u226b coprod.map f g = g \u226b coprod.inr :="}
{"input": "Statement in natural language:\nFor a subalgebra S of R and A, a function x from \u03c3 to S, and a multivariate polynomial p over \u03c3 and R, the algebraic evaluation of the function (where each value of the function is considered as an element of A) at the polynomial p is equal to the algebraic evaluation of the function at the polynomial p.\nTranslate the statement in natural language to Lean:", "output": "theorem mvPolynomial_aeval_coe (S : Subalgebra R A) (x : \u03c3 \u2192 S) (p : MvPolynomial \u03c3 R) :\n    aeval (fun i => (x i : A)) p = aeval x p :="}
{"input": "Statement in natural language:\nFor a given element 'g' from group 'G', the measure '\u03bc' is absolutely continuous with respect to the measure obtained by mapping '\u03bc' through multiplication by 'g' on the right.\nTranslate the statement in natural language to Lean:", "output": "theorem absolutelyContinuous_map_mul_right (g : G) : \u03bc \u226a map (\u00b7 * g) \u03bc :="}
{"input": "Statement in natural language:\nThe infimum (greatest lower bound) of the set containing elements 'a' and 'b' is equal to the infimum of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem csInf_pair (a b : \u03b1) : sInf {a, b} = a \u2293 b :="}
{"input": "Statement in natural language:\nFor a complete space F, given a formal multilinear series p with a positive radius, the sum of the series p has a formal power series on the ball centered at 0 with the same radius as p.\nTranslate the statement in natural language to Lean:", "output": "theorem FormalMultilinearSeries.hasFPowerSeriesOnBall [CompleteSpace F]\n    (p : FormalMultilinearSeries \ud835\udd5c E F) (h : 0 < p.radius) :\n    HasFPowerSeriesOnBall p.sum p 0 p.radius :="}
{"input": "Statement in natural language:\nThe cardinality of the support of a polynomial f is equal to one if and only if there exists a natural number k and a non-zero element x of the ring R such that f is equal to the product of the constant polynomial C x and the kth power of the polynomial X.\nTranslate the statement in natural language to Lean:", "output": "theorem card_support_eq_one : f.support.card = 1 \u2194\n    \u2203 (k : \u2115) (x : R) (hx : x \u2260 0), f = C x * X ^ k :="}
{"input": "Statement in natural language:\nThe composition of an applicative transformation '\u03b7' with the identity transformation is equal to '\u03b7' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_id (\u03b7 : ApplicativeTransformation F G) : \u03b7.comp idTransformation = \u03b7 :="}
{"input": "Statement in natural language:\nIf a permutation '\u03c3' has a prime order, and the number of elements in the set '\u03b1' is less than twice the order of '\u03c3', then '\u03c3' is a cycle.\nTranslate the statement in natural language to Lean:", "output": "theorem isCycle_of_prime_order' {\u03c3 : Perm \u03b1} (h1 : (orderOf \u03c3).Prime)\n    (h2 : Fintype.card \u03b1 < 2 * orderOf \u03c3) : \u03c3.IsCycle :="}
{"input": "Statement in natural language:\nFor any given stream, the interleave of its even and odd elements equals the original stream.\nTranslate the statement in natural language to Lean:", "output": "theorem interleave_even_odd (s\u2081 : Stream' \u03b1) : even s\u2081 \u22c8 odd s\u2081 = s\u2081 :="}
{"input": "Statement in natural language:\nFor any types \u03b1 and \u03b2, if \u03b1 and \u03b2 are primcodable (i.e., they have a primitive recursive encoding), then the function that takes a pair of \u03b1 and \u03b2 and returns the second element of the pair is also primitive recursive.\nTranslate the statement in natural language to Lean:", "output": "theorem snd {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] : Primrec (@Prod.snd \u03b1 \u03b2) :="}
{"input": "Statement in natural language:\nThe square root of zero is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sqrt_zero : sqrt 0 = 0 :="}
{"input": "Statement in natural language:\nFor any types G and \u03b1, where G is a group and \u03b1 is a set on which G acts multiplicatively, and for any measurable space \u03b1, measure \u03bc, and set s of \u03b1, if for all g in G, where g is not the identity element of G, the almost everywhere disjointness of the action of g on s and s holds, and for all g in G, the action of g is quasi measure preserving, then the pairwise almost everywhere disjointness holds for the action of any element of G on s.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_aedisjoint_of_aedisjoint_forall_ne_one {G \u03b1 : Type _} [Group G] [MulAction G \u03b1]\n    [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (h_ae_disjoint : \u2200 (g) (_ : g \u2260 (1 : G)), AEDisjoint \u03bc (g \u2022 s) s)\n    (h_qmp : \u2200 g : G, QuasiMeasurePreserving ((\u00b7 \u2022 \u00b7) g : \u03b1 \u2192 \u03b1) \u03bc \u03bc) :\n    Pairwise (AEDisjoint \u03bc on fun g : G => g \u2022 s) :="}
{"input": "Statement in natural language:\nFor a given localization map 'f' from a set 'S' to a set 'N', the first element of the section at zero, when mapped by 'f', equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem LocalizationMap.sec_zero_fst {f : LocalizationMap S N} : f.toMap (f.sec 0).fst = 0 :="}
{"input": "Statement in natural language:\nFor three sets M, N, and A, where M and N have a multiplicative identity (are MulOneClass) and A is a commutative group (CommGroup), if there are two morphisms \u03c6 from N to A and \u03c8 from M to N, then the composition of the inverse of \u03c6 and \u03c8 is equal to the inverse of the composition of \u03c6 and \u03c8.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_comp {M N A} [MulOneClass M] [MulOneClass N] [CommGroup A]\n  (\u03c6 : N \u2192* A) (\u03c8 : M \u2192* N) : \u03c6\u207b\u00b9.comp \u03c8 = (\u03c6.comp \u03c8)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor a linear map 'g' from module 'M' to module 'M'' and a function 'h' that asserts for all elements 'x' in 'S', 'x' is a unit in the ring of endomorphisms of 'M'', the composition of the lift of 'f' with respect to 'S', 'g', and 'h', with 'f' is equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_comp (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) :\n    (lift S f g h).comp f = g :="}
{"input": "Statement in natural language:\nFor any natural numbers n and m, if n is greater than 0 and m is greater than 1, then 1 is less than m raised to the power of n.\nTranslate the statement in natural language to Lean:", "output": "theorem one_lt_pow (n m : \u2115) (h\u2080 : 0 < n) (h\u2081 : 1 < m) : 1 < m ^ n :="}
{"input": "Statement in natural language:\nThe polynomial representation of zero in the cubic field of any ring R is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zero : (0 : Cubic R).toPoly = 0 :="}
{"input": "Statement in natural language:\nA measure is almost everywhere not equal to the bottom element if and only if the measure is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_neBot : \u03bc.ae.NeBot \u2194 \u03bc \u2260 0 :="}
{"input": "Statement in natural language:\nIf an element 'a' is in the supremum of a chain 'c' of partial orders, then 'a' is also in the chain 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_chain_of_mem_\u03c9Sup {c : Chain (Part \u03b1)} {a : \u03b1} (h : a \u2208 Part.\u03c9Sup c) : some a \u2208 c :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any function u from a finite set of size m to \u03b1, appending u with the function Fin.elim0' is equivalent to composing u with the function Fin.cast applied to the addition of zero.\nTranslate the statement in natural language to Lean:", "output": "theorem append_elim0' {\u03b1 : Type _} (u : Fin m \u2192 \u03b1) :\n    append u Fin.elim0' = u \u2218 Fin.cast (add_zero _) :="}
{"input": "Statement in natural language:\nThe cosine of the arctangent of a real number x is equal to 1 divided by the square root of 1 plus the square of x.\nTranslate the statement in natural language to Lean:", "output": "theorem cos_arctan (x : \u211d) : cos (arctan x) = 1 / sqrt (1 + x ^ 2) :="}
{"input": "Statement in natural language:\nFor a non-zero number b, the fraction a divided by b equals c if and only if c multiplied by b equals a.\nTranslate the statement in natural language to Lean:", "output": "theorem div_eq_iff_mul_eq (hb : b \u2260 0) : a / b = c \u2194 c * b = a :="}
{"input": "Statement in natural language:\nIf function 'f' is a left inverse of function 'g', then 'f' is a right inverse of 'g' on the range of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem LeftInverse.rightInvOn_range {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g) :\n    RightInvOn f g (range g) :="}
{"input": "Statement in natural language:\nFor any multiplication operation on \u03b3, the sum elimination of the product of 'a' and 'a'' and the product of 'b' and 'b'' is equal to the product of the sum elimination of 'a' and 'b' and the sum elimination of 'a'' and 'b''.\nTranslate the statement in natural language to Lean:", "output": "theorem elim_mul_mul [Mul \u03b3] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b' :="}
{"input": "Statement in natural language:\nFor any non-zero vector x, the unoriented angle between x and itself is 0.\nTranslate the statement in natural language to Lean:", "output": "theorem angle_self {x : V} (hx : x \u2260 0) : angle x x = 0 :="}
{"input": "Statement in natural language:\nIf set s is a proper subset of set t, then the cardinality (or size) of set s is less than the cardinality of set t.\nTranslate the statement in natural language to Lean:", "output": "theorem card_lt_card (h : s \u2282 t) : s.card < t.card :="}
{"input": "Statement in natural language:\nIf a function 'f' tends towards a value 'a' under a filter 'l', then the function that takes the minimum of 'f(i)' and 'a' also tends towards 'a' under the same filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.min_left {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun i => min (f i) a) l (\ud835\udcdd a) :="}
{"input": "Statement in natural language:\nFor a linear isometry equivalence 'e' from a normed vector space 'E' to itself over a field 'R', multiplying the identity linear isometry equivalence by 'e' results in 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem refl_mul (e : E \u2243\u2097\u1d62[R] E) : refl _ _ * e = e :="}
{"input": "Statement in natural language:\nFor any two sheaves F and G in a Grothendieck topology J on a category D, and a morphism f from F to G, f is a monomorphism if and only if the first component of f is a monomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem Sheaf.Hom.mono_iff_presheaf_mono {F G : Sheaf J D} (f : F \u27f6 G) : Mono f \u2194 Mono f.1 :="}
{"input": "Statement in natural language:\nIf a filter 'l' has a basis characterized by a predicate 'p' and a set 's' indexed by '\u03b9', and if there is a bijective mapping 'e' from '\u03b9'' to '\u03b9', then the filter 'l' also has a basis characterized by the predicate 'p' composed with 'e' and the set 's' composed with 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasBasis.comp_equiv (h : l.HasBasis p s) (e : \u03b9' \u2243 \u03b9) : l.HasBasis (p \u2218 e) (s \u2218 e) :="}
{"input": "Statement in natural language:\nFor any non-negative real number 'x' and any real number 'y', the inverse of 'x' raised to the power of 'y' is equal to the inverse of 'x' raised to the power of 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_rpow (x : \u211d\u22650) (y : \u211d) : x\u207b\u00b9 ^ y = (x ^ y)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nIf a function 'f' from \u03b2 to \u03b1 to \u03b3 is continuous on the product of the entire set and the unit interval, and for all 's', 'f' of 's' at 0 equals 'f' of 's' at 1, then the function that takes a pair of \u03b2 and \u03b1 to 'f' of the first element of the pair and the fractional part of the second element of the pair is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousOn.comp_fract' {f : \u03b2 \u2192 \u03b1 \u2192 \u03b3} (h : ContinuousOn (uncurry f) <| univ \u00d7\u02e2 I)\n    (hf : \u2200 s, f s 0 = f s 1) : Continuous fun st : \u03b2 \u00d7 \u03b1 => f st.1 (fract st.2) :="}
{"input": "Statement in natural language:\nFor a given nonempty set 's' of any type '\u03b9' and a function 'f' from '\u03b9' to a normed commutative ring '\u03b1', the nonnegative norm of the product of 'f i' for all 'i' in 's' is less than or equal to the product of the nonnegative norms of 'f i' for all 'i' in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finset.nnnorm_prod_le' {\u03b1 : Type _} [NormedCommRing \u03b1] (s : Finset \u03b9) (hs : s.Nonempty)\n    (f : \u03b9 \u2192 \u03b1) : \u2016\u220f i in s, f i\u2016\u208a \u2264 \u220f i in s, \u2016f i\u2016\u208a :="}
{"input": "Statement in natural language:\nThe pretopology of a Grothendieck topology on the category of open subsets of a topological space T is equal to the pretopology on T.\nTranslate the statement in natural language to Lean:", "output": "theorem pretopology_ofGrothendieck :\n    Pretopology.ofGrothendieck _ (Opens.grothendieckTopology T) = Opens.pretopology T :="}
{"input": "Statement in natural language:\nFor any type \u03b9 and any function f from \u03b9 to an ordinal, the complement of the range of f is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_compl_range {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : Set.range f\u1d9c.Nonempty :="}
{"input": "Statement in natural language:\nThe function f is summable.\nTranslate the statement in natural language to Lean:", "output": "theorem summable : Summable f :="}
{"input": "Statement in natural language:\nFor a type \u03b1 with decidable equality, given any two elements 'a' and 'b' of the symmetric square of \u03b1, the boolean equality of 'a' and 'b' is equivalent to the statement that 'a' equals 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem eqBool_spec [DecidableEq \u03b1] (a b : Sym2 \u03b1) : (eqBool a b) \u2194 (a = b) :="}
{"input": "Statement in natural language:\nFor a given finite type 'n', a vector 'v' of type 'n' to '\u03b1', a matrix 'A' of type 'Fin m' to 'n' to '\u03b1', and a matrix 'B' of type 'n' to 'o' to '\u03b1', the product of the matrix formed by the vector 'v' and the matrix 'A', and the matrix 'B', is equal to the matrix formed by the vector obtained by multiplying 'v' and 'B', and the product of the matrix 'A' and 'B'.\nTranslate the statement in natural language to Lean:", "output": "theorem cons_mul [Fintype n'] (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) (B : Matrix n' o' \u03b1) :\n    of (vecCons v A) \u2b1d B = of (vecCons (vecMul v B) (of.symm (of A \u2b1d B))) :="}
{"input": "Statement in natural language:\nFor a given topological space \u03b1, an open measurable space \u03b1, a topological space \u03b2, a pseudo-metrizable space \u03b2, a second countable topology for either \u03b1 or \u03b2, a function f from \u03b1 to \u03b2, a set s of \u03b1, and a measure \u03bc of \u03b1, if s is an open set and f is continuous on s, then for all x in s, f is strongly measurable at the filter of the neighborhood of x with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousOn.stronglyMeasurableAtFilter [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1]\n    [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [SecondCountableTopologyEither \u03b1 \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {\u03bc : Measure \u03b1} (hs : IsOpen s) (hf : ContinuousOn f s) :\n    \u2200 x \u2208 s, StronglyMeasurableAtFilter f (\ud835\udcdd x) \u03bc :="}
{"input": "Statement in natural language:\nFor any two elements 'a\u2081' and 'a\u2082' and a list 'l' of elements of type Sigma \u03b2, erasing 'a\u2081' from the list and then erasing 'a\u2082' is the same as erasing 'a\u2082' from the list and then erasing 'a\u2081'.\nTranslate the statement in natural language to Lean:", "output": "theorem kerase_comm (a\u2081 a\u2082) (l : List (Sigma \u03b2)) :\n    kerase a\u2082 (kerase a\u2081 l) = kerase a\u2081 (kerase a\u2082 l) :="}
{"input": "Statement in natural language:\nFor a given type \u03b9 with a linear order, and given predicates p, sets sa and sb dependent on \u03b9, if the filter la has a basis determined by p and sa, and the filter lb has a basis determined by p and sb, and if sa and sb are monotone on the set of elements i satisfying p, then the product of the filters la and lb has a basis determined by p and the product of the sets sa and sb.\nTranslate the statement in natural language to Lean:", "output": "theorem HasBasis.prod_same_index_mono {\u03b9 : Type _} [LinearOrder \u03b9] {p : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1}\n    {sb : \u03b9 \u2192 Set \u03b2} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : MonotoneOn sa { i | p i }) (hsb : MonotoneOn sb { i | p i }) :\n    (la \u00d7\u02e2 lb).HasBasis p fun i => sa i \u00d7\u02e2 sb i :="}
{"input": "Statement in natural language:\nThe coefficient of the zeroth term of a multivariate polynomial, when that polynomial is a constant, is equal to the constant itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_zero_C (a) : coeff 0 (C a : MvPolynomial \u03c3 R) = a :="}
{"input": "Statement in natural language:\nFor any element x from the set M, x is an element of the top substructure of M.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_top (x : M) : x \u2208 (\u22a4 : L.Substructure M) :="}
{"input": "Statement in natural language:\nThe zero locus of the union of a collection of sets (indexed by \u03b9) is equal to the intersection of the zero loci of each individual set in the collection.\nTranslate the statement in natural language to Lean:", "output": "theorem zeroLocus_iUnion {\u03b9 : Sort _} (s : \u03b9 \u2192 Set R) :\n    zeroLocus (\u22c3 i, s i) = \u22c2 i, zeroLocus (s i) :="}
{"input": "Statement in natural language:\nIf there is a surjective ring homomorphism 'f' from ring 'A' to ring 'B', and the kernel of 'f' is finitely generated, then 'f' has a finite presentation.\nTranslate the statement in natural language to Lean:", "output": "theorem of_surjective (f : A \u2192+* B) (hf : Surjective f) (hker : f.ker.FG) :\n    f.FinitePresentation :="}
{"input": "Statement in natural language:\nFor any three type vectors \u03b1\u2080, \u03b1\u2081, \u03b1\u2082 of length n and any three types \u03b2\u2080, \u03b2\u2081, \u03b2\u2082, given two functions f\u2080 and f\u2081 from \u03b1\u2080 to \u03b1\u2081 and \u03b1\u2081 to \u03b1\u2082 respectively, and two functions g\u2080 and g\u2081 from \u03b2\u2080 to \u03b2\u2081 and \u03b2\u2081 to \u03b2\u2082 respectively, the composition of f\u2081 and f\u2080 followed by the composition of g\u2081 and g\u2080 is equal to the composition of f\u2081 followed by g\u2081 and the composition of f\u2080 followed by g\u2080.\nTranslate the statement in natural language to Lean:", "output": "theorem appendFun_comp  {\u03b1\u2080 \u03b1\u2081 \u03b1\u2082 : TypeVec n}\n                        {\u03b2\u2080 \u03b2\u2081 \u03b2\u2082 : Type _}\n                        (f\u2080 : \u03b1\u2080 \u27f9 \u03b1\u2081) (f\u2081 : \u03b1\u2081 \u27f9 \u03b1\u2082)\n                        (g\u2080 : \u03b2\u2080 \u2192 \u03b2\u2081) (g\u2081 : \u03b2\u2081 \u2192 \u03b2\u2082) :\n    (f\u2081 \u229a f\u2080 ::: g\u2081 \u2218 g\u2080) = (f\u2081 ::: g\u2081) \u229a (f\u2080 ::: g\u2080) :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from 'M' to 'N' that is submultiplicative (meaning for any 'x' and 'y', 'f' of 'x * y' is less than or equal to 'f' of 'x' times 'f' of 'y'), and we have a nonempty finite set 's' and a function 'g' from '\u03b9' to 'M', then 'f' of the product of 'g' of 'i' for 'i' in 's' is less than or equal to the product of 'f' of 'g' of 'i' for 'i' in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_prod_nonempty_of_submultiplicative (f : M \u2192 N) (h_mul : \u2200 x y, f (x * y) \u2264 f x * f y)\n    {s : Finset \u03b9} (hs : s.Nonempty) (g : \u03b9 \u2192 M) : f (\u220f i in s, g i) \u2264 \u220f i in s, f (g i) :="}
{"input": "Statement in natural language:\nFor a given function '\u03b4' mapping from '\u03b1' to any type, a set 't' of '\u03b1', a function 't'' for each 'i' mapping to a set of '\u03b4 i', and two functions 'f' and 'g', if 'f' and 'g' are elements of the cartesian product of 't' and 't'', then the piecewise function of 's' with 'f' and 'g' is also an element of the cartesian product of 't' and 't''.\nTranslate the statement in natural language to Lean:", "output": "theorem piecewise_mem_set_pi {\u03b4 : \u03b1 \u2192 Type _} {t : Set \u03b1} {t' : \u2200 i, Set (\u03b4 i)} {f g}\n    (hf : f \u2208 Set.pi t t') (hg : g \u2208 Set.pi t t') : s.piecewise f g \u2208 Set.pi t t' :="}
{"input": "Statement in natural language:\nFor any two natural numbers m and n, if both m and n are greater than 0, then the least common multiple of m and n is also greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem lcm_pos {m n : \u2115} : 0 < m \u2192 0 < n \u2192 0 < m.lcm n :="}
{"input": "Statement in natural language:\nFor a given topological space \u03b4, and functions f : \u03b1 \u2192 \u03b2 \u2192 \u03b3, a : \u03b4 \u2192 hat\u03b1, and b : \u03b4 \u2192 hat\u03b2, if a and b are continuous, then the function that maps each element d of \u03b4 to the result of applying the function pkg.map\u2082 pkg' pkg'' f to the results of applying a and b to d, is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_map\u2082 {\u03b4} [TopologicalSpace \u03b4] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : \u03b4 \u2192 hat\u03b1} {b : \u03b4 \u2192 hat\u03b2}\n    (ha : Continuous a) (hb : Continuous b) :\n    Continuous fun d : \u03b4 => pkg.map\u2082 pkg' pkg'' f (a d) (b d) :="}
{"input": "Statement in natural language:\nThe support of the sequence of the probability mass functions q and p is equal to the union of the image of the support of p under each function in the support of q.\nTranslate the statement in natural language to Lean:", "output": "theorem support_seq : (seq q p).support = \u22c3 f \u2208 q.support, f '' p.support :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2 that can be decided for equality, a predicate P on \u03b1, an equivalence relation e between \u03b1 and \u03b2, a function f that applies to all elements of \u03b1, an element b of \u03b2, and an element x of P where P is applied to the inverse of b under e, updating f at the inverse of b with x and then applying the left congruence of e to P results in the same value as updating the result of applying the left congruence of e to P to f at b with x.\nTranslate the statement in natural language to Lean:", "output": "theorem piCongrLeft'_update [DecidableEq \u03b1] [DecidableEq \u03b2] (P : \u03b1 \u2192 Sort _) (e : \u03b1 \u2243 \u03b2)\n    (f : \u2200 a, P a) (b : \u03b2) (x : P (e.symm b)) :\n    e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x :="}
{"input": "Statement in natural language:\nFor a given set U in the neighborhood of the identity element (1) in the product group of G and K, there exist open subgroups V of G and W of K such that the Cartesian product of the sets V and W is a subset of U.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_subset {U} (hU : U \u2208 nhds (1 : G \u00d7 K)) :\n    \u2203 (V : OpenSubgroup G)(W : OpenSubgroup K), (V : Set G) \u00d7\u02e2 (W : Set K) \u2286 U :="}
{"input": "Statement in natural language:\nThe sine of the angle formed by points p\u2081, p\u2082, and p\u2083 equals one if and only if the angle formed by points p\u2081, p\u2082, and p\u2083 equals pi divided by two.\nTranslate the statement in natural language to Lean:", "output": "theorem sin_eq_one_iff_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} :\n    Real.sin (\u2220 p\u2081 p\u2082 p\u2083) = 1 \u2194 \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2 :="}
{"input": "Statement in natural language:\nThe natural number ordinal of 'a' is equal to 1 if and only if 'a' is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem toNatOrdinal_eq_one (a) : toNatOrdinal a = 1 \u2194 a = 1 :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from 'E' to 'F' over a ring 'R', the image of the graph of 'f' under the projection onto the second coordinate is equal to the range of the function associated with 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem graph_map_snd_eq_range (f : E \u2192\u2097.[R] F) :\n    f.graph.map (LinearMap.snd R E F) = LinearMap.range f.toFun :="}
{"input": "Statement in natural language:\nFor a set of simple graphs, the adjacency of two vertices a and b in the infimum of the set is equivalent to the condition that a and b are adjacent in every graph in the set and that a and b are not the same vertex.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_adj {s : Set (SimpleGraph V)} : (sInf s).Adj a b \u2194 (\u2200 G \u2208 s, Adj G a b) \u2227 a \u2260 b :="}
{"input": "Statement in natural language:\nFor any element 'a' of type \u03b1 and any function 's' from \u03b1 to a set of \u03b2, the union over 'x' in the singleton set containing only 'a', of 's x', is equal to 's a'.\nTranslate the statement in natural language to Lean:", "output": "theorem biUnion_singleton (a : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : (\u22c3 x \u2208 ({a} : Set \u03b1), s x) = s a :="}
{"input": "Statement in natural language:\nFor any point 'x' in the convex hull of a set 's', there exists a finite set '\u03b9', a function 'z' mapping from '\u03b9' to 'E', and a function 'w' mapping from '\u03b9' to '\ud835\udd5c', such that the range of 'z' is a subset of 's', 'z' is affine independent, all values of 'w' are positive, the sum of all values of 'w' is 1, and the weighted sum of 'z' with weights 'w' equals 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_pos_convex_span_of_mem_convexHull {x : E} (hx : x \u2208 convexHull \ud835\udd5c s) :\n    \u2203 (\u03b9 : Sort (u + 1)) (_ : Fintype \u03b9),\n      \u2203 (z : \u03b9 \u2192 E) (w : \u03b9 \u2192 \ud835\udd5c) (_ : Set.range z \u2286 s) (_ : AffineIndependent \ud835\udd5c z)\n        (_ : \u2200 i, 0 < w i), (\u2211 i, w i) = 1 \u2227 (\u2211 i, w i \u2022 z i) = x :="}
{"input": "Statement in natural language:\nFor any two elements x and y in the inner product space E, the inner product of (x - y) with itself is equal to the inner product of x with itself minus the inner product of x with y, minus the inner product of y with x, plus the inner product of y with itself.\nTranslate the statement in natural language to Lean:", "output": "theorem inner_sub_sub_self (x y : E) : \u27eax - y, x - y\u27eb = \u27eax, x\u27eb - \u27eax, y\u27eb - \u27eay, x\u27eb + \u27eay, y\u27eb :="}
{"input": "Statement in natural language:\nIf we have a measure '\u03bc' on a set '\u03b1' and this measure is finite, then for any non-infinite real number 'c', the measure obtained by scaling '\u03bc' by 'c' is also finite.\nTranslate the statement in natural language to Lean:", "output": "theorem Measure.smul_finite (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) :\n    IsFiniteMeasure (c \u2022 \u03bc) :="}
{"input": "Statement in natural language:\nFor any algebra from R to S, and a submonoid M of R, if S is a localization of R at M, then the function that comaps the algebra map from R to S is injective. This means that if two elements of the domain map to the same element in the codomain, then those two elements were originally the same.\nTranslate the statement in natural language to Lean:", "output": "theorem localization_comap_injective [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Function.Injective (comap (algebraMap R S)) :="}
{"input": "Statement in natural language:\nFor an isometry 'h' from a metric space '\u03b1' to another metric space '\u03b2', and for any two points 'x' and 'y' in '\u03b1', the extended distance between the images of 'x' and 'y' under 'h' is equal to the extended distance between 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem edist_eq (h : \u03b1 \u2243\u1d62 \u03b2) (x y : \u03b1) : edist (h x) (h y) = edist x y :="}
{"input": "Statement in natural language:\nThe cardinality of the infimum set of sets 's' and 't' is less than or equal to the product of the cardinalities of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_infs_le : (s \u22bc t).card \u2264 s.card * t.card :="}
{"input": "Statement in natural language:\nFor a polynomial 'f' over a ring 'R', the expansion of 'f' by the power of 'p' raised to 'q' is equal to the expansion of 'f' by 'p' raised to the power of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem expand_pow (f : R[X]) : expand R (p ^ q) f = (expand R p^[q]) f :="}
{"input": "Statement in natural language:\nIf we have a function 'f' that maps from a set '\u03b1' to a set '\u03b2', then applying this function to the identity element (1) of the free group over '\u03b1' results in the identity element of the free group over '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_one (f : \u03b1 \u2192 \u03b2) : f <$> (1 : FreeGroup \u03b1) = 1 :="}
{"input": "Statement in natural language:\nFor any natural number n, for any natural number k, the hyperoperation of n plus 3 and 1 on k equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem hyperoperation_ge_three_one (n : \u2115) : \u2200 k : \u2115, hyperoperation (n + 3) 1 k = 1 :="}
{"input": "Statement in natural language:\nFor a field K and a function s from some type I to K that is injective (i.e., it never maps different elements of I to the same element of K), the polynomials of the form X - C(s(i)) for each i in I are pairwise coprime. Here, two polynomials are said to be coprime if their greatest common divisor is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_coprime_X_sub_C {K} [Field K] {I : Type v} {s : I \u2192 K} (H : Function.Injective s) :\n    Pairwise (IsCoprime on fun i : I => X - C (s i)) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set '\u03b1', and for any order 'o', the comparison of 'a' and 'b' is equal to 'o' if and only if the relation derived from 'o' holds between 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem compare_iff (a b : \u03b1) {o : Ordering} : compare a b = o \u2194 o.toRel a b :="}
{"input": "Statement in natural language:\nPi divided by two, when considered as an angle, is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem pi_div_two_ne_zero : ((\u03c0 / 2 : \u211d) : Angle) \u2260 0 :="}
{"input": "Statement in natural language:\nFor any matrix A and any integer n, raising A to the power of an odd integer (bit1 n) is equal to the square of A raised to the power of n, multiplied by A.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_bit1' (A : M) (n : \u2124) : A ^ bit1 n = (A * A) ^ n * A :="}
{"input": "Statement in natural language:\nIf alpha is a subsingleton, then the second element function (snd) for a pair of alpha and beta is injective, meaning it maps distinct elements of its domain to distinct elements of its range.\nTranslate the statement in natural language to Lean:", "output": "theorem snd_injective [Subsingleton \u03b1] : Function.Injective (@snd \u03b1 \u03b2) :="}
{"input": "Statement in natural language:\nFor any topological categories W, X, Y, Z, S, T, and morphisms f\u2081 from W to S, f\u2082 from X to S, g\u2081 from Y to T, g\u2082 from Z to T, i\u2081 from W to Y, i\u2082 from X to Z, and i\u2083 from S to T, where i\u2083 is a monomorphism, and given that the composition of f\u2081 and i\u2083 equals the composition of i\u2081 and g\u2081, and the composition of f\u2082 and i\u2083 equals the composition of i\u2082 and g\u2082, the range of the pullback map of f\u2081, f\u2082, g\u2081, g\u2082, i\u2081, i\u2082, i\u2083, eq\u2081, and eq\u2082 equals the intersection of the preimage of the range of i\u2081 under the first projection of the pullback of g\u2081 and g\u2082, and the preimage of the range of i\u2082 under the second projection of the pullback of g\u2081 and g\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem range_pullback_map {W X Y Z S T : TopCat} (f\u2081 : W \u27f6 S) (f\u2082 : X \u27f6 S) (g\u2081 : Y \u27f6 T)\n    (g\u2082 : Z \u27f6 T) (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T) [H\u2083 : Mono i\u2083] (eq\u2081 : f\u2081 \u226b i\u2083 = i\u2081 \u226b g\u2081)\n    (eq\u2082 : f\u2082 \u226b i\u2083 = i\u2082 \u226b g\u2082) :\n    Set.range (pullback.map f\u2081 f\u2082 g\u2081 g\u2082 i\u2081 i\u2082 i\u2083 eq\u2081 eq\u2082) =\n      (pullback.fst : pullback g\u2081 g\u2082 \u27f6 _) \u207b\u00b9' Set.range i\u2081 \u2229\n        (pullback.snd : pullback g\u2081 g\u2082 \u27f6 _) \u207b\u00b9' Set.range i\u2082 :="}
{"input": "Statement in natural language:\nMapping the polynomial 'p' with the identity ring homomorphism results in the same polynomial 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id : p.map (RingHom.id _) = p :="}
{"input": "Statement in natural language:\nFor a given type \u03b9, a function \u03b1 from \u03b9 to another type, a topological space for each \u03b1 i, a set I of \u03b9 (which is finite), and a set s for each i, and a value x for each i, the neighborhood within the product of I and s at x is equal to the intersection of the infimum over i in I of the preimage under the function that maps x to x i of the neighborhood within s i at x i, and the infimum over i not in I of the preimage under the function that maps x to x i of the neighborhood at x i.\nTranslate the statement in natural language to Lean:", "output": "theorem nhdsWithin_pi_eq {\u03b9 : Type _} {\u03b1 : \u03b9 \u2192 Type _} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    (hI : I.Finite) (s : \u2200 i, Set (\u03b1 i)) (x : \u2200 i, \u03b1 i) :\n    \ud835\udcdd[pi I s] x =\n      (\u2a05 i \u2208 I, comap (fun x => x i) (\ud835\udcdd[s i] x i)) \u2293\n        \u2a05 (i) (_ : i \u2209 I), comap (fun x => x i) (\ud835\udcdd (x i)) :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements from a set 'A', 's' is a subset of the set obtained by adjoining 'R' to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_adjoin (s : Set A) : s \u2286 adjoin R s :="}
{"input": "Statement in natural language:\nThe function 'toFun' applied to 'f' is equal to the co-function of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem toFun_eq_coe : f.toFun = \u21d1f :="}
{"input": "Statement in natural language:\nFor any three vectors u, v, and w in a 3-dimensional real space, the dot product of u and the cross product of v and w is equal to the dot product of v and the cross product of w and u.\nTranslate the statement in natural language to Lean:", "output": "theorem triple_product_permutation (u v w : Fin 3 \u2192 R) : u \u2b1d\u1d65 v \u00d7\u2083 w = v \u2b1d\u1d65 w \u00d7\u2083 u :="}
{"input": "Statement in natural language:\nThe supremum of sets s and t is commutative, meaning the supremum of s and t is equal to the supremum of t and s.\nTranslate the statement in natural language to Lean:", "output": "theorem sups_comm : s \u22bb t = t \u22bb s :="}
{"input": "Statement in natural language:\nFor a function 'v' from '\u03b9' to 'E' that is injective, the function 'v' is orthonormal over the field '\ud835\udd5c' if and only if the subtype value function from the range of 'v' to 'E' is also orthonormal over the field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem orthonormal_subtype_range {v : \u03b9 \u2192 E} (hv : Function.Injective v) :\n    Orthonormal \ud835\udd5c (Subtype.val : Set.range v \u2192 E) \u2194 Orthonormal \ud835\udd5c v :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any integer 'z', 'p' raised to the power of 'n' divides 'z' if and only if the p-adic norm of 'z' is less than or equal to 'p' raised to the power of negative 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_iff_norm_le {n : \u2115} {z : \u2124} : \u2191(p ^ n) \u2223 z \u2194 padicNorm p z \u2264 (p : \u211a) ^ (-n : \u2124) :="}
{"input": "Statement in natural language:\nFor any given point 'a' and any given non-negative extended real number 'r', the closed ball centered at 'a' with radius 'r' is a closed set.\nTranslate the statement in natural language to Lean:", "output": "theorem EMetric.isClosed_ball {a : \u03b1} {r : \u211d\u22650\u221e} : IsClosed (closedBall a r) :="}
{"input": "Statement in natural language:\nFor any function M that maps an arbitrary type o to a matrix of m rows, n columns, and elements of type \u03b1, where o has a decidable equality, the block diagonal of the block diagonal of M is equal to M.\nTranslate the statement in natural language to Lean:", "output": "theorem blockDiag_blockDiagonal [DecidableEq o] (M : o \u2192 Matrix m n \u03b1) :\n    blockDiag (blockDiagonal M) = M :="}
{"input": "Statement in natural language:\nThe orthogonal complement of the entire space in an inner product space is the zero subspace.\nTranslate the statement in natural language to Lean:", "output": "theorem top_orthogonal_eq_bot : (\u22a4 : Submodule \ud835\udd5c E)\u15ee = \u22a5 :="}
{"input": "Statement in natural language:\nIf the non-negative norm of a function f is less than or equal to a non-negative real number C, then the non-negative norm of the function evaluated at m is less than or equal to C times the product of the non-negative norms of m evaluated at each index i.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_op_nnnorm_le {C : \u211d\u22650} (h : \u2016f\u2016\u208a \u2264 C) : \u2016f m\u2016\u208a \u2264 C * \u220f i, \u2016m i\u2016\u208a :="}
{"input": "Statement in natural language:\nFor any integer k, k is associated with the absolute value of k.\nTranslate the statement in natural language to Lean:", "output": "theorem Int.associated_natAbs (k : \u2124) : Associated k k.natAbs :="}
{"input": "Statement in natural language:\nIf \u03b3 is not equal to zero, then the set containing only \u03b3 is an element of the neighborhood of \u03b3 in the topological space \u0393\u2080.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_mem_nhds_of_ne_zero (h : \u03b3 \u2260 0) : ({\u03b3} : Set \u0393\u2080) \u2208 \ud835\udcdd (\u03b3 : \u0393\u2080) :="}
{"input": "Statement in natural language:\nFor any two natural numbers m and n, the size of m is less than or equal to n if and only if m is less than 2 to the power of n.\nTranslate the statement in natural language to Lean:", "output": "theorem size_le {m n : \u2115} : size m \u2264 n \u2194 m < 2 ^ n :="}
{"input": "Statement in natural language:\nThe split center of a box I is a partition.\nTranslate the statement in natural language to Lean:", "output": "theorem isPartition_splitCenter (I : Box \u03b9) : IsPartition (splitCenter I) :="}
{"input": "Statement in natural language:\nFor any three objects X, Y, and Z in category C, and morphisms f from X to Z and g from Y to Z, the composition of the homomorphism of the first isomorphism of the pullback of the diagonal object with the first and second pullbacks is equal to the composition of the second pullback with itself.\nTranslate the statement in natural language to Lean:", "output": "theorem diagonalObjPullbackFstIso_hom_fst_snd {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (diagonalObjPullbackFstIso f g).hom \u226b pullback.fst \u226b pullback.snd =\n      pullback.snd \u226b pullback.snd :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps each index 'i' from a value in the first beta set to a value in the second beta set, and for a condition 'hf' that states the function 'f' maps each index 'i' to zero, and for a function 'g' that maps each index 'i' to a value in the first beta set, and for any index 'i', applying the function 'mapRange' with parameters 'f', 'hf', 'g', and 'i' is equal to applying the function 'f' at index 'i' to the result of applying the function 'g' at index 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem mapRange_apply (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (hf : \u2200 i, f i 0 = 0) (g : \u03a0\u2080 i, \u03b2\u2081 i) (i : \u03b9) :\n    mapRange f hf g i = f i (g i) :="}
{"input": "Statement in natural language:\nFor any two objects X and Y in the opposite category C\u1d52\u1d56, if the map of f under coyoneda is an isomorphism, then f itself is an isomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem isIso {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) [IsIso (coyoneda.map f)] : IsIso f :="}
{"input": "Statement in natural language:\nFor a given cokernel cofork 'c' of the difference between two morphisms 'f' and 'g', if 'c' is a colimit, then for any cofork 's', the description of the colimit of the cokernel cofork 'c' using 's' is equal to the description of the colimit 'i' using the cokernel cofork of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isColimitCoforkOfCokernelCofork_desc {c : CokernelCofork (f - g)} (i : IsColimit c)\n    (s : Cofork f g) :\n    (isColimitCoforkOfCokernelCofork i).desc s = i.desc (cokernelCoforkOfCofork s) :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1' and any list 'l' of elements of type '\u03b1', the operation of converting the list (where 'a' is added to the front of 'l') to a sequence is equivalent to adding 'a' to the front of the sequence obtained from converting 'l' to a sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem ofList_cons (a : \u03b1) (l : List \u03b1) : ofList (a::l) = cons a (ofList l) :="}
{"input": "Statement in natural language:\nIf the argument of complex number x is equal to the argument of complex number y, then the absolute value of the difference between x and y is equal to the norm of the difference between the absolute values of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_sub_eq (h : x.arg = y.arg) : abs (x - y) = \u2016abs x - abs y\u2016 :="}
{"input": "Statement in natural language:\nFor a set 's' in a uniform space '\u03b1' and an element 'x' of '\u03b1', 's' is in the neighborhood of 'x' if and only if there exists a set 'V' in the uniform structure of '\u03b1' such that the ball centered at 'x' with 'V' as its radius is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem UniformSpace.mem_nhds_iff {x : \u03b1} {s : Set \u03b1} : s \u2208 \ud835\udcdd x \u2194 \u2203 V \u2208 \ud835\udce4 \u03b1, ball x V \u2286 s :="}
{"input": "Statement in natural language:\nFor a group with zero, if 'b' is not equal to zero, then for any element 'a' in the group, the product of 'a' and 'b' multiplied by the inverse of 'b' is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_inv_cancel_right\u2080 (h : b \u2260 0) (a : G\u2080) : a * b * b\u207b\u00b9 = a :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type 'G' and an element 'a' of type 'G' that belongs to the closure of 's', there exists a list 'l' of elements of type 'G' such that every element 'x' in 'l' either belongs to 's' or its inverse belongs to 's', and the product of all elements in 'l' equals 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_list_of_mem_closure {s : Set G} {a : G} (h : a \u2208 closure s) :\n    \u2203 l : List G, (\u2200 x \u2208 l, x \u2208 s \u2228 x\u207b\u00b9 \u2208 s) \u2227 l.prod = a :="}
{"input": "Statement in natural language:\nThe natural degree of the difference between two polynomials p and q is equal to the natural degree of the difference between the polynomials q and p.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_sub : (p - q).natDegree = (q - p).natDegree :="}
{"input": "Statement in natural language:\nFor a given non-unital semiring homomorphism 'g' from 'S' to 'T' and another non-unital semiring homomorphism 'f' from 'R' to 'S', the map of 'g' over the semiring range of 'f' is equal to the semiring range of the composition of 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_srange (g : S \u2192\u2099+* T) (f : R \u2192\u2099+* S) : map g (srange f) = srange (g.comp f) :="}
{"input": "Statement in natural language:\nFor a given type A, which is a semiring and an algebra over a ring R, and a linear map f from M to A, the application of the lift function on the tensor algebra element \u03b9 R x is equal to the application of the function f on x.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_\u03b9_apply {A : Type _} [Semiring A] [Algebra R A] (f : M \u2192\u2097[R] A) (x) :\n    lift R f (\u03b9 R x) = f x :="}
{"input": "Statement in natural language:\nFor a given type \u03b2', a multiset m of type \u03b1, and two functions f and f' from \u03b1 to \u03b2 and \u03b1 to \u03b2' respectively, if \u03b2 is equal to \u03b2' and for all elements a in the multiset m, f of a is identical to f' of a, then the multiset resulting from mapping f over m is identical to the multiset resulting from mapping f' over m.\nTranslate the statement in natural language to Lean:", "output": "theorem map_hcongr {\u03b2' : Type _} {m : Multiset \u03b1} {f : \u03b1 \u2192 \u03b2} {f' : \u03b1 \u2192 \u03b2'} (h : \u03b2 = \u03b2')\n    (hf : \u2200 a \u2208 m, HEq (f a) (f' a)) : HEq (map f m) (map f' m) :="}
{"input": "Statement in natural language:\nFor a bilinear form A on a module M over a ring R, and for any element x of M, the application of the linear homomorphism flip function to A and x is equal to the function that takes any element y and maps it to the bilinear form A applied to y and x.\nTranslate the statement in natural language to Lean:", "output": "theorem toLin'Flip_apply (A : BilinForm R M) (x : M) : \u21d1(toLinHomFlip R\u2082 A x) = fun y => A y x :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the product of a constant 'a' and 'X' raised to the power of 'n' is equal to a monomial with degree 'n' and coefficient 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem C_mul_X_pow_eq_monomial : \u2200 {n : \u2115}, C a * X ^ n = monomial n a"}
{"input": "Statement in natural language:\nFor a given element 'a' in a set '\u03b1', if the set of elements greater than 'a' is nonempty, then the frontier (the set of all boundary points) of the set of elements less than or equal to 'a' is the singleton set containing only 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem frontier_Iic' {a : \u03b1} (ha : (Ioi a).Nonempty) : frontier (Iic a) = {a} :="}
{"input": "Statement in natural language:\nThe empty set is Von Neumann bounded in the field \ud835\udd5c for the set E.\nTranslate the statement in natural language to Lean:", "output": "theorem isVonNBounded_empty : IsVonNBounded \ud835\udd5c (\u2205 : Set E) :="}
{"input": "Statement in natural language:\nFor any element 'x' of the supremum extension of the maximum singleton 'i' and function 'f' with respect to 'y', the value of 'x' is equal to the sum of the first element of the extension of the maximum adjoin 'i' with respect to 'x' and the product of the second element of the extension of the maximum adjoin 'i' with respect to 'x' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem ExtensionOfMaxAdjoin.eqn {y : N} (x : supExtensionOfMaxSingleton i f y) :\n    \u2191x = \u2191(ExtensionOfMaxAdjoin.fst i x) + ExtensionOfMaxAdjoin.snd i x \u2022 y :="}
{"input": "Statement in natural language:\nFor a given weight function 'w' from '\u03c3' to 'M' and a given 'i' in '\u03c3', the multivariate polynomial 'X i' is weighted homogeneous with respect to the weight 'w i'.\nTranslate the statement in natural language to Lean:", "output": "theorem isWeightedHomogeneous_X (w : \u03c3 \u2192 M) (i : \u03c3) :\n    IsWeightedHomogeneous w (X i : MvPolynomial \u03c3 R) (w i) :="}
{"input": "Statement in natural language:\nIn a second countable topology on a set \u03b1, the set of all pairs of elements from \u03b1 where the first element is less than the second element is a measurable set.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_lt' [SecondCountableTopology \u03b1] : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } :="}
{"input": "Statement in natural language:\nThe sine function has a strict derivative at any complex number x, and this derivative is the cosine of x.\nTranslate the statement in natural language to Lean:", "output": "theorem hasStrictDerivAt_sin (x : \u2102) : HasStrictDerivAt sin (cos x) x :="}
{"input": "Statement in natural language:\nThe projection of 0 in the polynomial ring K[X] is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem Q_zero : (Q 0 : K[X] \u27f6 _) = 0 :="}
{"input": "Statement in natural language:\nThe floor of the difference between a real number 'a' and a natural number 'n' is equal to the difference between the floor of 'a' and 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem floor_sub_nat (a : \u03b1) (n : \u2115) : \u230aa - n\u230b = \u230aa\u230b - n :="}
{"input": "Statement in natural language:\nThe cardinality (or size) of the multiset obtained by applying a function 'f' to each element of a multiset 's' is equal to the cardinality of the original multiset 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_map (f : \u03b1 \u2192 \u03b2) (s) : card (map f s) = card s :="}
{"input": "Statement in natural language:\nFor a convex set 's' in a topological vector space 'E', if 'x' is in the interior of 's' and 'y' is in the closure of 's', then the open segment from 'x' to 'y' is a subset of the interior of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Convex.openSegment_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) : openSegment \ud835\udd5c x y \u2286 interior s :="}
{"input": "Statement in natural language:\nFor any three matrices A, B, and D, where A is a square matrix of size m by m, B is a matrix of size m by n, and D is a square matrix of size n by n, the determinant of the block matrix formed by A, B, 0, and D is equal to the product of the determinants of A and D.\nTranslate the statement in natural language to Lean:", "output": "theorem det_fromBlocks_zero\u2082\u2081 (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) :\n    (Matrix.fromBlocks A B 0 D).det = A.det * D.det :="}
{"input": "Statement in natural language:\nFor any nonempty set \u03b1, the range of the second element of the product of \u03b1 and \u03b2 (represented as \u03b1 \u00d7 \u03b2 \u2192 \u03b2) is equal to the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Prod.range_snd [Nonempty \u03b1] : range (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2) = univ :="}
{"input": "Statement in natural language:\nIf we have a localization N of a ring T, and for all elements x in a subring S, x is a unit if and only if x is in N, then the localization of N under the mapping from R to S is a localization of T.\nTranslate the statement in natural language to Lean:", "output": "theorem localization_localization_isLocalization_of_has_all_units [IsLocalization N T]\n    (H : \u2200 x : S, IsUnit x \u2192 x \u2208 N) : IsLocalization (N.comap (algebraMap R S)) T :="}
{"input": "Statement in natural language:\nIn the context of a commutative ring \u03b1, which is also a uniform space, a uniform additive group, and a topological ring, the separation setoid of \u03b1 is equal to the quotient relation of the closure of the bottom ideal.\nTranslate the statement in natural language to Lean:", "output": "theorem ring_sep_rel (\u03b1) [CommRing \u03b1] [UniformSpace \u03b1] [UniformAddGroup \u03b1] [TopologicalRing \u03b1] :\n    separationSetoid \u03b1 = Submodule.quotientRel (Ideal.closure \u22a5) :="}
{"input": "Statement in natural language:\nFor any two subsets c\u2081 and c\u2082 of a topological space X, if the open set of c\u2081 is a subset of the closed set of c\u2082, and for any two natural numbers n\u2081 and n\u2082, and any point x in X, the approximation of c\u2082 at n\u2082 and x is less than or equal to the approximation of c\u2081 at n\u2081 and x.\nTranslate the statement in natural language to Lean:", "output": "theorem approx_le_approx_of_U_sub_C {c\u2081 c\u2082 : CU X} (h : c\u2081.U \u2286 c\u2082.C) (n\u2081 n\u2082 : \u2115) (x : X) :\n    c\u2082.approx n\u2082 x \u2264 c\u2081.approx n\u2081 x :="}
{"input": "Statement in natural language:\nIf a set s\u2081 is a subset of another set s\u2082, and for all elements x in s\u2082, if x is not in s\u2081 then the function f of x equals 1, then the product of the function f of each element in s\u2081 is equal to the product of the function f of each element in s\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_subset (h : s\u2081 \u2286 s\u2082) (hf : \u2200 x \u2208 s\u2082, x \u2209 s\u2081 \u2192 f x = 1) :\n    (\u220f x in s\u2081, f x) = \u220f x in s\u2082, f x :="}
{"input": "Statement in natural language:\nFor any number 'n' in the numerical system, when 'n' is converted to a negative ZNum (an integer type in Lean), it is equivalent to the negative of 'n' in an additive group '\u03b1' that also has a unit element 'One'.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_toZNumNeg [AddGroup \u03b1] [One \u03b1] : \u2200 n : Num, (n.toZNumNeg : \u03b1) = -n"}
{"input": "Statement in natural language:\nA number system \u03b1 is Archimedean if and only if for every number x in \u03b1, there exists a rational number q such that x is less than q.\nTranslate the statement in natural language to Lean:", "output": "theorem archimedean_iff_rat_lt : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 q : \u211a, x < q :="}
{"input": "Statement in natural language:\nIf a function c has a strict derivative c' at a point x, then the function that maps y to the product of c(y) and a constant f has a strict derivative at x, which is the derivative of c at x multiplied by the constant f.\nTranslate the statement in natural language to Lean:", "output": "theorem HasStrictFDerivAt.smul_const (hc : HasStrictFDerivAt c c' x) (f : F) :\n    HasStrictFDerivAt (fun y => c y \u2022 f) (c'.smulRight f) x :="}
{"input": "Statement in natural language:\nIf 'b' is an element of 't', then the image of 's' under the function that takes 'a' to the infimum of 'a' and 'b' is a subset of the symmetric difference of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_subset_infs_left : b \u2208 t \u2192 (s.image fun a => a \u2293 b) \u2286 s \u22bc t :="}
{"input": "Statement in natural language:\nA function f has a derivative f' within a set s at a point x if and only if the function that maps x' to the norm of x' minus x, inverse times the norm of f of x' minus f of x minus the scalar product of x' minus x and f', tends to 0 as x' approaches x within the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem hasDerivWithinAt_iff_tendsto :\n    HasDerivWithinAt f f' s x \u2194\n      Tendsto (fun x' => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - (x' - x) \u2022 f'\u2016) (\ud835\udcdd[s] x) (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nFor three orthonormal bases v, v', and v'' of vector spaces E, E', and E'' over a field \ud835\udd5c, indexed by types \u03b9, \u03b9', and \u03b9'' respectively, if there are equivalences e between \u03b9 and \u03b9', and e' between \u03b9' and \u03b9'', then the composition of the equivalence from v to v' and the equivalence from v' to v'' is the same as the equivalence from v to v'' under the composition of e and e'.\nTranslate the statement in natural language to Lean:", "output": "theorem Orthonormal.equiv_trans {v : Basis \u03b9 \ud835\udd5c E} (hv : Orthonormal \ud835\udd5c v) {v' : Basis \u03b9' \ud835\udd5c E'}\n    (hv' : Orthonormal \ud835\udd5c v') (e : \u03b9 \u2243 \u03b9') {v'' : Basis \u03b9'' \ud835\udd5c E''} (hv'' : Orthonormal \ud835\udd5c v'')\n    (e' : \u03b9' \u2243 \u03b9'') : (hv.equiv hv' e).trans (hv'.equiv hv'' e') = hv.equiv hv'' (e.trans e') :="}
{"input": "Statement in natural language:\nThe closed interval from 'a' to 'b' in the extended non-negative real numbers (with top element) is equal to the image of the closed interval from 'a' to 'b' under the embedding function 'some'.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_coe_coe : Icc (a : WithTop \u03b1) b = (Icc a b).map Embedding.some :="}
{"input": "Statement in natural language:\nIf a function 'a' is differentiable at a point 'x' within a set 's' in a field '\ud835\udd5c', then for any natural number 'n', the function that maps 'x' to the 'n'th power of 'a(x)' is also differentiable at 'x' within the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableWithinAt.pow (ha : DifferentiableWithinAt \ud835\udd5c a s x) :\n    \u2200 n : \u2115, DifferentiableWithinAt \ud835\udd5c (fun x => a x ^ n) s x"}
{"input": "Statement in natural language:\nFor any relation R between \u03b1 and \u03b2, and any condition C, swapping the arguments of the LiftRelO function applied to R and C is equivalent to applying LiftRelO to the swapped versions of R and C.\nTranslate the statement in natural language to Lean:", "output": "theorem LiftRelO.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C) :\n    swap (LiftRelO R C) = LiftRelO (swap R) (swap C) :="}
{"input": "Statement in natural language:\nFor any non-negative real number p, if s and t are measurable sets and the measure of t is not infinite, then the integral over the set s of the indicator function (which is constant and equal to x on the set t) with respect to the measure \u03bc is equal to the real part of the measure of the intersection of t and s, scaled by x.\nTranslate the statement in natural language to Lean:", "output": "theorem set_integral_indicatorConstLp {p : \u211d\u22650\u221e} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h\u03bct : \u03bc t \u2260 \u221e) (x : E) :\n    (\u222b a in s, indicatorConstLp p ht h\u03bct x a \u2202\u03bc) = (\u03bc (t \u2229 s)).toReal \u2022 x :="}
{"input": "Statement in natural language:\nIf we have a continuous addition operation on a normed vector space M\u2082, and if f and g are compact operators from M\u2081 to M\u2082, then the sum of f and g is also a compact operator.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompactOperator.add [ContinuousAdd M\u2082] {f g : M\u2081 \u2192 M\u2082} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f + g) :="}
{"input": "Statement in natural language:\nA natural transformation (\u03b7) between two functors (F and G) from category C to category D is a monomorphism if and only if for all objects (c) in category C, the application of the natural transformation (\u03b7) to the object (c) is also a monomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem NatTrans.mono_iff_mono_app {F G : C \u2964 D} (\u03b7 : F \u27f6 G) : Mono \u03b7 \u2194 \u2200 c, Mono (\u03b7.app c) :="}
{"input": "Statement in natural language:\nAny element 'a' of group 'G' raised to the power of zero (in the set of integers) is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_zero (a : G) : a ^ (0 : \u2124) = 1 :="}
{"input": "Statement in natural language:\nIf 'f' is a simple function in Lp space, then the function 'f' converted to a simple function is strongly measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem stronglyMeasurable (f : Lp.simpleFunc E p \u03bc) :\n    StronglyMeasurable (toSimpleFunc f) :="}
{"input": "Statement in natural language:\nFor a basis 'v' of a vector space 'E' over a field '\ud835\udd5c' indexed by '\u03b9', if 'v' is orthonormal, then the equivalence of 'v' with itself under the identity equivalence on '\u03b9' is equal to the identity linear isometry equivalence on the vector space 'E' over the field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem Orthonormal.equiv_refl {v : Basis \u03b9 \ud835\udd5c E} (hv : Orthonormal \ud835\udd5c v) :\n    hv.equiv hv (Equiv.refl \u03b9) = LinearIsometryEquiv.refl \ud835\udd5c E :="}
{"input": "Statement in natural language:\nIf a function f has a derivative within a set s at a point x, and either the constant c is not zero or the function f at point x is not zero, then the function that maps x to c raised to the power of f(x) has a derivative within the set s at point x. The derivative is equal to the product of c raised to the power of f(x), the complex logarithm of c, and the derivative of f.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :="}
{"input": "Statement in natural language:\nIn the context of a semiring R, the product of \u03b5 (epsilon) and \u03b5 (epsilon) in the dual number system over R equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eps_mul_eps [Semiring R] : (\u03b5 * \u03b5 : R[\u03b5]) = 0 :="}
{"input": "Statement in natural language:\nFor any element 'a' in a finite set of size 'n', the successor of the successor of 1 (essentially, 3) is less than the successor of the successor of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem one_lt_succ_succ (a : Fin n) : (1 : Fin (n + 2)) < a.succ.succ :="}
{"input": "Statement in natural language:\nIf 'a' is not a minimum, then the predecessor of 'a' is not a limit predecessor.\nTranslate the statement in natural language to Lean:", "output": "theorem not_isPredLimit_pred_of_not_isMin (ha : \u00acIsMin a) : \u00acIsPredLimit (pred a) :="}
{"input": "Statement in natural language:\nFor any complete lattice \u03b2, any filter \u03b1, any function from \u03b1 to \u03b2, and any element x of \u03b2, if there frequently exists an element a in the filter such that the function of a is less than or equal to x, then the limit inferior of the function with respect to the filter is less than or equal to x.\nTranslate the statement in natural language to Lean:", "output": "theorem liminf_le_of_frequently_le' {\u03b1 \u03b2} [CompleteLattice \u03b2] {f : Filter \u03b1} {u : \u03b1 \u2192 \u03b2} {x : \u03b2}\n    (h : \u2203\u1da0 a in f, u a \u2264 x) : liminf u f \u2264 x :="}
{"input": "Statement in natural language:\nIn any ring R, the product of the Riemann zeta function and the M\u00f6bius function, when considered as arithmetic functions on R, is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_zeta_mul_coe_moebius [Ring R] : (\u03b6 * \u03bc : ArithmeticFunction R) = 1 :="}
{"input": "Statement in natural language:\nFor a given equivalence 'e' between two types '\u03b1' and '\u03b2', and for any element 'x' of type '\u03b1', applying 'e' to 'x' and then applying the inverse of 'e' to the result will return 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_apply_apply (e : \u03b1 \u2243 \u03b2) (x : \u03b1) : e.symm (e x) = x :="}
{"input": "Statement in natural language:\nFor a function 'f' from 'E' to 'F' and a function 'g' from 'E' to 'F', both continuously differentiable on a set 's' in 'E' up to order 'N', and for a point 'x' in 's' and a natural number 'n' less than or equal to 'N', the norm of the 'n'-th iterated Fr\u00e9chet derivative of the function that maps 'y' to 'f(y)' applied to 'g(y)' at 'x' within 's' is less than or equal to the sum, over 'i' in the range from 0 to 'n', of the binomial coefficient 'n choose i' times the norm of the 'i'-th iterated Fr\u00e9chet derivative of 'f' at 'x' within 's' times the norm of the '(n - i)'-th iterated Fr\u00e9chet derivative of 'g' at 'x' within 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_iteratedFDerivWithin_clm_apply {f : E \u2192 F \u2192L[\ud835\udd5c] G} {g : E \u2192 F} {s : Set E} {x : E}\n    {N : \u2115\u221e} {n : \u2115} (hf : ContDiffOn \ud835\udd5c N f s) (hg : ContDiffOn \ud835\udd5c N g s) (hs : UniqueDiffOn \ud835\udd5c s)\n    (hx : x \u2208 s) (hn : \u2191n \u2264 N) : \u2016iteratedFDerivWithin \ud835\udd5c n (fun y => (f y) (g y)) s x\u2016 \u2264\n      \u2211 i in Finset.range (n + 1), \u2191(n.choose i) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 *\n        \u2016iteratedFDerivWithin \ud835\udd5c (n - i) g s x\u2016 :="}
{"input": "Statement in natural language:\nApplying the function 'toIsometryEquiv' to 'e' and then dereferencing the result is equal to 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toIsometryEquiv : \u21d1e.toIsometryEquiv = e :="}
{"input": "Statement in natural language:\nThe function 'succAbove' for a given natural number 'n' is injective. This means that if two different inputs are given to the function 'succAbove', it will always produce two different outputs.\nTranslate the statement in natural language to Lean:", "output": "theorem succAbove_left_injective : Injective (@succAbove n) :="}
{"input": "Statement in natural language:\nFor a given natural number 'n', the function 'f' commutes with its 'n'-th iteration.\nTranslate the statement in natural language to Lean:", "output": "theorem self_iterate (n : \u2115) : Commute f (f^[n]) :="}
{"input": "Statement in natural language:\nIf x is an element of set s and y is an element of set t, then the line segment from x to y is a subset of the convex join of sets s and t in a field \ud835\udd5c.\nTranslate the statement in natural language to Lean:", "output": "theorem segment_subset_convexJoin (hx : x \u2208 s) (hy : y \u2208 t) : segment \ud835\udd5c x y \u2286 convexJoin \ud835\udd5c s t :="}
{"input": "Statement in natural language:\nFor any real number 'a' that is not infinity, raising 'a' to the power of any natural number 'n' will not result in infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_ne_top (h : a \u2260 \u221e) {n : \u2115} : a ^ n \u2260 \u221e :="}
{"input": "Statement in natural language:\nIn the context of a top element in a tropical semiring R, the tropicalization of the top element is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem trop_top [Top R] : trop (\u22a4 : R) = 0 :="}
{"input": "Statement in natural language:\nThe multiplication of a certain element 'a' is less than the multiplication of another element 'b' if and only if 'a' is less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofMul_lt {a b : \u03b1} : ofMul a < ofMul b \u2194 a < b :="}
{"input": "Statement in natural language:\nFor any integer 'n', the counit of 'n' in ring 'R' when applied to the constant polynomial 'C n' is equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem counit_C (n : \u2124) : counit R (C n) = n :="}
{"input": "Statement in natural language:\nFor a linear map D from A to M over a ring R, and a given condition h, the linear map created by the function 'mk' applied to D and h is equal to D.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mk'_linearMap (D : A \u2192\u2097[R] M) (h) : (mk' D h : A \u2192\u2097[R] M) = D :="}
{"input": "Statement in natural language:\nIf there is a homotopy equivalence between two topological spaces X and Y, then the function representing this equivalence is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous (h : HomotopyEquiv X Y) : Continuous h :="}
{"input": "Statement in natural language:\nIn a measurable singleton class within a null measurable space, if a set 's' is null measurable, then the set resulting from inserting an element 'a' into 's' is also null measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem insert [MeasurableSingletonClass (NullMeasurableSpace \u03b1 \u03bc)]\n    (hs : NullMeasurableSet s \u03bc) (a : \u03b1) : NullMeasurableSet (insert a s) \u03bc :="}
{"input": "Statement in natural language:\nFor any two lists l\u2081 and l\u2082 of any type \u03b1, l\u2081 being less than or equal to l\u2082 is equivalent to it not being true that l\u2082 is less than l\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem le_eq_not_gt [LT \u03b1] : \u2200 l\u2081 l\u2082 : List \u03b1, (l\u2081 \u2264 l\u2082) = \u00acl\u2082 < l\u2081 :="}
{"input": "Statement in natural language:\nIf two group homomorphisms f and g from a group G to a group M are equal on a set s in G, then they are also equal on the closure of the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem eqOn_closure {f g : G \u2192* M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :="}
{"input": "Statement in natural language:\nFor a given index 'i' and an element 'x' from the set 'S' at index 'i', if 'S' at index 'i' is a subset of 'T', then the indexed union lift of 'S' using function 'f' and the inclusion of 'x' in 'h' is equal to the application of function 'f' at index 'i' on 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem iUnionLift_inclusion {i : \u03b9} (x : S i) (h : S i \u2286 T) :\n    iUnionLift S f hf T hT (Set.inclusion h x) = f i x :="}
{"input": "Statement in natural language:\nFor any nontrivial type \u03b1, there exist a pair of elements x and y in \u03b1 such that x is not equal to y.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_pair_ne (\u03b1 : Type _) [Nontrivial \u03b1] : \u2203 x y : \u03b1, x \u2260 y :="}
{"input": "Statement in natural language:\nThe norm of the zeroth iterated Fr\u00e9chet derivative of a function at a point x is equal to the norm of the function at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_iteratedFDeriv_zero : \u2016iteratedFDeriv \ud835\udd5c 0 f x\u2016 = \u2016f x\u2016 :="}
{"input": "Statement in natural language:\nThe range of the adjoint representation of a Lie algebra L over a ring R is nilpotent if and only if the Lie algebra L itself is nilpotent.\nTranslate the statement in natural language to Lean:", "output": "theorem LieAlgebra.isNilpotent_range_ad_iff : IsNilpotent R (ad R L).range \u2194 IsNilpotent R L :="}
{"input": "Statement in natural language:\nFor a given natural number 'p' which is a prime number, the cardinality or the number of elements in the group of units of integers modulo 'p' is equal to 'p' minus 1.\nTranslate the statement in natural language to Lean:", "output": "theorem card_units (p : \u2115) [Fact p.Prime] : Fintype.card (ZMod p)\u02e3 = p - 1 :="}
{"input": "Statement in natural language:\nThe absolute value of a complex number z is equal to the square root of the norm squared of z.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_apply {z : \u2102} : Complex.abs z = (normSq z).sqrt :="}
{"input": "Statement in natural language:\nThe imaginary part of the product of the imaginary unit (I) and a complex number (z) is equal to the imaginary part of the complex number (z).\nTranslate the statement in natural language to Lean:", "output": "theorem I_im' (z : K) : im (I : K) * im z = im z :="}
{"input": "Statement in natural language:\nThe inverse function of zero in the context of matrix algebra over a ring R with matrix A of size n is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem invFun_zero : invFun R A n 0 = 0 :="}
{"input": "Statement in natural language:\nIf 'a' is the least element of set 's' and 'b' is the greatest element of set 't', then the least element of the image of the function 'f' applied to sets 's' and 't' is 'f(a, b)'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLeast.isLeast_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsLeast (Set.image2 f s t) (f a b) :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements from a ring 'R', 's' is a subset of the vanishing ideal of the zero locus of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_vanishingIdeal_zeroLocus (s : Set R) : s \u2286 vanishingIdeal (zeroLocus s) :="}
{"input": "Statement in natural language:\nIn the field of ring theory, for a Dedekind domain R with a finite class group, the cardinality of the class group of R is equal to 1 if and only if R is a principal ideal ring.\nTranslate the statement in natural language to Lean:", "output": "theorem card_classGroup_eq_one_iff [IsDedekindDomain R] [Fintype (ClassGroup R)] :\n    Fintype.card (ClassGroup R) = 1 \u2194 IsPrincipalIdealRing R :="}
{"input": "Statement in natural language:\nFor any two types U and V, with both being quivers, and any prefunctor F from U to V, the composition of the identity function with F is equal to F itself.\nTranslate the statement in natural language to Lean:", "output": "theorem id_comp {U V : Type _} [Quiver U] [Quiver V] (F : Prefunctor U V) :\n    (id _).comp F = F :="}
{"input": "Statement in natural language:\nIf function f\u2081 is the left inverse of function f\u2082, and function g\u2081 is the left inverse of function g\u2082, then the function that maps f\u2081 and g\u2081 is the left inverse of the function that maps f\u2082 and g\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem LeftInverse.Prod_map (hf : LeftInverse f\u2081 f\u2082) (hg : LeftInverse g\u2081 g\u2082) :\n    LeftInverse (map f\u2081 g\u2081) (map f\u2082 g\u2082) :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', and any two finite partitions 'P' and 'Q' of 'a', if 'P' is less than or equal to 'Q', then the cardinality (or size) of the parts of 'Q' is less than or equal to the cardinality of the parts of 'P'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_mono {a : \u03b1} {P Q : Finpartition a} (h : P \u2264 Q) : Q.parts.card \u2264 P.parts.card :="}
{"input": "Statement in natural language:\nIf we have a Noetherian ring R and a finite module M over R, and if F is a stable filtration of M, then for any other filtration F' of M that is less than or equal to F, F' is also stable.\nTranslate the statement in natural language to Lean:", "output": "theorem Stable.of_le [IsNoetherianRing R] [h : Module.Finite R M] (hF : F.Stable)\n    {F' : I.Filtration M} (hf : F' \u2264 F) : F'.Stable :="}
{"input": "Statement in natural language:\nFor any field K and commutative ring K\u2098, and a submonoid M of K such that 0 is not in M, if K\u2098 is a localization of K at M, then the algebra map from K to K\u2098 is bijective.\nTranslate the statement in natural language to Lean:", "output": "theorem Field.localization_map_bijective {K K\u2098 : Type _} [Field K] [CommRing K\u2098] {M : Submonoid K}\n    (hM : (0 : K) \u2209 M) [Algebra K K\u2098] [IsLocalization M K\u2098] :\n    Function.Bijective (algebraMap K K\u2098) :="}
{"input": "Statement in natural language:\nFor any type \u03b3, any filter F on \u03b3, any function \u03bcs from \u03b3 to the finite measures on \u03a9, and any finite measure \u03bc on \u03a9, if \u03bcs tends to \u03bc with respect to the filter F, then the mass of \u03bcs tends to the mass of \u03bc with respect to the same filter F.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Filter.Tendsto.mass {\u03b3 : Type _} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    {\u03bc : FiniteMeasure \u03a9} (h : Tendsto \u03bcs F (\ud835\udcdd \u03bc)) : Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd \u03bc.mass) :="}
{"input": "Statement in natural language:\nFor any equivalence 'e' between '\u03b2\u2081' and '\u03b2\u2082', the product congruence of the reflexive equivalence of '\u03b1\u2081' and 'e' is equal to the product congruence on the right for any function that maps to 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem prodCongr_refl_left (e : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    prodCongr (Equiv.refl \u03b1\u2081) e = prodCongrRight fun _ => e :="}
{"input": "Statement in natural language:\nIf 'a' is less than or equal to 'b', then the implication from 'b' to 'c' is less than or equal to the implication from 'a' to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem himp_le_himp_right (h : a \u2264 b) : b \u21e8 c \u2264 a \u21e8 c :="}
{"input": "Statement in natural language:\nIf 'f' is a split monomorphism (a morphism that has a right inverse) from 'X' to 'Y' in category 'C', and the retraction of 'f' is a monomorphism (a morphism that is left-cancellable), then 'f' is an isomorphism (a morphism that has both a left and a right inverse).\nTranslate the statement in natural language to Lean:", "output": "theorem IsIso.of_mono_retraction' {X Y : C} {f : X \u27f6 Y} (hf : SplitMono f) [Mono <| hf.retraction] :\n    IsIso f :="}
{"input": "Statement in natural language:\nIf two local equivalences 'e' and 'e'' are equal on their source, then their sources are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem EqOnSource.source_eq {e e' : LocalEquiv \u03b1 \u03b2} (h : e \u2248 e') : e.source = e'.source :="}
{"input": "Statement in natural language:\nFor a list 'l' of elements of any type '\u03b1' and a natural number 'i', if 'i' is less than the length of the enumerated list 'l' and 'i' is less than the length of the list 'l' (which is proven by simplifying the length of the enumerated list), then the 'i'-th element of the enumerated list 'l' is equal to the pair consisting of 'i' and the 'i'-th element of the list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem nthLe_enum (l : List \u03b1) (i : \u2115) (hi' : i < l.enum.length)\n    (hi : i < l.length := (by simpa [length_enum] using hi')) :\n    l.enum.nthLe i hi' = (i, l.nthLe i hi) :="}
{"input": "Statement in natural language:\nIf \ud835\udc9c is a lower set of finite sets of elements of type \u03b1, then the subfamily of \ud835\udc9c that contains a specific element a is also a lower set of finite sets of elements of type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLowerSet.memberSubfamily (h : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1))) :\n    IsLowerSet (\ud835\udc9c.memberSubfamily a : Set (Finset \u03b1)) :="}
{"input": "Statement in natural language:\nThe image of the function that maps each pair of elements from sets \u03b1 and \u03b2 to the product of the first element and the second element, over the Cartesian product of sets s and t, is equal to the scalar multiplication of sets s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem image_smul_prod : (fun x : \u03b1 \u00d7 \u03b2 \u21a6 x.fst \u2022 x.snd) '' s \u00d7\u02e2 t = s \u2022 t :="}
{"input": "Statement in natural language:\nIf \u03c6 is a function from \u03b1 to the space of continuous linear maps from H to E and \u03c6 is integrable with respect to measure \u03bc, then for any vector v in H, the function that maps a to \u03c6(a, v) is also integrable with respect to measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasureTheory.Integrable.apply_continuousLinearMap {\u03c6 : \u03b1 \u2192 H \u2192L[\ud835\udd5c] E}\n    (\u03c6_int : Integrable \u03c6 \u03bc) (v : H) : Integrable (fun a => \u03c6 a v) \u03bc :="}
{"input": "Statement in natural language:\nThe norm of the application of p to n is equal to the norm of the coefficient of p at n.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_apply_eq_norm_coef : \u2016p n\u2016 = \u2016coeff p n\u2016 :="}
{"input": "Statement in natural language:\nThe property of positive multiplication being monotonically decreasing in a certain type \u03b1 is equivalent to the property of positive multiplication reflecting less than in the same type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem mulPosMonoRev_iff_mulPosReflectLT : MulPosMonoRev \u03b1 \u2194 MulPosReflectLT \u03b1 :="}
{"input": "Statement in natural language:\nIf \u03b5 is greater than 0, for every natural number n, the function f(n) is strongly measurable, the function g is strongly measurable, the set s is measurable, the measure of set s is not infinite, and for almost every x with respect to measure \u03bc, if x is in set s, then the sequence of f(n) x tends to g(x) at the topological space, then the sequence of functions f tends uniformly on the topological space to function g at the set s excluding the union of sequences that do not converge according to Egorov's theorem.\nTranslate the statement in natural language to Lean:", "output": "theorem tendstoUniformlyOn_diff_iUnionNotConvergentSeq (h\u03b5 : 0 < \u03b5)\n    (hf : \u2200 n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g) (hsm : MeasurableSet s)\n    (hs : \u03bc s \u2260 \u221e) (hfg : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) :\n    TendstoUniformlyOn f g atTop (s \\ Egorov.iUnionNotConvergentSeq h\u03b5 hf hg hsm hs hfg) :="}
{"input": "Statement in natural language:\nFor any given element 'a' of type '\u03b1', and for any given option 'o' of type '\u03b1', 'a' is an element of the option 'o' if and only if 'a' is an element of 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_ofOption {a : \u03b1} : \u2200 {o : Option \u03b1}, a \u2208 ofOption o \u2194 a \u2208 o"}
{"input": "Statement in natural language:\nFor a given semi-quotient 'q' of type \u03b1, 'p' is an element of 'q' if 'p' is obtained from 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem get_mem {q : Semiquot \u03b1} (p) : get q p \u2208 q :="}
{"input": "Statement in natural language:\nFor a semilinear map class with parameters \ud835\udcd5, \u03c3\u2081\u2082, E, and F, and a function f from \ud835\udcd5 that is continuous, there exists a positive constant C such that for all x in E, the norm of f(x) is less than or equal to C times the norm of x.\nTranslate the statement in natural language to Lean:", "output": "theorem SemilinearMapClass.bound_of_continuous [SemilinearMapClass \ud835\udcd5 \u03c3\u2081\u2082 E F] (f : \ud835\udcd5)\n    (hf : Continuous f) : \u2203 C, 0 < C \u2227 \u2200 x : E, \u2016f x\u2016 \u2264 C * \u2016x\u2016 :="}
{"input": "Statement in natural language:\nFor any proposition 'p' that is decidable, 'p' is decided as false if and only if 'p' is not true.\nTranslate the statement in natural language to Lean:", "output": "theorem decide_false_iff (p : Prop) [Decidable p] : decide p = false \u2194 \u00acp :="}
{"input": "Statement in natural language:\nIf a function F (which maps from a set \u03b9 to a function from \u03b2 to \u03b1) is uniformly equicontinuous, then for any element i in \u03b9, the function F(i) is uniformly continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem UniformEquicontinuous.uniformContinuous {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} (h : UniformEquicontinuous F)\n    (i : \u03b9) : UniformContinuous (F i) :="}
{"input": "Statement in natural language:\nFor any elements 'a' from ring 'R' and 'b' from ring 'S', if 'b' is an integer in ring 'R', then the scalar multiplication of 'a' and 'b' is also an integer in ring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem isInteger_smul {a : R} {b : S} (hb : IsInteger R b) : IsInteger R (a \u2022 b) :="}
{"input": "Statement in natural language:\nFor a given ring homomorphism composition triple \u03c3\u2081\u2082, \u03c3\u2082\u2083, \u03c3\u2081\u2083 and a topological add group M\u2083, the composition of the negative of a continuous linear map g with a continuous linear map f is equal to the negative of the composition of g with f.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_comp [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [TopologicalAddGroup M\u2083] (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083)\n    (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : (-g).comp f = -g.comp f :="}
{"input": "Statement in natural language:\nOne is less than two in the set of extended non-negative real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem one_lt_two : (1 : \u211d\u22650\u221e) < 2 :="}
{"input": "Statement in natural language:\nIf the composition of \u03c8 and f\u2081 equals the composition of f\u2082 and \u03c6, and the composition of \u03c8 and g\u2081 equals the composition of g\u2082 and \u03c6, then the composition of \u03b9 with f\u2082 and g\u2082 and the map of \u03c6 and \u03c8 with respect to hf and hg equals the composition of \u03c6 and \u03b9 with f\u2081 and g\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03b9_comp_map (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6) :\n    (\u03b9 f\u2082 g\u2082).comp (map \u03c6 \u03c8 hf hg) = \u03c6.comp (\u03b9 f\u2081 g\u2081) :="}
{"input": "Statement in natural language:\nFor a given open set V in a topological space X, and for all indices i in an index set \u03b9, if there is a morphism from U[i] to V, and if V is a subset of or equal to the supremum of U, and if s and t are objects of the functor F applied to the opposite of V, and if for all i the functor F applied to the morphism from U[i] to V applied to s equals the functor F applied to the same morphism applied to t, then s equals t.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_locally_eq' (V : Opens X) (iUV : \u2200 i : \u03b9, U i \u27f6 V) (hcover : V \u2264 iSup U)\n    (s t : F.1.obj (op V)) (h : \u2200 i, F.1.map (iUV i).op s = F.1.map (iUV i).op t) : s = t :="}
{"input": "Statement in natural language:\nFor a function from \u03b2 to \u03b1, a filter on \u03b2, a point in \u03b1, and two sets in \u03b1, if the first set is a subset of the second set, and the function tends to the point within the first set, then the function also tends to the point within the second set.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_nhdsWithin_mono_right {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} {s t : Set \u03b1} (hst : s \u2286 t)\n    (h : Tendsto f l (\ud835\udcdd[s] a)) : Tendsto f l (\ud835\udcdd[t] a) :="}
{"input": "Statement in natural language:\nThe imaginary part of 1 in the quaternion number system over the real numbers is 0.\nTranslate the statement in natural language to Lean:", "output": "theorem one_im : (1 : \u210d[R]).im = 0 :="}
{"input": "Statement in natural language:\nIf for every index 'i', 'f i' is a lower set, then the union over all 'i' of 'f i' is also a lower set.\nTranslate the statement in natural language to Lean:", "output": "theorem isLowerSet_iUnion {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsLowerSet (f i)) : IsLowerSet (\u22c3 i, f i) :="}
{"input": "Statement in natural language:\nThe hyperbolic sine function is differentiable over the set of real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiable_sinh : Differentiable \u211d sinh :="}
{"input": "Statement in natural language:\nFor any given non-negative extended real number 'a', the real number equivalent of 'a' is also non-negative.\nTranslate the statement in natural language to Lean:", "output": "theorem toReal_nonneg {a : \u211d\u22650\u221e} : 0 \u2264 a.toReal :="}
{"input": "Statement in natural language:\nFor a given ring isomorphism between R and P, R is a fraction ring of S if and only if P is a fraction ring of S under the algebra map composed with the inverse of the ring isomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem isFractionRing_iff_of_base_ringEquiv (h : R \u2243+* P) :\n    IsFractionRing R S \u2194\n      @IsFractionRing P _ S _ ((algebraMap R S).comp h.symm.toRingHom).toAlgebra :="}
{"input": "Statement in natural language:\nFor any computation 's' of type \u03b1 and any natural number 'n', the computation that results from thinking 'n' times is equivalent to the original computation 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem thinkN_equiv (s : Computation \u03b1) (n) : thinkN s n ~ s :="}
{"input": "Statement in natural language:\nFor a topological homomorphism 'f' from '\u03b1' to '\u03b2', the composition of 'f' with the identity topological homomorphism on '\u03b1' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_id (f : TopHom \u03b1 \u03b2) : f.comp (TopHom.id \u03b1) = f :="}
{"input": "Statement in natural language:\nFor a set 's' of ring 'R', a submonoid 'sm' of 'R', and an additive subgroup 'sa' of 'R', if the carrier of 'sm' is equal to 's' and the carrier of 'sa' is also equal to 's', then an element 'x' of 'R' belongs to the subring generated by 's', 'sm', and 'sa' if and only if 'x' belongs to the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_mk' {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubgroup R} (ha : \u2191sa = s)\n    {x : R} : x \u2208 Subring.mk' s sm sa hm ha \u2194 x \u2208 s :="}
{"input": "Statement in natural language:\nFor a list 'l' of elements of type '\u03b1', sorting the list 'l' using relation 'r' is equivalent to merging and sorting the list 'l' using the same relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sort (l : List \u03b1) : sort r l = mergeSort r l :="}
{"input": "Statement in natural language:\nFor any finite type \u03b1, the number of permutations of \u03b1 is equal to the factorial of the number of elements in \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem Fintype.card_perm [Fintype \u03b1] : Fintype.card (Perm \u03b1) = (Fintype.card \u03b1)! :="}
{"input": "Statement in natural language:\nIn a configuration that has points P and lines L, if P and L are finite, then the number of lines L is less than or equal to the number of points P.\nTranslate the statement in natural language to Lean:", "output": "theorem HasPoints.card_le [HasPoints P L] [Fintype P] [Fintype L] :\n    Fintype.card L \u2264 Fintype.card P :="}
{"input": "Statement in natural language:\nFor two linear isometries 'f' and 'g' from a normed vector space 'E' to another normed vector space 'E\u2082', 'f' and 'g' are equal if and only if their corresponding linear maps are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem toLinearMap_inj {f g : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} : f.toLinearMap = g.toLinearMap \u2194 f = g :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that has a zero and a less than operation, if zero is greater than a certain value 'a', then 'a' is less than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_zero_of_zero_gt [Zero \u03b1] [LT \u03b1] {a : \u03b1} (h : 0 > a) : a < 0 :="}
{"input": "Statement in natural language:\nFor all boolean values b, the negation of b is equivalent to not b.\nTranslate the statement in natural language to Lean:", "output": "theorem not_iff_not : \u2200 {b : Bool}, !b \u2194 \u00acb :="}
{"input": "Statement in natural language:\nThe sum of the cardinalities of the sequences generated by the function for each index i is equal to the sum of the cardinalities of a\u2080, a\u2081, and a\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_card : (Cardinal.sum fun i => #Sequence\u2082 a\u2080 a\u2081 a\u2082 i) = (#a\u2080) + (#a\u2081) + (#a\u2082) :="}
{"input": "Statement in natural language:\nFor any index set, if every index has a nonempty set, then the coproduct filter of a family of filters is not the bottom filter if and only if there exists an index such that the filter at that index is not the bottom filter.\nTranslate the statement in natural language to Lean:", "output": "theorem coprod\u1d62_neBot_iff [\u2200 i, Nonempty (\u03b1 i)] : NeBot (Filter.coprod\u1d62 f) \u2194 \u2203 d, NeBot (f d) :="}
{"input": "Statement in natural language:\nFor any type \u03b9, any function f from \u03b1 to non-negative extended real numbers, and any function t from \u03b9 to sets of \u03b1, the sum over all x in the union of the sets t i of f(x) is less than or equal to the sum over all i of the sum over all x in t i of f(x).\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_iUnion_le_tsum {\u03b9 : Type _} (f : \u03b1 \u2192 \u211d\u22650\u221e) (t : \u03b9 \u2192 Set \u03b1) :\n    (\u2211' x : \u22c3 i, t i, f x) \u2264 \u2211' i, \u2211' x : t i, f x :="}
{"input": "Statement in natural language:\nFor two linear maps f\u2081 from M to M\u2082 and f\u2082 from M\u2082 to M, if f\u2082 is a right inverse of f\u2081, then for any pair y consisting of an element from M\u2082 and an element from the kernel of f\u2081, applying the inverse of the equivalence of f\u2081 and f\u2082 (under the condition that f\u2082 is a right inverse of f\u2081) to y is equal to the sum of applying f\u2082 to the first element of y and the second element of y.\nTranslate the statement in natural language to Lean:", "output": "theorem equivOfRightInverse_symm_apply (f\u2081 : M \u2192L[R] M\u2082) (f\u2082 : M\u2082 \u2192L[R] M)\n    (h : Function.RightInverse f\u2082 f\u2081) (y : M\u2082 \u00d7 ker f\u2081) :\n    (equivOfRightInverse f\u2081 f\u2082 h).symm y = f\u2082 y.1 + y.2 :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't', if 's' is a measurable set and the measure of 't' under the sum of two measures '\u03bc' and '\u03bd' is not infinity, then the measure of the intersection of 't' (made measurable under the sum of '\u03bc' and '\u03bd') and 's' under '\u03bc' is equal to the measure of the intersection of 't' and 's' under '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem measure_toMeasurable_add_inter_left {s t : Set \u03b1} (hs : MeasurableSet s)\n    (ht : (\u03bc + \u03bd) t \u2260 \u221e) : \u03bc (toMeasurable (\u03bc + \u03bd) t \u2229 s) = \u03bc (t \u2229 s) :="}
{"input": "Statement in natural language:\nFor any property 'p' that applies to two quotients from equivalence relations 's1' and 's2', if for any two elements 'a1' and 'a2', the property 'p' holds when these elements are made into quotients, then this property 'p' also holds for any two quotients 'q1' and 'q2' from the equivalence relations 's1' and 's2' respectively.\nTranslate the statement in natural language to Lean:", "output": "theorem ind\u2082' {p : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Prop}\n    (h : \u2200 a\u2081 a\u2082, p (Quotient.mk'' a\u2081) (Quotient.mk'' a\u2082))\n    (q\u2081 : Quotient s\u2081) (q\u2082 : Quotient s\u2082) : p q\u2081 q\u2082 :="}
{"input": "Statement in natural language:\nThe dot product of a one-vector (a vector where all elements are one) with itself is equal to the cardinality (or size) of the finite type 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem one_dotProduct_one : (1 : n \u2192 \u03b1) \u2b1d\u1d65 1 = Fintype.card n :="}
{"input": "Statement in natural language:\nGiven a measure \u03bd that is left invariant under multiplication, a measurable set s such that the measure of s is neither zero nor infinity, and a measurable function f from G to the set of non-negative extended real numbers, the product of the measure of s and the integral over y of the function f of the inverse of y divided by the measure of the preimage of s under the function that multiplies x by the inverse of y, with respect to the measure \u03bd, is equal to the integral over x of the function f with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem measure_lintegral_div_measure [IsMulLeftInvariant \u03bd] (sm : MeasurableSet s) (h2s : \u03bd s \u2260 0)\n    (h3s : \u03bd s \u2260 \u221e) (f : G \u2192 \u211d\u22650\u221e) (hf : Measurable f) :\n    (\u03bc s * \u222b\u207b y, f y\u207b\u00b9 / \u03bd ((fun x => x * y\u207b\u00b9) \u207b\u00b9' s) \u2202\u03bd) = \u222b\u207b x, f x \u2202\u03bc :="}
{"input": "Statement in natural language:\nThe inner product of two vectors x and y equals zero if and only if the angle between x and y equals pi divided by two.\nTranslate the statement in natural language to Lean:", "output": "theorem inner_eq_zero_iff_angle_eq_pi_div_two (x y : V) : \u27eax, y\u27eb = 0 \u2194 angle x y = \u03c0 / 2 :="}
{"input": "Statement in natural language:\nIf we have a nontrivial ring R and a set of vectors v that are linearly independent over R, and if we have an injective function f from \u03b9' to \u03b9 such that the range of v is contained within the span of the range of the composition of v and f, then the function f is surjective.\nTranslate the statement in natural language to Lean:", "output": "theorem surjective_of_linearIndependent_of_span [Nontrivial R] (hv : LinearIndependent R v)\n    (f : \u03b9' \u21aa \u03b9) (hss : range v \u2286 span R (range (v \u2218 f))) : Surjective f :="}
{"input": "Statement in natural language:\nFor a filter 'f' on a set '\u03b1', a function 'm' from '\u03b1' to '\u03b2', and a filter 'g' on '\u03b2', 'g' is less than or equal to the image of 'f' under 'm' if and only if for every set 's' in 'f', the image of 's' under 'm' is in 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_map_iff {f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {g : Filter \u03b2} : g \u2264 f.map m \u2194 \u2200 s \u2208 f, m '' s \u2208 g :="}
{"input": "Statement in natural language:\nThe function obtained by applying the valuation of S is equal to the function that coerces S into L.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_val : \u21d1S.val = ((\u2191) : S \u2192 L) :="}
{"input": "Statement in natural language:\nIf a matrix M has a determinant that is not equal to zero, then the bilinear form of M is nondegenerate.\nTranslate the statement in natural language to Lean:", "output": "theorem nondegenerate_toBilin'_of_det_ne_zero' (M : Matrix \u03b9 \u03b9 A) (h : M.det \u2260 0) :\n    M.toBilin'.Nondegenerate :="}
{"input": "Statement in natural language:\n\"b divided by a equals c divided by a if and only if b equals c\".\nTranslate the statement in natural language to Lean:", "output": "theorem div_left_inj : b / a = c / a \u2194 b = c :="}
{"input": "Statement in natural language:\nFor a given preorder on \u03b1 and a function f from \u03b1 to \u03b2, if for every b, the function that maps a to f of a and b is strictly monotonic, then for any list of \u03b2, the function that maps a to the left fold of the list with f and a is also strictly monotonic.\nTranslate the statement in natural language to Lean:", "output": "theorem foldl_strictMono [Preorder \u03b1] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} (H : \u2200 b, StrictMono fun a \u21a6 f a b)\n    (l : List \u03b2) : StrictMono fun a \u21a6 l.foldl f a :="}
{"input": "Statement in natural language:\nThe limit inferior (liminf) of a function 'u' with respect to a filter 'f' is equal to the supremum (least upper bound) of the set of all infimum (greatest lower bound) of 'u' over all sets 's' in the filter 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem liminf_eq_iSup_iInf {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : liminf u f = \u2a06 s \u2208 f, \u2a05 a \u2208 s, u a :="}
{"input": "Statement in natural language:\nFor any function 'f' from a set '\u03b1' to itself, if 'f' is Lipschitz with a constant 'K', then for any natural number 'n', the 'n'-th iteration of 'f' is Lipschitz with a constant 'K' to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : LipschitzWith K f) : \u2200 n, LipschitzWith (K ^ n) (f^[n])"}
{"input": "Statement in natural language:\nThe second element of the universal set under the measure \u03c1 is equal to the measure of the universal set itself.\nTranslate the statement in natural language to Lean:", "output": "theorem snd_univ : \u03c1.snd univ = \u03c1 univ :="}
{"input": "Statement in natural language:\nFor any doubly-linked list 'l', if you convert 'l' to a regular list and then convert it back to a doubly-linked list, you will get the original doubly-linked list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem DList.ofList_toList (l : DList \u03b1) : DList.ofList (DList.toList l) = l :="}
{"input": "Statement in natural language:\nFor all lists l\u2081 and l\u2082 of any type \u03b1, and for any element a of type \u03b1, if l\u2081 is a sublist of l\u2082, then the difference between l\u2082 with a erased and l\u2081 with a erased is a sublist of the difference between l\u2082 and l\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_diff_erase_sublist_of_sublist {a : \u03b1} :\n    \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 <+ l\u2082 \u2192 (l\u2082.erase a).diff (l\u2081.erase a) <+ l\u2082.diff l\u2081"}
{"input": "Statement in natural language:\nThe segment between two points x and y in the field \ud835\udd5c is equal to the closed interval between the minimum and maximum of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem segment_eq_Icc' (x y : \ud835\udd5c) : [x -[\ud835\udd5c] y] = Icc (min x y) (max x y) :="}
{"input": "Statement in natural language:\nFor any two types R' and S' with commutative ring structures, given two ring homomorphisms f from R to S and f' from R' to S', and two other ring homomorphisms g from R to R' and g' from S to S', if the composition of f' and g equals the composition of g' and f, and given an ideal I of S', then the composition of the quotient map of I with respect to g' and the quotient map of the preimage of I under g' with respect to f equals the composition of the quotient map of I with respect to f' and the quotient map of the preimage of I under f' with respect to g. This is under the condition that the preimage of I under the composition of f and g' equals the preimage of I under the composition of g and f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_quotientMap_eq_of_comp_eq {R' S' : Type _} [CommRing R'] [CommRing S'] {f : R \u2192+* S}\n    {f' : R' \u2192+* S'} {g : R \u2192+* R'} {g' : S \u2192+* S'} (hfg : f'.comp g = g'.comp f) (I : Ideal S') :\n    -- Porting note: was losing track of I\n    let leq := le_of_eq (_root_.trans (comap_comap (I := I) f g') (hfg \u25b8 comap_comap (I := I) g f'))\n    (quotientMap I g' le_rfl).comp (quotientMap (I.comap g') f le_rfl) =\n    (quotientMap I f' le_rfl).comp (quotientMap (I.comap f') g leq) :="}
{"input": "Statement in natural language:\nFor all indices 'i', if 'f i' is almost everywhere measurable with respect to measure '\u03bc', then for any element 'x' of the set 'aeSeqSet' associated with 'f' and 'p', the 'i'-th term of the almost everywhere sequence associated with 'f', 'p', and 'x' is equal to the 'i'-th term of the sequence 'f' evaluated at 'x', made measurable with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem aeSeq_eq_mk_of_mem_aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) {x : \u03b1}\n    (hx : x \u2208 aeSeqSet hf p) (i : \u03b9) : aeSeq hf p i x = (hf i).mk (f i) x :="}
{"input": "Statement in natural language:\nThe inverse of the homeomorphism corresponding to a continuous linear equivalence 'e' between two topological vector spaces M\u2081 and M\u2082 is equal to the homeomorphism corresponding to the inverse of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_toHomeomorph (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : e.toHomeomorph.symm = e.symm.toHomeomorph :="}
{"input": "Statement in natural language:\nFor all closure operators c\u2081 and c\u2082 on a set \u03b1, if the function from \u03b1 to \u03b1 defined by c\u2081 is equal to the function from \u03b1 to \u03b1 defined by c\u2082, then c\u2081 is equal to c\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem ext : \u2200 c\u2081 c\u2082 : ClosureOperator \u03b1, (c\u2081 : \u03b1 \u2192 \u03b1) = (c\u2082 : \u03b1 \u2192 \u03b1) \u2192 c\u2081 = c\u2082"}
{"input": "Statement in natural language:\nThe sine of the difference between two times pi and any real number x is equal to the negative sine of x.\nTranslate the statement in natural language to Lean:", "output": "theorem sin_two_pi_sub (x : \u211d) : sin (2 * \u03c0 - x) = -sin x :="}
{"input": "Statement in natural language:\nIf two non-unital algebra homomorphisms 'f' and 'g' from 'A' to 'B' under a ring 'R' are equal when considered as distributive multiplication action homomorphisms, then 'f' and 'g' are equal as non-unital algebra homomorphisms.\nTranslate the statement in natural language to Lean:", "output": "theorem to_distribMulActionHom_injective {f g : A \u2192\u2099\u2090[R] B}\n    (h : (f : A \u2192+[R] B) = (g : A \u2192+[R] B)) : f = g :="}
{"input": "Statement in natural language:\nFor any object 'X' in category 'C' and any presheaf 'P' from the opposite of 'C' to 'D', for any object 'x' in the image of 'X' under 'P', the application of 'toPlus' function on 'P' at 'x' is equal to the 'mk' function applied to the 'Meq.mk' function at the top element and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem toPlus_eq_mk {X : C} {P : C\u1d52\u1d56 \u2964 D} (x : P.obj (op X)) :\n    (J.toPlus P).app _ x = mk (Meq.mk \u22a4 x) :="}
{"input": "Statement in natural language:\nThe set obtained by converting a reversed list is the same as the set obtained by converting the original list.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinset_reverse {l : List \u03b1} : toFinset l.reverse = l.toFinset :="}
{"input": "Statement in natural language:\nFor a given element 'm' of set 'M' and two elements 's\u2081' and 's\u2082' of set 'S', the function 'mk'' with inputs 'f', 's\u2081' scaled by 'm', and the product of 's\u2081' and 's\u2082' is equal to the function 'mk'' with inputs 'f', 'm', and 's\u2082'. This is essentially saying that the left multiplication of 'm' by 's\u2081' can be cancelled out in the function 'mk''.\nTranslate the statement in natural language to Lean:", "output": "theorem mk'_cancel_left (m : M) (s\u2081 s\u2082 : S) : mk' f (s\u2081 \u2022 m) (s\u2081 * s\u2082) = mk' f m s\u2082 :="}
{"input": "Statement in natural language:\nFor any indexed set of sets, if each set is a Pi System, then the product of these sets over the entire index set, mapped through the product of the original sets, is also a Pi System.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPiSystem.pi {C : \u2200 i, Set (Set (\u03b1 i))} (hC : \u2200 i, IsPiSystem (C i)) :\n    IsPiSystem (pi univ '' pi univ C) :="}
{"input": "Statement in natural language:\nFor any given vectors 'v' and 'w' in a single point space (PUnit), the dot product of 'v' and 'w' is equal to the product of the values of 'v' and 'w' at that single point. This is under the condition that the type '\u03b1' forms an additive commutative monoid and has a multiplication operation.\nTranslate the statement in natural language to Lean:", "output": "theorem dotProduct_pUnit [AddCommMonoid \u03b1] [Mul \u03b1] (v w : PUnit \u2192 \u03b1) : v \u2b1d\u1d65 w = v \u27e8\u27e9 * w \u27e8\u27e9 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', the function 'optionEquivSumPUnit' applied to 'a' is equal to the left injection of 'a' into a sum type.\nTranslate the statement in natural language to Lean:", "output": "theorem optionEquivSumPUnit_coe (a : \u03b1) : optionEquivSumPUnit \u03b1 a = Sum.inl a :="}
{"input": "Statement in natural language:\nFor a given element 'a', the application of the indicator function '1' on 's' at 'a' is less than or equal to the application of the Dirac measure on 's' at 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_dirac_apply {a} : s.indicator 1 a \u2264 dirac a s :="}
{"input": "Statement in natural language:\nFor any given value 'r' of type '\u03b2', the interval of all numbers less than or equal to 'r' is convex.\nTranslate the statement in natural language to Lean:", "output": "theorem convex_Iic (r : \u03b2) : Convex \ud835\udd5c (Iic r) :="}
{"input": "Statement in natural language:\n\"a\" infimum \"b\" is less than \"b\" if and only if \"b\" is not less than or equal to \"a\".\nTranslate the statement in natural language to Lean:", "output": "theorem inf_lt_right : a \u2293 b < b \u2194 \u00acb \u2264 a :="}
{"input": "Statement in natural language:\nThe identity relation is a subset of a set 's' of ordered pairs of elements of type '\u03b1' if and only if for every element 'a' of type '\u03b1', the ordered pair (a, a) is in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem idRel_subset {s : Set (\u03b1 \u00d7 \u03b1)} : idRel \u2286 s \u2194 \u2200 a, (a, a) \u2208 s :="}
{"input": "Statement in natural language:\nThe exponential function is an open embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem openEmbedding_exp : OpenEmbedding exp :="}
{"input": "Statement in natural language:\nIn a preordered set \u03b2, the element x is less than the element y if and only if the lift of x to the ultraproduct \u03b2* is less than the lift of y to the ultraproduct \u03b2*.\nTranslate the statement in natural language to Lean:", "output": "theorem const_lt_iff [Preorder \u03b2] {x y : \u03b2} : (\u2191x : \u03b2*) < \u2191y \u2194 x < y :="}
{"input": "Statement in natural language:\nA rational number 'n' is non-negative if and only if its cast in field 'K' is also non-negative.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_nonneg {n : \u211a} : 0 \u2264 (n : K) \u2194 0 \u2264 n :="}
{"input": "Statement in natural language:\nFor a given separable contraction 'g' of 'f' by a factor 'q', there exists a natural number 'm' such that the natural degree of 'g' multiplied by 'q' to the power of 'm' equals the natural degree of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSeparableContraction.dvd_degree' {g} (hf : IsSeparableContraction q f g) :\n    \u2203 m : \u2115, g.natDegree * q ^ m = f.natDegree :="}
{"input": "Statement in natural language:\nIf there exists a unique element 'a' in the list 'l' that satisfies the property 'p', then choosing this element from the list 'l' based on the property 'p' will result in an element that is in the list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem choose_mem (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l :="}
{"input": "Statement in natural language:\nThe ceiling function, which maps any real number to the smallest integer greater than or equal to it, is monotone. This means that if a real number x is less than or equal to another real number y, then the ceiling of x is less than or equal to the ceiling of y.\nTranslate the statement in natural language to Lean:", "output": "theorem ceil_mono : Monotone (ceil : \u03b1 \u2192 \u2115) :="}
{"input": "Statement in natural language:\nFor any two functions 'x' and 'y' from natural numbers to a set 'E', and for any natural number 'n', 'y' is in the cylinder of 'x' at 'n' if and only if the cylinder of 'y' at 'n' is equal to the cylinder of 'x' at 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_cylinder_iff_eq {x y : \u2200 n, E n} {n : \u2115} :\n    y \u2208 cylinder x n \u2194 cylinder y n = cylinder x n :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to a pair of values 'E' and 'F', if 'f' is integrable with respect to measure '\u03bc', then the first component of the integral of 'f' with respect to '\u03bc' is equal to the integral of the first component of 'f' with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_integral {f : \u03b1 \u2192 E \u00d7 F} (hf : Integrable f \u03bc) : (\u222b x, f x \u2202\u03bc).1 = \u222b x, (f x).1 \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from a set 'M' to a set 'N', the mapping operation is monotone. This means that if an element 'a' in 'M' is less than or equal to an element 'b' in 'M', then the image of 'a' under 'f' is less than or equal to the image of 'b' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem monotone_map {f : M \u2192\u2099* N} : Monotone (map f) :="}
{"input": "Statement in natural language:\nIf a local homeomorphism 'e' maps set 's' to set 't' and set 's'' to set 't'', then 'e' also maps the intersection of 's' and 's'' to the intersection of 't' and 't''.\nTranslate the statement in natural language to Lean:", "output": "theorem inter {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \u2229 s') (t \u2229 t') :="}
{"input": "Statement in natural language:\nMapping two functions, m and g, where the first function is the bottom element, results in the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_bot_left : map\u2082 m \u22a5 g = \u22a5 :="}
{"input": "Statement in natural language:\nFor any type \u03b1, and any three elements a, b, c of type \u03b1, and a relation r between elements of type \u03b1, if a equals b and the relation r holds between b and c, then the relation r also holds between a and c. This is essentially the principle of transitivity applied to relations.\nTranslate the statement in natural language to Lean:", "output": "theorem trans_rel_right {\u03b1 : Sort u} {a b c : \u03b1}\n    (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : a = b) (h\u2082 : r b c) : r a c :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from object 'X' to object 'Y', if 'f' is an isomorphism and there exists a morphism 'g' from 'Y' to 'X' such that the composition of 'f' and 'g' equals the identity on 'X', then the inverse of 'f' is equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_eq_of_hom_inv_id {f : X \u27f6 Y} [IsIso f] {g : Y \u27f6 X} (hom_inv_id : f \u226b g = \ud835\udfd9 X) :\n    inv f = g :="}
{"input": "Statement in natural language:\nIf polynomial p is not equal to zero and polynomial q is monic, then polynomial q is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_zero_of_ne_zero_of_monic (hp : p \u2260 0) (hq : Monic q) : q \u2260 0 :="}
{"input": "Statement in natural language:\nIf the map of a prime number p through a function f is not the bottom element, if P is a prime number, and if P is not the bottom element, then the ramification index of f, p, and P is equal to the count of P in the factors of the map of p through f.\nTranslate the statement in natural language to Lean:", "output": "theorem ramificationIdx_eq_factors_count (hp0 : map f p \u2260 \u22a5) (hP : P.IsPrime) (hP0 : P \u2260 \u22a5) :\n    ramificationIdx f p P = (factors (map f p)).count P :="}
{"input": "Statement in natural language:\nFor a unit matrix M and any matrix N, the determinant of the product of the inverse of M, N, and M is equal to the determinant of N.\nTranslate the statement in natural language to Lean:", "output": "theorem det_units_conj' (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (\u2191M\u207b\u00b9 \u2b1d N \u2b1d \u2191M : Matrix m m R) = det N :="}
{"input": "Statement in natural language:\nFor a given set 's' of type '\u03b9' and a function 'I' from '\u03b9' to 'R' such that every pair in the set 's' is coprime with respect to 'I', the intersection of the ideals spanned by the singleton set of 'I i' for each 'i' in 's' is equal to the ideal spanned by the product of 'I i' for all 'i' in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem finset_inf_span_singleton {\u03b9 : Type _} (s : Finset \u03b9) (I : \u03b9 \u2192 R)\n    (hI : Set.Pairwise (\u2191s) (IsCoprime on I)) :\n    (s.inf fun i => Ideal.span ({I i} : Set R)) = Ideal.span {\u220f i in s, I i} :="}
{"input": "Statement in natural language:\nFor a scalar 'c' and a finite measure '\u03bc' on a set '\u03a9', the measure obtained by scaling '\u03bc' by 'c' is equal to the measure '\u03bc' scaled by 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem toMeasure_smul (c : R) (\u03bc : FiniteMeasure \u03a9) : \u2191(c \u2022 \u03bc) = c \u2022 (\u03bc : Measure \u03a9) :="}
{"input": "Statement in natural language:\nFor a given element 'y' of type '\u03b2', the function that takes an element 'x' of type '\u03b1' and produces a pair (x, y) is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_prod_mk_right {y : \u03b2} : Measurable fun x : \u03b1 => (x, y) :="}
{"input": "Statement in natural language:\nFor any element 'x' of the set 'E', the application of the additive group norm '1' to 'x' equals '0' if 'x' is '0', otherwise it equals '1'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_one (x : E) : (1 : AddGroupNorm E) x = if x = 0 then 0 else 1 :="}
{"input": "Statement in natural language:\nFor a nonempty set \u03c3 and a nontrivial ring R, the cardinality of the multivariate polynomial over \u03c3 and R is equal to the maximum of the cardinality of R, the cardinality of \u03c3, and aleph null (\u2135\u2080, the cardinality of the set of natural numbers).\nTranslate the statement in natural language to Lean:", "output": "theorem cardinal_mk_eq_max [Nonempty \u03c3] [Nontrivial R] :\n    (#MvPolynomial \u03c3 R) = max (max (#R) (#\u03c3)) \u2135\u2080 :="}
{"input": "Statement in natural language:\nIf there is a morphism 's' from object B to object A such that the composition of 's' and 'f' equals the identity on B, and the composition of 's' and 'g' also equals the identity on B, then 'f' and 'g' form a reflexive pair.\nTranslate the statement in natural language to Lean:", "output": "theorem IsReflexivePair.mk' (s : B \u27f6 A) (sf : s \u226b f = \ud835\udfd9 B) (sg : s \u226b g = \ud835\udfd9 B) :\n    IsReflexivePair f g :="}
{"input": "Statement in natural language:\nFor a convex cone K in a real Hilbert space H, if K is nonempty and closed, and if a point b is not in K, then there exists a point y in H such that for all points x in K, the inner product of x and y is nonnegative, and the inner product of y and b is negative.\nTranslate the statement in natural language to Lean:", "output": "theorem ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem (K : ConvexCone \u211d H)\n    (ne : (K : Set H).Nonempty) (hc : IsClosed (K : Set H)) {b : H} (disj : b \u2209 K) :\n    \u2203 y : H, (\u2200 x : H, x \u2208 K \u2192 0 \u2264 \u27eax, y\u27eb_\u211d) \u2227 \u27eay, b\u27eb_\u211d < 0 :="}
{"input": "Statement in natural language:\nIf two structures M and N are isomorphic under a language L, then the complete theory of M under L is equal to the complete theory of N under L.\nTranslate the statement in natural language to Lean:", "output": "theorem completeTheory_eq (h : M \u2245[L] N) : L.completeTheory M = L.completeTheory N :="}
{"input": "Statement in natural language:\nFor a set function T from a set of \u03b1 to the space of continuous linear maps from E to F, and a real number C, if T is dominated by a finite measure additive \u03bc with domination constant C, and C is non-negative, then the norm of the set function T transformed to L1 space is less than or equal to C.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_setToL1SCLM_le {T : Set \u03b1 \u2192 E \u2192L[\u211d] F} {C : \u211d} (hT : DominatedFinMeasAdditive \u03bc T C)\n    (hC : 0 \u2264 C) : \u2016setToL1SCLM \u03b1 E \u03bc hT\u2016 \u2264 C :="}
{"input": "Statement in natural language:\nIf a set 's' is connected and an element 'x' belongs to this set 's', then 's' is a subset of the connected component of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsConnected.subset_connectedComponent {x : \u03b1} {s : Set \u03b1} (H1 : IsConnected s)\n    (H2 : x \u2208 s) : s \u2286 connectedComponent x :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a certain type '\u03b1', if 'a' is less than 'b', then the half-open interval from 'a' to 'b' is an element of the neighborhood within the set of all elements less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ico_mem_nhdsWithin_Iio' {a b : \u03b1} (H : a < b) : Ico a b \u2208 \ud835\udcdd[<] b :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of any type '\u03b1', and an element 'x' from the set interpretation of 's', the element 'x' is equal to itself when it is considered as an element of the set interpretation of 's' with some property 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_coe {s : Finset \u03b1} (x : (s : Set \u03b1)) {h} : (\u27e8x, h\u27e9 : (s : Set \u03b1)) = x :="}
{"input": "Statement in natural language:\nFor a covariant and contravariant class of type \u03b1, given any elements 'a' and 'b' of type \u03b1, the product of 'a' and 'b' is less than 'b' if and only if 'a' is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_lt_iff_lt_one_right' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a : \u03b1} (b : \u03b1) : a * b < b \u2194 a < 1 :="}
{"input": "Statement in natural language:\nFor any ultrafilter 'f' on a set '\u03b1' and any filter 'g' on the same set, if the infimum (greatest lower bound) of 'g' and 'f' is not the bottom element, then 'f' is less than or equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_inf_neBot' (f : Ultrafilter \u03b1) {g : Filter \u03b1} (hg : NeBot (g \u2293 f)) : \u2191f \u2264 g :="}
{"input": "Statement in natural language:\nFor any natural number 'k', the 'k'-th upper central series of the trivial Lie submodule of 'M' when mapped back via the inclusion of 'N' is equal to the 'k'-th upper central series of the trivial Lie submodule of 'N'.\nTranslate the statement in natural language to Lean:", "output": "theorem ucs_comap_incl (k : \u2115) :\n    ((\u22a5 : LieSubmodule R L M).ucs k).comap N.incl = (\u22a5 : LieSubmodule R L N).ucs k :="}
{"input": "Statement in natural language:\nFor a given set 's' in a topological space, if 's' is compact and nonempty, then there exists an element 'x' in 's' that is the greatest lower bound of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompact.exists_isGLB {s : Set \u03b1} (hs : IsCompact s) (ne_s : s.Nonempty) :\n    \u2203 x \u2208 s, IsGLB s x :="}
{"input": "Statement in natural language:\nA set 's' is in the coproduct filter 'f' if and only if for every index 'i', there exists a set 't\u2081' in the filter at index 'i', such that the preimage of 't\u2081' under the evaluation map at index 'i' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_coprod\u1d62_iff {s : Set (\u2200 i, \u03b1 i)} :\n    s \u2208 Filter.coprod\u1d62 f \u2194 \u2200 i : \u03b9, \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 s :="}
{"input": "Statement in natural language:\nIf 'c' is less than the maximum of 'a' and 'b', then the union of the open interval from 'a' to 'b' and the interval greater than 'c' is equal to the interval greater than the minimum of 'a' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioo_union_Ioi (h : c < max a b) : Ioo a b \u222a Ioi c = Ioi (min a c) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set '\u03b1', the empty relation applied to 'a' and 'b' is equivalent to 'False'.\nTranslate the statement in natural language to Lean:", "output": "theorem empty_relation_apply (a b : \u03b1) : EmptyRelation a b \u2194 False :="}
{"input": "Statement in natural language:\nA matrix A of size n by n with elements from \u03b2 belongs to the orthogonal group of size n over \u03b2 if and only if the conjugate transpose of A multiplied by A equals the identity matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_orthogonalGroup_iff' {A : Matrix n n \u03b2} :\n    A \u2208 Matrix.orthogonalGroup n \u03b2 \u2194 star A * A = 1 :="}
{"input": "Statement in natural language:\nThe sign of a number 'a' is non-negative if and only if the number 'a' itself is non-negative.\nTranslate the statement in natural language to Lean:", "output": "theorem sign_nonneg_iff : 0 \u2264 sign a \u2194 0 \u2264 a :="}
{"input": "Statement in natural language:\nThe sum of 'a' and 'b' is not the smallest element if and only if 'a' is not the smallest element and 'b' is not the smallest element.\nTranslate the statement in natural language to Lean:", "output": "theorem add_ne_bot : a + b \u2260 \u22a5 \u2194 a \u2260 \u22a5 \u2227 b \u2260 \u22a5 :="}
{"input": "Statement in natural language:\nFor any real number 'a' and natural number 'n' (where 'n' is not equal to 0), 'a' raised to the power of twice 'n' is greater than 0 if and only if 'a' is not equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_bit0_pos_iff (a : R) {n : \u2115} (hn : n \u2260 0) : 0 < a ^ bit0 n \u2194 a \u2260 0 :="}
{"input": "Statement in natural language:\nFor any real numbers 's' and 'b', where 'b' is greater than 0, the function that maps 'x' to the exponential of 'b' times 'x' divided by 'x' to the power of 's' tends to infinity as 'x' tends to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_exp_mul_div_rpow_atTop (s : \u211d) (b : \u211d) (hb : 0 < b) :\n    Tendsto (fun x : \u211d => exp (b * x) / x ^ s) atTop atTop :="}
{"input": "Statement in natural language:\nThe restriction of a continuous function from a set \u03b1 to a set \u03b2 to a subset s of \u03b1 is also a continuous function.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_restrict (s : Set \u03b1) : Continuous fun F : C(\u03b1, \u03b2) => F.restrict s :="}
{"input": "Statement in natural language:\nFor a normed division ring \ud835\udd5c, a module \ud835\udd5c over \u03b2, and a bounded scalar multiplication of \ud835\udd5c and \u03b2, given a non-zero element c from \ud835\udd5c and a function f from \u03b1 to \u03b2, the function f is integrable with respect to measure \u03bc if and only if the function obtained by scalar multiplication of c and f is also integrable with respect to measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem integrable_smul_iff [NormedDivisionRing \ud835\udd5c] [Module \ud835\udd5c \u03b2] [BoundedSMul \ud835\udd5c \u03b2] {c : \ud835\udd5c}\n    (hc : c \u2260 0) (f : \u03b1 \u2192 \u03b2) : Integrable (c \u2022 f) \u03bc \u2194 Integrable f \u03bc :="}
{"input": "Statement in natural language:\nA presheaf P is separated for a sieve R if and only if it is separated for the sieve generated by R on a presieve X.\nTranslate the statement in natural language to Lean:", "output": "theorem isSeparatedFor_iff_generate :\n    IsSeparatedFor P R \u2194 IsSeparatedFor P (generate R : Presieve X) :="}
{"input": "Statement in natural language:\nFor any list 'l' of elements of type '\u03b1' and any natural number 'n', rotating the list 'l' by 'n' positions is equivalent to dropping the first 'n mod length of l' elements from 'l' and then appending the first 'n mod length of l' elements of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem rotate_eq_drop_append_take_mod {l : List \u03b1} {n : \u2115} :\n    l.rotate n = l.drop (n % l.length) ++ l.take (n % l.length) :="}
{"input": "Statement in natural language:\nFor any given function 'M' that produces a matrix for each index 'i', where the matrix has dimensions determined by the functions 'm'' and 'n'' and entries of type '\u03b1', if we first create a block diagonal matrix from 'M' using the function 'blockDiagonal'' and then convert it back to the original matrix form using the function 'blockDiag'', we will get the original matrix 'M'. This holds true when 'o' (the type of the index 'i') has decidable equality.\nTranslate the statement in natural language to Lean:", "output": "theorem blockDiag'_blockDiagonal' [DecidableEq o] (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) :\n    blockDiag' (blockDiagonal' M) = M :="}
{"input": "Statement in natural language:\nIn the context of Noetherian rings and modules, for a given endomorphism 'f' of a module 'M' over a ring 'R' and a scalar '\u03bc' in 'R', the maximal generalized eigenspace of 'f' corresponding to '\u03bc' is equal to the generalized eigenspace of 'f' corresponding to '\u03bc' at the maximal generalized eigenspace index of 'f' corresponding to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem maximalGeneralizedEigenspace_eq [h : IsNoetherian R M] (f : End R M) (\u03bc : R) :\n    maximalGeneralizedEigenspace f \u03bc =\n      f.generalizedEigenspace \u03bc (maximalGeneralizedEigenspaceIndex f \u03bc) :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuous on a set 's', then 'f' is also lower semicontinuous on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousOn.lowerSemicontinuousOn {f : \u03b1 \u2192 \u03b3} (h : ContinuousOn f s) :\n    LowerSemicontinuousOn f s :="}
{"input": "Statement in natural language:\nFor any two objects A and B in a category T, the function that creates an arrow (or morphism) from A to B is injective. This means that different morphisms from A to B will result in different arrows, ensuring uniqueness of the arrows.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_injective (A B : T) :\n    Function.Injective (Arrow.mk : (A \u27f6 B) \u2192 Arrow T) :="}
{"input": "Statement in natural language:\nFor any natural number 'b' greater than 1 and any integer 'z', the common logarithm base 'b' of 'b' raised to the power of 'z' is equal to 'z'.\nTranslate the statement in natural language to Lean:", "output": "theorem clog_zpow {b : \u2115} (hb : 1 < b) (z : \u2124) : clog b ((b : R) ^ z : R) = z :="}
{"input": "Statement in natural language:\nFor any vertex 'u' in a graph 'G', the list of darts (an ordered pair of adjacent vertices) in a walk (a sequence of vertices where each adjacent pair is connected by an edge in the graph) from 'u' to 'u' that does not include any edges (represented as 'nil') is an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem darts_nil {u : V} : (nil : G.Walk u u).darts = [] :="}
{"input": "Statement in natural language:\nFor a given array of Union-Find nodes and a Union-Find model of the same size, if the model represents the array, then the parent of the i-th element in the array is the same as the parent of the i-th element in the model.\nTranslate the statement in natural language to Lean:", "output": "theorem parent_eq' {arr : Array (UFNode \u03b1)} {m : UFModel arr.size} (H : m.Models arr)\n  (i : Fin arr.size) : (arr[i.1]).parent = m.parent i :="}
{"input": "Statement in natural language:\nFor a local equivalence 'e' and 'e'' between two types \u03b1 and \u03b2, and for any index 'i' where it is decidable whether 'i' is in set 's' or 't', if 'e' maps 's' to 't' and 'e'' also maps 's' to 't', then the function that is the inverse of 'e' on 't' and the inverse of 'e'' on the complement of 't', is a left inverse on the function that is 'e' on 's' and 'e'' on the complement of 's', over the set that is 'e.source' if 's' is true and 'e''.source' otherwise.\nTranslate the statement in natural language to Lean:", "output": "theorem leftInvOn_piecewise {e' : LocalEquiv \u03b1 \u03b2} [\u2200 i, Decidable (i \u2208 s)]\n    [\u2200 i, Decidable (i \u2208 t)] (h : e.IsImage s t) (h' : e'.IsImage s t) :\n    LeftInvOn (t.piecewise e.symm e'.symm) (s.piecewise e e') (s.ite e.source e'.source) :="}
{"input": "Statement in natural language:\nFor a function 'f' from type \u03b1 to type \u03b2, a natural number 'n', and a list 'as' of type \u03b1, if the function 'f' applied to a default value equals the default value, then the 'n'th element of the list 'as' mapped by the function 'f' is equal to the function 'f' applied to the 'n'th element of the list 'as'.\nTranslate the statement in natural language to Lean:", "output": "theorem get_map' {f : \u03b1 \u2192 \u03b2} {n : \u2115} {as : List \u03b1} :\n    f default = default \u2192 get n (as.map f) = f (get n as) :="}
{"input": "Statement in natural language:\nIf a function 'f' has a strict Frechet derivative 'f'' at a point 'x', then the function that takes a pair of points in 'E' and subtracts the second from the first is a big O of the function that takes a pair of points in 'E', applies 'f' to each, and subtracts the second result from the first, in the neighborhood of the pair '(x, x)'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasStrictFDerivAt.isBigO_sub_rev {f' : E \u2243L[\ud835\udd5c] F}\n    (hf : HasStrictFDerivAt f (f' : E \u2192L[\ud835\udd5c] F) x) :\n    (fun p : E \u00d7 E => p.1 - p.2) =O[\ud835\udcdd (x, x)] fun p : E \u00d7 E => f p.1 - f p.2 :="}
{"input": "Statement in natural language:\nFor any morphism 'f' from one profinite space 'X' to another profinite space 'Y', 'f' is a monomorphism if and only if 'f' is an injective function.\nTranslate the statement in natural language to Lean:", "output": "theorem mono_iff_injective {X Y : Profinite.{u}} (f : X \u27f6 Y) : Mono f \u2194 Function.Injective f :="}
{"input": "Statement in natural language:\nThe angle between the negatives of two vectors x and y is equal to the angle between the original vectors x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem angle_neg_neg (x y : V) : angle (-x) (-y) = angle x y :="}
{"input": "Statement in natural language:\nThe function \"f.lift hg\" is surjective if and only if for every element \"v\" in set \"P\", there exists an element \"x\" in the Cartesian product of sets \"M\" and \"S\" such that the product of \"v\" and the second element of \"x\" equals the first element of \"x\" under function \"g\".\nTranslate the statement in natural language to Lean:", "output": "theorem lift_surjective_iff :\n    Function.Surjective (f.lift hg) \u2194 \u2200 v : P, \u2203 x : M \u00d7 S, v * g x.2 = g x.1 :="}
{"input": "Statement in natural language:\nIf x is a Liouville number with a certain constant p, then x plus any integer m is also a Liouville number with the same constant p.\nTranslate the statement in natural language to Lean:", "output": "theorem add_int (h : LiouvilleWith p x) (m : \u2124) : LiouvilleWith p (x + m) :="}
{"input": "Statement in natural language:\nFor any two subgroups 'p' and 'q' of a group 'G', 'p' is equal to 'q' if and only if the submonoid of 'p' is equal to the submonoid of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem toSubmonoid_eq {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid \u2194 p = q :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuously differentiable 'n' times on a set 's' in a field '\ud835\udd5c', and 'm' is less than 'n', and 's' is a set where all points have unique tangent spaces, then the 'm'-th derivative of 'f' is differentiable on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiffOn.differentiableOn_iteratedDerivWithin {n : \u2115\u221e} {m : \u2115} (h : ContDiffOn \ud835\udd5c n f s)\n    (hmn : (m : \u2115\u221e) < n) (hs : UniqueDiffOn \ud835\udd5c s) :\n    DifferentiableOn \ud835\udd5c (iteratedDerivWithin m f s) s :="}
{"input": "Statement in natural language:\nFor any two multisets s and t, the difference between s and the intersection of s and t is equal to the difference between s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_inter (s t : Multiset \u03b1) : s - s \u2229 t = s - t :="}
{"input": "Statement in natural language:\nIf set t is a subset of set s, then if s is a clique in graph G, t is also a clique in graph G.\nTranslate the statement in natural language to Lean:", "output": "theorem IsClique.subset (h : t \u2286 s) : G.IsClique s \u2192 G.IsClique t :="}
{"input": "Statement in natural language:\nFor any probability measure \u03bd on a set \u03a9, the measure obtained by converting \u03bd to a finite measure is equal to the measure obtained by directly converting \u03bd to a measure.\nTranslate the statement in natural language to Lean:", "output": "theorem toMeasure_comp_toFiniteMeasure_eq_toMeasure (\u03bd : ProbabilityMeasure \u03a9) :\n    (\u03bd.toFiniteMeasure : Measure \u03a9) = (\u03bd : Measure \u03a9) :="}
{"input": "Statement in natural language:\nIf 'f' is a strictly decreasing function and 'g' is also a strictly decreasing function, given a property 'p' that can be decided for any input, and if for any 'x' and 'y' where 'x' is less than 'y', 'p' of 'y' implies 'p' of 'x', and for any 'x' and 'y', if 'p' of 'x' is true and 'p' of 'y' is false and 'x' is less than 'y', then 'g' of 'y' is less than 'f' of 'x', then the function that maps 'x' to 'f' of 'x' if 'p' of 'x' is true and to 'g' of 'x' if 'p' of 'x' is false, is a strictly decreasing function.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictAnti.ite' (hf : StrictAnti f) (hg : StrictAnti g) {p : \u03b1 \u2192 Prop}\n    [DecidablePred p]\n    (hp : \u2200 \u2983x y\u2984, x < y \u2192 p y \u2192 p x) (hfg : \u2200 \u2983x y\u2984, p x \u2192 \u00acp y \u2192 x < y \u2192 g y < f x) :\n    StrictAnti fun x \u21a6 if p x then f x else g x :="}
{"input": "Statement in natural language:\nThe inverse of the co-domain of a set 's' is equal to the inverse of the set 's' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_inv : \u2191s\u207b\u00b9 = (s : Set \u03b1)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nExtending the domain of a permutation with the identity equivalence relation (Equiv.refl) is equivalent to the identity equivalence relation itself.\nTranslate the statement in natural language to Lean:", "output": "theorem Perm.extendDomain_refl : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _ :="}
{"input": "Statement in natural language:\nZero is an element of the ideal I in the ring \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_mem : (0 : \u03b1) \u2208 I :="}
{"input": "Statement in natural language:\nFor a given polynomial 'p' over a field 'F' and an intermediate field 'K' of a field extension 'E' over 'F', 'p' is a splitting field over 'F' for 'K' if and only if 'p' splits over the algebraic mapping from 'F' to 'K' and 'K' is equal to the field obtained by adjoining 'F' with the set of roots of 'p' in 'E'.\nTranslate the statement in natural language to Lean:", "output": "theorem isSplittingField_iff {p : F[X]} {K : IntermediateField F E} :\n    p.IsSplittingField F K \u2194 p.Splits (algebraMap F K) \u2227 K = adjoin F (p.rootSet E) :="}
{"input": "Statement in natural language:\nFor a relation 'r' between '\u03b2' and '\u03b3', and functions 'f' from '\u03b1' to '\u03b2' and 'g' from '\u03b1' to '\u03b3', the lifting of the relation 'r' to the germs of 'f' and 'g' is equivalent to the statement that for almost every 'x' in 'l', the relation 'r' holds between 'f(x)' and 'g(x)'.\nTranslate the statement in natural language to Lean:", "output": "theorem liftRel_coe {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} :\n    LiftRel r (f : Germ l \u03b2) g \u2194 \u2200\u1da0 x in l, r (f x) (g x) :="}
{"input": "Statement in natural language:\nFor any two vectors x and y, the midpoint of the vector resulting from subtracting y from x and the vector resulting from adding x and y is x.\nTranslate the statement in natural language to Lean:", "output": "theorem midpoint_sub_add (x y : V) : midpoint R (x - y) (x + y) = x :="}
{"input": "Statement in natural language:\nFor any two positive natural numbers m and n, if m divides n, then the greatest common divisor of m and n is m.\nTranslate the statement in natural language to Lean:", "output": "theorem gcd_eq_left {m n : \u2115+} : m \u2223 n \u2192 m.gcd n = m :="}
{"input": "Statement in natural language:\nThe cardinality of the interval (a, b] is equal to the cardinality of the interval (a, b] after replacing a.1 with b.1 if a.1 is equal to b.1, otherwise it is 0.\nTranslate the statement in natural language to Lean:", "output": "theorem card_Ioc : (Ioc a b).card = if h : a.1 = b.1 then (Ioc (h.rec a.2) b.2).card else 0 :="}
{"input": "Statement in natural language:\nFor any two elements 'f' and 'g' of the monoid algebra over a monoid 'G' and a field 'k', and for any element 'x' of 'G', the value of the product 'f * g' at 'x' is equal to the sum over 'g' of the product of 'f' at 'x * a\u207b\u00b9' and 'b', where 'a' and 'b' are elements of 'G'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_apply_right (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = g.sum fun a b => f (x * a\u207b\u00b9) * b :="}
{"input": "Statement in natural language:\nFor any two objects 'a' and 'b' in the Simplex Category, and for any order-preserving function 'f' from the finite set of size 'a.len + 1' to the finite set of size 'b.len + 1', and for any element 'i' in the finite set of size 'a.len + 1', the order-preserving function associated with the morphism created from 'f' evaluated at 'i' is equal to 'f' evaluated at 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_toOrderHom_apply {a b : SimplexCategory} (f : Fin (a.len + 1) \u2192o Fin (b.len + 1))\n    (i : Fin (a.len + 1)) : (mk f).toOrderHom i = f i :="}
{"input": "Statement in natural language:\nFor any matrix A in M, if the determinant of A is a unit, then for any integer n, the negative nth power of A is equal to the inverse of the nth power of A.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_neg {A : M} (h : IsUnit A.det) : \u2200 n : \u2124, A ^ (-n) = (A ^ n)\u207b\u00b9"}
{"input": "Statement in natural language:\nFor two functions 'f' and 'g', where 'g' is an inducing function, and for a set 's' and an element 'x' in 's', the function 'f' is continuous within 's' at 'x' if and only if the composition of 'g' and 'f' is also continuous within 's' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem Inducing.continuousWithinAt_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) {s : Set \u03b1}\n    {x : \u03b1} : ContinuousWithinAt f s x \u2194 ContinuousWithinAt (g \u2218 f) s x :="}
{"input": "Statement in natural language:\nIf there is a pullback of two morphisms f (from object X to Z) and g (from object Y to Z), then the first projection from the pullback to X and the second projection from the pullback to Y form a pullback square with f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem of_hasPullback (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g] :\n    IsPullback (pullback.fst : pullback f g \u27f6 X) (pullback.snd : pullback f g \u27f6 Y) f g :="}
{"input": "Statement in natural language:\nFor a list of elements from a ring R, if every element in the list belongs to a subsemiring s, then the sum of all elements in the list also belongs to the subsemiring s.\nTranslate the statement in natural language to Lean:", "output": "theorem list_sum_mem {l : List R} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.sum \u2208 s :="}
{"input": "Statement in natural language:\nFor a given element 'a' from set \u03b1 and an element 'x' from ring R, the congruence class of the scalar multiple 'a \u2022 x' is equal to the scalar multiple of the congruence class of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_smul (a : \u03b1) (x : R) : (\u2191(a \u2022 x) : c.Quotient) = a \u2022 (x : c.Quotient) :="}
{"input": "Statement in natural language:\nFor a given predicate 'p' on '\u03b9', if 'p' is true for a particular 'i' in '\u03b9' and 'x' is an element of '\u03b2' at 'i', then filtering the singleton set containing 'i' and 'x' with 'p' will result in the same singleton set.\nTranslate the statement in natural language to Lean:", "output": "theorem filter_single_pos {p : \u03b9 \u2192 Prop} [DecidablePred p] (i : \u03b9) (x : \u03b2 i) (h : p i) :\n    (single i x).filter p = single i x :="}
{"input": "Statement in natural language:\nIf a number 'a' is greater than 1 and 'n' is less than 'm', then 'a' to the power of 'n' is less than 'a' to the power of 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_lt_pow (h : 1 < a) (h2 : n < m) : a ^ n < a ^ m :="}
{"input": "Statement in natural language:\nFor a given sort '\u03b9', a function 'l' from '\u03b9' to a language '\u03b1', and a list 'x' of '\u03b1', 'x' is an element of the supremum of 'l i' over 'i' if and only if there exists an 'i' such that 'x' is an element of 'l i'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_iSup {\u03b9 : Sort v} {l : \u03b9 \u2192 Language \u03b1} {x : List \u03b1} : (x \u2208 \u2a06 i, l i) \u2194 \u2203 i, x \u2208 l i :="}
{"input": "Statement in natural language:\nFor a function 'f' from a type '\u03b1' to '\u03b1' and an element 'a' of type '\u03b1', the corecursion of 'id' and 'f' on 'a' is equal to the iteration of 'f' on 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem corec_id_f_eq_iterate (f : \u03b1 \u2192 \u03b1) (a : \u03b1) : corec id f a = iterate f a :="}
{"input": "Statement in natural language:\nIf E has a second-countable topology, then for any model with corners I on E, the model space H also has a second-countable topology.\nTranslate the statement in natural language to Lean:", "output": "theorem secondCountableTopology [SecondCountableTopology E] (I : ModelWithCorners \ud835\udd5c E H) :\n    SecondCountableTopology H :="}
{"input": "Statement in natural language:\nWithin a unique differential set 's' at a point 'x' in a field '\ud835\udd5c', the derivative within the set 's' at 'x' of the function that evaluates a polynomial 'p' at 'x' is equal to the evaluation at 'x' of the derivative of the polynomial 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem derivWithin (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    derivWithin (fun x => p.eval x) s x = p.derivative.eval x :="}
{"input": "Statement in natural language:\nFor any three natural numbers a, b, and c, if b divides a and a divides c, then the result of dividing c by the result of dividing a by b, and then dividing that result by b, is equal to the result of dividing c by a.\nTranslate the statement in natural language to Lean:", "output": "theorem div_div_div_eq_div {a b c : \u2115} (dvd : b \u2223 a) (dvd2 : a \u2223 c) : c / (a / b) / b = c / a :="}
{"input": "Statement in natural language:\nThe support of a function 'f' (from some set '\u03b1' to a set 'M') is equal to the empty set if and only if the function 'f' is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem support_eq_empty {f : \u03b1 \u2192\u2080 M} : f.support = \u2205 \u2194 f = 0 :="}
{"input": "Statement in natural language:\nIf the set 's' is measurable and the conditional probability of 't' given 's' is not zero, then the measure of the intersection of 's' and 't' is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_pos_of_cond_ne_zero (hms : MeasurableSet s) (hcst : \u03bc[t|s] \u2260 0) : 0 < \u03bc (s \u2229 t) :="}
{"input": "Statement in natural language:\nThe function 'trunc', which maps from the ring of Laurent polynomials in T and T inverse to the ring of polynomials in X, is the left inverse of the function 'toLaurent'. This means that if you first apply 'toLaurent' and then 'trunc', you get back to where you started.\nTranslate the statement in natural language to Lean:", "output": "theorem leftInverse_trunc_toLaurent :\n    Function.LeftInverse (trunc : R[T;T\u207b\u00b9] \u2192 R[X]) Polynomial.toLaurent :="}
{"input": "Statement in natural language:\nUpdating the last element of a sequence obtained by appending an element 'x' to a sequence 'p' with a new element 'z' is equivalent to appending 'z' to the sequence 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem update_snoc_last : update (snoc p x) (last n) z = snoc p z :="}
{"input": "Statement in natural language:\nFor any nonempty finite set 's', the coercion of the maximum element of 's' (with respect to the proof that 's' is nonempty) is equal to the maximum element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_max' {s : Finset \u03b1} (hs : s.Nonempty) : \u2191(s.max' hs) = s.max :="}
{"input": "Statement in natural language:\nFor any list 'l' and for any two lists 'l\u2081' and 'l\u2082' of pairs in the form of Sigma \u03b2, if 'l\u2081' has no duplicate keys and 'l\u2081' is a permutation of 'l\u2082', then the key-union of 'l' and 'l\u2081' is a permutation of the key-union of 'l' and 'l\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem Perm.kunion_left :\n    \u2200 (l) {l\u2081 l\u2082 : List (Sigma \u03b2)}, l\u2081.NodupKeys \u2192 l\u2081 ~ l\u2082 \u2192 kunion l l\u2081 ~ kunion l l\u2082"}
{"input": "Statement in natural language:\nFor a sesquilinear form B on a module M\u2081 over a ring R with indices I\u2081 and I\u2081', a vector x is orthogonal to a vector y if and only if, under the flipped sesquilinear form, the vector y is orthogonal to the vector x.\nTranslate the statement in natural language to Lean:", "output": "theorem isOrtho_flip {B : M\u2081 \u2192\u209b\u2097[I\u2081] M\u2081 \u2192\u209b\u2097[I\u2081'] R} {x y} : B.IsOrtho x y \u2194 B.flip.IsOrtho y x :="}
{"input": "Statement in natural language:\nFor a Cauchy sequence of complex numbers, the limit of the conjugate of the sequence is equal to the conjugate of the limit of the sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem lim_conj (f : CauSeq \u2102 Complex.abs) : lim (cauSeqConj f) = conj (lim f) :="}
{"input": "Statement in natural language:\nIf the absolute value of a is less than b, then negative b is less than a.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_lt_of_abs_lt (h : |a| < b) : -b < a :="}
{"input": "Statement in natural language:\nThe map of the division of two functions 'f' and 'g' by a function 'm' is equal to the division of the map of function 'f' by 'm' and the map of function 'g' by 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_div : (f / g).map m = f.map m / g.map m :="}
{"input": "Statement in natural language:\nThe closure of the universal set in the set R is equal to the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_univ : closure (Set.univ : Set R) = \u22a4 :="}
{"input": "Statement in natural language:\nIf function f is eventually equal to function g with respect to filter l, then function f is eventually less than or equal to function g with respect to the same filter.\nTranslate the statement in natural language to Lean:", "output": "theorem EventuallyEq.le (h : f =\u1da0[l] g) : f \u2264\u1da0[l] g :="}
{"input": "Statement in natural language:\nIf we have a function 'f' that is continuous at a point 'a', and another function 'g' that is also continuous at the same point 'a', then the function that updates the value of 'f' at index 'i' with the value of 'g' at the same point is also continuous at 'a'. This is under the condition that the index 'i' is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousAt.update [DecidableEq \u03b9] {a : \u03b1} (hf : ContinuousAt f a) (i : \u03b9) {g : \u03b1 \u2192 \u03c0 i}\n    (hg : ContinuousAt g a) : ContinuousAt (fun a => update (f a) i (g a)) a :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that has a measure space and is sigma-finite with respect to the measure 'volume', the function 'finTwoArrow' (which is a measurable equivalence) preserves the measure 'volume'.\nTranslate the statement in natural language to Lean:", "output": "theorem volume_preserving_finTwoArrow (\u03b1 : Type u) [MeasureSpace \u03b1]\n    [SigmaFinite (volume : Measure \u03b1)] :\n    MeasurePreserving (@MeasurableEquiv.finTwoArrow \u03b1 _) volume volume :="}
{"input": "Statement in natural language:\nThe co-compact topology on a set \u03b1 has a basis consisting of the complements of compact sets.\nTranslate the statement in natural language to Lean:", "output": "theorem hasBasis_cocompact : (cocompact \u03b1).HasBasis IsCompact compl :="}
{"input": "Statement in natural language:\nIn the context of a preorder and a NoMaxOrder on a type \u03b1, the filter atTop is less than or equal to the cofinite filter.\nTranslate the statement in natural language to Lean:", "output": "theorem atTop_le_cofinite [Preorder \u03b1] [NoMaxOrder \u03b1] : (atTop : Filter \u03b1) \u2264 cofinite :="}
{"input": "Statement in natural language:\nFor any element 'a' of a multiplication zero class 'G\u2080', zero commutes with 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_left [MulZeroClass G\u2080] (a : G\u2080) : Commute 0 a :="}
{"input": "Statement in natural language:\nThe union of sets s and t is disjoint from set u if and only if both set s is disjoint from u and set t is disjoint from u.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_union_left : Disjoint (s \u222a t) u \u2194 Disjoint s u \u2227 Disjoint t u :="}
{"input": "Statement in natural language:\nThe function 'ofArrows' applied to any function from the unit type PUnit to 'f' is equal to the singleton set containing 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofArrows_pUnit : (ofArrows _ fun _ : PUnit => f) = singleton f :="}
{"input": "Statement in natural language:\nIf we have a faithful scalar multiplication of M and X, and if P and Q are elements of M such that P and Q are left projections of X, then P and Q commute.\nTranslate the statement in natural language to Lean:", "output": "theorem commute [FaithfulSMul M X] {P Q : M} (h\u2081 : IsLprojection X P) (h\u2082 : IsLprojection X Q) :\n    Commute P Q :="}
{"input": "Statement in natural language:\nA natural number 'i' is in the range of the successor function if and only if 'i' is greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Nat.mem_range_succ (i : \u2115) : i \u2208 range Nat.succ \u2194 0 < i :="}
{"input": "Statement in natural language:\nThe sine of pi divided by thirty-two is equal to the square root of two minus the square root of two plus the square root of two plus the square root of two, all divided by two.\nTranslate the statement in natural language to Lean:", "output": "theorem sin_pi_div_thirty_two : sin (\u03c0 / 32) = sqrt (2 - sqrt (2 + sqrt (2 + sqrt 2))) / 2 :="}
{"input": "Statement in natural language:\nThe Hausdorff distance of a set to itself is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem hausdorffDist_self_zero : hausdorffDist s s = 0 :="}
{"input": "Statement in natural language:\nIf the degree of a polynomial p is less than or equal to n and the coefficient of the nth term of the polynomial p is not zero, then the degree of the polynomial p is equal to n.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_eq_of_le_of_coeff_ne_zero (pn : p.degree \u2264 n) (p1 : p.coeff n \u2260 0) : p.degree = n :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from an arbitrary type '\u03b1' to natural numbers, if for every element 'a' in a set 's', 'f' of 'a' equals 'g' of 'a', then the multinomial of 's' and 'f' equals the multinomial of 's' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem multinomial_congr {f g : \u03b1 \u2192 \u2115} (h : \u2200 a \u2208 s, f a = g a) :\n    multinomial s f = multinomial s g :="}
{"input": "Statement in natural language:\nFor a continuous affine map 'f' from 'P' to 'Q', the coercion of 'f' to an affine map is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_to_affineMap (f : P \u2192A[R] Q) : ((f : P \u2192\u1d43[R] Q) : P \u2192 Q) = f :="}
{"input": "Statement in natural language:\nFor a multiplication-preserving and order-preserving function 'g' from '\u03b2' to '\u03b3', and two such functions 'f\u2081' and 'f\u2082' from '\u03b1' to '\u03b2', the composition of 'g' with the product of 'f\u2081' and 'f\u2082' is equal to the product of the composition of 'g' with 'f\u2081' and the composition of 'g' with 'f\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_mul (g : \u03b2 \u2192*\u2080o \u03b3) (f\u2081 f\u2082 : \u03b1 \u2192*\u2080o \u03b2) : g.comp (f\u2081 * f\u2082) = g.comp f\u2081 * g.comp f\u2082 :="}
{"input": "Statement in natural language:\nThe infimum of the set 's' and the union of sets 't\u2081' and 't\u2082' is equal to the union of the infimum of the set 's' and 't\u2081' and the infimum of the set 's' and 't\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem infs_union_right : s \u22bc (t\u2081 \u222a t\u2082) = s \u22bc t\u2081 \u222a s \u22bc t\u2082 :="}
{"input": "Statement in natural language:\nThe evaluation of the head of a vector 'v' is equal to the pure function applied to the head of 'v' as a singleton list.\nTranslate the statement in natural language to Lean:", "output": "theorem head_eval (v) : head.eval v = pure [v.headI] :="}
{"input": "Statement in natural language:\nIf 'b' is less than or equal to 'a', then the supremum (or join) of the difference of 'a' and 'b' and 'b' is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_sup_cancel (h : b \u2264 a) : a \\ b \u2294 b = a :="}
{"input": "Statement in natural language:\nA substructure N of M is finitely generated if and only if there exists a set S of M such that S is finite and the closure of S in L equals N.\nTranslate the statement in natural language to Lean:", "output": "theorem fg_def {N : L.Substructure M} : N.FG \u2194 \u2203 S : Set M, S.Finite \u2227 closure L S = N :="}
{"input": "Statement in natural language:\nThe cardinality (or size) of the intersection of edges between sets s and t is less than or equal to the product of the cardinalities of sets s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem card_interedges_le_mul (s : Finset \u03b1) (t : Finset \u03b2) :\n    (interedges r s t).card \u2264 s.card * t.card :="}
{"input": "Statement in natural language:\nFor any two homological complexes C\u2081 and C\u2082 in a category V with indexing category c, if C\u2081 is equal to C\u2082, then for any index n, the morphism function of the equality morphism between C\u2081 and C\u2082 at index n is equal to the equality morphism between the objects of C\u2081 and C\u2082 at index n. This equality is obtained by applying the function congruence and argument congruence to the homological complex objects of the equality h at index n.\nTranslate the statement in natural language to Lean:", "output": "theorem eqToHom_f {C\u2081 C\u2082 : HomologicalComplex V c} (h : C\u2081 = C\u2082) (n : \u03b9) :\n    HomologicalComplex.Hom.f (eqToHom h) n =\n      eqToHom (congr_fun (congr_arg HomologicalComplex.X h) n) :="}
{"input": "Statement in natural language:\nIf a function 'f' is summable, then the function that applies the complex conjugate operation (star) to 'f' is also summable.\nTranslate the statement in natural language to Lean:", "output": "theorem Summable.star (hf : Summable f) : Summable fun b => star (f b) :="}
{"input": "Statement in natural language:\nThe function that evaluates a polynomial at a point x is differentiable over the field \ud835\udd5c.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiable : Differentiable \ud835\udd5c fun x => p.eval x :="}
{"input": "Statement in natural language:\nFor any two partial extended natural numbers 'x' and 'y' with defined domains, 'x' is less than or equal to 'y' if and only if the value of 'x' obtained using 'hx' is less than or equal to the value of 'y' obtained using 'hy'.\nTranslate the statement in natural language to Lean:", "output": "theorem get_le_get {x y : PartENat} {hx : x.Dom} {hy : y.Dom} : x.get hx \u2264 y.get hy \u2194 x \u2264 y :="}
{"input": "Statement in natural language:\nFor any object 'a', the object of the multispan at the left of 'a' is equal to the left of 'a' in category theory 'I'.\nTranslate the statement in natural language to Lean:", "output": "theorem multispan_obj_left (a) : I.multispan.obj (WalkingMultispan.left a) = I.left a :="}
{"input": "Statement in natural language:\nThe coercion of 1 as a nonempty interval in the set \u03b1 is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_one : ((1 : NonemptyInterval \u03b1) : Set \u03b1) = 1 :="}
{"input": "Statement in natural language:\nFor any element 'a' and any lists 'l\u2081' and 'l\u2082', 'a' followed by 'l\u2081' is a sub-permutation of 'a' followed by 'l\u2082' if and only if 'l\u2081' is a sub-permutation of 'l\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem subperm_cons (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} : a :: l\u2081 <+~ a :: l\u2082 \u2194 l\u2081 <+~ l\u2082 :="}
{"input": "Statement in natural language:\nThe aleph number 0 is less than or equal to the aleph prime of an ordinal number 'o' if and only if the omega number is less than or equal to 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem aleph0_le_aleph' {o : Ordinal} : \u2135\u2080 \u2264 aleph' o \u2194 \u03c9 \u2264 o :="}
{"input": "Statement in natural language:\nFor a set 's' of symmetric pairs of type '\u03b1', applying the function 'fromRel' to the result of 'toRel_symmetric' applied to 's' returns the original set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem fromRel_toRel (s : Set (Sym2 \u03b1)) : fromRel (toRel_symmetric s) = s :="}
{"input": "Statement in natural language:\nThe theory of distinct constants in a language L is directed under the subset relation for any set \u03b1. This means that for any two sets of sentences in the theory, there is another set in the theory that contains both of them.\nTranslate the statement in natural language to Lean:", "output": "theorem directed_distinctConstantsTheory :\n    Directed (\u00b7 \u2286 \u00b7) (L.distinctConstantsTheory : Set \u03b1 \u2192 L[[\u03b1]].Theory) :="}
{"input": "Statement in natural language:\nFor any equivalence 'e' between two rings R and S, for every element 'x' in S, applying 'e' to the inverse of 'x' under 'e' gives back 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_symm_apply (e : R \u2243+* S) : \u2200 x, e (e.symm x) = x :="}
{"input": "Statement in natural language:\nFor a given compact open set K in a topological space \u03b1, mapping K with the identity function under the conditions of continuous identity and identity open map, results in the original set K.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id (K : CompactOpens \u03b1) : K.map id continuous_id IsOpenMap.id = K :="}
{"input": "Statement in natural language:\nFor any integer 'n', there exists an integer 'k' such that 'n' is either equal to twice 'k' or twice 'k' plus one. This is essentially stating that any integer is either even or odd.\nTranslate the statement in natural language to Lean:", "output": "theorem even_or_odd' (n : \u2124) : \u2203 k, n = 2 * k \u2228 n = 2 * k + 1 :="}
{"input": "Statement in natural language:\nFor any two cones 's' and 't' of a functor 'F' where 's' and 't' are limits, for any object 'j' in the index category 'J', the composition of the morphism from the unique isomorphism from 's' to 't' and the projection of 't' at 'j' is equal to the projection of 's' at 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem conePointUniqueUpToIso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).hom \u226b t.\u03c0.app j = s.\u03c0.app j :="}
{"input": "Statement in natural language:\nFor any types 'xl' and 'xr', and any functions 'xL' from 'xl' to PGame and 'xR' from 'xr' to PGame, and any element 'i' of 'xr', the PGame 'xR i' is an option of the PGame constructed by 'mk' from 'xl', 'xr', 'xL', and 'xR'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsOption.mk_right {xl xr : Type u} (xL : xl \u2192 PGame) (xR : xr \u2192 PGame) (i : xr) :\n    (xR i).IsOption (mk xl xr xL xR) :="}
{"input": "Statement in natural language:\nThe scalar multiplication of a set 's' and the negation of a set 't' is equal to the negation of the scalar multiplication of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_neg : s \u2022 -t = -(s \u2022 t) :="}
{"input": "Statement in natural language:\nIf a is covered by b (denoted as a \u22d6 b), then if a is less than c, it follows that b is less than or equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem Covby.ge_of_gt (hab : a \u22d6 b) : a < c \u2192 b \u2264 c :="}
{"input": "Statement in natural language:\nFor a function from natural numbers to any set \u03b1, the pairwise disjoint property holds for the disjointed version of the function. This means that for any two different natural numbers, the corresponding disjointed sets from the function do not share any common elements.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_disjointed (f : \u2115 \u2192 \u03b1) : Pairwise (Disjoint on disjointed f) :="}
{"input": "Statement in natural language:\nThe boundary of the double negation of a proposition 'a' is equal to the boundary of the negation of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem boundary_hnot_hnot (a : \u03b1) : \u2202 (\uffe2\uffe2a) = \u2202 (\uffe2a) :="}
{"input": "Statement in natural language:\nA set 's' is bounded if and only if there exists a radius 'r' such that 's' is a subset of the closed ball centered at 'c' with radius 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem bounded_iff_subset_ball (c : \u03b1) : Bounded s \u2194 \u2203 r, s \u2286 closedBall c r :="}
{"input": "Statement in natural language:\nFor any set S of elements of type \u03b1 and any bijective function f from \u03b1 to \u03b2, the image of S under f is equal to the preimage of S under the inverse of f.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Set.image_equiv_eq_preimage_symm {\u03b1 \u03b2} (S : Set \u03b1) (f : \u03b1 \u2243 \u03b2) :\n    f '' S = f.symm \u207b\u00b9' S :="}
{"input": "Statement in natural language:\nFor any multiset 't' of type '\u03b9', any function 'f' from '\u03b9' to a set of '\u03b1', and any function 'g' from '\u03b9' to '\u03b1', if for all elements 'i' in 't', 'g' of 'i' is an element of 'f' of 'i', then the product of the multiset 't' mapped by 'g' is an element of the product of the multiset 't' mapped by 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem multiset_prod_mem_multiset_prod (t : Multiset \u03b9) (f : \u03b9 \u2192 Set \u03b1) (g : \u03b9 \u2192 \u03b1)\n    (hg : \u2200 i \u2208 t, g i \u2208 f i) : (t.map g).prod \u2208 (t.map f).prod :="}
{"input": "Statement in natural language:\nFor any two objects X and Y in category C, the monoidal product of functors F and G applied to X and Y is equal to the tuple of the monoidal product of functor F applied to X and Y and the monoidal product of functor G applied to X and Y.\nTranslate the statement in natural language to Lean:", "output": "theorem prod'_\u03bc (X Y : C) : (F.prod' G).\u03bc X Y = (F.\u03bc X Y, G.\u03bc X Y) :="}
{"input": "Statement in natural language:\nFor a given point 'x' in a topological space '\u03b1' and a given filter 'f' on '\u03b1', if 'f' is less than or equal to the neighborhood filter at 'x' and 'f' is not the bottom element, then 'x' is a cluster point of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem ClusterPt.of_le_nhds {x : \u03b1} {f : Filter \u03b1} (H : f \u2264 \ud835\udcdd x) [NeBot f] : ClusterPt x f :="}
{"input": "Statement in natural language:\nA unit \u03b6 in ring R is a kth root of unity if and only if \u03b6 is among the kth roots of 1 in R.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_rootsOfUnity_iff_mem_nthRoots {\u03b6 : R\u02e3} :\n    \u03b6 \u2208 rootsOfUnity k R \u2194 (\u03b6 : R) \u2208 nthRoots k (1 : R) :="}
{"input": "Statement in natural language:\nFor any element 'a' in group 'G', the division of 'a' by itself equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem div_self' (a : G) : a / a = 1 :="}
{"input": "Statement in natural language:\nFor any two objects X and Y in category C, and any morphism f from X to Y, the composition of the application of the counit natural transformation at X and the mapping of f under the functor applied to the monoidal unit is equal to the composition of f and the application of the counit natural transformation at Y.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03b5_naturality {X Y : C} (f : X \u27f6 Y) : F.\u03b5.app X \u226b (F.obj (\ud835\udfd9_ M)).map f = f \u226b F.\u03b5.app Y :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of type '\u03b2' and a function 'f' from '\u03b2' to '\u03b1', the infinite sum over the set 's' of the function 'f' is equal to the finite sum over 's' of the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finset.tsum_subtype' (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    (\u2211' x : (s : Set \u03b2), f x) = \u2211 x in s, f x :="}
{"input": "Statement in natural language:\nFor an array 'arr' of elements of type \u03b1 and a function 'm' that maps elements of type Fin n to \u03b2, if 'arr' and 'f' agree according to 'm', then 'n' is equal to the size of 'arr'.\nTranslate the statement in natural language to Lean:", "output": "theorem size_eq {arr : Array \u03b1} {m : Fin n \u2192 \u03b2} (H : Agrees arr f m) :\n  n = arr.size :="}
{"input": "Statement in natural language:\nFor any topological space \u03b1, the function ULift.up, which maps \u03b1 to ULift of \u03b1, is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_uLift_up [TopologicalSpace \u03b1] : Continuous (ULift.up : \u03b1 \u2192 ULift.{v, u} \u03b1) :="}
{"input": "Statement in natural language:\nThe domain of a scalar multiple of a linear map is the same as the domain of the original linear map.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_domain (a : M) (f : E \u2192\u2097.[R] F) : (a \u2022 f).domain = f.domain :="}
{"input": "Statement in natural language:\nFor any real numbers p and q that are conjugate exponents, and for any two almost everywhere measurable functions f and g from \u03b1 to the nonnegative extended real numbers, if the integral of f to the power of p and the integral of g to the power of p are both not equal to positive infinity, then the integral of the sum of f and g to the power of p is less than or equal to the sum of the pth power integrals of f and g, each raised to the power of 1/p, times the integral of the sum of f and g to the power of p, raised to the power of 1/q.\nTranslate the statement in natural language to Lean:", "output": "theorem lintegral_rpow_add_le_add_snorm_mul_lintegral_rpow_add {p q : \u211d}\n    (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n    (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) (hg : AEMeasurable g \u03bc) (hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2264\n      ((\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)) *\n        (\u222b\u207b a, (f a + g a) ^ p \u2202\u03bc) ^ (1 / q) :="}
{"input": "Statement in natural language:\nIf a function is locally integrable on a set under a measure, given that the topology of the set is second-countable, then the function is almost everywhere strongly measurable when the measure is restricted to the set.\nTranslate the statement in natural language to Lean:", "output": "theorem LocallyIntegrableOn.aestronglyMeasurable [SecondCountableTopology X]\n    (hf : LocallyIntegrableOn f s \u03bc) : AEStronglyMeasurable f (\u03bc.restrict s) :="}
{"input": "Statement in natural language:\nFor any injective function 'f' from type '\u03b1' to type '\u03b2', the composition of 'f' and the inverse of 'f' (obtained from the fact that 'f' is injective) is equal to the function that retrieves the value of a subtype.\nTranslate the statement in natural language to Lean:", "output": "theorem self_comp_ofInjective_symm {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    f \u2218 (ofInjective f hf).symm = Subtype.val :="}
{"input": "Statement in natural language:\nFor any natural number 'k' and any two polynomials 'f' and 'g' over a ring 'R', the 'k'-th derivative of the difference of 'f' and 'g' is equal to the difference of the 'k'-th derivative of 'f' and the 'k'-th derivative of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_derivative_sub {k : \u2115} {f g : R[X]} :\n    (derivative^[k]) (f - g) = (derivative^[k]) f - (derivative^[k]) g :="}
{"input": "Statement in natural language:\nFor any linear order \u03b1, if it is not true that a is less than b, and b is equal to b', then b' is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem of_not_lt_right [LinearOrder \u03b1] (h : \u00ac(a:\u03b1) < b) (eq : b = b') : b' \u2264 a :="}
{"input": "Statement in natural language:\nTaking zero elements from any given stream results in an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem take_zero (s : Stream' \u03b1) : take 0 s = [] :="}
{"input": "Statement in natural language:\nIf a set S is a subset of or equal to a set R, and if S is an element of the site J on X, then R is also an element of the site J on X.\nTranslate the statement in natural language to Lean:", "output": "theorem superset_covering (Hss : S \u2264 R) (sjx : S \u2208 J X) : R \u2208 J X :="}
{"input": "Statement in natural language:\nFor two star subalgebras S\u2081 and S\u2082 of a ring R and an algebra A, S\u2081 is less than or equal to S\u2082 in terms of their corresponding subalgebras if and only if S\u2081 is less than or equal to S\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem toSubalgebra_le_iff {S\u2081 S\u2082 : StarSubalgebra R A} :\n    S\u2081.toSubalgebra \u2264 S\u2082.toSubalgebra \u2194 S\u2081 \u2264 S\u2082 :="}
{"input": "Statement in natural language:\nFor any element 'x' in the ring of fractions 'R[S\u207b\u00b9]', multiplying 'x' by 1 results in 'x'. This is the multiplicative identity property.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_one (x : R[S\u207b\u00b9]) : x * 1 = x :="}
{"input": "Statement in natural language:\nIf an element 'a' is not in list 'l' and list 'l' contains no duplicate elements (Nodup), then the list resulting from concatenating 'a' to 'l' will also contain no duplicate elements.\nTranslate the statement in natural language to Lean:", "output": "theorem Nodup.concat (h : a \u2209 l) (h' : l.Nodup) : (l.concat a).Nodup :="}
{"input": "Statement in natural language:\nFor a pseudo-epimorphism 'f' from '\u03b1' to '\u03b2', the function 'f.toFun' is equal to the function 'f' when it is considered as a function from '\u03b1' to '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem toFun_eq_coe {f : PseudoEpimorphism \u03b1 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2) :="}
{"input": "Statement in natural language:\nFor any pair of elements from two groups with inverses, the inverse of the swapped pair is equal to the swap of the inverse pair.\nTranslate the statement in natural language to Lean:", "output": "theorem swap_inv [Inv G] [Inv H] (p : G \u00d7 H) : p\u207b\u00b9.swap = p.swap\u207b\u00b9 :="}
{"input": "Statement in natural language:\nThe set obtained by dividing set 's' by the interior of set 't' is a subset of the interior of the set obtained by dividing 's' by 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_interior_div_right : s / interior t \u2286 interior (s / t) :="}
{"input": "Statement in natural language:\nIf a ring homomorphism function 'f' is surjective, then 'f' is integral.\nTranslate the statement in natural language to Lean:", "output": "theorem RingHom.isIntegral_of_surjective (hf : Function.Surjective f) : f.IsIntegral :="}
{"input": "Statement in natural language:\nFor any types c, f\u2081, f\u2082, r\u2081, r\u2082, the set of constants in the language created with these types (using the function Language.mk\u2082) is equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem constants_mk\u2082 (c f\u2081 f\u2082 : Type u) (r\u2081 r\u2082 : Type v) :\n    (Language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082).Constants = c :="}
{"input": "Statement in natural language:\nIf 'f' is a function that maps closed sets to closed sets (i.e., 'f' is a closed map), then the function that restricts the preimage of 'f' to a set 's' is also a closed map.\nTranslate the statement in natural language to Lean:", "output": "theorem Set.restrictPreimage_isClosedMap (s : Set \u03b2) (H : IsClosedMap f) :\n    IsClosedMap (s.restrictPreimage f) :="}
{"input": "Statement in natural language:\nFor a given predicate 'p', an element 'a', and a multiset 's', if 'a' does not satisfy the predicate 'p', then the count of 'a' in the multiset that results from filtering 's' with 'p' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem count_filter_of_neg {p} [DecidablePred p] {a} {s : Multiset \u03b1} (h : \u00acp a) :\n    count a (filter p s) = 0 :="}
{"input": "Statement in natural language:\nFor any object 'Z' in category 'C' and any morphism 'f' from 'Z' to 'M.X', the composition of the tensor product of 'f' and 'M.one' with 'M.mul' is equal to the composition of the right unitor at 'Z' with 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_one_hom {Z : C} (f : Z \u27f6 M.X) : (f \u2297 M.one) \u226b M.mul = (\u03c1_ Z).hom \u226b f :="}
{"input": "Statement in natural language:\nFor a non-zero polynomial 'p', the natural number equivalent of its trailing degree is equal to the minimum of its support set, given that the support set is non-empty.\nTranslate the statement in natural language to Lean:", "output": "theorem natTrailingDegree_eq_support_min' (h : p \u2260 0) :\n    natTrailingDegree p = p.support.min' (nonempty_support_iff.mpr h) :="}
{"input": "Statement in natural language:\nFor any finite type \u03b1, there exists a natural number n such that \u03b1 is equivalent to the finite sequence of natural numbers less than n.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.exists_equiv_fin (\u03b1 : Sort _) [h : Finite \u03b1] : \u2203 n : \u2115, Nonempty (\u03b1 \u2243 Fin n) :="}
{"input": "Statement in natural language:\nFor a given subspace W of the dual space of a vector space V over a field K, the sum of the finite dimension of W and the finite dimension of the coannihilator of W in the dual space is equal to the finite dimension of V.\nTranslate the statement in natural language to Lean:", "output": "theorem finrank_add_finrank_dualCoannihilator_eq (W : Subspace K (Module.Dual K V)) :\n    finrank K W + finrank K W.dualCoannihilator = finrank K V :="}
{"input": "Statement in natural language:\nIf a function 'f' is antitone (non-increasing) on the closed interval from 'a' to 'b' (inclusive), then the integral of 'f' from 'a' to 'b' is less than or equal to the sum of 'f' over the half-open interval from 'a' to 'b' (inclusive of 'a' but not 'b').\nTranslate the statement in natural language to Lean:", "output": "theorem AntitoneOn.integral_le_sum_Ico (hab : a \u2264 b) (hf : AntitoneOn f (Set.Icc a b)) :\n    (\u222b x in a..b, f x) \u2264 \u2211 x in Finset.Ico a b, f x :="}
{"input": "Statement in natural language:\nFor a given scalar 'r' from the ring 'R', the map of the scalar multiplication of 'r' and polynomial 'p' is equal to the scalar multiplication of the map of 'r' and the map of polynomial 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_smul (r : R) : (r \u2022 p).map f = f r \u2022 p.map f :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'd' and 'n', where 'd' is less than 'n', there frequently exists a natural number 'm' such that the remainder of 'm' divided by 'n' equals 'd'. This is under the condition that 'm' approaches infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem frequently_mod_eq {d n : \u2115} (h : d < n) : \u2203\u1da0 m in atTop, m % n = d :="}
{"input": "Statement in natural language:\nFor a given set function 's' indexed by '\u03b9' in a preorder, if 's' is antitone (meaning it reverses the order), and given a function 'f' from '\u03b1' to '\u03b2' where '\u03b2' is a zero element, and an element 'a' of '\u03b1', then the function that maps 'i' to the indicator function of 's i' and 'f' at 'a' tends to the indicator function of the intersection of all 's i' and 'f' at 'a' as 'i' tends to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem Antitone.tendsto_indicator {\u03b9} [Preorder \u03b9] [Zero \u03b2] (s : \u03b9 \u2192 Set \u03b1) (hs : Antitone s)\n    (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    Tendsto (fun i => indicator (s i) f a) atTop (pure <| indicator (\u22c2 i, s i) f a) :="}
{"input": "Statement in natural language:\nFor a given pair of elements (x : \u03b1 \u00d7 \u03b2), if the set of neighbors of x.1 in graph G, the set of neighbors of x.2 in graph H, and the set of neighbors of x in the box product of G and H are all finite, then the degree of x in the box product of G and H is equal to the sum of the degree of x.1 in G and the degree of x.2 in H.\nTranslate the statement in natural language to Lean:", "output": "theorem boxProd_degree (x : \u03b1 \u00d7 \u03b2)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] [Fintype ((G \u25a1 H).neighborSet x)] :\n    (G \u25a1 H).degree x = G.degree x.1 + H.degree x.2 :="}
{"input": "Statement in natural language:\nA set of non-negative rational numbers 's' is bounded above if and only if the set of real numbers obtained by applying the function '\u2191' to each element of 's' is also bounded above.\nTranslate the statement in natural language to Lean:", "output": "theorem bddAbove_coe {s : Set \u211a\u22650} : BddAbove ((\u2191) '' s : Set \u211a) \u2194 BddAbove s :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't' of a certain type 'M', and any two elements 'a' and 'b' of the same type 'M', if 'a' is in the lower bounds of set 's' and 'b' is in the lower bounds of set 't', then the product of 'a' and 'b' is in the lower bounds of the product set of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_mem_lowerBounds_mul {s t : Set M} {a b : M} (ha : a \u2208 lowerBounds s)\n    (hb : b \u2208 lowerBounds t) : a * b \u2208 lowerBounds (s * t) :="}
{"input": "Statement in natural language:\nFor a given clopen set 's' in a topological space '\u03b1', the set generated by the function 'mk' with 's' and a proof 'h' is equal to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mk (s : Clopens \u03b1) (h) : (mk s h : Set \u03b1) = s :="}
{"input": "Statement in natural language:\nThe finite rank of a field extension F to K is equal to one if and only if K is the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem finrank_eq_one_iff : finrank F K = 1 \u2194 K = \u22a5 :="}
{"input": "Statement in natural language:\nIf functions f and g are integrable, then the sum of functions f and g is also integrable.\nTranslate the statement in natural language to Lean:", "output": "theorem Integrable.add {f g : \u03b1 \u2192\u2098[\u03bc] \u03b2} : Integrable f \u2192 Integrable g \u2192 Integrable (f + g) :="}
{"input": "Statement in natural language:\nThe composition of a linear isometry 'e' and the reflexive relation on the normed vector space 'E\u2082' over the field 'R\u2082' is equal to 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem trans_refl : e.trans (refl R\u2082 E\u2082) = e :="}
{"input": "Statement in natural language:\nFor any two indices i and j in a complex C, if there is a relation r between i and j, then the differential from i in C is equal to the composition of the differential from i to j in C and the inverse of the next isomorphism from r in C.\nTranslate the statement in natural language to Lean:", "output": "theorem dFrom_eq {i j : \u03b9} (r : c.Rel i j) : C.dFrom i = C.d i j \u226b (C.xNextIso r).inv :="}
{"input": "Statement in natural language:\nFor a given ring homomorphism 'f' from ring 'R' to ring 'S', a given element 'x' from ring 'S', and a given polynomial 'p' from the additive monoid algebra of 'R' over natural numbers, the evaluation of the polynomial 'p' at 'x' using the homomorphism 'f' is equal to the lift of the natural numbers to the powers of 'x' in ring 'S' applied to 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem eval\u2082_ofFinsupp {f : R \u2192+* S} {x : S} {p : AddMonoidAlgebra R \u2115} :\n    eval\u2082 f x (\u27e8p\u27e9 : R[X]) = liftNC (\u2191f) (powersHom S x) p :="}
{"input": "Statement in natural language:\nThe closure of a linear map 'f' from a module 'E' to another module 'F' over a ring 'R' has its core as the domain of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem closureHasCore (f : E \u2192\u2097.[R] F) : f.closure.HasCore f.domain :="}
{"input": "Statement in natural language:\nFor a function from natural numbers to a type \u03b1, and for any natural number k, the supremum over all n of the infimum over all i greater than or equal to n of the function applied to (i + k) is equal to the supremum over all n of the infimum over all i greater than or equal to n of the function applied to i.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_iInf_ge_nat_add (f : \u2115 \u2192 \u03b1) (k : \u2115) :\n    (\u2a06 n, \u2a05 i \u2265 n, f (i + k)) = \u2a06 n, \u2a05 i \u2265 n, f i :="}
{"input": "Statement in natural language:\nFor any three natural numbers m, n, and k, m is coprime with (n + k * m) if and only if m is coprime with n.\nTranslate the statement in natural language to Lean:", "output": "theorem coprime_add_mul_right_right (m n k : \u2115) : coprime m (n + k * m) \u2194 coprime m n :="}
{"input": "Statement in natural language:\nFor a property 'p' pertaining to an element 'a' of type 'hat\u03b1', if the set of elements for which 'p' holds is closed, and 'p' holds for all elements in the image of 'a' under the function '\u03b9', then 'p' holds for 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem induction_on {p : hat\u03b1 \u2192 Prop} (a : hat\u03b1) (hp : IsClosed { a | p a }) (ih : \u2200 a, p (\u03b9 a)) :\n    p a :="}
{"input": "Statement in natural language:\nIf 'a' is less than 'b' (where 'a' and 'b' are associates in algebra), then 'a' divides 'b' but 'a' is not a unit of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvdNotUnit_of_lt {a b : Associates \u03b1} (hlt : a < b) : DvdNotUnit a b :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from an index set '\u03b9' to a set 'M' that has an addition operation and a zero element, the direct sum of 'f' and 'g' converted to a decidable function is equal to the sum of 'f' and 'g' each converted to a decidable function.\nTranslate the statement in natural language to Lean:", "output": "theorem toDfinsupp_add [AddZeroClass M] (f g : \u03b9 \u2192\u2080 M) :\n    (f + g).toDfinsupp = f.toDfinsupp + g.toDfinsupp :="}
{"input": "Statement in natural language:\nFor a given property M of multivariate polynomials over a ring R with variables from a set \u03c3, if the property holds for all constant polynomials, and if the property is preserved under addition and multiplication by a variable, then the property holds for all multivariate polynomials.\nTranslate the statement in natural language to Lean:", "output": "theorem induction_on {M : MvPolynomial \u03c3 R \u2192 Prop} (p : MvPolynomial \u03c3 R) (h_C : \u2200 a, M (C a))\n    (h_add : \u2200 p q, M p \u2192 M q \u2192 M (p + q)) (h_X : \u2200 p n, M p \u2192 M (p * X n)) : M p :="}
{"input": "Statement in natural language:\nThe cardinality of the set of all terms in the language L, where the terms are formed over a sum of a set \u03b1 and a finite set of size n, is equal to the maximum of the cardinality of the set of all aleph-null (\u2135\u2080, a cardinal number representing the size of the set of all natural numbers) and the cardinality of the sum of the set \u03b1 and the set of all functions in the language L for each i.\nTranslate the statement in natural language to Lean:", "output": "theorem card_sigma : (#\u03a3n, L.Term (Sum \u03b1 (Fin n))) = max \u2135\u2080 (#Sum \u03b1 (\u03a3i, L.Functions i)) :="}
{"input": "Statement in natural language:\nThe left inverse of 1 in the submonoid S is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem fromLeftInv_one : S.fromLeftInv 1 = 1 :="}
{"input": "Statement in natural language:\nA function 'f' is injective if and only if the kernel of 'f' is the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem injective_iff_ker_eq_bot : Function.Injective f \u2194 ker f = \u22a5 :="}
{"input": "Statement in natural language:\nFor a given algebra homomorphism 'f' from algebra 'A' to algebra 'B' over a commutative ring 'R', and for any element 'x' in 'A', the action of applying the algebra evaluation map to the image of 'x' under 'f' is the same as first applying the algebra evaluation map to 'x' and then composing the result with 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem aeval_algHom (f : A \u2192\u2090[R] B) (x : A) : aeval (f x) = f.comp (aeval x) :="}
{"input": "Statement in natural language:\nThe Lie bracket of two ideals I and J is less than or equal to the intersection of I and J.\nTranslate the statement in natural language to Lean:", "output": "theorem lie_le_inf : \u2045I, J\u2046 \u2264 I \u2293 J :="}
{"input": "Statement in natural language:\nIf 'f' is a strictly decreasing function, and for all 'p', 'p' is less than or equal to 'f a', then 'a' is less than or equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictAnti.minimal_of_maximal_image (hf : StrictAnti f) {a} (hmax : \u2200 p, p \u2264 f a) (x : \u03b1) :\n    a \u2264 x :="}
{"input": "Statement in natural language:\nIf a functor composition F following G preserves epimorphisms and G reflects epimorphisms, then F also preserves epimorphisms.\nTranslate the statement in natural language to Lean:", "output": "theorem preservesEpimorphisms_of_preserves_of_reflects (F : C \u2964 D) (G : D \u2964 E)\n    [PreservesEpimorphisms (F \u22d9 G)] [ReflectsEpimorphisms G] : PreservesEpimorphisms F :="}
{"input": "Statement in natural language:\nThe sum of the floor of f at 0 and the floor of g at 0 is less than or equal to the floor of f at the value of g at 0.\nTranslate the statement in natural language to Lean:", "output": "theorem le_floor_map_map_zero : \u230af 0\u230b + \u230ag 0\u230b \u2264 \u230af (g 0)\u230b :="}
{"input": "Statement in natural language:\nIf x and z are disjoint, z is less than or equal to y, and y is less than or equal to the union of x and z, then the set difference of y and x equals z.\nTranslate the statement in natural language to Lean:", "output": "theorem Disjoint.sdiff_unique (hd : Disjoint x z) (hz : z \u2264 y) (hs : y \u2264 x \u2294 z) :\n    y \\ x = z :="}
{"input": "Statement in natural language:\nFor any elements 'a' from set \u03b1 and 'b' from set \u03b2, and any function 'f' from \u03b1 to \u03b2 to \u03b3 that is uniformly continuous, the mapping of 'f' on the elements 'a' and 'b' in the packages pkg and pkg' respectively, is equal to the element in the package pkg'' that is the result of applying 'f' on 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_coe_coe (a : \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf : UniformContinuous\u2082 f) :\n    pkg.map\u2082 pkg' pkg'' f (\u03b9 a) (\u03b9' b) = \u03b9'' (f a b) :="}
{"input": "Statement in natural language:\nFor any measurable space '\u03b1' and any element 'b' of type '\u03b2', the range of the constant function (which maps every element of '\u03b1' to 'b') is a subset of the set containing only 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_const_subset (\u03b1) [MeasurableSpace \u03b1] (b : \u03b2) : (const \u03b1 b).range \u2286 {b} :="}
{"input": "Statement in natural language:\nFor any index 'i' and any element 'x' from the set '\u03b1s' indexed by 'i', applying the 'split' function to 'l', 'i', and 'x' is equal to applying 'l' to the pair consisting of 'i' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem split_apply (i : \u03b9) (x : \u03b1s i) : split l i x = l \u27e8i, x\u27e9 :="}
{"input": "Statement in natural language:\nFor a given element 'r' from the ring 'R', the function '\u03c6' applied to the algebraic mapping of 'r' from 'R' to 'A' is equal to the algebraic mapping of 'r' from 'R' to 'B'. This means that the function '\u03c6' commutes with the algebraic mapping.\nTranslate the statement in natural language to Lean:", "output": "theorem commutes (r : R) : \u03c6 (algebraMap R A r) = algebraMap R B r :="}
{"input": "Statement in natural language:\nFor a given group G, with a scalar multiplication operation on a ring R and a multiplication action on a module M, and assuming that G is a scalar tower, the span of the scalar multiplication of an element g from G and an element x from M is equal to the span of the element x. This means that scaling x by g does not change the span of x.\nTranslate the statement in natural language to Lean:", "output": "theorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M]\n    (g : G) (x : M) : (R \u2219 g \u2022 x) = R \u2219 x :="}
{"input": "Statement in natural language:\nFor a given lower set 's' of type '\u03b1', 's' is a lower set in the context of set '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem lower (s : LowerSet \u03b1) : IsLowerSet (s : Set \u03b1) :="}
{"input": "Statement in natural language:\nThe cosine of the negative of an angle is equal to the cosine of the angle itself.\nTranslate the statement in natural language to Lean:", "output": "theorem cos_neg (\u03b8 : Angle) : cos (-\u03b8) = cos \u03b8 :="}
{"input": "Statement in natural language:\nIf for all 'a' greater than 'b', the predecessor of 'a' is less than 'b', then 'b' is a predecessor limit.\nTranslate the statement in natural language to Lean:", "output": "theorem isPredLimit_of_pred_lt (H : \u2200 a > b, pred a < b) : IsPredLimit b :="}
{"input": "Statement in natural language:\nThe maximum function is commutative for any two elements of type \u03b1. This means that the order in which the elements are inputted into the function does not affect the output; the maximum of a and b is the same as the maximum of b and a.\nTranslate the statement in natural language to Lean:", "output": "theorem max_commutative : Commutative (max : \u03b1 \u2192 \u03b1 \u2192 \u03b1) :="}
{"input": "Statement in natural language:\nFor any element 'x' of type '\u03b2', any function 'f' from '\u03b1' to '\u03b2', and any element 'a' of type '\u03b1', applying the 'casesOn'' function to an option of '\u03b1' with 'x' and 'f' is equal to applying the function 'f' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem casesOn'_coe (x : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : casesOn' (a : Option \u03b1) x f = f a :="}
{"input": "Statement in natural language:\nThe zero element of a submodule 'p' of a module 'M', when considered as an element of 'M', is equal to the zero element of 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_zero : ((0 : p) : M) = 0 :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that is a linearly ordered commutative ring with a floor function, given two elements a and b of \u03b1, if the floor of a is equal to the floor of b, then the absolute value of the difference between a and b is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_sub_lt_one_of_floor_eq_floor {\u03b1 : Type _} [LinearOrderedCommRing \u03b1] [FloorRing \u03b1]\n    {a b : \u03b1} (h : \u230aa\u230b = \u230ab\u230b) : |a - b| < 1 :="}
{"input": "Statement in natural language:\nFor any index 'x' of a vector space over a field 'K' with vectors 'V', applying the function 'ofVectorSpace' to 'x' will yield 'x' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem ofVectorSpace_apply_self (x : ofVectorSpaceIndex K V) : ofVectorSpace K V x = x :="}
{"input": "Statement in natural language:\nFor a given ring R and module M, both having zero elements, and a function f from a class of zero homomorphisms between R and M, if the result of applying f to a certain element r of R is not zero, then the element r itself is not zero.\nTranslate the statement in natural language to Lean:", "output": "theorem of_map {R M} [Zero R] [Zero M] [ZeroHomClass F R M]\n  (f : F) {r : R} [neZero : NeZero (f r)] : NeZero r :="}
{"input": "Statement in natural language:\nFor any element 'a' of a set '\u03b1' that has an inverse, the inverse of 'toLex a' is equal to 'toLex' of the inverse of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem toLex_inv [Inv \u03b1] (a : \u03b1) : toLex a\u207b\u00b9 = (toLex a)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nIn a contravariant class of type \u03b1, for any two elements 'a' and 'b' of type \u03b1, if the product of 'a' and 'b' is less than 'b', then 'a' is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_one_of_mul_lt_left [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1}\n    (h : a * b < b) :\n    a < 1 :="}
{"input": "Statement in natural language:\nThe exponential of the inverse hyperbolic sine of a real number x is equal to x plus the square root of 1 plus x squared.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_arsinh (x : \u211d) : exp (arsinh x) = x + sqrt (1 + x ^ 2) :="}
{"input": "Statement in natural language:\nFor any two real numbers x and y, if x is less than y, then there exists a rational number q such that x is less than q and q is less than y.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_rat_btwn {x y : \u03b1} (h : x < y) : \u2203 q : \u211a, x < q \u2227 (q : \u03b1) < y :="}
{"input": "Statement in natural language:\nFor any element 'x' in 'A', the function that maps an element from the star algebra over 'R' and 'x' to 'A' is a closed embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem closedEmbedding_coe (x : A) : ClosedEmbedding ((\u2191) : elementalStarAlgebra R x \u2192 A) :="}
{"input": "Statement in natural language:\nThe intersection of the closed intervals from a\u2081 to b\u2081 and from a\u2082 to b\u2082 is equal to the closed interval from the maximum of a\u2081 and a\u2082 to the minimum of b\u2081 and b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_inter_Icc : Icc a\u2081 b\u2081 \u2229 Icc a\u2082 b\u2082 = Icc (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082) :="}
{"input": "Statement in natural language:\nFor a given element 'm' of set 'M', 'f m' equals zero if and only if there exists an element 's'' in set 'S' such that the scalar multiplication of 's'' and 'm' equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_zero_iff {m : M} : f m = 0 \u2194 \u2203 s' : S, s' \u2022 m = 0 :="}
{"input": "Statement in natural language:\nIf the product of 'a' and 'b' equals one, then 'a' cannot be zero.\nTranslate the statement in natural language to Lean:", "output": "theorem left_ne_zero_of_mul_eq_one (h : a * b = 1) : a \u2260 0 :="}
{"input": "Statement in natural language:\nThe function f has a strict Frechet derivative at point x if and only if it has a strict derivative at point x with respect to the linear map f' applied to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem hasStrictFDerivAt_iff_hasStrictDerivAt {f' : \ud835\udd5c \u2192L[\ud835\udd5c] F} :\n    HasStrictFDerivAt f f' x \u2194 HasStrictDerivAt f (f' 1) x :="}
{"input": "Statement in natural language:\nFor a given multiset 's' of type \u03b1 and a function 'f' that maps from \u03b1 to a multiset of type \u03b2, binding the function 'f' to the attached elements of 's' is equivalent to binding 'f' directly to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem attach_bind_coe (s : Multiset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) :\n    (s.attach.bind fun i => f i) = s.bind f :="}
{"input": "Statement in natural language:\nFor any two cones 's' and 't' of a functor 'F', if 'P' is a limit of 's' and 'Q' is a limit of 't', then for any object 'j' in the index category 'J', the composition of the inverse of the unique isomorphism from 's' to 't' and the morphism from 's' to 'j' is equal to the morphism from 't' to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem conePointUniqueUpToIso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).inv \u226b s.\u03c0.app j = t.\u03c0.app j :="}
{"input": "Statement in natural language:\nFor any odd number 'n', the power of -1 raised to 'n' equals -1.\nTranslate the statement in natural language to Lean:", "output": "theorem Odd.neg_one_pow (h : Odd n) : (-1 : \u03b1) ^ n = -1 :="}
{"input": "Statement in natural language:\nFor any two types G and H, where both are groups, if there exists a surjective group homomorphism from G to H, then the cardinality of H divides the cardinality of G.\nTranslate the statement in natural language to Lean:", "output": "theorem nat_card_dvd_of_surjective {G H : Type _} [Group G] [Group H] (f : G \u2192* H)\n    (hf : Function.Surjective f) : Nat.card H \u2223 Nat.card G :="}
{"input": "Statement in natural language:\nFor a given type \u03b9, a filter l on \u03b9, and a function x from \u03b9 to the real numbers, if the limit inferior (liminf) of the non-negative part of the function x (considered as a real number) under the filter l is not infinite, then there exists a real number R such that R is less than the value of the function x at some point n in the filter l frequently.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_frequently_lt_of_liminf_ne_top' {\u03b9 : Type _} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, R < x n :="}
{"input": "Statement in natural language:\nFor any given elements a, b, and c, if the lift relation of r and s holds between a and b, and also between b and c, then the lift relation of r and s also holds between a and c. This is under the condition that r is a transitive relation on \u03b1 and s is a transitive relation on \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem LiftRel.trans [IsTrans \u03b1 r] [IsTrans \u03b2 s] :\n    \u2200 {a b c}, LiftRel r s a b \u2192 LiftRel r s b c \u2192 LiftRel r s a c"}
{"input": "Statement in natural language:\nFor any integer modulo 0, the value of the negation of this integer is equal to the value of the integer itself.\nTranslate the statement in natural language to Lean:", "output": "theorem val_neg' {n : ZMod 0} : (-n).val = n.val :="}
{"input": "Statement in natural language:\nFor any arithmetic function 'f' with values in the ring 'R', the pointwise multiplication of 'f' with the Riemann zeta function is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem pmul_zeta (f : ArithmeticFunction R) : f.pmul \u2191\u03b6 = f :="}
{"input": "Statement in natural language:\nIn a topological space \u03b2, given two functions f and g from \u03b2 to \u03b1 and a set s in \u03b2 that is closed, if f and g are continuous on s, then the set of all elements x in s such that f(x) is less than or equal to g(x) is also closed.\nTranslate the statement in natural language to Lean:", "output": "theorem IsClosed.isClosed_le [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (hs : IsClosed s)\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) : IsClosed ({ x \u2208 s | f x \u2264 g x }) :="}
{"input": "Statement in natural language:\nFor any two objects X and Y in a category C, given that X is a terminal object and c is a binary fan of X and Y, there exists a limit of c if and only if the second projection of c is an isomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem BinaryFan.isLimit_iff_isIso_snd {X Y : C} (h : IsTerminal X) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) \u2194 IsIso c.snd :="}
{"input": "Statement in natural language:\nFor a given index 'i' and a function 't' that maps each index to a set of elements of type '\u03b1 i', the Cartesian product of the sets 't i' for 'i' in a singleton set containing only 'i' is equal to the preimage of the set 't i' under the evaluation map at 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_pi (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = eval i \u207b\u00b9' t i :="}
{"input": "Statement in natural language:\nFor any element 'x' of type '\u03b1', the relation defined by the setoid of 'hs' relates the element obtained by applying the function 'some' to the index of 'x' in 'hs' to 'x' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem some_index (x : \u03b1) : hs.setoid.Rel (hs.some (hs.index x)) x :="}
{"input": "Statement in natural language:\nFor any element 'a' of a group with zero and any integer 'n', 'a' raised to the power of 'bit1 n' (which is a function that maps an integer to another integer) is equal to 'a' times 'a', raised to the power of 'n', times 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_bit1' (a : G\u2080) (n : \u2124) : a ^ bit1 n = (a * a) ^ n * a :="}
{"input": "Statement in natural language:\nFor any division operation on a type \u03b1, the unary operation applied to the division of a and b is equal to the division of the unary operation applied to a and the unary operation applied to b.\nTranslate the statement in natural language to Lean:", "output": "theorem unop_div [Div \u03b1] (a b : \u03b1\u1d43\u1d52\u1d56) : unop (a / b) = unop a / unop b :="}
{"input": "Statement in natural language:\nFor any natural number 'n', 'n' is congruent modulo 11 to the alternating sum of its digits when represented in base 10.\nTranslate the statement in natural language to Lean:", "output": "theorem modEq_eleven_digits_sum (n : \u2115) :\n    n \u2261 ((digits 10 n).map fun n : \u2115 => (n : \u2124)).alternatingSum [ZMOD 11] :="}
{"input": "Statement in natural language:\nFor any type \u03b1, the comap (preimage function) of the identity function on \u03b1 in the context of a uniform space is the identity function itself.\nTranslate the statement in natural language to Lean:", "output": "theorem uniformSpace_comap_id {\u03b1 : Type _} : UniformSpace.comap (id : \u03b1 \u2192 \u03b1) = id :="}
{"input": "Statement in natural language:\nIf we have two co-structured arrows A and B from categories S and T, and a morphism f from A to B such that the left part of f is an epimorphism, then f itself is an epimorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem epi_of_epi_left {A B : CostructuredArrow S T} (f : A \u27f6 B) [h : Epi f.left] : Epi f :="}
{"input": "Statement in natural language:\nThe function that creates a tuple product from a list, denoted as \"TProd.mk\", is measurable. Here, \"measurable\" refers to the property of a function that can be integrated or differentiated under certain mathematical conditions.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_tProd_mk (l : List \u03b4) : Measurable (@TProd.mk \u03b4 \u03c0 l) :="}
{"input": "Statement in natural language:\nFor any type \u03b1, if for every x less than the cardinality of \u03b1, 2 to the power of x is less than the cardinality of \u03b1, and for any relation r on \u03b1 that is a well-ordering, if the order type of the cardinality of \u03b1 is equal to the type of r, then the cardinality of the set of all subsets of \u03b1 that are bounded by r is equal to the cardinality of \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_bounded_subset {\u03b1 : Type _} (h : \u2200 x < #\u03b1, (2^x) < (#\u03b1)) {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsWellOrder \u03b1 r] (hr : (#\u03b1).ord = type r) : (#{ s : Set \u03b1 // Bounded r s }) = (#\u03b1) :="}
{"input": "Statement in natural language:\nFor any two polynomials 'p' and 'q', the map of the composition of 'p' and 'q' is equal to the composition of the map of 'p' and the map of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_comp (p q : R[X]) : map f (p.comp q) = (map f p).comp (map f q) :="}
{"input": "Statement in natural language:\nFor any finite type 'n', given a matrix 'M' with dimensions 'm' by 'n', another matrix 'N' with dimensions 'n' by 'o', and a scalar 'a', the product of the matrix created by multiplying each element of 'M' by 'a' and 'N' is equal to 'a' times the product of 'M' and 'N'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_mul_left [Fintype n] (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) (a : \u03b1) :\n    (of fun i j => a * M i j) \u2b1d N = a \u2022 M \u2b1d N :="}
{"input": "Statement in natural language:\nA complex number z is not less than zero if and only if the real part of z is greater than or equal to zero or the imaginary part of z is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem not_lt_zero_iff {z : \u2102} : \u00acz < 0 \u2194 0 \u2264 z.re \u2228 z.im \u2260 0 :="}
{"input": "Statement in natural language:\nIf we have two ring homomorphisms, 'g' from ring B to ring C and 'f' from ring A to ring B, and if both 'g' and 'f' are of finite type, then the composition of 'g' and 'f' (i.e., g following f) is also of finite type.\nTranslate the statement in natural language to Lean:", "output": "theorem comp {g : B \u2192+* C} {f : A \u2192+* B} (hg : g.FiniteType) (hf : f.FiniteType) :\n    (g.comp f).FiniteType :="}
{"input": "Statement in natural language:\nThe double negation of the Heyting implication from 'a' to 'b' is equal to the Heyting implication from the double negation of 'a' to the double negation of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem compl_compl_himp_distrib (a b : \u03b1) : (a \u21e8 b)\u1d9c\u1d9c = a\u1d9c\u1d9c \u21e8 b\u1d9c\u1d9c :="}
{"input": "Statement in natural language:\nThe set of all elements less than or equal to the predecessor of a given element 'a' is equal to the set of all elements strictly less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem Iic_pred (a : \u03b1) : Iic (pred a) = Iio a :="}
{"input": "Statement in natural language:\nIf 'p' is an affine independent function over a nontrivial field 'k', then 'p' is a function that is injective, meaning that it assigns a unique value to each unique input.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineIndependent.injective [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) : Function.Injective p :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that is a ring, and for any two elements x and y of this type that commute, and for any natural number n, the sum of the product of x to the power of i and y to the power of (n - i) for all i in the range from 0 to n (inclusive) is equal to x to the power of n plus y times the sum of the product of x to the power of i and y to the power of (n - 1 - i) for all i in the range from 0 to n-1 (inclusive).\nTranslate the statement in natural language to Lean:", "output": "theorem Commute.geom_sum\u2082_succ_eq {\u03b1 : Type u} [Ring \u03b1] {x y : \u03b1} (h : Commute x y)\n    {n : \u2115} :\n    (\u2211 i in range (n + 1), x ^ i * y ^ (n - i)) =\n      x ^ n + y * \u2211 i in range n, x ^ i * y ^ (n - 1 - i) :="}
{"input": "Statement in natural language:\nFor any finite set 's' and any function 'f' from 's' to the set of trivial square zero extensions of 'R' and 'M', the first component of the sum of 'f i' for all 'i' in 's' is equal to the sum of the first component of 'f i' for all 'i' in 's'. Here, 'R' and 'M' are assumed to be additive commutative monoids.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_sum {\u03b9} [AddCommMonoid R] [AddCommMonoid M] (s : Finset \u03b9) (f : \u03b9 \u2192 tsze R M) :\n    (\u2211 i in s, f i).fst = \u2211 i in s, (f i).fst :="}
{"input": "Statement in natural language:\nFor any two natural numbers m and n, m and n are not coprime if and only if there exists a prime number p such that p divides both m and n.\nTranslate the statement in natural language to Lean:", "output": "theorem Prime.not_coprime_iff_dvd {m n : \u2115} : \u00accoprime m n \u2194 \u2203 p, Prime p \u2227 p \u2223 m \u2227 p \u2223 n :="}
{"input": "Statement in natural language:\nIf L\u2081 reduces to L\u2082 (denoted as Red L\u2081 L\u2082), then L\u2082 is an element of the enumeration of all reductions of L\u2081 (denoted as Red.enum L\u2081).\nTranslate the statement in natural language to Lean:", "output": "theorem Red.enum.complete (H : Red L\u2081 L\u2082) : L\u2082 \u2208 Red.enum L\u2081 :="}
{"input": "Statement in natural language:\nIf the function pair (f, g) is antivariant, then the sum of the product of f(i) and g(i) for all i is less than or equal to the sum of the product of f(i) and g(\u03c3(i)) for all i. Here, \u03c3 is a permutation function.\nTranslate the statement in natural language to Lean:", "output": "theorem Antivary.sum_smul_le_sum_smul_comp_perm (hfg : Antivary f g) :\n    (\u2211 i, f i \u2022 g i) \u2264 \u2211 i, f i \u2022 g (\u03c3 i) :="}
{"input": "Statement in natural language:\nFor a given localization 'x' of a set 'S' and two elements 'y' and 'z' of a localized module over 'S' and 'M', the scalar multiplication of 'x' with the sum of 'y' and 'z' is equal to the sum of the scalar multiplication of 'x' with 'y' and the scalar multiplication of 'x' with 'z'. This is a property of distributivity in the context of scalar multiplication and addition in a localized module.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_add' (x : Localization S) (y z : LocalizedModule S M) :\n    x \u2022 (y + z) = x \u2022 y + x \u2022 z :="}
{"input": "Statement in natural language:\nFor a set 's' of elements of type \u03b1, if 's' is preconnected and has a lower bound, but does not have an upper bound, then the set of all elements greater than the greatest lower bound of 's' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPreconnected.Ioi_csInf_subset {s : Set \u03b1} (hs : IsPreconnected s) (hb : BddBelow s)\n    (ha : \u00acBddAbove s) : Ioi (sInf s) \u2286 s :="}
{"input": "Statement in natural language:\nFor any integer n, in the context of an order-closed topology and a topological add group, the fractional part function tends to 0 as it approaches n from the right.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_fract_right' [OrderClosedTopology \u03b1] [TopologicalAddGroup \u03b1] (n : \u2124) :\n    Tendsto (fract : \u03b1 \u2192 \u03b1) (\ud835\udcdd[\u2265] n) (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nThe union of the image of the set s under scalar multiplication by each element a in set t is equal to the scalar multiplication of set s by set t.\nTranslate the statement in natural language to Lean:", "output": "theorem iUnion_smul_right_image : (\u22c3 a \u2208 t, (\u00b7 \u2022 a) '' s) = s \u2022 t :="}
{"input": "Statement in natural language:\nIf a function F, which maps from a set \u03b9 to a function from X to \u03b1, is equicontinuous, then for any element i in \u03b9, the function F(i) is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Equicontinuous.continuous {F : \u03b9 \u2192 X \u2192 \u03b1} (h : Equicontinuous F) (i : \u03b9) :\n    Continuous (F i) :="}
{"input": "Statement in natural language:\nFor a power series 'f' over a ring 'R' and an element 'a' from 'R', the scalar multiplication of 'a' and 'f' is equal to the product of 'f' and the constant term 'a' in the ring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_eq_C_mul (f : PowerSeries R) (a : R) : a \u2022 f = C R a * f :="}
{"input": "Statement in natural language:\nFor a finite type 's' and a decidable equality on '\u03b1', the epsilon-infimum separation of 's' is equal to the infimum of the extended distance function applied to the off-diagonal elements of 's' converted to a finite set.\nTranslate the statement in natural language to Lean:", "output": "theorem einfsep_of_fintype [DecidableEq \u03b1] [Fintype s] :\n    s.einfsep = s.offDiag.toFinset.inf (uncurry edist) :="}
{"input": "Statement in natural language:\nThe complement of the set I in the ideal filter (IF) is equal to the filter F in the ideal filter (IF).\nTranslate the statement in natural language to Lean:", "output": "theorem compl_I_eq_F : (IF.I : Set P)\u1d9c = IF.F :="}
{"input": "Statement in natural language:\nFor a given element 'g' of a set '\u03b1', the multiplication action function ((\u00b7 \u2022 \u00b7) g : \u03b2 \u2192 \u03b2) is surjective. This means that for every element in the set '\u03b2', there is at least one element in the same set '\u03b2' that, when the multiplication action is applied with 'g', gives that element.\nTranslate the statement in natural language to Lean:", "output": "theorem MulAction.surjective (g : \u03b1) : Function.Surjective ((\u00b7 \u2022 \u00b7) g : \u03b2 \u2192 \u03b2) :="}
{"input": "Statement in natural language:\nFor a given element 'a' and a given finite set 's', if 'a' is not an element of 's', then if we insert 'a' into 's' and then erase 'a', we will get back the original set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_insert {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : erase (insert a s) a = s :="}
{"input": "Statement in natural language:\nFor any semigroup \u03b1, and any matrices A, B, and C with elements from \u03b1, the submatrix of the Kronecker product of A, B, and C, when rearranged according to the symmetric of the product association of their respective dimensions, is equal to the Kronecker product of A with the Kronecker product of B and C.\nTranslate the statement in natural language to Lean:", "output": "theorem kronecker_assoc' [Semigroup \u03b1] (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) (C : Matrix q r \u03b1) :\n    submatrix (A \u2297\u2096 B \u2297\u2096 C) (Equiv.prodAssoc l n q).symm (Equiv.prodAssoc m p r).symm =\n    A \u2297\u2096 (B \u2297\u2096 C) :="}
{"input": "Statement in natural language:\nFor a nontrivial ring R, if for all elements a and b of R, a and b are both not units in R implies that their sum is also not a unit in R, then R is a local ring.\nTranslate the statement in natural language to Lean:", "output": "theorem of_nonunits_add [Nontrivial R]\n    (h : \u2200 a b : R, a \u2208 nonunits R \u2192 b \u2208 nonunits R \u2192 a + b \u2208 nonunits R) : LocalRing R :="}
{"input": "Statement in natural language:\nFor any positive natural number 'n' and a primitive root '\u03b6' of 'n', the cardinality (or the number of elements) of the roots of unity of 'n' in the ring 'R' is equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_rootsOfUnity' {n : \u2115+} (h : IsPrimitiveRoot \u03b6 n) :\n    Fintype.card (rootsOfUnity n R) = n :="}
{"input": "Statement in natural language:\nThe product of 'a' and 'b' is less than or equal to zero if and only if either 'a' is greater than or equal to zero and 'b' is less than or equal to zero, or 'a' is less than or equal to zero and 'b' is greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_nonpos_iff : a * b \u2264 0 \u2194 0 \u2264 a \u2227 b \u2264 0 \u2228 a \u2264 0 \u2227 0 \u2264 b :="}
{"input": "Statement in natural language:\nFor a homotopy 'F' with properties 'f\u2080', 'f\u2081', and 'P', and for a real number 't', the property 'P' holds for the extension of the homotopy 'F' at 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem extendProp (F : HomotopyWith f\u2080 f\u2081 P) (t : \u211d) : P (F.toHomotopy.extend t) :="}
{"input": "Statement in natural language:\nFor any two connected components C and D of a simple graph G, C and D are identical if and only if their supports (the set of vertices that belong to them) are identical.\nTranslate the statement in natural language to Lean:", "output": "theorem supp_inj {C D : G.ConnectedComponent} : C.supp = D.supp \u2194 C = D :="}
{"input": "Statement in natural language:\nFor any two integers 'a' and 'b', if the product of 'a' and 'b' equals zero, then either 'a' equals zero or 'b' equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_zero_or_eq_zero_of_mul_eq_zero {a b : \u2124} (h : a * b = 0) : a = 0 \u2228 b = 0 :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', if 'f' is continuous and is an open map, and 's' is a compact open subset of '\u03b1', then the image of 's' under the map 'f' is equal to the set 's' mapped by 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_map {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (hf' : IsOpenMap f) (s : CompactOpens \u03b1) :\n    (s.map f hf hf' : Set \u03b2) = f '' s :="}
{"input": "Statement in natural language:\nThe inverse of a rational number 'q' is equal to the quotient of the denominator of 'q' divided by the numerator of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_def'' {q : \u211a} : q\u207b\u00b9 = (q.den : \u211a) / q.num :="}
{"input": "Statement in natural language:\nThe Lebesgue integral of a constant function c over any measure space is equal to the product of the constant c and the measure of the entire space.\nTranslate the statement in natural language to Lean:", "output": "theorem lintegral_const (c : \u211d\u22650\u221e) : (\u222b\u207b _, c \u2202\u03bc) = c * \u03bc univ :="}
{"input": "Statement in natural language:\nFor any two power series \u03c6 and \u03c8 over a ring R, if for every natural number n, the coefficient of the nth term in \u03c6 is equal to the coefficient of the nth term in \u03c8, then the two power series \u03c6 and \u03c8 are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {\u03c6 \u03c8 : PowerSeries R} (h : \u2200 n, coeff R n \u03c6 = coeff R n \u03c8) : \u03c6 = \u03c8 :="}
{"input": "Statement in natural language:\nFor any three elements x, y, and z in the field F, the inner product of x with the sum of y and z is equal to the sum of the inner product of x with y and the inner product of x with z.\nTranslate the statement in natural language to Lean:", "output": "theorem inner_add_right (x y z : F) : \u27eax, y + z\u27eb = \u27eax, y\u27eb + \u27eax, z\u27eb :="}
{"input": "Statement in natural language:\nIf 'a' is not equal to 'b', then the count of 'a' in a list 'l' after 'b' has been erased is equal to the count of 'a' in the original list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem count_erase_of_ne (ab : a \u2260 b) (l : List \u03b1) : count a (l.erase b) = count a l :="}
{"input": "Statement in natural language:\nIn the context of an ordered ring, if the product of two elements 'a' and 'b' is positive (greater than 0) and 'a' is non-negative (greater than or equal to 0), then 'b' must be positive (greater than 0).\nTranslate the statement in natural language to Lean:", "output": "theorem pos_of_mul_pos_right [PosMulReflectLT \u03b1] (h : 0 < a * b) (ha : 0 \u2264 a) : 0 < b :="}
{"input": "Statement in natural language:\nFor two group homomorphisms f and g from a group P to groups M and N respectively, and two other group homomorphisms f' and g' from groups M and N to groups M' and N' respectively, the composition of the product map of f' and g' with the product of f and g is equal to the product of the compositions of f' and f, and g' and g.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_comp_prodMap (f : P \u2192* M) (g : P \u2192* N) (f' : M \u2192* M') (g' : N \u2192* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :="}
{"input": "Statement in natural language:\nFor any property 'p' that applies to an element 'x' of type '\u03b1', the proposition that 'for all x, if p(x) then True' is equivalent to 'True'. This means that regardless of the property 'p' and the element 'x', if 'p(x)' implies 'True', then the whole statement is always 'True'.\nTranslate the statement in natural language to Lean:", "output": "theorem ball_true_iff (p : \u03b1 \u2192 Prop) : (\u2200 x, p x \u2192 True) \u2194 True :="}
{"input": "Statement in natural language:\nFor any two positive natural numbers 'm' and 'n', if 'm' is equal to 'n' when both are considered as natural numbers, then 'm' is equal to 'n' when both are considered as positive natural numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem eq {m n : \u2115+} : (m : \u2115) = n \u2192 m = n :="}
{"input": "Statement in natural language:\nThe supremum of the union of two sets s and t is equal to the join (or least upper bound) of the supremum of set s and the supremum of set t.\nTranslate the statement in natural language to Lean:", "output": "theorem sSup_union {s t : Set \u03b1} : sSup (s \u222a t) = sSup s \u2294 sSup t :="}
{"input": "Statement in natural language:\nThe negation of the infimum (greatest lower bound) of two elements 'a' and 'b' is equal to the supremum (least upper bound) of the negation of 'a' and the negation of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem hnot_inf_distrib (a b : \u03b1) : \uffe2(a \u2293 b) = \uffe2a \u2294 \uffe2b :="}
{"input": "Statement in natural language:\nFor any element 'a' from set 'A', the first element of 'a' when considered as an element of the multiplier space of '\ud835\udd5c' and 'A', is equal to the continuous linear map of multiplication of '\ud835\udd5c' and 'A' with 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_fst (a : A) : (a : \ud835\udcdc(\ud835\udd5c, A)).fst = ContinuousLinearMap.mul \ud835\udd5c A a :="}
{"input": "Statement in natural language:\nFor a sequence 's', the operation 'get s' is a refinement of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem get_promises : s ~> get s :="}
{"input": "Statement in natural language:\nFor a given predicate 'p' on a type '\u03b2', where 'p' is a decidable and primitive recursive predicate, and a function 'f' from type '\u03b1' to the subtype of '\u03b2' satisfying 'p', the function 'f' is primitive recursive if and only if the function that maps 'a' to the first component of 'f(a)' is primitive recursive. This is under the assumption that the subtype satisfying 'p' is primcodable.\nTranslate the statement in natural language to Lean:", "output": "theorem subtype_val_iff {p : \u03b2 \u2192 Prop} [DecidablePred p] {hp : PrimrecPred p} {f : \u03b1 \u2192 Subtype p} :\n    haveI := Primcodable.subtype hp\n    (Primrec fun a => (f a).1) \u2194 Primrec f :="}
{"input": "Statement in natural language:\nFor a given cocone 'D' of a functor 'F', if 'D' is a colimit, then there exists a surjective function 'ff' from the disjoint union of the objects of 'F' to the point of 'D'. This function 'ff' is defined by applying the cocone morphism of 'D' to each object in the disjoint union.\nTranslate the statement in natural language to Lean:", "output": "theorem Concrete.from_union_surjective_of_isColimit {D : Cocone F} (hD : IsColimit D) :\n    let ff : (\u03a3j : J, F.obj j) \u2192 D.pt := fun a => D.\u03b9.app a.1 a.2\n    Function.Surjective ff :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1 and sets 's', 't', and 'u' of type \u03b1, if 'a' is an element of 's', 's' is an open set, and the intersection of 't' and 's' equals the intersection of 'u' and 's', then the neighborhood of 'a' within 't' is equal to the neighborhood of 'a' within 'u'.\nTranslate the statement in natural language to Lean:", "output": "theorem nhdsWithin_eq_nhdsWithin {a : \u03b1} {s t u : Set \u03b1} (h\u2080 : a \u2208 s) (h\u2081 : IsOpen s)\n    (h\u2082 : t \u2229 s = u \u2229 s) : \ud835\udcdd[t] a = \ud835\udcdd[u] a :="}
{"input": "Statement in natural language:\nIf \"a\" semi-conjugates \"x\" to \"y\", then the inverse of \"a\" semi-conjugates the inverse of \"y\" to the inverse of \"x\".\nTranslate the statement in natural language to Lean:", "output": "theorem inv_inv_symm : SemiconjBy a x y \u2192 SemiconjBy a\u207b\u00b9 y\u207b\u00b9 x\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any filter 'f' and any function 'u' from '\u03b2' to '\u03b1', the bounded limit inferior of 'u' over 'f' where the predicate is always true is equal to the limit inferior of 'u' over 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem bliminf_true (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) : (bliminf u f fun _ => True) = liminf u f :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', if 'f' is absolutely measurable with respect to measure '\u03bc', then the linear map of the measurable function 'f' with respect to measure '\u03bc' is equal to the map of function 'f' with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2097_mk_apply_of_aemeasurable {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) :\n    map\u2097 (hf.mk f) \u03bc = map f \u03bc :="}
{"input": "Statement in natural language:\nThe logarithm function is differentiable on the set of real numbers excluding zero.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableOn_log : DifferentiableOn \u211d log ({0}\u1d9c) :="}
{"input": "Statement in natural language:\nIf \u03b1 is a complete space and s is a closed set within \u03b1, then s is also a complete space.\nTranslate the statement in natural language to Lean:", "output": "theorem IsClosed.completeSpace_coe [CompleteSpace \u03b1] {s : Set \u03b1} (hs : IsClosed s) :\n    CompleteSpace s :="}
{"input": "Statement in natural language:\nFor a given list 's' of any type '\u03b1', the function that appends 's' to another list 't' is injective. This means that if two different lists 't1' and 't2' produce the same result when appended to 's', then 't1' and 't2' must be the same list.\nTranslate the statement in natural language to Lean:", "output": "theorem append_right_injective (s : List \u03b1) : Injective fun t \u21a6 s ++ t :="}
{"input": "Statement in natural language:\nFor a given time 't' within the closed interval from 'v.tMin' to 'v.tMax', the function 'f' at time 't' belongs to the closed ball centered at 'v.x\u2080' with radius 'v.R'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_closedBall (t : Icc v.tMin v.tMax) : f t \u2208 closedBall v.x\u2080 v.R :="}
{"input": "Statement in natural language:\nFor two localization maps 'f' and 'g' from a multiplicative set 'S' to a type 'N', 'f' is equal to 'g' if and only if for all elements 'x', the mapping of 'x' under 'f' is equal to the mapping of 'x' under 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {f g : LocalizationMap S N} : f = g \u2194 \u2200 x, f.toMap x = g.toMap x :="}
{"input": "Statement in natural language:\nThe composition of the function 'pointedToBipointedSnd' and 'Bipointed.swap' is equal to the function 'pointedToBipointedFst'.\nTranslate the statement in natural language to Lean:", "output": "theorem pointedToBipointedSnd_comp_swap :\n    pointedToBipointedSnd \u22d9 Bipointed.swap = pointedToBipointedFst :="}
{"input": "Statement in natural language:\nIf a set of cardinals 's' is small, then it is bounded above.\nTranslate the statement in natural language to Lean:", "output": "theorem bddAbove_of_small (s : Set Cardinal.{u}) [h : Small.{u} s] : BddAbove s :="}
{"input": "Statement in natural language:\nFor any subgroup H of a group G, H is a subset of the preimage under f of the image under f of H.\nTranslate the statement in natural language to Lean:", "output": "theorem le_comap_map (H : Subgroup G) : H \u2264 comap f (map f H) :="}
{"input": "Statement in natural language:\nFor any two multivariate polynomials 'p' and 'q', if the total degree of 'q' is less than the total degree of 'p', then the total degree of the sum of 'q' and 'p' is equal to the total degree of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem totalDegree_add_eq_right_of_totalDegree_lt {p q : MvPolynomial \u03c3 R}\n    (h : q.totalDegree < p.totalDegree) : (q + p).totalDegree = p.totalDegree :="}
{"input": "Statement in natural language:\nFor any two linear maps 'f' from M\u2081 to M\u2082 and 'g' from M\u2082 to M\u2083 in a module over a ring R with an additive commutative group structure, the composition of the dual map of 'f' and the dual map of 'g' is equal to the dual map of the composition of 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.dualMap_comp_dualMap {M\u2083 : Type _} [AddCommGroup M\u2083] [Module R M\u2083]\n    (f : M\u2081 \u2192\u2097[R] M\u2082) (g : M\u2082 \u2192\u2097[R] M\u2083) : f.dualMap.comp g.dualMap = (g.comp f).dualMap :="}
{"input": "Statement in natural language:\nFor a given value B in field K, if the nth denominator of a generalized continued fraction g is equal to B, then there exists a continued fraction such that the nth continuant of g is equal to this continued fraction and the second element of this continued fraction is B.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_conts_b_of_denom {B : K} (nth_denom_eq : g.denominators n = B) :\n    \u2203 conts, g.continuants n = conts \u2227 conts.b = B :="}
{"input": "Statement in natural language:\nFor any two ordinals 'o' and 'a', if 'o' is a limit ordinal, then if 'a' is less than 'o', the successor of 'a' is also less than 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLimit.succ_lt {o a : Ordinal} (h : IsLimit o) : a < o \u2192 succ a < o :="}
{"input": "Statement in natural language:\nIn a monoid structure \u03b1, for any elements a, b, and c, if b is associated with c, then a divides b if and only if a divides c.\nTranslate the statement in natural language to Lean:", "output": "theorem Associated.dvd_iff_dvd_right [Monoid \u03b1] {a b c : \u03b1} (h : b ~\u1d64 c) : a \u2223 b \u2194 a \u2223 c :="}
{"input": "Statement in natural language:\nFor any subobject 'x' of 'X', mapping 'x' with the identity morphism of 'X' results in 'x' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id (x : Subobject X) : (map (\ud835\udfd9 X)).obj x = x :="}
{"input": "Statement in natural language:\nThe integral of the function that always equals zero is integrable over any interval I with respect to any measure l and volume vol.\nTranslate the statement in natural language to Lean:", "output": "theorem integrable_zero : Integrable I l (fun _ => (0 : E)) vol :="}
{"input": "Statement in natural language:\nFor a function 'f' from type \u03b1 to \u03b3, given that for all elements a\u2081 and a\u2082 of type \u03b1, if they are related by relation 'r', then 'f' of a\u2081 equals 'f' of a\u2082. Then for any element 'a' of type \u03b1, lifting the function 'f' over the quotient of 'a' by the relation 'r' equals applying 'f' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_mk (f : \u03b1 \u2192 \u03b3) (h : \u2200 a\u2081 a\u2082, r a\u2081 a\u2082 \u2192 f a\u2081 = f a\u2082) (a : \u03b1) :\n    Quot.lift f h (Quot.mk r a) = f a :="}
{"input": "Statement in natural language:\nThe supremum (or join) of 'a' and 'b', subtracted by 'c', is equal to the supremum of 'a' subtracted by 'c' and 'b' subtracted by 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_sdiff : (a \u2294 b) \\ c = a \\ c \u2294 b \\ c :="}
{"input": "Statement in natural language:\nThe preimage of the interval from b to c under the function that subtracts each element from a is the interval from a minus b to a minus c.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_const_sub_uIcc : (fun x => a - x) \u207b\u00b9' [[b, c]] = [[a - b, a - c]] :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps each element 'i' to a value in the set '\u03b4 i', the Cartesian product of singleton sets (each containing the value 'f i') is equal to the singleton set containing the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem piFinset_singleton (f : \u2200 i, \u03b4 i) : piFinset (fun i => {f i} : \u2200 i, Finset (\u03b4 i)) = {f} :="}
{"input": "Statement in natural language:\nThe composition of the second projection function from the product of sets S and T with the product of functions f and g is equal to function g.\nTranslate the statement in natural language to Lean:", "output": "theorem snd_comp_prod : (snd S T).comp (f.prod g) = g :="}
{"input": "Statement in natural language:\nThe reflection of a ring equivalence in ring R, when cast as a ring homomorphism from R to R, is equal to the identity of the ring homomorphism in R.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_ringHom_refl : (RingEquiv.refl R : R \u2192+* R) = RingHom.id R :="}
{"input": "Statement in natural language:\nFor a given set 's' of a finite type '\u03b1', the cardinality (or the number of elements) of the complement of 's' is equal to the difference between the cardinality of '\u03b1' and the cardinality of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Fintype.card_compl_set [Fintype \u03b1] (s : Set \u03b1) [Fintype s] [Fintype (\u21a5(s\u1d9c) : Sort _)] :\n    Fintype.card (\u21a5(s\u1d9c) : Sort _) = Fintype.card \u03b1 - Fintype.card s :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2' and a set 's' of subsets of '\u03b2', the comap (the preimage function) of the generated sigma-algebra from 's' under 'f' is equal to the sigma-algebra generated from the image of 's' under the preimage function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_generateFrom {f : \u03b1 \u2192 \u03b2} {s : Set (Set \u03b2)} :\n    (generateFrom s).comap f = generateFrom (preimage f '' s) :="}
{"input": "Statement in natural language:\nFor a given isomorphism 'f' from group 'N' to group 'G' and a subgroup 'K' of group 'G', the preimage of 'K' under 'f' is equal to the image of 'K' under the inverse of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_equiv_eq_map_symm (f : N \u2243* G) (K : Subgroup G) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that has a topological space, a linear order, and an order-closed topology, and for any sets s and t of type \u03b1, the measurable space generated from the set of all sets S such that there exists an element l in s and an element u in t where l is less than u and the closed interval from l to u is equal to S, is a subset of or equal to the Borel \u03c3-algebra of \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem generateFrom_Ico_mem_le_borel {\u03b1 : Type _} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderClosedTopology \u03b1] (s t : Set \u03b1) :\n    MeasurableSpace.generateFrom { S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S }\n      \u2264 borel \u03b1 :="}
{"input": "Statement in natural language:\nIf set s is disjoint from set u, and set t is also disjoint from set u, then the union of set s and set t is disjoint from set u.\nTranslate the statement in natural language to Lean:", "output": "theorem union_left (hs : Disjoint s u) (ht : Disjoint t u) : Disjoint (s \u222a t) u :="}
{"input": "Statement in natural language:\nFor every index 'i', given a set 'C' of subsets of '\u03b1 i', if the smallest sigma-algebra containing 'C i' is generated by 'C i' for every 'i', and 'C i' is a pi-system for every 'i', and for every 'i', the measure '\u03bc i' has finite spanning sets in 'C i', then for any measure '\u03bc\u03bd' on the product space of '\u03b1 i', if for all sets 's i' in 'C i', the measure of the product set 's' under '\u03bc\u03bd' is equal to the product of the measures of 's i' under '\u03bc i', then the product measure '\u03bc' is equal to '\u03bc\u03bd'.\nTranslate the statement in natural language to Lean:", "output": "theorem pi_eq_generateFrom {C : \u2200 i, Set (Set (\u03b1 i))}\n    (hC : \u2200 i, generateFrom (C i) = by apply_assumption) (h2C : \u2200 i, IsPiSystem (C i))\n    (h3C : \u2200 i, (\u03bc i).FiniteSpanningSetsIn (C i)) {\u03bc\u03bd : Measure (\u2200 i, \u03b1 i)}\n    (h\u2081 : \u2200 s : \u2200 i, Set (\u03b1 i), (\u2200 i, s i \u2208 C i) \u2192 \u03bc\u03bd (pi univ s) = \u220f i, \u03bc i (s i)) :\n    Measure.pi \u03bc = \u03bc\u03bd :="}
{"input": "Statement in natural language:\nIf function 'f\u2081'' is a left inverse of function 'f' on set 's', and function 'f\u2082'' is a right inverse of function 'f' on set 't', and function 'f\u2082'' maps set 't' to set 's', then function 'f\u2081'' and function 'f\u2082'' are equal on set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem eqOn_of_leftInvOn_of_rightInvOn (h\u2081 : LeftInvOn f\u2081' f s) (h\u2082 : RightInvOn f\u2082' f t)\n    (h : MapsTo f\u2082' t s) : EqOn f\u2081' f\u2082' t :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'n' and 'm' where 'n' is less than or equal to 'm', the factorial of 'n' multiplied by 'n' raised to the power of the difference between 'm' and 'n' is less than or equal to the factorial of 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem factorial_mul_pow_sub_le_factorial {n m : \u2115} (hnm : n \u2264 m) : n ! * n ^ (m - n) \u2264 m ! :="}
{"input": "Statement in natural language:\nFor any three cardinals a, b, and c, the power of a to the sum of b and c is equal to the product of the power of a to b and the power of a to c.\nTranslate the statement in natural language to Lean:", "output": "theorem power_add {a b c : Cardinal} : (a ^ (b + c)) = (a ^ b) * (a ^ c) :="}
{"input": "Statement in natural language:\nThe function 'f' from the continuous map 'C(X, Y)' to 'X \u2192 Y' is equal to the function 'f' from 'X \u2192 Y'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_continuousMap : ((f : C(X, Y)) : X \u2192 Y) = (f : X \u2192 Y) :="}
{"input": "Statement in natural language:\nIf a function f\u2081 is eventually equal to a function f within a neighborhood of a point x in a set s, then the n-th iterated Fr\u00e9chet derivative of f\u2081 within the set s is eventually equal to the n-th iterated Fr\u00e9chet derivative of f within the same set s in the neighborhood of the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.EventuallyEq.iteratedFDerivWithin (h : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (n : \u2115) :\n    iteratedFDerivWithin \ud835\udd5c n f\u2081 s =\u1da0[\ud835\udcdd[s] x] iteratedFDerivWithin \ud835\udd5c n f s :="}
{"input": "Statement in natural language:\nFor any index 'i', the support of the function obtained by applying 'toPouFun' to 'f' at index 'i' is a subset of the support of the function 'f' at index 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem support_toPouFun_subset (i : \u03b9) : support (f.toPouFun i) \u2286 support (f i) :="}
{"input": "Statement in natural language:\nThe symmetric of the set obtained from a given set 's' is equal to the set obtained from 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofSet_symm : (ofSet s).symm = ofSet s :="}
{"input": "Statement in natural language:\nFor all boolean values p and q, the symmetric difference of p and q is equal to the exclusive or (xor) of p and q.\nTranslate the statement in natural language to Lean:", "output": "theorem Bool.symmDiff_eq_xor : \u2200 p q : Bool, p \u2206 q = xor p q :="}
{"input": "Statement in natural language:\nIf a function 'f' is antitone (meaning it is decreasing or constant) and the range of 'f' is bounded above, then 'f' tends to the supremum of the values 'f i' as 'i' tends to negative infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_atBot_ciSup (h_anti : Antitone f) (hbdd : BddAbove <| range f) :\n    Tendsto f atBot (\ud835\udcdd (\u2a06 i, f i)) :="}
{"input": "Statement in natural language:\nFor two uniform spaces u\u2081 and u\u2082 over the same set \u03b1, if u\u2081 is less than or equal to u\u2082, then the neighborhood system of a point a in the topological space corresponding to u\u2081 is less than or equal to the neighborhood system of the same point a in the topological space corresponding to u\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem to_nhds_mono {u\u2081 u\u2082 : UniformSpace \u03b1} (h : u\u2081 \u2264 u\u2082) (a : \u03b1) :\n    @nhds _ (@UniformSpace.toTopologicalSpace _ u\u2081) a \u2264\n      @nhds _ (@UniformSpace.toTopologicalSpace _ u\u2082) a :="}
{"input": "Statement in natural language:\nFor a given decidable equality on \u03b9 and two elements i and j of \u03b9 that are not equal, the function g applied to the composition of v and the swapping of i and j is equal to the negation of g applied to v.\nTranslate the statement in natural language to Lean:", "output": "theorem map_swap [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) : g (v \u2218 Equiv.swap i j) = -g v :="}
{"input": "Statement in natural language:\nThe sum of the cardinality of the continuum (the size of the set of real numbers) and any natural number is equal to the cardinality of the continuum.\nTranslate the statement in natural language to Lean:", "output": "theorem continuum_add_nat (n : \u2115) : \ud835\udd20 + n = \ud835\udd20 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a ring 'R', 'a' is equivalent to 'b' in the quotient ring defined by the congruence relation 'c' if and only if 'a' and 'b' are related by 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq {a b : R} : (a : c.Quotient) = (b : c.Quotient) \u2194 c a b :="}
{"input": "Statement in natural language:\nIf a morphism property P in the opposite category C\u1d52\u1d56 is stable under composition, then the unopposite of P is also stable under composition.\nTranslate the statement in natural language to Lean:", "output": "theorem StableUnderComposition.unop {P : MorphismProperty C\u1d52\u1d56} (h : StableUnderComposition P) :\n    StableUnderComposition P.unop :="}
{"input": "Statement in natural language:\nFor any nonempty set of type \u03b1, there exists an element x of type \u03b1 that belongs to the universal set of type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_mem_of_nonempty (\u03b1) : \u2200 [Nonempty \u03b1], \u2203 x : \u03b1, x \u2208 (univ : Set \u03b1)"}
{"input": "Statement in natural language:\nThe inverse of the bottom element of an interval in the ordered set \u03b1 is equal to the bottom element itself.\nTranslate the statement in natural language to Lean:", "output": "theorem Interval.inv_bot : (\u22a5 : Interval \u03b1)\u207b\u00b9 = \u22a5 :="}
{"input": "Statement in natural language:\nFor any type X with a topological space structure and any two subsets s and t of X, if s has a discrete topology and t is a subset of s, then t also has a discrete topology.\nTranslate the statement in natural language to Lean:", "output": "theorem DiscreteTopology.of_subset {X : Type _} [TopologicalSpace X] {s t : Set X}\n    (_ : DiscreteTopology s) (ts : t \u2286 s) : DiscreteTopology t :="}
{"input": "Statement in natural language:\n\"the successor of a number 'a' is less than or equal to another number 'b' if and only if 'a' is less than 'b'\".\nTranslate the statement in natural language to Lean:", "output": "theorem succ_le_iff : succ a \u2264 b \u2194 a < b :="}
{"input": "Statement in natural language:\nIf x and y are complex numbers and either x or y is not equal to zero, then the function that raises x to the power of y has a strict derivative at y, which is equal to x raised to the power of y times the natural logarithm of x.\nTranslate the statement in natural language to Lean:", "output": "theorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y :="}
{"input": "Statement in natural language:\nFor any type \u03b9 and any filter l on \u03b9, and any property p of \u03b9, if the filter l is countably generated and there frequently exists an element in l for which the property p holds, then there exists a sequence of natural numbers to \u03b9 that tends to l at the top and for all natural numbers n, the property p holds for the sequence at n.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_seq_forall_of_frequently {\u03b9 : Type _} {l : Filter \u03b9} {p : \u03b9 \u2192 Prop}\n    [hl : l.IsCountablyGenerated] (h : \u2203\u1da0 n in l, p n) :\n    \u2203 ns : \u2115 \u2192 \u03b9, Tendsto ns atTop l \u2227 \u2200 n, p (ns n) :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that is empty, the universal set of \u03b1 (denoted as 'univ') is equal to the empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem univ_eq_empty [IsEmpty \u03b1] : (univ : Finset \u03b1) = \u2205 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type \u03b1, any element 'b' of type \u03b2 associated with 'a', and any AList 's' of type \u03b2, replacing 'a' with 'b' in the Finmap of 's' is equal to the Finmap of 's' where 'a' has been replaced with 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem replace_toFinmap (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) :\n    replace a b \u27e6s\u27e7 = (\u27e6s.replace a b\u27e7 : Finmap \u03b2) :="}
{"input": "Statement in natural language:\nThe intersection of set s and set s' is a subset of the set t, which is defined by the if-then-else condition on sets s and s'.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_subset_ite (t s s' : Set \u03b1) : s \u2229 s' \u2286 t.ite s s' :="}
{"input": "Statement in natural language:\nIf you have a value 'x' from the sum of \u03b1 and \u03b2, swapping 'x' and checking if it is left is the same as checking if 'x' is right.\nTranslate the statement in natural language to Lean:", "output": "theorem isLeft_swap (x : Sum \u03b1 \u03b2) : x.swap.isLeft = x.isRight :="}
{"input": "Statement in natural language:\nFor a given sequence of natural numbers 'u' and a property 'p' of natural numbers, the bounded limit superior of 'u' at the top is equal to the greatest lower bound of the set of all least upper bounds of 'u' for all 'j' such that 'p' holds for 'j' and 'i' is less than or equal to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem blimsup_eq_iInf_biSup_of_nat {p : \u2115 \u2192 Prop} {u : \u2115 \u2192 \u03b1} :\n    blimsup u atTop p = \u2a05 i, \u2a06 (j) (_ : p j \u2227 i \u2264 j), u j :="}
{"input": "Statement in natural language:\nThe integral from a to b of the function f applied to (d - x / c), multiplied by the inverse of c, is equal to the integral from (d - b / c) to (d - a / c) of the function f applied to x.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_mul_integral_comp_sub_div :\n    (c\u207b\u00b9 * \u222b x in a..b, f (d - x / c)) = \u222b x in d - b / c..d - a / c, f x :="}
{"input": "Statement in natural language:\nFor any two objects X and Y in a category C, the composition of the tensor product of the identity on X and the left unitor on Y's inverse, with the inverse of the associator on X, the identity on C, and Y, is equal to the inverse of the right unitor on X tensor the identity on Y.\nTranslate the statement in natural language to Lean:", "output": "theorem triangle_assoc_comp_left_inv (X Y : C) :\n    (\ud835\udfd9 X \u2297 (\u03bb_ Y).inv) \u226b (\u03b1_ X (\ud835\udfd9_ C) Y).inv = (\u03c1_ X).inv \u2297 \ud835\udfd9 Y :="}
{"input": "Statement in natural language:\nFor any elements m from set M, n from set N, and p from set P, the inverse of the left commutative operation applied to the tensor product of n and the tensor product of m and p, is equal to the tensor product of m and the tensor product of n and p.\nTranslate the statement in natural language to Lean:", "output": "theorem leftComm_symm_tmul (m : M) (n : N) (p : P) :\n    (leftComm R M N P).symm (n \u2297\u209c (m \u2297\u209c p)) = m \u2297\u209c (n \u2297\u209c p) :="}
{"input": "Statement in natural language:\nFor any real number 'x' that is greater than or equal to -1 and less than or equal to 1, the sine of the arcsine of 'x' is equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem sin_arcsin {x : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) : sin (arcsin x) = x :="}
{"input": "Statement in natural language:\nThe trace of the identity matrix over a ring R and a module M is equal to the finite rank of the module M over the ring R.\nTranslate the statement in natural language to Lean:", "output": "theorem trace_one : trace R M 1 = (finrank R M : R) :="}
{"input": "Statement in natural language:\nFor any two natural numbers m and n, the bit0 (which is a function that doubles the input) of m equals the bit0 of n if and only if m equals n.\nTranslate the statement in natural language to Lean:", "output": "theorem bit0_eq_bit0 {m n : \u2115} : bit0 m = bit0 n \u2194 m = n :="}
{"input": "Statement in natural language:\nFor the given condition where a\u2081 is less than or equal to b\u2081, the closed interval [a\u2081, b\u2081] is a subset of the half-open interval [a\u2082, b\u2082) if and only if a\u2082 is less than or equal to a\u2081 and b\u2081 is less than b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_subset_Ico_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 < b\u2082 :="}
{"input": "Statement in natural language:\nThe preimage filter of a function 'm' on a filter 'f' is not the bottom filter if and only if for every set 't' in the filter 'f', there exists an element 'a' such that the image of 'a' under the function 'm' is in the set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_neBot_iff {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} : NeBot (comap m f) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t :="}
{"input": "Statement in natural language:\nFor a given function 'f' that maps from the associates of a type '\u03b1' to '\u03b1', and a right inverse function 'hinv' of 'f', and a given element 'a' of type '\u03b1', the product of 'a' and the chosen element from the associated map of 'hinv' and 'a' is equal to the result of applying function 'f' to the associate of 'a'. This theorem assumes that '\u03b1' is a type for which equality is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem map_mk_unit_aux [DecidableEq \u03b1] {f : Associates \u03b1 \u2192* \u03b1}\n    (hinv : Function.RightInverse f Associates.mk) (a : \u03b1) :\n    a * \u2191(Classical.choose (associated_map_mk hinv a)) = f (Associates.mk a) :="}
{"input": "Statement in natural language:\nFor any lists l\u2081 and l\u2082, and any element a, the last element of the list formed by appending a and l\u2082 to l\u2081 is the same as the last element of the list formed by prepending a to l\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem getLast?_append_cons :\n    \u2200 (l\u2081 : List \u03b1) (a : \u03b1) (l\u2082 : List \u03b1), getLast? (l\u2081 ++ a :: l\u2082) = getLast? (a :: l\u2082)"}
{"input": "Statement in natural language:\nThe preimage of the image of a set s under a smooth manifold with corners I is equal to the set s itself.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_image (s : Set H) : I \u207b\u00b9' (I '' s) = s :="}
{"input": "Statement in natural language:\nR is a unique factorization monoid.\nTranslate the statement in natural language to Lean:", "output": "theorem toUniqueFactorizationMonoid : UniqueFactorizationMonoid R :="}
{"input": "Statement in natural language:\nFor any two types X and Y, a function f from X to Y is a monomorphism if and only if it is an injective function.\nTranslate the statement in natural language to Lean:", "output": "theorem mono_iff_injective {X Y : Type u} (f : X \u27f6 Y) : Mono f \u2194 Function.Injective f :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set 'F', a submonoid 'S' of 'M', and an element 'x' in 'S', the application of 'f' to 'x' is an element of the map of 'S' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_coe_mem_map (f : F) (S : Submonoid M) (x : S) : f x \u2208 S.map f :="}
{"input": "Statement in natural language:\nFor any two real numbers x and y, the condition that x and y are equal when considered as quaternions is equivalent to the condition that x and y are equal as real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_inj {x y : R} : (x : \u210d[R,c\u2081,c\u2082]) = y \u2194 x = y :="}
{"input": "Statement in natural language:\nIf the greatest common divisor of integers x and y is 1 (meaning x and y are coprime), then z cannot be equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_zero_of_coprime (hc : Int.gcd x y = 1) : z \u2260 0 :="}
{"input": "Statement in natural language:\nIf set s is nonempty and set t is nonempty, then the set resulting from the vector subtraction of set t from set s (denoted as s -\u1d65 t) is also nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem Nonempty.vsub : s.Nonempty \u2192 t.Nonempty \u2192 (s -\u1d65 t : Set \u03b1).Nonempty :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', the application of the singleton monoid homomorphism on 'a' results in a set containing only 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem singletonMonoidHom_apply (a : \u03b1) : singletonMonoidHom a = {a} :="}
{"input": "Statement in natural language:\nFor a simple function f from \u03b1 to non-negative real numbers, and a non-zero \u03b5 of type non-negative extended real numbers, there exists a function g from \u03b1 to non-negative real numbers such that for all x, f(x) is less than or equal to g(x), g is lower semicontinuous, and the lower integral of g with respect to measure \u03bc is less than or equal to the lower integral of f with respect to measure \u03bc plus \u03b5.\nTranslate the statement in natural language to Lean:", "output": "theorem SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge (f : \u03b1 \u2192\u209b \u211d\u22650) {\u03b5 : \u211d\u22650\u221e}\n    (\u03b50 : \u03b5 \u2260 0) :\n    \u2203 g : \u03b1 \u2192 \u211d\u22650, (\u2200 x, f x \u2264 g x) \u2227 LowerSemicontinuous g \u2227\n      (\u222b\u207b x, g x \u2202\u03bc) \u2264 (\u222b\u207b x, f x \u2202\u03bc) + \u03b5 :="}
{"input": "Statement in natural language:\nFor any type \u03b9, any finite set s of \u03b9, any function f from \u03b9 to polynomials over a ring R, any ideal I of R, any function n from \u03b9 to natural numbers, and any natural number k, if for every element i in s and for every natural number k, the coefficient of the k-th term of the polynomial f(i) is in the power of I corresponding to n(i) minus k, then the coefficient of the k-th term of the product of the polynomials f(i) for all i in s is in the power of I corresponding to the sum of n(i) for all i in s minus k.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Polynomial.coeff_prod_mem_ideal_pow_tsub {\u03b9 : Type _} (s : Finset \u03b9) (f : \u03b9 \u2192 R[X])\n    (I : Ideal R) (n : \u03b9 \u2192 \u2115) (h : \u2200 i \u2208 s, \u2200 (k), (f i).coeff k \u2208 I ^ (n i - k)) (k : \u2115) :\n    (s.prod f).coeff k \u2208 I ^ (s.sum n - k) :="}
{"input": "Statement in natural language:\nFor any square matrix M over a ring R and any natural number k, the k-th power of M is equal to the evaluation of the polynomial obtained by taking the k-th power of the variable X and reducing it modulo the characteristic polynomial of M.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_eq_aeval_mod_charpoly (M : Matrix n n R) (k : \u2115) :\n    M ^ k = aeval M (X ^ k %\u2098 M.charpoly) :="}
{"input": "Statement in natural language:\nFor any three points x, y, and z that are collinear (i.e., they lie on the same straight line), one of the following must be true: x is between y and z, y is between z and x, or z is between x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem Collinear.wbtw_or_wbtw_or_wbtw {x y z : P} (h : Collinear R ({x, y, z} : Set P)) :\n    Wbtw R x y z \u2228 Wbtw R y z x \u2228 Wbtw R z x y :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of any type '\u03b1', where '\u03b1' has a decidable equality, the off-diagonal of the finite set 's' converted to a finset is equal to the off-diagonal of the finset converted from the finite set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.toFinset_offDiag {s : Set \u03b1} [DecidableEq \u03b1] (hs : s.Finite) :\n    hs.offDiag.toFinset = hs.toFinset.offDiag :="}
{"input": "Statement in natural language:\nIf a vector x is in the span of a set s over a ring R, then the span of the set obtained by inserting x into s is equal to the span of s.\nTranslate the statement in natural language to Lean:", "output": "theorem span_insert_eq_span (h : x \u2208 span R s) : span R (insert x s) = span R s :="}
{"input": "Statement in natural language:\nIf \u0393 is a normal subgroup, and \u03bc is both left and right invariant, then the measure map of the quotient group \u0393, restricted to a fundamental domain \ud835\udcd5, is left invariant.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasureTheory.IsFundamentalDomain.isMulLeftInvariant_map [Subgroup.Normal \u0393]\n    [\u03bc.IsMulLeftInvariant] [\u03bc.IsMulRightInvariant] :\n    (Measure.map (QuotientGroup.mk' \u0393) (\u03bc.restrict \ud835\udcd5)).IsMulLeftInvariant where"}
{"input": "Statement in natural language:\nGiven objects X\u2081\u2081, X\u2081\u2082, X\u2081\u2083, X\u2082\u2081, X\u2082\u2082, X\u2082\u2083 in a category C, morphisms h\u2081\u2081 from X\u2081\u2081 to X\u2081\u2082, h\u2081\u2082 from X\u2081\u2082 to X\u2081\u2083, h\u2082\u2081 from X\u2082\u2081 to X\u2082\u2082, h\u2082\u2082 from X\u2082\u2082 to X\u2082\u2083, v\u2081\u2081 from X\u2081\u2081 to X\u2082\u2081, v\u2081\u2082 from X\u2081\u2082 to X\u2082\u2082, and v\u2081\u2083 from X\u2081\u2083 to X\u2082\u2083, if s is a pullback of h\u2081\u2082, v\u2081\u2082, v\u2081\u2083, and h\u2082\u2082, and the composition of h\u2081\u2081 and v\u2081\u2082 equals the composition of v\u2081\u2081 and h\u2082\u2081, then the composition of h\u2081\u2081 and h\u2081\u2082 being a pullback of v\u2081\u2081, v\u2081\u2083, and the composition of h\u2082\u2081 and h\u2082\u2082 is equivalent to h\u2081\u2081 being a pullback of v\u2081\u2081, v\u2081\u2082, and h\u2082\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem paste_horiz_iff {X\u2081\u2081 X\u2081\u2082 X\u2081\u2083 X\u2082\u2081 X\u2082\u2082 X\u2082\u2083 : C} {h\u2081\u2081 : X\u2081\u2081 \u27f6 X\u2081\u2082} {h\u2081\u2082 : X\u2081\u2082 \u27f6 X\u2081\u2083}\n    {h\u2082\u2081 : X\u2082\u2081 \u27f6 X\u2082\u2082} {h\u2082\u2082 : X\u2082\u2082 \u27f6 X\u2082\u2083} {v\u2081\u2081 : X\u2081\u2081 \u27f6 X\u2082\u2081} {v\u2081\u2082 : X\u2081\u2082 \u27f6 X\u2082\u2082} {v\u2081\u2083 : X\u2081\u2083 \u27f6 X\u2082\u2083}\n    (s : IsPullback h\u2081\u2082 v\u2081\u2082 v\u2081\u2083 h\u2082\u2082) (e : h\u2081\u2081 \u226b v\u2081\u2082 = v\u2081\u2081 \u226b h\u2082\u2081) :\n    IsPullback (h\u2081\u2081 \u226b h\u2081\u2082) v\u2081\u2081 v\u2081\u2083 (h\u2082\u2081 \u226b h\u2082\u2082) \u2194 IsPullback h\u2081\u2081 v\u2081\u2081 v\u2081\u2082 h\u2082\u2081 :="}
{"input": "Statement in natural language:\nIf there is a surjective function from a ring R to another ring S, and if the ring R is an Artinian ring, then the ring S is also an Artinian ring.\nTranslate the statement in natural language to Lean:", "output": "theorem Function.Surjective.isArtinianRing {R} [Ring R] {S} [Ring S] {F} [RingHomClass F R S]\n    {f : F} (hf : Function.Surjective f) [H : IsArtinianRing R] : IsArtinianRing S :="}
{"input": "Statement in natural language:\nFor any function 'f' from the lp space of 'E' with parameter 'p', the norm of the negative of 'f' is equal to the norm of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_neg \u2983f : lp E p\u2984 : \u2016-f\u2016 = \u2016f\u2016 :="}
{"input": "Statement in natural language:\nThe product of the universal set and set t\u2081 is disjoint from the product of the universal set and set t\u2082 if and only if there exists an element i such that set t\u2081 at index i is disjoint from set t\u2082 at index i.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_univ_pi : Disjoint (pi univ t\u2081) (pi univ t\u2082) \u2194 \u2203 i, Disjoint (t\u2081 i) (t\u2082 i) :="}
{"input": "Statement in natural language:\nThe functor of the equivalence between hF and hG is equal to the composition of functor F and the inverse of eB.\nTranslate the statement in natural language to Lean:", "output": "theorem equivalence_functor : (equivalence hF hG).functor = F \u22d9 eB.inverse :="}
{"input": "Statement in natural language:\nThe hyperbolic sine function is differentiable at any real number x.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableAt_sinh : DifferentiableAt \u211d sinh x :="}
{"input": "Statement in natural language:\nIn a complete space F, the sum of the formal multilinear series p is continuous on the E-metric ball with center 0 and radius equal to the radius of p.\nTranslate the statement in natural language to Lean:", "output": "theorem FormalMultilinearSeries.continuousOn [CompleteSpace F] :\n    ContinuousOn p.sum (EMetric.ball 0 p.radius) :="}
{"input": "Statement in natural language:\nA set 'pi s t' is measurable if and only if for every element 'i' in set 's', the set 't i' is measurable, or the set 'pi s t' is empty. This is under the condition that set 's' is countable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_pi {s : Set \u03b4} {t : \u2200 i, Set (\u03c0 i)} (hs : s.Countable) :\n    MeasurableSet (pi s t) \u2194 (\u2200 i \u2208 s, MeasurableSet (t i)) \u2228 pi s t = \u2205 :="}
{"input": "Statement in natural language:\nFor any real number \u03b8, the real value of \u03b8 as an angle is equal to \u03b8 plus two times pi if and only if \u03b8 is in the interval between negative three times pi and negative pi (exclusive).\nTranslate the statement in natural language to Lean:", "output": "theorem toReal_coe_eq_self_add_two_pi_iff {\u03b8 : \u211d} :\n    (\u03b8 : Angle).toReal = \u03b8 + 2 * \u03c0 \u2194 \u03b8 \u2208 Set.Ioc (-3 * \u03c0) (-\u03c0) :="}
{"input": "Statement in natural language:\nFor a continuous affine map 'f' from 'P' to 'Q', given a condition 'h', the continuous linear part of the constructed continuous affine map from 'P' to 'Q' is equal to the linear part of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mk_const_linear_eq_linear (f : P \u2192\u1d43[R] Q) (h) :\n    ((\u27e8f, h\u27e9 : P \u2192A[R] Q).contLinear : V \u2192 W) = f.linear :="}
{"input": "Statement in natural language:\nA single-term polynomial with degree 0 and coefficient 1 is equal to the polynomial 1.\nTranslate the statement in natural language to Lean:", "output": "theorem single_zero_one_eq_one : (Finsupp.single 0 1 : R[T;T\u207b\u00b9]) = (1 : R[T;T\u207b\u00b9]) :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and another natural number 'i' such that 'i' is less than 'n + 1', and any value 'w', the predecessor of the ordered pair consisting of 'i' and the proof of 'i' being less than 'n + 1' is equal to the ordered pair consisting of 'i - 1' and the proof that 'i - 1' is less than 'n'. This proof is obtained by rewriting the inequality using the fact that 'i - 1' is less than 'n' if and only if 'i' is less than or equal to 'n', which is a consequence of the fact that 'i' is greater than zero, which in turn is a consequence of 'i' not being equal to zero, which is proven by the assumption that the value 'w' is not equal to the value of the ordered pair.\nTranslate the statement in natural language to Lean:", "output": "theorem pred_mk {n : \u2115} (i : \u2115) (h : i < n + 1) (w) : Fin.pred \u27e8i, h\u27e9 w =\n    \u27e8i - 1, by\n      rwa [tsub_lt_iff_right (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero\n        (by simpa using Fin.vne_of_ne w))]\u27e9 :="}
{"input": "Statement in natural language:\nFor a surjective function 'f' from '\u03b2' to '\u03b1' in a topological space 'T', the mapping of the neighborhood of 'a' in '\u03b2' under the topology induced by 'f' is equal to the neighborhood of 'f(a)' in '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_nhds_induced_of_surjective [T : TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Surjective f)\n    (a : \u03b2) : map f (@nhds \u03b2 (TopologicalSpace.induced f T) a) = \ud835\udcdd (f a) :="}
{"input": "Statement in natural language:\nTaking the last 'n' elements from a list 'l' is equivalent to reversing the list, taking the first 'n' elements, and then reversing the result.\nTranslate the statement in natural language to Lean:", "output": "theorem rtake_eq_reverse_take_reverse : l.rtake n = reverse (l.reverse.take n) :="}
{"input": "Statement in natural language:\nFor a given list of scalars 'l' and a vector 'x', the sum of the list 'l' scaled by 'x' is equal to the sum of the list obtained by mapping each scalar in 'l' to its scaled version by 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem List.sum_smul {l : List R} {x : M} : l.sum \u2022 x = (l.map fun r \u21a6 r \u2022 x).sum :="}
{"input": "Statement in natural language:\nFor two algebraic equivalences e\u2081 (from algebraic structure A\u2081 to A\u2082) and e\u2082 (from A\u2082 to A\u2083), the linear equivalence corresponding to the composition of e\u2081 and e\u2082 is the same as the composition of the linear equivalences corresponding to e\u2081 and e\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem toLinearEquiv_trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) :\n    (e\u2081.trans e\u2082).toLinearEquiv = e\u2081.toLinearEquiv.trans e\u2082.toLinearEquiv :="}
{"input": "Statement in natural language:\nFor any real numbers 'x', 'a', 'b', and any natural number 'm', if 'n + 1' equals 'm', 'm' equals 'rm' (a real number), the absolute value of 'x' is less than or equal to 1, and the absolute value of '1 - a' is less than or equal to 'b' minus the absolute value of 'x' divided by 'rm' times the quantity of 'rm + 1' divided by 'rm', then the absolute difference between the exponential of 'x' and the near exponential of 'x' at 'n' with 'a' is less than or equal to the 'n'th power of the absolute value of 'x' divided by the factorial of 'n' times 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_approx_end' {n} {x a b : \u211d} (m : \u2115) (e\u2081 : n + 1 = m) (rm : \u211d) (er : \u2191m = rm)\n    (h : |x| \u2264 1) (e : |1 - a| \u2264 b - |x| / rm * ((rm + 1) / rm)) :\n    |exp x - expNear n x a| \u2264 |x| ^ n / n.factorial * b :="}
{"input": "Statement in natural language:\nFor any function 'f' from a set '\u03b9' to a set of elements 'E', if every 'f(i)' is a balanced set over a field '\ud835\udd5c', then the intersection of all 'f(i)' is also a balanced set over the same field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem balanced_iInter {f : \u03b9 \u2192 Set E} (h : \u2200 i, Balanced \ud835\udd5c (f i)) : Balanced \ud835\udd5c (\u22c2 i, f i) :="}
{"input": "Statement in natural language:\nFor any sheafed space X, the global sections functor applied to the opposite of X is equal to the presheaf of X applied to the opposite of the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem \u0393_obj_op (X : SheafedSpace C) : \u0393.obj (op X) = X.presheaf.obj (op \u22a4) :="}
{"input": "Statement in natural language:\nFor every integer 'n', the function 'ofInt'' applied to 'n + 1' is equal to the function 'ofInt'' applied to 'n' plus 1.\nTranslate the statement in natural language to Lean:", "output": "theorem succ_ofInt' : \u2200 n, ZNum.ofInt' (n + 1) = ZNum.ofInt' n + 1"}
{"input": "Statement in natural language:\nFor a set \ud835\udc9c of finite sets of elements of type \u03b1 that is a lower set, and a set \u212c of finite sets of elements of type \u03b1 that is an upper set, the cardinality of the intersection of \ud835\udc9c and \u212c multiplied by 2 to the power of the cardinality of the finite type \u03b1 is less than or equal to the product of the cardinalities of \ud835\udc9c and \u212c.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLowerSet.card_inter_le_finset (h\ud835\udc9c : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsUpperSet (\u212c : Set (Finset \u03b1))) :\n    2 ^ Fintype.card \u03b1 * (\ud835\udc9c \u2229 \u212c).card \u2264 \ud835\udc9c.card * \u212c.card :="}
{"input": "Statement in natural language:\nFor any two objects P and Q in category C, if there exists a binary biproduct data for P and Q, then P and Q have a binary biproduct.\nTranslate the statement in natural language to Lean:", "output": "theorem HasBinaryBiproduct.mk {P Q : C} (d : BinaryBiproductData P Q) : HasBinaryBiproduct P Q :="}
{"input": "Statement in natural language:\nThe multiplication of an empty vector 'v' (a vector of length 0) with any vector 'w' results in an empty vector.\nTranslate the statement in natural language to Lean:", "output": "theorem empty_vecMulVec (v : Fin 0 \u2192 \u03b1) (w : n' \u2192 \u03b1) : vecMulVec v w = ![] :="}
{"input": "Statement in natural language:\nIf N\u2081 and N\u2082 are finitely generated substructures of a structure M, then the supremum of N\u2081 and N\u2082 is also finitely generated.\nTranslate the statement in natural language to Lean:", "output": "theorem FG.sup {N\u2081 N\u2082 : L.Substructure M} (hN\u2081 : N\u2081.FG) (hN\u2082 : N\u2082.FG) : (N\u2081 \u2294 N\u2082).FG :="}
{"input": "Statement in natural language:\nFor a given real number \u03b4, a set E of any type \u03b1, and an element x of type \u03b1, the thickened indicator auxiliary of \u03b4, E, and x is less than infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem thickenedIndicatorAux_lt_top {\u03b4 : \u211d} {E : Set \u03b1} {x : \u03b1} :\n    thickenedIndicatorAux \u03b4 E x < \u221e :="}
{"input": "Statement in natural language:\nFor any type F, given two applicatives A1 and A2 of type F that are lawful, if for all types \u03b1 and any value x of type \u03b1, the pure function of A1 equals the pure function of A2, and for all types \u03b1 and \u03b2, any function f from \u03b1 to \u03b2, and any value x of type F \u03b1, the sequence function of A1 equals the sequence function of A2, then A1 is equal to A2.\nTranslate the statement in natural language to Lean:", "output": "theorem Applicative.ext {F} :\n    \u2200 {A1 : Applicative F} {A2 : Applicative F} [@LawfulApplicative F A1] [@LawfulApplicative F A2],\n      (\u2200 {\u03b1 : Type u} (x : \u03b1), @Pure.pure _ A1.toPure _ x = @Pure.pure _ A2.toPure _ x) \u2192\n      (\u2200 {\u03b1 \u03b2 : Type u} (f : F (\u03b1 \u2192 \u03b2)) (x : F \u03b1),\n          @Seq.seq _ A1.toSeq _ _ f (fun _ => x) = @Seq.seq _ A2.toSeq _ _ f (fun _ => x)) \u2192\n      A1 = A2"}
{"input": "Statement in natural language:\nFor any two Cauchy sequences of rational numbers 'f' and 'g', 'f' is less than or equal to 'g' if and only if the real number constructed from 'f' is less than or equal to the real number constructed from 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_le {f g : CauSeq \u211a abs} : mk f \u2264 mk g \u2194 f \u2264 g :="}
{"input": "Statement in natural language:\nThe function 'coeSubmodule', which maps from the ideal of ring R to the submodule of ring R in field K, is injective. This means that each element in the ideal of ring R is mapped to a unique element in the submodule of ring R in field K.\nTranslate the statement in natural language to Lean:", "output": "theorem coeSubmodule_injective : Function.Injective (coeSubmodule K : Ideal R \u2192 Submodule R K) :="}
{"input": "Statement in natural language:\nThe function which appends an element \"a\" of type \"\u03b1\" to the end of a list \"l\" is computable.\nTranslate the statement in natural language to Lean:", "output": "theorem list_concat : Computable\u2082 fun l (a : \u03b1) => l ++ [a] :="}
{"input": "Statement in natural language:\nIf there is a basis 's' for a vector space 'V' over a field 'K', and if 's' is a finite set, then the vector space 'V' is finite-dimensional over the field 'K'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_finite_basis {\u03b9 : Type w} {s : Set \u03b9} (h : Basis s K V) (hs : Set.Finite s) :\n    FiniteDimensional K V :="}
{"input": "Statement in natural language:\nFor a given element 'b' of set '\u03b2', the application of function 'bind' on probability mass function 'p' and function 'f' at 'b' is equal to the sum over all 'a' of the product of the probability mass function 'p' at 'a' and the application of function 'f' at 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem bind_apply (b : \u03b2) : p.bind f b = \u2211' a, p a * f a b :="}
{"input": "Statement in natural language:\nThe zero element of the normed addition group homomorphism from V\u2081 to V\u2082 is equivalent to the zero element.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_zero : \u21d1(0 : NormedAddGroupHom V\u2081 V\u2082) = 0 :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of elements of type \u03b1, a function 'f' from \u03b1 to \u03b2, and an element 'a' of type \u03b1, the product of 'f x' raised to the power of the indicator function (which is 1 if 'a' equals 'x' and 0 otherwise) for all 'x' in 's', is equal to the indicator function (which is 'f a' if 'a' is in 's' and 1 otherwise).\nTranslate the statement in natural language to Lean:", "output": "theorem prod_pow_boole [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (\u220f x in s, f x ^ ite (a = x) 1 0) = ite (a \u2208 s) (f a) 1 :="}
{"input": "Statement in natural language:\nIf a function f has a derivative f' within a set s at a point x, then the function f is differentiable within the set s at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivWithinAt.differentiableWithinAt (h : HasFDerivWithinAt f f' s x) :\n    DifferentiableWithinAt \ud835\udd5c f s x :="}
{"input": "Statement in natural language:\nIf we have a morphism 'i' from \u0394' to \u0394, and 'i' is a monomorphism (injective function), and \u0394 is not equal to \u0394', and 'i' is not a \u03b4\u2080 morphism, then the map of the monomorphism 'i' in the functor K is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem mapMono_eq_zero (i : \u0394' \u27f6 \u0394) [Mono i] (h\u2081 : \u0394 \u2260 \u0394') (h\u2082 : \u00acIs\u03b4\u2080 i) : mapMono K i = 0 :="}
{"input": "Statement in natural language:\nFor a given element x from set E, the mapping of the negative of x by function f is equal to the negative of the mapping of x by function f.\nTranslate the statement in natural language to Lean:", "output": "theorem map_neg (x : E) : f (-x) = -f x :="}
{"input": "Statement in natural language:\nFor any two elements 'i' and 'j', if 'i' equals 'j', then the inverse of the casting of 'i' to 'j' is equal to the casting of the inverse of 'i' to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_symm {i j} (h : i = j) : (cast R M h).symm = cast R M h.symm :="}
{"input": "Statement in natural language:\nIf a function 'f' is almost everywhere strongly measurable with respect to a measure '\u03bc', then 'f' is strongly measurable at a filter 'l' with respect to the same measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasureTheory.AEStronglyMeasurable.stronglyMeasurableAtFilter\n    (h : AEStronglyMeasurable f \u03bc) : StronglyMeasurableAtFilter f l \u03bc :="}
{"input": "Statement in natural language:\nFor a covariant class \u03b1 with respect to multiplication and less than or equal to relation, given any two elements 'a' and 'b' of \u03b1 such that 'a' and 'b' are greater than or equal to 1, the product of 'a' and 'b' equals 1 if and only if both 'a' and 'b' are equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_eq_one_iff' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 \u2264 a) (hb : 1 \u2264 b) :\n    a * b = 1 \u2194 a = 1 \u2227 b = 1 :="}
{"input": "Statement in natural language:\nThe function that maps a symmetric sequence of length n over a type \u03b1 to a multiset of \u03b1 is injective. This means that if two symmetric sequences are mapped to the same multiset, then the two sequences were identical to begin with.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_injective : Injective ((\u2191) : Sym \u03b1 n \u2192 Multiset \u03b1) :="}
{"input": "Statement in natural language:\nThe set of all elements greater than or equal to 'a' and less than 'b' is a measurable set.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_uIoc : MeasurableSet (uIoc a b) :="}
{"input": "Statement in natural language:\nFor a homeomorphism 'f' from a topological space '\u03b1' to another topological space '\u03b2', the inverse of the function that maps open sets in '\u03b1' to open sets in '\u03b2' under 'f' is equal to the function that maps open sets in '\u03b2' to open sets in '\u03b1' under the inverse of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Homeomorph.opensCongr_symm (f : \u03b1 \u2243\u209c \u03b2) : f.opensCongr.symm = f.symm.opensCongr :="}
{"input": "Statement in natural language:\nFor a given element 'a' from the ring 'R', the iteration of the function 'iterToSum' applied to the constant function 'C' of 'C' of 'a' is equal to the constant function 'C' of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem iterToSum_C_C (a : R) : iterToSum R S\u2081 S\u2082 (C (C a)) = C a :="}
{"input": "Statement in natural language:\nThe function that gives the complement of an open set is bijective. This means that for every closed set, there is exactly one open set such that the closed set is the complement of the open set, and vice versa.\nTranslate the statement in natural language to Lean:", "output": "theorem Opens.compl_bijective : Function.Bijective (@Opens.compl \u03b1 _) :="}
{"input": "Statement in natural language:\nFor a given element 'a' and a given finite set 's', if 'a' is not an element of 's', then the intersection of the set containing only 'a' and 's' is an empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_inter_of_not_mem {a : \u03b1} {s : Finset \u03b1} (H : a \u2209 s) : {a} \u2229 s = \u2205 :="}
{"input": "Statement in natural language:\nFor any three integers a, b, and c, if a and b are coprime (i.e., their greatest common divisor is 1), and for a natural number k, if the product of a and b equals c raised to the power of (2k + 1), then there exists an integer d such that a equals d raised to the power of (2k + 1).\nTranslate the statement in natural language to Lean:", "output": "theorem eq_pow_of_mul_eq_pow_bit1_left {a b c : \u2124} (hab : IsCoprime a b) {k : \u2115}\n    (h : a * b = c ^ bit1 k) : \u2203 d, a = d ^ bit1 k :="}
{"input": "Statement in natural language:\nFor a given measure '\u03bc' on a set '\u03b1', where '\u03bc' is a finite measure, and for a given subset 'i' of '\u03b1' that is a measurable set, the signed measure of 'i' derived from '\u03bc' is equal to the real number representation of the measure of 'i' under '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem toSignedMeasure_apply_measurable {\u03bc : Measure \u03b1} [IsFiniteMeasure \u03bc] {i : Set \u03b1}\n    (hi : MeasurableSet i) : \u03bc.toSignedMeasure i = (\u03bc i).toReal :="}
{"input": "Statement in natural language:\nIf a function f is m-times continuously differentiable on a set s, and m is less than or equal to a real number p, then the function that maps x to the p-th power of f(x) is also m-times continuously differentiable on the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiffOn.rpow_const_of_le (hf : ContDiffOn \u211d m f s) (h : \u2191m \u2264 p) :\n    ContDiffOn \u211d m (fun x => f x ^ p) s :="}
{"input": "Statement in natural language:\nFor a list 'l' of elements of type '\u03b1', a natural number 'n', and an element 'x' of type '\u03b1', the rotation of the list 'l' by 'n' positions equals a list containing only 'x' if and only if the list 'l' itself equals a list containing only 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem rotate_eq_singleton_iff {l : List \u03b1} {n : \u2115} {x : \u03b1} : l.rotate n = [x] \u2194 l = [x] :="}
{"input": "Statement in natural language:\nIf 'a' is less than or equal to 'b', then inserting 'a' into the open-closed interval from 'a' to 'b' is equal to the closed interval from 'a' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioc_insert_left (h : a \u2264 b) : insert a (Ioc a b) = Icc a b :="}
{"input": "Statement in natural language:\nThe open interval between two positive natural numbers 'a' and 'b' is equal to the subtype of the open interval between 'a' and 'b' where 'n' is a positive natural number greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioo_eq_finset_subtype : Ioo a b = (Ioo (a : \u2115) b).subtype fun n : \u2115 => 0 < n :="}
{"input": "Statement in natural language:\nThe norm function, when applied to a sequence of elements in E that converges to 1, will result in a sequence that converges to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_norm_one : Tendsto (fun a : E => \u2016a\u2016) (\ud835\udcdd 1) (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nFor a given filter 'f' of type \u03b2, a function 'u' from \u03b2 to \u03b1, and a predicate 'p' on \u03b2, the bounded limit inferior of 'u' with respect to 'f' and 'p' is equal to the limit inferior of the composition of 'u' and the inclusion function from the subtype of elements satisfying 'p' to \u03b2, with respect to the preimage filter of the inclusion function on 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem bliminf_eq_liminf_subtype {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} :\n    bliminf u f p = liminf (u \u2218 ((\u2191) : { x | p x } \u2192 \u03b2)) (comap (\u2191) f) :="}
{"input": "Statement in natural language:\nFor a function 'm' mapping from a pair of elements (one from set \u03b1 and one from set \u03b2) to an element in set \u03b3, and two filters 'f' and 'g' on sets \u03b1 and \u03b2 respectively, the map of the curried version of 'm' over 'f' and 'g' is equal to the map of 'm' over the product of 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_curry (m : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    map\u2082 (curry m) f g = (f \u00d7\u02e2 g).map m :="}
{"input": "Statement in natural language:\nFor any three cardinals \u03b1, \u03b2, and \u03b3, if \u03b3 is less than aleph0 (the cardinality of the set of natural numbers), then the equality of \u03b1 + \u03b3 and \u03b2 + \u03b3 implies the equality of \u03b1 and \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem add_right_inj_of_lt_aleph0 {\u03b1 \u03b2 \u03b3 : Cardinal} (\u03b3\u2080 : \u03b3 < aleph0) : \u03b1 + \u03b3 = \u03b2 + \u03b3 \u2194 \u03b1 = \u03b2 :="}
{"input": "Statement in natural language:\nFor a given set 's' of type '\u03b9' and a function 'f' that maps '\u03b9' to a multivariate polynomial, the total degree of the sum of the set 's' under the function 'f' is less than or equal to the supremum (greatest element) of the set 's' under the function that maps 'i' to the total degree of 'f i'.\nTranslate the statement in natural language to Lean:", "output": "theorem totalDegree_finset_sum {\u03b9 : Type _} (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    (s.sum f).totalDegree \u2264 Finset.sup s fun i => (f i).totalDegree :="}
{"input": "Statement in natural language:\nFor a given order-preserving bijection 'e' from type \u03b1 to type \u03b2, and a set 's' of type \u03b2, the image of the inverse image of 's' under 'e' is equal to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_symm_image (e : \u03b1 \u2243o \u03b2) (s : Set \u03b2) : e '' (e.symm '' s) = s :="}
{"input": "Statement in natural language:\nFor a given function 'w' from '\u03c3' to 'M' and a given element 'm' of 'M', the weighted homogeneous submodule of 'R' with respect to 'w' and 'm' is equal to the finitely supported function from 'R' to 'R' where the support is the set of 'd' such that the weighted degree of 'd' with respect to 'w' is equal to 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem weightedHomogeneousSubmodule_eq_finsupp_supported (w : \u03c3 \u2192 M) (m : M) :\n    weightedHomogeneousSubmodule R w m = Finsupp.supported R R { d | weightedDegree' w d = m } :="}
{"input": "Statement in natural language:\nFor any integer n, the intervals (a * b^n, a * b^(n+1)) are pairwise disjoint. This means that no two such intervals share any common elements.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_disjoint_Ioc_mul_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ioc (a * b ^ n) (a * b ^ (n + 1))) :="}
{"input": "Statement in natural language:\nFor any real number x with its absolute value less than 1, the product of (1 - x) and the sum of the infinite geometric series where each term is x raised to the power of a natural number, is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_neg_geom_series (x : R) (h : \u2016x\u2016 < 1) : ((1 - x) * \u2211' i : \u2115, x ^ i) = 1 :="}
{"input": "Statement in natural language:\nFor any element 'x' from the set M, the function 'inl' applied to 'x' results in a pair where 'x' is the first element and '1' is the second element.\nTranslate the statement in natural language to Lean:", "output": "theorem inl_apply (x) : inl M N x = (x, 1) :="}
{"input": "Statement in natural language:\nIf the intersection of sets s and t with the support of function f are disjoint, and both of these intersections are finite, then the product of the function f over the union of sets s and t is equal to the product of the function f over set s multiplied by the product of the function f over set t.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_mem_union'' (hst : Disjoint (s \u2229 mulSupport f) (t \u2229 mulSupport f))\n    (hs : (s \u2229 mulSupport f).Finite) (ht : (t \u2229 mulSupport f).Finite) :\n    (\u220f\u1da0 i \u2208 s \u222a t, f i) = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i :="}
{"input": "Statement in natural language:\nIf we have a matrix M and we update a row i with a new row b, then for any other row i' that is not equal to i, the updated row i' remains the same as in the original matrix M. This is under the condition that the equality of rows can be decided.\nTranslate the statement in natural language to Lean:", "output": "theorem updateRow_ne [DecidableEq m] {i' : m} (i_ne : i' \u2260 i) : updateRow M i b i' = M i' :=\n  -- Porting note: (implicit arg) added `(\u03b2 := _)`"}
{"input": "Statement in natural language:\nFor any polynomial 'p' over a ring 'R', the degree of the polynomial obtained by mapping 'p' through a function 'f' is less than or equal to the degree of the original polynomial 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_map_le (p : R[X]) : natDegree (p.map f) \u2264 natDegree p :="}
{"input": "Statement in natural language:\nFor any element 'x' from field 'K', the application of 'of' function on 'K', 'p' and 'x' is equal to the making of a pair with '0' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_apply (x : K) : of K p x = mk _ _ (0, x) :="}
{"input": "Statement in natural language:\nFor any associative list 's' of type '\u03b2', the value of the keys of the quotient of 's' is equal to the keys of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem keys_val (s : AList \u03b2) : (keys \u27e6s\u27e7).val = s.keys :="}
{"input": "Statement in natural language:\nThe exponential of the sum of two numbers (x + y) is equal to the product of the exponentials of the two numbers separately (exp x * exp y).\nTranslate the statement in natural language to Lean:", "output": "theorem exp_add : exp (x + y) = exp x * exp y :="}
{"input": "Statement in natural language:\nFor any element 'a' from a set '\u03b1', the value of 'a' raised to the power of negative two is always greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_neg_two_nonneg (a : \u03b1) : 0 \u2264 a ^ (-2 : \u2124) :="}
