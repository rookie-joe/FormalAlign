[
  {
    "input": "Statement in natural language:\nProve that for any natural number n, n is even if and only if n leaves no remainder when divided by 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": true
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 9) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 90 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n o : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n p : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) ‚â† 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 44 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 6 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n u : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 53 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 97 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n x : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n l : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 22) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 76 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 68) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two elements \\( a \\) and \\( b \\) from a set \\( \\alpha \\) where any two elements can be compared, if a property \\( p \\) holds for both \\( a \\) and \\( b \\), then \\( p \\) also holds for the least upper bound (or supremum), denoted by \\( a \\sqcup b \\), of \\( a \\) and \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": true
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha s : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : ùïÄ) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p z : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : Œ≤) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_ind (a b : ùïå) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb t : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : √ó) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p q : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : ùïè) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha m : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p j : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : ùïç) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha g : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha r : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb n : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers 'm' and 'n' where 'n' is less than or equal to 'm', the difference 'm - n' is odd if and only if 'm' being odd is equivalent to 'n' being even.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": true
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of two open sets of complex numbers is also an open set in the complex plane.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": true
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht b : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht h : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht c : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht n : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht p : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht q : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht t : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht d : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht e : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht o : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht g : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht i : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'm' from set 'Œ±' to set 'Œ≤' and an element 'b' in 'Œ≤', prove that the inverse image of the singleton set '{b}' under 'm', is equal to the power set of the inverse image of 'b' under 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": true
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) ‚â† ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a complete metric space, the distance between any point and itself is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": true
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 74 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 84 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 51 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 92 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 79 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 11 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 35 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 39 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 82 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 8 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 62 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers `a` and `b`, the set of natural numbers from `a + 1` (inclusive) to `b` (exclusive) is the same as the set of natural numbers from `a` (exclusive) to `b` (exclusive).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": true
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b ‚â† Ioo a b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function from a set  'X' to the empty set (denoted as '0') must be equal to a function that does nothing.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": true
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 93) : f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f x : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f z : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 75) : f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f r : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f b : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 6) : f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f y : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f e : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f o : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 60) : f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(K\\) be a convex set in a Euclidean space \\(E\\). Prove that if \\(s\\) is a face of \\(K\\), then \\(s\\) is a subset of \\(K\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": true
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s f : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s w : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s b : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s j : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s m : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s n : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s v : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s p : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property P defined over infinite sequences, there exists an infinite sequence satisfying P if and only if there exists an element 'a' and an infinite sequence 'v' such that the sequence formed by prepending 'a' to 'v' also satisfies P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": true
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the measure of an open ball in a metric space is always greater than 0, given that the radius of the ball is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": true
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 74 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr g : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : ùïä) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 33 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 21 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r h : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : √ó) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 13 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr u : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : ùïç) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 85 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 40 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem measure_ball_pos (x : ‚Ñï) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood of a point 'a' is equivalent to the union of the punctured neighborhood of 'a' and the set containing only 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": true
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a ‚â† ùìù a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[=] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ‚Ñö) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ùïä) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ‚Ñù) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : √ó) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ùîπ) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ùïÑ) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ùïê) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ùïÜ) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : ùïã) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two angles \\(x\\) and \\(y\\) in an interval \\(I\\), the cotangent of \\(x\\) equals the cotangent of \\(y\\) if and only if the difference between \\(x\\) and \\(y\\) is a multiple of \\(\\pi\\) (i.e., \\(x - y\\) belongs to the set of all integral multiples of \\(\\pi\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": true
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 40 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y n : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : ùïê) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x ‚â† I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 95 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 6 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y w : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : ùïÜ) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y p : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 28 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 7 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y o : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : ùïÄ) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : ùïé) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : ‚Ñö) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 44 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the polynomial \\(1\\) (interpreted as a constant polynomial with real coefficients) has no roots.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem roots_one : (40 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem roots_one : (1 z : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 : ‚Ñö).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_one : (1 p : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (53 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_one : (1 v : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 q : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 : ùïç).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (100 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 w : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 : Œ≤).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_one : (8 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : ùïÄ).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_one : (81 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s_1 \\), \\( s_2 \\), and \\( t \\), the intersection of the union of \\( s_1 \\) and \\( s_2 \\) with \\( t \\) is equal to the union of the intersection of  \\( s_1 \\)  and \\( t \\) with the intersection of \\( s_2 \\) and \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": true
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t ‚â† s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of closing a sieve under a certain condition (J‚ÇÅ) always produces a larger sieve, or more formally, the closure operation associated with J‚ÇÅ is monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": true
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close x : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close t : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close a : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close o : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close b : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close n : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close p : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'a' has finite order with respect to another element 'b', then 'a' cannot be a unit (i.e., it doesn't have a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": true
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h w : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h m : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h d : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h r : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h a : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h x : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h t : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h u : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set of points is always cospherical.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": true
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in an inner product space, the real part of the inner product of any vector with itself is greater than or equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": true
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 45 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 57 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 54 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 66 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 36 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 27 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 38 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 68 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 55 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 48 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 3 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property \\( p \\) that takes two arguments, saying \"for all x and for all y, p(x, y) holds\" is equivalent to saying \"for all y and for all x, p(x, y) holds.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": true
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property \\( p \\) defined on elements of type \\( \\alpha \\), and for any element \\( x \\) of type \\( \\alpha \\), \\( x \\) satisfies the property \\( p \\) if and only if \\( x \\) belongs to the set of elements for which \\( p \\) holds true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": true
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x p : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x k : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x b : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x h : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x r : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x l : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x m : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x a : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x v : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\( s \\) and \\( t \\), if \\( s \\) is a subset of \\( t \\), then the intersection of \\( s \\) and \\( t \\) is equal to \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": true
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any nontrivial multiplicative group `M‚ÇÄ`, the element `0` is a primitive root of unity of order `0`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": true
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (6 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 e : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 m : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : Œ≤) 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (13 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (80 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : ùïÑ) 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : ‚Ñù) 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : ‚Ñí) 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (72 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (62 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (60 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 f : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : √ó) 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (14 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 n : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (90 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a sequence of elements in a normed vector space. Prove that if \\(f\\) is \\(q\\)-summable (i.e., the \\(q\\)-th powers of the norms of its elements form a convergent series) for some non-negative real number \\(q\\), then \\(f\\) is also \\(p\\)-summable for any \\(p\\) greater than or equal to \\(q\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": true
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•41‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•82‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq p : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•25‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•13‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•65‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq v : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f m : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•49‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•78‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq q : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq x : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•17‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq k : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the order of a monomial (a term in a polynomial with a single term) is equal to the exponent of its variable, given that the coefficient of the monomial is not zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": true
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 61) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a n : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a q : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : ùïè) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 26) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : ‚Ñù) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h w : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : Œ±) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a = 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 91) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : ùïê) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a r : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 82) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 11) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two groups, N and G, and a homomorphism œÜ from G to the automorphism group of N. This data allows us to construct a new group called the semidirect product of N and G, denoted by N ‚ãä[œÜ] G.  Now, let's say we have another semidirect product with groups N' and G', and a homomorphism œÜ' from G' to the automorphism group of N'. \n\nGiven a group element 'g' from the semidirect product N ‚ãä[œÜ] G, and functions f‚ÇÅ (a homomorphism from N to N'), f‚ÇÇ (a homomorphism from G to G'), and h (satisfying a specific property related to œÜ and œÜ'), prove that if we map 'g' using a function called 'map' constructed from f‚ÇÅ, f‚ÇÇ, and h, and then extract the 'right' component (which would be an element of G'), it's the same as first extracting the 'right' component of 'g' (an element of G) and then applying f‚ÇÇ to it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": true
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right ‚â† f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the diagonal of a zero matrix of size n x n is a zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": true
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (91 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 s : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 f : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (18 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (62 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 r : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 w : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (78 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 c : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 m : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (75 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (58 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (49 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 a : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the product of a finite collection of elements is equal to the product of the norms of those elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": true
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä ‚â† ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f x : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f a : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f p : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f e : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f w : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f m : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f u : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f q : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f y : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f v : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f t : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f g : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `ghostMap` is a bijection between the set of infinite sequences of real numbers (denoted as ùïé R) and the set of functions from natural numbers to real numbers (denoted as ‚Ñï ‚Üí R).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": true
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap x : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap e : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap b : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap k : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap q : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap t : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap l : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap u : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap d : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\(f\\) from a vector space \\(V\\) to another vector space \\(V_1\\) (both over the same field \\(K\\)), the rank of \\(f\\) is less than or equal to the dimension of \\(V\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": true
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function  f(x) = x^(-1/x), where x is a real number, approaches 1 as x approaches positive infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": true
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(82 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù-3) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 z : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñí) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x ‚â†> x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(92 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù-2) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(40 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñö) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(68 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(91 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù-5) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 g : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 s : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù+1) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(89 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù+3) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "exponent"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\) and any natural number \\( n \\),  the sine of the difference between \\( x \\) and \\( n \\) times two pi is equal to the sine of \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": true
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (79 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : Œ≤) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n b : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ùïé) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) ‚â† sin x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (55 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n e : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n g : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñí) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñ§) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (47 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (91 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n a : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ùïã) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (42 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n s : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (21 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the non-negative norm of the zero function in the Lp space is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": true
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(1 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(49 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 a : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(84 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 e : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 b : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(7 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(33 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 h : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 z : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(12 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 c : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 f : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(46 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(G\\) be a group and \\(P\\) be a Sylow \\(p\\)-subgroup of \\(G\\). Prove that the kernel of the transfer homomorphism from \\(G\\) to \\(P\\) is a complement of \\(P\\) in \\(G\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": true
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to represent a mathematical expression called \"P\". This expression \"P\" has a specific term we call \"b\". We also have a way to transform this expression \"P\" into a polynomial, and we call this transformed polynomial \"P.toPoly\".  Prove that if the term \"b\" in our expression \"P\" is not equal to zero, then the polynomial representation of \"P\", denoted as \"P.toPoly\", is also not equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 72) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b = 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 17) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 64) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 27) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 1) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 94) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 83) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 76) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 41) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 11) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 66) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 5) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the homogeneous component of a polynomial  is indeed homogeneous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": true
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\(f\\) is injective, then two elements \\(x\\) and \\(y\\) are different if and only if their images under \\(f\\) (i.e., \\(f(x)\\) and \\(f(y)\\)) are different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": true
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y j : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y n : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x = y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x = f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y k : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y g : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y e : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y w : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y l : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a set Œ± with a largest element (denoted by ‚ä§) and a subset of Œ±, called Subtype p, which also has its own largest element (also denoted by ‚ä§, but representing the largest element within the subset).  Given that the largest element of Œ± satisfies the condition 'p' which defines the subset, prove that the largest element of the subset, when viewed as an element of the original set Œ±, is the same as the largest element of Œ±.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(H\\) be a set and \\(I\\) be a function from \\(H\\) to another set. This theorem states that for every element \\(x\\) in \\(H\\), the image of the neighborhood of \\(x\\) under the function \\(I\\) is equal to the neighborhood of the image of \\(x\\) within the range of \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": true
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : ùîπ) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nhds_eq (x : ùïÄ) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nhds_eq (x : Œ≤) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) ‚â† ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : ùïç) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : ‚Ñù) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nhds_eq (x : Œ±) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : ùïÑ) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nhds_eq (x : ùïé) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : ùïê) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\(a\\) which can be positive, negative or zero, the negation of \\(a\\) is equal to \\(a\\) if and only if \\(a\\) is equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": true
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 83 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : √ó) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_eq_self_iff (a : ùïÄ) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 36 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a ‚â† a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 37 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_eq_self_iff (a : Œ≤) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_eq_self_iff (a : ‚Ñù) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 40 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 31 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 12 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 30 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\(s\\) and \\(t\\), and an element \\(a\\), if \\(a\\) is not an element of \\(s\\), then the intersection of \\(s\\) with the union of \\(a\\) and \\(t\\) is equal to the intersection of \\(s\\) and \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": true
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t ‚â† s ‚à© t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) be a function from a set \\( Œ± \\) to a set \\( Œ≤ \\). Let \\( m \\) and \\( m' \\) be two outer measures on \\( Œ± \\). Prove that for any subset \\( s \\) of \\( Œ≤ \\), the outer measure of \\( s \\) under the image of the supremum of \\( m \\) and \\( m' \\) is equal to the supremum of the outer measure of \\( s \\) under the image of \\( m \\) and the outer measure of \\( s \\) under the image of \\( m' \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": true
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') ‚â† map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers 'm' and 'n', and any element 'a' from a set with an operation denoted by '‚Ä¢', the following holds: (m + n) ‚Ä¢ a = (m ‚Ä¢ a) + (n ‚Ä¢ a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": true
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a ‚â† m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add_nsmul (a : ùïè) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nsmul (a : ùîπ) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ùïê) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : ùïÑ) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n i : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n s : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ùïã) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n f : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : ùïê) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n q : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n o : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñ§) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n a : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list of elements 'l', if every element 'x' in 'l' is also a member of a set 's', then the sum of all elements in 'l' is also a member of the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) and a property \\(p\\), prove that \\(p\\) holds frequently for elements in the preimage of a set \\(l\\) under \\(f\\) if and only if there are frequently elements \\(b\\) in \\(l\\) such that there exists an element \\(a\\) where \\(f(a) = b\\) and \\(p(a)\\) is true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": true
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a ‚â† b ‚àß p a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three positive natural numbers  \\(m\\), \\(n\\), and  \\(k\\), if  \\(k\\) and \\(n\\) are coprime, then the greatest common divisor (GCD) of \\(m \\times k\\) and \\(n\\) is equal to the GCD of \\(m\\) and \\(n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": true
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k l : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k t : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ùïê) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n ‚â† m.gcd n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k w : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k f : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k i : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : Œ≤) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k j : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k n : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k o : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñ§) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a subgroup \\(p\\) and an element \\(x\\) within that subgroup, prove that the difference between \\(x\\) and any element \\(y\\) belongs to the subgroup \\(p\\) if and only if \\(y\\) itself belongs to the subgroup \\(p\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": true
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is an isometry, then it is anti-Lipschitz with constant 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": true
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 39 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 29 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 13 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 69 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 81 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 28 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 60 f :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three finite sets \\( s‚ÇÅ \\), \\( s‚ÇÇ \\), and \\( s‚ÇÉ \\), if \\( s‚ÇÅ \\) is a superset of \\( s‚ÇÇ \\) and \\( s‚ÇÇ \\) is a superset of \\( s‚ÇÉ \\), then \\( s‚ÇÅ \\) is a superset of \\( s‚ÇÉ \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": true
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two functions \\( f \\) and \\( g \\), the set of points where \\( f + g \\) differs from \\( f \\) is precisely the set of points where \\( g \\) is nonzero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": true
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f ‚â† g.support :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `fromLocalizedModule S f` is bijective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": true
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a collection of simple graphs, all defined on the same set of vertices \\(V\\), prove that two distinct vertices \\(a\\) and \\(b\\) are adjacent in the intersection of these graphs if and only if they are adjacent in every individual graph in the collection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": true
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a = b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of lower bounds of the empty set is equal to the universal set (the set containing all elements).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": true
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) ‚â† univ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\( s \\) is unbounded with respect to the less than or equal to relation (‚â§), then it is also unbounded with respect to the strictly less than relation (<).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": true
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a basket and a box. Inside the basket, you have pairs of items, where the first item in each pair comes from a specific group called \"left\" and the second item comes from a specific group called \"right.\"  This basket represents \"Sigma.\" Now, you have two ways to get to the second item (\"right\") of a specific pair (let's call this pair \"b\"):\n\n   **Method 1:**\n     1. You first take the pair \"b\" from the basket.\n     2. Then, you directly take the second item from the pair.\n\n   **Method 2:** \n     1. You first take all the second items from every pair in the basket and put them in the box.\n     2. Then, you find the second item that originally belonged to pair \"b\" inside the box.\n\n This theorem states that both methods will lead you to the same second item from pair \"b.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": true
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap ‚â† I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any type of objects Œ±, if we have a specific object 'd' of type Œ± and another object 'x' of the same type, then applying a function called \"unbot'\" with 'd' and 'x' as inputs will always result in 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": true
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : ùïé) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : ùîπ) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : ùïã) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : ùïÑ) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : ùïÜ) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : ‚Ñí) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any irrational number \\( x \\) and a non-zero natural number \\( m \\), the division of \\( x \\) by \\( m \\) is also irrational.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": true
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 79) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm o : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m = 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 65) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 44) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m k : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 21) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 57) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 53) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm w : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm a : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( s \\), \\( t \\), and \\( u \\), if \\( s \\) is a subset of \\( u \\), then \\( s \\) is also a subset of the union of \\( t \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": true
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t i : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t p : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h q : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t j : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h d : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h v : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h o : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h p : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t v : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h l : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h b : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t r : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t y : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative numbers x and y, if the square of x is less than y, then x is less than the square root of y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": true
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 96 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 4 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 72 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 5 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 29 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ (-2) < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 93 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 88 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 80 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ (-3) < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 49 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 78 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 21 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 54 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 1 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "exponent"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine a collection of boxes indexed by a set called \"Œπ\". Each box can hold a value of a certain type. Consider a function 'f' that assigns a value to each box. Now, let's say we have a special function called \"single\" that takes an index 'i' and a value, and puts that value only in the box with index 'i', leaving all other boxes empty. There's also a function \"erase\" that takes a function like 'f' and an index 'i', and removes the value from the box with index 'i', leaving other boxes untouched.  Prove that if we add the result of  \"single i (f i)\" (which puts the value of 'f' at index 'i' into the box 'i') to the result of \"f.erase i\" (which removes the value at index 'i' from 'f'), we get back the original function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": true
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem single_add_erase (i : Œ≤) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f r : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem single_add_erase (i : √ó) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f j : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem single_add_erase (i : ‚Ñï) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem single_add_erase (i : ùïÜ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f v : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f q : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem single_add_erase (i : ‚Ñ§) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f c : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : ùîπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n', the length of its binary representation is equal to the number of bits required to represent it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": true
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length ‚â† n.size :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem size_eq_bits_len (n : ùïã) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ùïÜ) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : Œ±) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : Œ≤) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : ùïÑ) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñö) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ùïä) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : ùïè) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñí) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ùïç) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the successor of *n* is oddly bounded if and only if *n* is not oddly bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": true
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) ‚â† not (bodd n) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñ§) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : √ó) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ùîπ) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ùïÑ) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bodd_succ (n : ùïç) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bodd_succ (n : Œ≤) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bodd_succ (n : ùïÄ) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet M, N, and P be subsets of a larger set R that has addition and subtraction defined on it. Prove that the product set of M and N is a subset of P if and only if for every element m in M and every element n in N, their product m * n is an element of P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": true
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function is continuous on a set, then its inverse function (assuming it exists) is continuous on the image of that set under the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": true
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers x and y, applying the exponential map to their sum is the same as multiplying the results of applying the exponential map to each number individually.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": true
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) ‚â† expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñ§) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem expMapCircle_add (x y : Œ±) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùîπ) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùïê) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùïä) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùïÑ) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùïã) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùïÄ) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ùïé) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of two open intervals (a, ‚àû) and (b, ‚àû) is equal to the open interval (max(a, b), ‚àû).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": true
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b ‚â† Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any homomorphism 'f' between two Heyting algebras Œ± and Œ≤, composing 'f' with the identity homomorphism on Œ≤ results in 'f' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": true
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have two functions, `f` and `g`, both of which map elements from a set `X` to a set `Y`. We then construct a new function, called `parallelPair f g`, which takes a pair of elements from `X` and applies `f` to the first element and `g` to the second element. Prove that applying this new function to a special pair, where both elements are the 'zero' element of `X`, results in the set `X` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": true
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero ‚â† X :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two objects, \\(A\\) and \\(B\\), and a diagram consisting of two parallel arrows, \\(f\\) and \\(g\\), pointing from \\(A\\) to \\(B\\). Let's say we have a cocone \\(s\\) over this diagram, which essentially means we have another object, let's call it \\(C\\), along with an arrow \\(s.\\pi\\) going from \\(B\\) to \\(C\\).  Additionally, assume that \\(s\\) is not just any cocone, but a colimit of the diagram. Now, if we have another cocone \\(t\\) over the same diagram (meaning there's an arrow \\(t.\\pi\\) from \\(B\\) to some object), then we can find a unique map from the colimit object \\(C\\) to the object pointed to by \\(t.\\pi\\), such that everything commutes. This unique map is denoted by \\(hs.desc\\ t\\). The theorem then states that composing the arrow \\(s.\\pi\\) with this unique map \\(hs.desc\\ t\\) is the same as the arrow \\(t.\\pi\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": true
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t ‚â† t.œÄ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs y : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs h : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs u : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs i : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs m : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs d : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs b : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs e : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs r : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs g : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all scalar multiples of a vector 'x' only contains the zero vector if and only if the vector 'x' itself is the zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": true
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 70 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) ‚â† ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 59 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 34 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 27 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 99 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 55 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 97 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 94 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 35 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 7 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a special kind of \"sieve\" called a filter (represented by `G`) that helps us pick out certain elements from a set Œ¥. We also have four transformations: œÜ, œà, Œ∏, and œÅ, which can be thought of as ways to rearrange or map elements between different sets. The problem is to prove that applying the transformations in a specific order doesn't matter when working with these filters.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": true
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) ‚â† comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an isomorphism (a structure-preserving map between two sets that has an inverse) between sets  is differentiable everywhere on its domain.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": true
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number 4 satisfies a specific property called \"Admissible E'\". (Note: We won't define \"Admissible E'\" precisely, as it requires deeper knowledge of a specific formal system. The focus here is on how the proof works structurally.)\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": true
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 54) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 18) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 6) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 33) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 44) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 27) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 5) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 16) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if you convert a finite set into a regular set, the resulting set is countable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": true
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës x : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës t : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës o : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës w : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës r : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës c : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës k : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës n : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës u : Set Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that the function `inl R A B`, which takes an element `x` of type `A` and returns the pair `(x, 0)` of type `A √ó B`, is equivalent to the function `fun x => (x, 0)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": true
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 39) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 58) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B w : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x ‚â†> (x, 0) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 86) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 81) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B o : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_inl : (inl R A B x : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 62) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B g : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_inl : (inl R A B y : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 98) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) ‚â† fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B z : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) from a set \\( Œ± \\) to a set \\( Œ≤ \\), and any subset \\( o \\) of \\( Œ± \\), if an element \\( a \\) belongs to \\( o \\), then the image of \\( a \\) under \\( f \\) (i.e., \\( f(a) \\)) belongs to the image of the subset \\( o \\) under  \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": true
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o r : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o c : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o t : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© ‚â†> ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o n : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o m : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o q : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o i : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o v : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o k : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cardinality of the set of natural numbers (aleph-null, denoted as ‚Ñµ‚ÇÄ) is less than or equal to the cardinality of the set of real numbers (continuum, denoted as ùî†).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": true
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\(x\\), the square of the hyperbolic sine of  \\(x\\) is equal to the square of the hyperbolic cosine of \\(x\\) minus 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": true
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 91 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ (-2) = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 ‚â† cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 9 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 87 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 7 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 4 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 5 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 68 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ (-1) = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 83 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 73 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 4 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 6 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "exponent"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a direct product of two modules (like combining two separate lines into a plane), any element can be expressed as the sum of an element from the first module and an element from the second module.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function \\(f\\) and a factorization of \\(f\\) into two functions, \\(e\\) and \\(m\\), where \\(m\\) is a monomorphism (a function that preserves distinctness of elements). This factorization can be visualized as \\(f = e \\circ m\\). Now, consider the image of \\(f\\), denoted as \\(Im(f)\\). We can lift the function \\(e\\) to a function from \\(Im(f)\\) to the codomain of \\(f\\), denoted as \\(lift(e)\\). Prove that the composition of \\(lift(e)\\) and \\(m\\) is equal to the inclusion map from \\(Im(f)\\) to the codomain of \\(f\\), denoted as \\(Œπ\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": true
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m ‚â† Image.Œπ f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function `f` from a set `Œπ` to a set `Œ±` is \"monovariant\" with itself. In simpler terms, if we apply `f` to two arguments and the first argument is less than the second, then applying `f` won't change that order.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": true
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of natural numbers, ordered by the less-than relation (<), is well-founded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": true
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the exponential of any element in a normed field is a unit (i.e., has a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": true
      },
      {
        "response": "theorem isUnit_exp (x : ùïç) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_exp (x : ùïÄ) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_exp (x : Œ≤) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_exp (x : ùîπ) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ‚Ñï) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_exp (x : ùïÜ) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_exp (x : √ó) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_exp (x : ùïã) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùïä) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ‚Ñö) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of zero numbers is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": true
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 48 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 101 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 54 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 58 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 43 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 73 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 24 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is an isometry, then it is Lipschitz continuous with Lipschitz constant 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": true
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 67 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 80 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 24 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 15 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 96 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 47 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 63 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 76 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 77 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 95 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 14 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 56 f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 32 f :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\( f \\) between vector spaces \\( B \\) and \\( C \\), if \\( f \\) is injective (one-to-one), then the sequence consisting of the zero map from the zero vector space to \\( B \\) followed by \\( f \\) is exact.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": true
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (59 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f x : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f t : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (81 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (41 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 j : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f i : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f u : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 a : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (95 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 w : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 r : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (66 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 c : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any permutation \\( f \\) of a set and any element \\( x \\) in that set, applying the inverse permutation \\( f^{-1} \\) to the result of applying \\( f \\) to \\( x \\) gives us back the original element \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": true
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\( a \\) and finite set \\( s \\), checking if \\( a \\) belongs to \\( s \\) is the same as checking if \\( a \\) belongs to the underlying implementation of \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": true
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.80 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.67 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s a : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s c : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.16 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.57 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s g : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.75 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.64 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s e : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s o : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.59 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s n : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic cosine of a number x is strictly less than the hyperbolic cosine of another number y if and only if the absolute value of x is strictly less than the absolute value of y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": true
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number \\(x\\) is a factor of a number \\(a\\) (where \\(a\\) is not zero), then \\(x\\) must be a prime number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": true
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x z : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x o : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x w : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : ‚Ñö) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : ‚Ñ§) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x t : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x l : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : ùïã) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : ùïä) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : ùïÑ) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx c : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x k : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : √ó) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements 'a' and 'b', applying a strictly increasing function 'ofAdd' to them preserves the order, meaning if 'a' is less than or equal to 'b', then 'ofAdd(a)' is less than or equal to 'ofAdd(b)', and vice versa.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": true
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a relation `r` that holds between elements of a set `N`. There is also a function `Œº` that takes an element from a set `M` and an element from `N` and returns a new element in `N`. The statement says that if the relation `r` holds between the results of applying `Œº` with `m` to `a` and `b` respectively, then the relation `r` must also hold directly between `a` and `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": true
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab y : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b u : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab w : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ùïè) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : √ó) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab b : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b p : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ùïÄ) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ùïç) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ‚Ñö) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab j : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ùïÑ) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ùïé) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : ùîπ) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a ring called \\(R\\), a module over that ring called \\(M\\), and a subset of the ring called \\(s\\). We can create a special subgroup of \\(M\\) called the \"torsion subset by \\(s\\)\", written as (torsionBySet R M s). This subset consists of all elements in \\(M\\) that can be \"annihilated\" (sent to zero) by multiplying with some element from our subset \\(s\\).  Prove that this torsion subset is indeed a torsion subset with respect to the set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": true
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements \\(a\\), \\(b\\), and \\(c\\) in a set with a defined least upper bound operation (\\(\\sqcup\\)), the following holds:  \\(a \\sqcup b \\sqcup c = a \\sqcup c \\sqcup (b \\sqcup c)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": true
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : ùïç) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : ‚Ñí) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c ‚â† a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : ùïÜ) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : ùïä) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : ‚Ñï) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : ‚Ñ§) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vectors u, v, and w (where w is non-zero), the absolute value of the difference between the lengths of u/w and v/w is less than or equal to the length of (u/w - v/w).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : ‚Ñí) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : ‚Ñö) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : ùïÜ) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : Œ≤) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : ùïç) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : ùïä) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : ùïå) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the open interval (b, c) under the function that adds a constant 'a' to a number is equal to the open interval (b - a, c - a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": true
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c ‚â† Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x ‚â†> x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a ring \\(R\\) and an ideal \\(I\\) of \\(R\\), prove that the product of the annihilator of \\(I\\) and \\(I\\) is equal to the zero ideal (denoted by ‚ä•).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing any function \\(f\\) with the identity function results in the function \\(f\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": true
      },
      {
        "response": "theorem id_comp : id.comp f ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the projection function, which takes an ordered pair (x, y) and returns the first element x, is infinitely differentiable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": true
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst n : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst y : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst a : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst h : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst z : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst p : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst l : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst v : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a matrix representing a linear transformation that maps everything to zero, all the entries are zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": true
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (14 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 f : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ≤) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (98 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 z : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : Œ≤) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (32 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j t : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j y : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (78 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (57 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a function to a function with finite support and then taking its support is the same as directly taking the support of the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": true
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support ‚â† Function.support f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet A be a Noetherian ring, and let f be a ring homomorphism from A to B. Prove that the algebra B is finitely generated over A if and only if B is finitely presented as an A-algebra.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": true
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn any category, the pullback of a morphism along a morphism from the initial object is isomorphic to the initial object.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": true
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (79 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 k : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : √ó) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (76 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (96 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (54 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 p : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : ùïé) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (48 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (24 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 u : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_left (X : √ó) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_left (X : ùîπ) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : ùïå) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two functions, \\( e \\) and \\( e' \\), always produce the same output for any given input, then the two functions are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": true
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e ‚â† e' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x ‚â† e' x) : e = e' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the multiplicative inverse of a positive number 'a' is greater than 1 if and only if the number 'a' itself is less than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": true
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 29 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 84 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 54 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 34 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 5 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 32 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 74 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 59 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 64 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 99 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 37 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 39 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a constant real polynomial has no roots.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": true
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 62 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem roots_C (x : ‚Ñï) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_C (x : ùïÜ) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 59 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 9 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 21 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 95 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 79 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 43 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 42 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C (x : √ó) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_C (x : Œ≤) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 11 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have two objects, X and Y, and a map (like a function) called 'f' that goes from X to Y.  This map 'f' lives in a special world where everything is \"opposite\" - we call this the \"opposite category.\" In this opposite world, there's a way to turn 'f' into a map that goes from Y to X (going backwards). We call this backwards map \"f.unop\". Now, sometimes a map is special because it has an \"inverse\" - another map that undoes it completely. We call these special maps \"isomorphisms.\" This theorem wants to prove that:  f.unop is an isomorphism if and only if the original map f is an isomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": true
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f d : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f j : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f g : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f r : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f t : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f i : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f c : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f a : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, and c, adding 'a' to every number within the open interval (b, c) is equivalent to shifting the interval (b, c) by 'a' units to the right on the number line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": true
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x ‚â†> a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c ‚â† Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two groups, H and K, where H is a subgroup of K (denoted by H ‚â§ K). Prove that if H has finite index in K, then K also has finite index.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": true
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number c, b divided by c is less than a if and only if b is less than a multiplied by c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": true
      },
      {
        "response": "theorem div_lt_iff (hc : 67 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 33 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_lt_iff (hc : 62 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 49 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 2 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 86 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_lt_iff (hc : 42 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 36 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\( E \\) and a positive real number \\( \\delta \\), the \\( \\delta \\)-thickening of \\( E \\) is a neighborhood of \\( E \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": true
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 68 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 89 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ q : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ a : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 27 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 22 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ l : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 4 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 71 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 54 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ i : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 46 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 65 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function that takes two indices, \\(i\\) and \\(j\\), and returns a downward-closed set (a \"lower set\") of elements from some set Œ±. Prove that an element \\(a\\) belongs to the union of all these lower sets if and only if there exists some indices \\(i\\) and \\(j\\) such that \\(a\\) belongs to the lower set \\(f(i, j)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": true
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that shifting any three points in a vector space by the same vector does not change the angle between them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": true
      },
      {
        "response": "theorem angle_const_add (v : ‚Ñù) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ a : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ f : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : ùïç) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) ‚â† ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : ùïä) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : ùïè) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : ùïã) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : ‚Ñö) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ u : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ j : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem angle_const_add (v : ‚Ñï) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : ‚Ñö) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ l : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(a\\) be a point and \\(s\\) and \\(t\\) be sets. If \\(s\\) is a neighborhood of \\(a\\) within the set \\(t\\), then a set is a neighborhood of \\(a\\) within the intersection of \\(s\\) and \\(t\\) if and only if it is a neighborhood of \\(a\\) within \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": true
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h b : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t w : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t g : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a ‚â† ùìù[t] a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h x : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t u : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h l : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t f : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h n : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h s : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h f : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t z : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'f' between two structures 'C‚ÇÅ' and 'C‚ÇÇ' that preserves certain properties (Hom), applying a specific construction 'sqFrom' at an index 'i' and then projecting to the 'left' component is the same as directly applying 'f' at index 'i'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": true
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : √ó) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i p : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : ùîπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left ‚â† f.f i :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i k : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œ≤) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i g : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i y : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : ùïê) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : ùïÜ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i o : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\(f\\) is injective (meaning it maps distinct elements to distinct elements), then the function \\(map f\\) is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": true
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a quotient set of lower sets back to a regular set results in the same quotient set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": true
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) ‚â† s / t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a value 'a' is not the successor of another value if and only if 'a' is in the range of the successor function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": true
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a walk in a graph is Eulerian, then it is also a trail.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": true
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p u : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : ùïê) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h b : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : ùïä) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h e : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h k : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : ‚Ñö) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p s : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h o : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : ‚Ñí) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : Œ±) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h m : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : ùïè) : p.IsTrail :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set  \\(ùíú\\) and a natural number \\(k\\), prove that a set \\(s\\) belongs to the \"falling set\"  \\(falling \\; k \\; ùíú\\)  if and only if:\n 1. There exists a set \\(t\\) in \\(ùíú\\) such that \\(s\\) is a subset of \\(t\\), AND\n 2. The number of elements in \\(s\\) (its cardinality) is equal to \\(k\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": true
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card ‚â† k :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers m and n, the sum (m + n) is odd if and only if exactly one of m or n is odd and the other is even.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": true
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\), the elements of the intersection of \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\) are the same as the elements in the intersection of the underlying sets of \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": true
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).90 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).16 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).25 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).28 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 ‚â† s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).3 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).77 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).99 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).69 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).88 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).80 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).94 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a specific element 'a' and a function 'e'. 'e' takes an element from a set we'll call Œ≤‚ÇÅ and gives us back an element from another set (it doesn't matter what this other set is for this problem). Now, let's say we have a pair containing 'a' and an element 'b' from Œ≤‚ÇÅ. If we use a special operation called 'prodExtendRight' on this pair, 'a', and our function 'e', it should be the same as creating a new pair. This new pair will still have 'a' as its first element, but the second element will be the result of applying the function 'e' to 'b'. Prove that this is true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": true
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) ‚â† (a, e b) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ùïÑ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ùîπ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ùïã) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ùïè) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ùïç) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ‚Ñö) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : ùïÜ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets  \\( s‚ÇÅ \\), \\( s‚ÇÇ \\), and \\( t \\), the image of the union of sets \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\) under a function \\( ‚Ä¢ \\) with elements of set \\( t \\) is equal to the union of the images of \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\) under the function \\( ‚Ä¢ \\) with elements of \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": true
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t ‚â† s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the constant coefficient of a formal power series \\( \\phi \\) is equal to the coefficient of the term with degree 0 in \\( \\phi \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": true
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 65 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ ‚â† œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 58 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 24 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 13 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 42 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 6 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(s\\), \\(t\\), and \\(u\\) be sets. Prove that the product set \\(s * t\\) is a subset of \\(u\\) if and only if for every element \\(b\\) in \\(t\\), the set obtained by multiplying each element of \\(s\\) by \\(b\\) (denoted as \\(op b ‚Ä¢ s\\)) is a subset of \\(u\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": true
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any partisan game 'x', prove that 'x' is less than or equal to the game obtained by performing a right move on 'x' for any value of 'j'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": true
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the distance between a solution (soln) and a point 'a' is less than the norm of the derivative of a function F evaluated at 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the closure of a countable set \\(s\\) in a topological space with respect to a linear operator \\(L\\) is countably generated.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": true
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ùïÜ) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs z : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs m : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ‚Ñù) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ùïé) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs b : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ‚Ñï) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : √ó) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ùïå) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs w : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ùïê) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : ùïÄ) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs o : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number `n`, there is no natural number that comes after the last element within the range from 0 to `n` (inclusive).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": true
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) ‚â† none :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) that maps each ordinal number smaller than 1 to another ordinal number, prove that the smallest ordinal number greater than or equal to all \\(f(a)\\) (where \\(a\\) is an ordinal smaller than 1) is equal to \\(f(0)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": true
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (4 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f ‚â† f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 k : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : √ó), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : ùïé), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (98 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 13 zero_lt_one :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 q : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 64 zero_lt_one :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : ‚Ñù), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 41 zero_lt_one :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 f : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : ùïä), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 m : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (52 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the square of 'a' is equal to the square of 'b' if and only if 'a' is equal to 'b' or 'a' is equal to the negative of 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": true
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 70 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 5 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 4 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 46 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a ‚â† b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 3 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 7 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 5 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 ‚â† b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 51 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 1 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ (-1) = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ (-2) ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 97 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the order of the identity element in a group is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": true
      },
      {
        "response": "theorem orderOf_one : orderOf (41 : G) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (21 : G) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 h : G) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : Œ≤) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (71 : G) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 m : G) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 y : G) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : ùïå) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (23 : G) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (13 : G) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : ùîπ) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : ùïç) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 r : G) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : ùïê) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any filter \\( l \\) on a set \\( \\alpha \\), the intersection of all sets in the neighborhood filter of \\( l \\) is equal to the principal filter generated by \\( l \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": true
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } ‚â† Iic l :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the top element of a convex cone to a set results in the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": true
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ h : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ e : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) ‚â† (univ : Set E) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ a : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ y : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ r : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ l : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ w : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ f : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ s : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ n : Set E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood of infinity in the one-point compactification of a topological space X is equal to the union of the image of the collection of co-closed compact sets under the inclusion map and the set containing only infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": true
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) ‚â† map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the addition operation is associative for morphisms between objects in a category C. In simpler terms, if we have three morphisms (a, b, and c) between the same objects, then adding a to the sum of b and c is the same as adding the sum of a and b to c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": true
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c ‚â† a + (b + c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c v : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c y : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c g : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c b : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c q : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c j : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c h : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c t : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c z : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c f : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of real numbers between any two distinct real numbers a and b is infinite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": true
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\(s\\) and \\(t\\) which are subsets of a larger set, the preimage of set \\(t\\) under the inclusion map from \\(s\\) to the larger set is empty if and only if the intersection of sets \\(s\\) and \\(t\\) is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t ‚â† ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function from \\(A\\) to \\(Œ≤\\) that is already known to satisfy a certain property (represented by \\(n\\)). The function \\(mk\\) takes \\(f\\) and a proof \\(h\\) of this property as input and produces a new function from \\(A\\) to \\(Œ≤\\). Prove that the function produced by \\(mk\\) is actually the same as the original function \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": true
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we take a path (a continuous curve) between two points and reparameterize it using the identity function, we get the same path back.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": true
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl ‚â† Œ≥ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet M be a set with a binary operation and an identity element.  For elements a in M and invertible elements x, y in M, the element obtained by first applying the inverse of y, then the inverse of x, and finally conjugating by a is the same as first conjugating a by x and then by y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": true
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y u : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y q : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y v : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y x : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y m : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y w : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y n : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that reversing a pair formed by \"single\" results in a new pair with the elements swapped.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": true
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm ‚â† single b a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b o : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : ùïä) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_single (a : ùïä) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : ùïÄ) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b x : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b m : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b e : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ±) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b v : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : ùïé) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b h : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn category theory, prove that the left unitor and right unitor are equal when applied to the identity morphism of an object in a monoidal category.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": true
      },
      {
        "response": "theorem unitors_equal : (Œª_ (87 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (43 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (48 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom ‚â† (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (15 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (41 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (90 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (66 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (84 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (35 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (98 a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\(a\\) and natural numbers \\(m\\) and \\(n\\) where  \\(m ‚â§ n\\),  \\(a^m * a^{(n-m)} = a^n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": true
      },
      {
        "response": "theorem pow_mul_pow_sub (a : ùïê) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ (n-4) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h m : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : ùïé) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) ‚â† a ^ n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n s : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m-4) = a ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n p : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : ‚Ñù) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ (n+5) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n q : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : ùïå) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m+4) = a ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h b : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : ùïè) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a finite linear combination 'l' of elements from a set 'Œπ' with coefficients in a ring 'R'.  Given a specific element 'e' from 'Œπ', we can construct a dual basis element 'DualBases.lc e l'. This theorem states that if we extract the coefficients of this dual basis element using 'h.coeffs', we recover our original linear combination 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": true
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) ‚â† l :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers *m* and *n*, *m* divides *n* if and only if *m* as an integer divides *n* as an integer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": true
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm a : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm s : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ùîπ) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ùïè) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm g : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ùïå) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñö) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñí) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm u : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ùïÄ) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm i : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm n : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ùïç) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of a function plus a constant is equal to the derivative of the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": true
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x ‚â† fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem fderiv_add_const (c : ùïÄ) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y ‚â†> f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem fderiv_add_const (c : Œ±) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : ùïÑ) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : ‚Ñö) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : ùïä) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fderiv_add_const (c : ‚Ñï) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function œÜ that maps elements from a set with an operation ^ (like repeated multiplication), prove that applying œÜ to the n-th power of an element x is the same as taking the n-th power of œÜ(x).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": true
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ (n+1)) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem map_pow (x : A) (n j : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_pow (x : ùïç) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) ‚â† œÜ x ^ n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ (n+5)) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem map_pow (x : A) (n o : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_pow (x : A) (n : ùïå) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_pow (x : A) (n e : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ (n+2)) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ (n-3)) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem map_pow (x : A) (n b : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_pow (x : A) (n : ùïè) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ùïä) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that scaling a ball of radius Œ¥ around the point 1 by a factor of 1/s is the same as taking a thickening of the point 1 with radius Œ¥/s.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem ball_div_one : ball 57 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s ‚â† thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ball_div_one : ball 81 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 74 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 34 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 21 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 84 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 72 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 3 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 61 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 38 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function that maps elements from a set to itself.  Assume that for any element \\(x\\), \\(f(x)\\) is always less than or equal to \\(x\\). Prove that for any natural number \\(n\\), applying \\(f\\) repeatedly \\(n\\) times will result in a value less than or equal to the initial input.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": true
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ùïå) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n y : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ùïÜ) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : Œ±) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n t : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n r : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ùïç) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n u : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ùïè) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n b : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n d : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n g : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n p : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n o : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets, A and B, if we have two subsets of A, A1 and A2, such that A1 is a subset of A2, and two subsets of B, B1 and B2, such that B1 is a subset of B2, then the Cartesian product of A1 and B1 is a subset of the Cartesian product of A2 and B2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": true
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'a' in a set 's' is a minimum point of a function 'f' over the set 's', then 'a' is also an extreme point of 'f' over 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": true
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element belongs to the symmetric difference of two sets if and only if it belongs to exactly one of the two sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": true
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three integers i, j, and k, the greatest common divisor (GCD) of the product of i and j and the product of i and k is equal to the product of the absolute value of i and the GCD of j and k.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": true
      },
      {
        "response": "theorem gcd_mul_left (i j k : ùïê) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) ‚â† natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ùïç) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ùïå) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ùïÄ) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ùîπ) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : Œ±) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ùïè) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : Œ≤) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of indices of non-zero coefficients of the zero polynomial is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem support_zero : (13 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem support_zero : (0 k : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 : ‚Ñï).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_zero : (0 : ‚Ñù).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (34 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem support_zero : (0 : ùïê).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_zero : (0 b : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 : ùîπ).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_zero : (0 x : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (35 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem support_zero : (0 : ‚Ñö).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_zero : (0 q : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 c : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 l : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : ‚Ñ§).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_zero : (0 : ùïÑ).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a property `p` that holds for some positive natural number `m`, prove that the smallest positive natural number satisfying `p` (denoted by `PNat.find h`) is less than or equal to `m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": true
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm r : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm e : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm a : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm p : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm v : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm g : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm h : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm b : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm c : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative number 'a' in the set of numbers of the form  x + y‚àöd, where x and y are integers and d is a fixed non-square integer, it can be expressed in one of the following forms:\n1. x + y‚àöd, where x and y are both natural numbers.\n2. x - y‚àöd, where x and y are both natural numbers.\n3. -x + y‚àöd, where x and y are both natural numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": true
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+24]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñí), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñí), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a x : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : Œ≤), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : Œ≤), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ ‚â†> ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+11]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+34]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ùîπ), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ùîπ), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a ‚â† ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+29]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y i : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ùïç, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ùïç)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ùïç)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñù, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñù)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñù)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+15]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any nonzero natural number `n`, taking the set of numbers from 0 to `n` and filtering it to keep only the divisors of `n` results in the same set as the set of divisors of `n`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": true
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 40) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) ‚â† n.divisors :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 56) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 58) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n = 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 16) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 9) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 66) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 26) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 86) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 18) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 46) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 89) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 31) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 47) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any real number 'r', a function 'p' that measures the size of elements in a space 'E' (like measuring the length of a vector), and an element 'x' in the space 'E', applying the scaled function '(r ‚Ä¢ p)' to 'x' is the same as scaling the result of applying 'p' to 'x' by 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": true
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : ùïä) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x s : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_apply (r : R) (p z : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_apply (r : ùîπ) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x ‚â† r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : ùïè) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x j : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : ùïÑ) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p n : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p h : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p u : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : ‚Ñö) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a scalar 's', and a matrix 'a' over some field 'ùïú' and set 'A', prove that scaling the matrix 'a' by 's' and then applying a transformation (represented by '.toProd') is the same as first applying the transformation to 'a' and then scaling the result by 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": true
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd ‚â† s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a i : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_toProd (s : ‚Ñù) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_toProd (s : ‚Ñö) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a y : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_toProd (s : Œ≤) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_toProd (s : S) (a c : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_toProd (s : ‚Ñí) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : ùïÄ) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_toProd (s : ùïê) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_toProd (s : S) (a d : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a j : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' has an upper bound, then the image of 's' under a function 'f' also has an upper bound.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": true
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© ‚â†> ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a scenario where we are working with elements from a set 'Œ±' and we have a specific element 'p'. We can think of 'toIocMod hp' as an operation that takes two elements from 'Œ±' and gives us a new element, potentially modified based on 'hp' and 'p'. This theorem aims to prove that applying this operation on elements 'a' and 'b + m ‚Ä¢ p' yields the same result as applying it on 'a' and 'b', where 'm' is an integer and '‚Ä¢' represents an operation between an integer and an element from 'Œ±'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": true
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m s : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) ‚â† toIocMod hp a b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m r : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : ùïÄ) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m d : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñï) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ùïç) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m l : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m z : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñö) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : ‚Ñ§) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ùïÜ) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m w : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function \\( f \\) is differentiable on the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function \\( f \\) that maps elements from set \\( R \\) to set \\( S \\) while preserving some structure \\( M \\) (like addition or multiplication), then applying \\( f \\) directly is the same as first converting \\( f \\) into a regular function and then applying it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": true
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f n : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f w : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f e : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f c : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f d : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f r : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f y : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that the number of elements in a finite set containing 'n' natural numbers is equal to 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": true
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Fintype.card_fin (n : ùïÄ) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : Œ≤) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Fintype.card_fin (n : ùïè) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ùïç) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ùïã) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñí) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Fintype.card_fin (n : √ó) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ùïÜ) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ùïå) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the p-adic valuation of 1 is 0, for any prime number p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": true
      },
      {
        "response": "theorem one : padicValNat p 93 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 53 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one : padicValNat p 1 ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 68 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one : padicValNat p 1 = 44 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 4 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one : padicValNat p 1 = 98 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 72 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one : padicValNat p 1 = 24 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 22 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one : padicValNat p 1 = 51 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if you reverse a list twice, you get back the original list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": true
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) ‚â† L‚ÇÅ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two lists l‚ÇÅ and l‚ÇÇ, if an element 'a' belongs to list l‚ÇÅ, then 'a' also belongs to the union of lists l‚ÇÅ and l‚ÇÇ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ t : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ q : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ k : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ x : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ g : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ h : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ z : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ c : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ o : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two functions, viewed as mere mappings from one set to another, are equal, then they are also equal when considered as specific constructions called \"subtypes.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": true
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f t : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f y : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f k : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) ‚â† g) : f = g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f v : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f a : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f i : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f x : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f z : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f h : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f j : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given two pairs, if the first pair is less than or equal to the second pair, then the second element of the first pair is less than or equal to the second element of the second pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": true
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any proposition \\( p \\) that is decidable (meaning we can determine whether it is true or false), proving \\( p \\) is the same as evaluating the truth of  \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": true
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any finite set 's' is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": true
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs c : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs p : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : ùïÜ) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs v : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : ùïÑ) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs h : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : ùïç) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs a : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs x : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs w : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : ‚Ñù) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : ‚Ñí) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : Œ≤) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs k : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural numbers \\(b\\) and \\(n\\) where \\(b\\) is greater than 1 and \\(n\\) is not 0, prove that the logarithm base \\(b\\) of (\\(n\\) multiplied by \\(b\\)) is equal to the logarithm base \\(b\\) of \\(n\\) plus 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": true
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 88 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb v : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn x : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 101 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) ‚â† log b n + 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 34 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 51) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn j : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n = 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 99 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb s : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb t : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb x : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 11 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb f : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the linear transformation represented by a matrix A to a vector v is the same as multiplying the matrix A with the vector v.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": true
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v ‚â† Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number 'n', prove that calculating 'bit1 n' and then casting it to type 'R' is the same as first casting 'n' to type 'R' and then calculating 'bit1' of the result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": true
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n a : R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n e : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : ùïã) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) ‚â† bit1 (n : R) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n p : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ùïÜ) : ((bit1 n : ùïÜ) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ùïè) : ((bit1 n : ùïè) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n y : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : ‚Ñö) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n v : R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a family of sets {X_i} indexed by elements 'i' from a set 'I', and a function 'f' that takes an element 'i' from 'I' and returns a function from a set 'A' to the corresponding set X_i, prove that evaluating the function 'pi f' at an element 'a' from 'A' is the same as defining a new function that takes an element 'i' from 'I' and returns the result of applying the function f(i) to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": true
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I ‚â†> (f i) a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a ‚â† fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a y : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(√ó, X i)) (a : √ó) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a b : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a p : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(ùïå, X i)) (a : ùïå) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i q : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a s : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(Œ≤, X i)) (a : Œ≤) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(ùïê, X i)) (a : ùïê) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(‚Ñ§, X i)) (a : ‚Ñ§) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set `s` is a subset of another set `t` if and only if the nonempty interval represented by `s` is contained within the nonempty interval represented by `t`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": true
      },
      {
        "response": "theorem coe_subset_coe : (s c : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s c : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s o : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s a : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s o : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s p : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s d : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s t : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function that adds a constant value 'a' to any input 'x', prove that the preimage of the open interval (b, c) under this function is equal to the open interval (b-a, c-a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": true
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c ‚â† Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x ‚â†> a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing duplicates from a multiset formed by adding an element 'a' to a multiset 's' is equivalent to adding 'a' to the multiset obtained by removing duplicates from 's', but only if 'a' is not already present in the de-duplicated version of 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": true
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s u : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s i : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) ‚â† ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s y : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s n : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s x : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `t`, the set product of the empty set and `t` is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a structure that preserves a specific operation (like addition or multiplication) and a specific element 'z', applying a function that essentially doesn't change the elements within this structure to 'z' will result in 'z' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": true
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.57) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_id (z : ùïÜ) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z ‚â† z :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_id (z : ùïå) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.20) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_id (z : ùïç) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.46) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_id (z : ùïÑ) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_id (z : ùïã) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.31) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.25) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : ùïä) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_id (z : √ó) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.74) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.35) f z = z :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any type \\( \\alpha \\) and a type \\( \\beta \\) that has a smallest element (denoted as \\( \\bot \\)), applying the bottom infimum homomorphism (represented as \\( \\bot \\)) from \\( \\alpha \\) to \\( \\beta \\) to any element \\( a \\) of type \\( \\alpha \\) will always result in the smallest element (\\( \\bot \\)) of type  \\( \\beta \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ùïÄ) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ùïä) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ùïç) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ùïê) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ‚Ñù) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ≤) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ‚Ñö) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ùïÜ) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : ùïÑ) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(b\\) be an ultrafilter on a set \\(\\alpha\\). Prove that the preimage of the neighborhood filter of \\(b\\) under the function \\(pure\\) is a subset of \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": true
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `g` directly to a value `x` is equivalent to first packaging `x` into a constant function (represented by `C x`) and then evaluating it using a generalized evaluation function `aevalTower` with arbitrary arguments `g` and `y`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": true
      },
      {
        "response": "theorem aevalTower_C (x : ‚Ñù) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) ‚â† g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem aevalTower_C (x : √ó) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : ùïç) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : Œ≤) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : ‚Ñ§) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : ùïÑ) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem aevalTower_C (x : ùïã) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem aevalTower_C (x : ùïê) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : ùïÜ) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any cardinal numbers `a` and `b`, if `b` is not equal to 0 and `a` divides `b`, then `a` is less than or equal to `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": true
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 25 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h q : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b e : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© ‚â†> by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 ‚â†> b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.6 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.81 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h f : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h m : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b o : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 7 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b a : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h c : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 65 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b = 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h j : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a given function 'e' is an isometry.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isometry : Isometry e :=",
        "label": true
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a list of characters `l`, the length of the string representation of `l` is equal to the length of `l`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": true
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length ‚â† l.length :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have two balls centered at the same point \\(x\\) with radii \\(Œµ‚ÇÅ\\) and \\(Œµ‚ÇÇ\\), and if \\(Œµ‚ÇÅ\\) is less than or equal to \\(Œµ‚ÇÇ\\), then the ball with radius \\(Œµ‚ÇÅ\\) is entirely contained within the ball with radius \\(Œµ‚ÇÇ\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the restriction of any measure Œº to a singleton set {a} is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": true
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 63 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 64 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 69 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 40 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 3 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 38 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 57 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 84 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two integers, \\(z_1\\) and \\(z_2\\), are equal if and only if their residues modulo a prime number \\(p\\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": true
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ùïå) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñù) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 h : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : Œ≤) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) ‚â† z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 k : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ùïê) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 ‚â† z2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 t : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 u : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 d : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : Œ±) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 r : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 b : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\( f_0 \\) and \\( f_1 \\), and a continuous deformation (homotopy) \\( F \\) between them that preserves a property \\( P \\). Then, for any input \\( x \\), evaluating the homotopy \\( F \\) at the starting point of the deformation (represented by 0) yields the same result as applying the initial function \\( f_0 \\) to \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": true
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (49, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : Œ≤) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x y : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : ùïÑ) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) ‚â† f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (84, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x p : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : ùïä) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (80, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : ‚Ñ§) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x n : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : ùïè) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : ‚Ñï) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x l : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an ordered pair (x, y), where x is an element of a set with a multiplicative identity (denoted as 1) and y is an element of another set with a multiplicative identity (also denoted as 1), is equal to the ordered pair (1, 1) if and only if x equals 1 and y equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": true
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 43 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y v : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y g : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y a : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 4 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y p : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 32 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y i : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 79 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y l : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y b : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y c : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) ‚â† 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y n : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers `n`, `m`, and `l`,  `l` belongs to the interval `[n, m)` if and only if `n ‚â§ l` and `l < m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": true
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the limit superior of a sequence is always less than or equal to its supremum.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": true
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u f : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u o : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u l : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u p : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u k : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u d : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u c : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u t : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u g : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u h : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two ordered pairs, swapping the elements of the first pair results in the same ordered pair as swapping the elements of the second pair if and only if the two original pairs are the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": true
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p ‚â† q :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p ‚â† swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a vector space element to an element in its completion using the canonical linear isometry is equivalent to directly embedding the element into the completion.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": true
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ y : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) ‚â† ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ t : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ i : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ e : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ b : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ o : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ m : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ g : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet K and L be fields where K is a subfield of L. Let s represent an intermediate field between K and L. Prove that an element x of L belongs to the subalgebra generated by s if and only if x belongs to s itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x f : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x a : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x i : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : ùïå) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : ùïã) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x n : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : √ó) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : ùîπ) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x u : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : ùïÜ) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x l : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x y : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we construct a cone from a bicone, the apex of the cone will be the same as the apex of the original bicone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": true
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt ‚â† B.pt :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element \\( x \\) is a duplicate within a singleton set (a set containing only one element, \\( y \\)), then we have a contradiction (False).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": true
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h c : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h w : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h n : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h t : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h x : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h f : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h v : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h z : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h e : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the entire space under any function is still the entire space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : √ó) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : ùïã) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : ‚Ñí) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : ùîπ) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comap_top (f : ùïå) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comap_top (f : ùïé) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : ùïÜ) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a non-negative extended real number x, when considered as a general extended real number, equals 1 if and only if x itself equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": true
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 2 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : ùïÄ) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : Œ±) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) ‚â† 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 13 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 84 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x w : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : ‚Ñö) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•97‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : ùïè) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x q : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : ùïê) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•19‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x m : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) be an ultrafilter and \\( g \\) be a filter on a set \\( Œ± \\). Prove that if the infimum (greatest lower bound) of \\( f \\) and \\( g \\) is not the bottom element (the filter containing only the whole set \\( Œ± \\)), then \\( f \\) is a subset of \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": true
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg j : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg w : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g k : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg q : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg y : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g e : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g v : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g y : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg n : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) and \\(g\\) represent sets of vectors, and let \\(s\\) be a vector in \\(f\\) and \\(t\\) be a vector in \\(g\\). Prove that the vector difference \\(s - t\\) is an element of the set obtained by taking the difference of every vector in \\(f\\) with every vector in \\(g\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": true
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if set  'a' is a subset of set 'b', then 'b' cannot be a strict subset of 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": true
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all elements that, when multiplied by the inverse of \\( b \\), result in 1 is equal to the set containing only \\( b \\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": true
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 41 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 72 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) ‚â† {b} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 74 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 11 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 58 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 95 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 51 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 35 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of two sets \\(s\\) and \\(t\\) is equal to the universal set (‚ä§) if and only if at least one of the sets \\(s\\) or \\(t\\) is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t ‚â† ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s ‚â† ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nConsider a function 'x' that takes an index 'i' and returns a real number. This function represents a point in a multi-dimensional space, where each dimension is indexed by 'i'. Suppose we have another function 'a' that also takes an index 'i' and returns a real number, representing a point 'a' in the same multi-dimensional space. If for every index 'i', the value of 'a' at 'i' is strictly less than the value of 'x' at 'i', then the open box with lower bound 'a' is a neighborhood of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": true
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Hamming norm of the zero vector is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": true
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (58 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 q : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 r : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 c : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (71 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 a : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (46 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (84 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (85 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 z : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (82 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (43 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (96 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (72 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing an element `a'` from a finite map `s` doesn't affect the result of looking up a different element `a` in the map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": true
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h p : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h m : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h e : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) ‚â† lookup a s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h n : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h f : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h g : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h t : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h o : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h q : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h v : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h b : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the totient of 2 is equal to 1. (The totient of a number 'n', denoted as œÜ(n), is the count of positive integers less than or equal to 'n' that are relatively prime to 'n', i.e., they share no common divisors other than 1).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": true
      },
      {
        "response": "theorem totient_two : œÜ 91 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem totient_two : œÜ 2 ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 43 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 16 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem totient_two : œÜ 98 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 44 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 43 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 50 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) belongs to the set generated by the ideal \\(I\\) if and only if \\(x\\) belongs to the ideal \\(I\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": true
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' is a subset of the empty set, then 's' must also be the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a category with a strict initial object, any morphism from an object to the initial object is an isomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": true
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f j : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f y : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A s : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f o : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A c : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f u : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f n : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A i : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f e : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f t : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A h : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A k : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine we can form objects by combining objects of three types, Œ±, Œ≤, and Œ≥. We can denote the combination of, say, 'a' of type Œ± and 'b' of type Œ≤ as either (a, b) or inr(a) depending on the context.  Prove that if we have an object 'c' of type Œ≥ and apply the inverse of the natural transformation that re-associates combinations of the three types, specifically for the case (c), we get back 'c'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": true
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) ‚â† inr c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v`, converting it to a function using `get` and then back to a vector using `ofFn` results in the original vector `v`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": true
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) ‚â† v :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval (a, b] is non-empty if and only if a < b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": true
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the infimum distance between a point \\(x\\) and the closure of a set \\(s\\) is equal to the infimum distance between the point \\(x\\) and the original set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": true
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) ‚â† infDist x s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any valuation 'v', applying the 'toFun' operation to 'v' results in 'v' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": true
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun ‚â† v :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element `a` of a type `Œ±` with a top element added (denoted as `WithTop Œ±`), `a` is less than or equal to the top element (`none`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": true
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( x \\) belongs to the complement of a set \\( s \\) if and only if \\( x \\) does not belong to the set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive numbers a, b, c, and d, the fraction a/b is less than the fraction c/d if and only if the product of a and d is less than the product of c and b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": true
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two distinct natural numbers \\( k \\) and \\( l \\), the sets of primitive roots of unity of orders \\( k \\) and \\( l \\)  in the complex numbers are disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": true
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h w : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h a : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h d : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k = l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h m : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h u : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h f : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h o : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h c : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h t : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vectors x, y, and z in a vector space F, the inner product of x and the difference of y and z is equal to the difference between the inner product of x and y and the inner product of x and z.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": true
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ ‚â† ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inner_sub_right (x y z : ùïå) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : ‚Ñö) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_sub_right (x y z : ùïä) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_sub_right (x y z : Œ≤) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_sub_right (x y z : ùïÜ) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : ùïÑ) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : ‚Ñù) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_sub_right (x y z : √ó) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a vector space E over a field ùïú, any open ball centered at the origin with radius r > 0 is an absorbent set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": true
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 92 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 l : E) r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 u : E) r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : √ó) r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 82 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 47 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 c : E) r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : Œ±) r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 94 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : ùïê) r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : ùïé) r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 q : E) r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 w : E) r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 i : E) r) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the germ of the top element of a type with a top element is equal to the top element of the germ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : ùïê) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : ùïå) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : ùïã) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : ùïÜ) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : ‚Ñí) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : ‚Ñï) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : √ó) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ±) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two Lie ideals I and J of a Lie algebra L over a ring R such that I is a subset of J, prove that for any natural number k, the k-th derived ideal of I is a subset of the k-th derived ideal of J.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": true
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h j : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k g : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñù) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h l : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : Œ±) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ùïå) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h o : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ùïé) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k o : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñ§) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ùîπ) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k c : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ùïè) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ùïÑ) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ùïÄ) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a finite set 's' is not empty if and only if it's true that 's' is not equal to the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s = ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero real number x, x is infinitesimal if and only if its inverse 1/x is infinite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 47) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h w : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x = 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 20) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h z : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 15) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 71) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h o : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h i : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h n : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 44) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real number 1 belongs to the interval I, where I is defined as the set of all real numbers x such that 0 ‚â§ x ‚â§ 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": true
      },
      {
        "response": "theorem one_mem : (94 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_mem : (1 p : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ùïç) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_mem : (1 o : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (95 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_mem : (1 b : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_mem : (1 f : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñï) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (87 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ùïè) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_mem : (6 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 j : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the constant polynomial 1 is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": true
      },
      {
        "response": "theorem deg_one : (14 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem deg_one : (1 c : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 z : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem deg_one : (99 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 28 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 42 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem deg_one : (1 i : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 w : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 44 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 57 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem deg_one : (1 v : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 x : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 j : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 t : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that scaling a submonoid \\(S\\) by an element \\(a\\) and then viewing it as a set is the same as viewing the submonoid as a set first and then scaling each element by \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": true
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïÑ) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S g : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S d : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïã) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) ‚â† a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S r : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïé) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S o : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : √ó) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïå) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïÄ) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïÜ) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S a : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : ùïç) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S j : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S i : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that repeatedly multiplying by a number 'a' for 'n' times is equivalent to multiplying by 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": true
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] ‚â† (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ (n+1) * ¬∑) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ (n+3) * ¬∑) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ (n+2) * ¬∑) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ (n-1) * ¬∑) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ (n-4) * ¬∑) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ (n-3) * ¬∑) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number n greater than 0, n multiplied by the factorial of (n-1) is equal to the factorial of n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": true
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 16)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 65 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 68 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! ‚â† n ! :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 8 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 95 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 1 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 39 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 86)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 28)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 64 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the p-adic norm of any non-zero p-adic number is a rational power of p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": true
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 35) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm ‚â† (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha g : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : Œ≤) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha w : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 16) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 19) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha u : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ùïå) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 32) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p b : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z x : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 85) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z u : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet R be a set of numbers with multiplication and a special element Œµ (epsilon).  We can form \"dual numbers\" over R, written R[Œµ], which are expressions of the form  'a + bŒµ', where 'a' and 'b' belong to R.  Multiplication in R[Œµ] works similarly to regular numbers, but with the additional rule that Œµ¬≤ = 0. Prove that for any 'r' in R, the dual number '0 + rŒµ' is the same as multiplying 'r' by Œµ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": true
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r ‚â† (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : ùïé) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : ùîπ) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : ùîπ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : ùïå) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : ùïê) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : ‚Ñö) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : ùïÑ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : Œ≤) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : √ó) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a polynomial function has a derivative at every point, and the value of the derivative at that point is equal to the evaluation of the derivative polynomial at that point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": true
      },
      {
        "response": "theorem hasDerivAt (x : ùïÜ) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x ‚â†> p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem hasDerivAt (x : ùïå) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïê) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasDerivAt (x : √ó) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasDerivAt (x : ùïã) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ‚Ñ§) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasDerivAt (x : ùîπ) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasDerivAt (x : Œ≤) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : Œ±) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that, for any ordered ring, multiplying a non-positive number by a positive number results in a non-positive number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": true
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 96) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb h : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 36) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb a : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 3) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb e : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 88) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 29) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 20) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha q : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha r : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb u : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 26) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, and c, if a is less than b, then c plus a is less than c plus b. Note that a, b and c are numbers of the form  x + y‚àöd, where x and y are integers, and d is a non-negative integer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": true
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñö) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_lt_add_left (a b : ùïã) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h k : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñï) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h t : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h z : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h m : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h o : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ùïê) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h l : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ùïé) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_lt_add_left (a b : ùïè) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h i : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any module \\(M\\) over a ring \\(R\\), if there exists a basis \\(b\\) for \\(M\\) indexed by a type \\(Œπ\\), then \\(M\\) is a free module.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": true
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b s : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b a : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b h : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b v : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b l : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b q : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b y : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b f : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b n : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two multisets \\(s\\) and \\(t\\), prove that an element \\(a\\) belongs to the union of \\(s\\) and \\(t\\) if and only if \\(a\\) belongs to \\(s\\) or \\(a\\) belongs to \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": true
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a m : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a z : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a w : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a y : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a p : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a v : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a t : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a e : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a f : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a b : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the extended real number system, adding any extended real number 'x' to negative infinity (‚ä•) always results in negative infinity (‚ä•).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : ‚Ñö) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bot_add (x : ùïä) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : ‚Ñù) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_add (x : ‚Ñ§) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : ùîπ) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_add (x : ‚Ñí) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : ùïã) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : ùïê) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a bag of objects (this is our set). We can add objects to the bag or take them out.  We have two such bags, 'S' and 'T'. We also have a special way to modify these bags using 'a', which acts like a multiplier. We can either multiply everything in a bag by 'a' or by its inverse, 'a‚Åª¬π'.  The theorem states that:  Having every object from bag 'S' also exist in bag 'T' after multiplying 'T' by 'a' is the same as having every object from bag 'S', after being multiplied by 'a‚Åª¬π', exist in the original bag 'T'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": true
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T j : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T h : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T f : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T v : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T m : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T y : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T a : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T b : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T q : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a function 'h' that operates on sets, and we know that this function is \"monotone\". Monotone means that if you input a larger set into 'h', the resulting set will also be larger (or at least not smaller). Now, consider another function 'f' that produces a collection of sets. We're interested in comparing two ways of taking the intersection of sets generated by 'h':\n\n1.  **Method 1:** We first apply 'f' to get a collection of sets, then apply 'h' to each set in this collection, and finally take the intersection of all the resulting sets.\n2.  **Method 2:**  We directly take the intersection of all sets 's' in the collection produced by 'f', where each 's' is transformed by applying 'h'.\n\nProve that given 'h' is monotone, these two methods always produce the same result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": true
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } ‚â† ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a constant function between two ordered sets is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": true
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : ‚Ñö) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : ùïé) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_const (x : ‚Ñù) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : ùïÄ) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_const (x : ùîπ) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : ùïã) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : ùïä) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_const (x : √ó) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : ‚Ñï) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the zero element of the subtype of M, consisting of elements P where P is a linear projection on X, to an element of M itself, results in the zero element of M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": true
      },
      {
        "response": "theorem coe_zero : ‚Üë(31 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero : ‚Üë(95 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P q : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : Œ≤) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) ‚â† (0 : M) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : ùîπ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 a : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : √ó) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_zero : ‚Üë(42 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(66 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero : ‚Üë(38 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 h : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : ùïÄ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_zero : ‚Üë(83 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(36 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero : ‚Üë(22 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the trace of a zero matrix of size n x n is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": true
      },
      {
        "response": "theorem trace_zero : trace (68 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem trace_zero : trace (0 p : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trace_zero : trace (0 e : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (43 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem trace_zero : trace (22 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem trace_zero : trace (97 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (65 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (21 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (87 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (11 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a partition P of a graph G has no parts (i.e., the set of parts is empty), then the partition is a uniform partition with respect to any epsilon.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": true
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts ‚â† ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the highest power of \\( X \\) in the polynomial \\( X \\) itself is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": true
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 70 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_le : (X : ùïè).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_le : (X h : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_X_le : (X : ‚Ñí).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_le : (X : ùïå).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 49 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 86 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_le : (X y : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 64 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 7 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X k : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_X_le : (X : ùïÑ).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_le : (X p : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 56 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_le : (X : Œ±).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a category C and a presheaf P on C, applying a \"sheafification\" process to P results in a sheaf, denoted as J.sheafify P. This theorem states that if we have the identity map on the presheaf P, then applying the \"sheafification\" process to this identity map results in the identity map on the sheaf J.sheafify P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": true
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (88 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (86 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) ‚â† ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (24 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (18 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (16 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (91 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (15 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (51 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (78 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (31 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (6 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (40 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (74 P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a ring 'R', the basic open set generated by 'a' is indeed an open set in the Zariski topology on the set of prime ideals of 'R'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": true
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a v : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a i : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a z : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a p : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a f : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a r : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any square matrix `A` whose row and column indices come from a \"subsingleton\" type (a type with at most one element) is a diagonal matrix.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": true
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(E\\) and a positive real number \\( \\delta \\), the set of all points that are within a distance of \\( \\delta \\) from some point in \\( E \\) (this set is called the thickening of \\( E \\) by \\( \\delta \\)) is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": true
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E z : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E n : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E y : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E x : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E g : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E a : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E v : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E u : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E r : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E o : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers M, N, and P, if M is less than or equal to N, then M multiplied by P is less than or equal to N multiplied by P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": true
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number p, and any integer z that is greater than or equal to 0, z modulo p is equal to z when z is treated as an element of Z/p (the integers modulo p).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": true
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 5 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h ‚â†> by simp at h\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n v : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ùïê), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 43 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 14 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 58 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z f : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nat_cast_toNat (p : ùïÑ) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) ‚â† z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 70 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nat_cast_toNat (p : ùïä) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n i : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nat_cast_toNat (p : ùïç) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 61 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of a nonempty set  's' and an infinite set 't' is also an infinite set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": true
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : ùïé) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs c : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : ùïÄ) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : ùïÄ) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs r : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : Œ±) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs p : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : ùïÑ) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Infinite.prod_right (ht : Œ≤) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs a : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : ùïä) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs g : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs f : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vertex 'v' in a graph G, the set of neighbors of 'v' and the singleton set containing only 'v' are disjoint. In other words, a vertex 'v' cannot be its own neighbor.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": true
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two combinatorial games, \\(x\\) and \\(y\\), prove that either \\(x\\) is less than or equal to \\(y\\), or \\(y\\) is not less than or equal to \\(x\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": true
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : ùïÄ) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_or_gf (x y : ùïå) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_or_gf (x y : ùïã) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : ùïè) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : Œ±) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : ùïä) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_or_gf (x y : ùîπ) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_or_gf (x y : ‚Ñù) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_or_gf (x y : ‚Ñï) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : ùïç) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two finite sets \\( s \\) and \\( t \\), prove that the number of elements in \\( s \\) that also belong to the intersection of \\( s \\) and \\( t \\) is equal to the number of elements in \\( s \\) that belong to \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": true
      },
      {
        "response": "theorem condCount_inter_self (hs : ùïÜ) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : ùïã) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) ‚â† condCount s t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : ‚Ñö) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem condCount_inter_self (hs : ‚Ñ§) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : ‚Ñù) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem condCount_inter_self (hs : Œ≤) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : ùïÄ) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element \\( a \\) belongs to the intersection of two sets \\( l‚ÇÅ \\) and \\( l‚ÇÇ \\), then \\( a \\) belongs to the set \\( l‚ÇÅ \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": true
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of the function \\(f(x) = ax^2\\) is \\(f'(x) = 2ax\\), where 'a' is any real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": true
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 53) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ (-1)) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : ùïä) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) ‚â† C (a * 2) * X :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 44) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 7) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 3) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : ùïå) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 34) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : ‚Ñï) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 6) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : ‚Ñ§) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any measure-preserving function \\( f \\) between measurable spaces and a natural number \\( n \\), applying \\( f \\) \\( n \\) times and then taking its equivalence class (with respect to the measure) is the same as first taking the equivalence class of \\( f \\) and then applying it \\( n \\) times.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": true
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n g : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ (n-2)) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n a : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ùïè) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) ‚â†·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ (n-4)) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñö) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : Œ≤) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n w : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ (n+1)) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n i : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ùïé) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n v : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : √ó) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ùïã) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'l' to the least upper bound of two elements, a‚ÇÅ and a‚ÇÇ, is the same as taking the least upper bound of the images of those elements under 'l'. In simpler terms, the function 'l' preserves the least upper bound operation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) ‚â† l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\( f \\) that preserves addition and multiplication between two fields \\( K \\) and \\( L \\) (meaning \\( f(a + b) = f(a) + f(b) \\) and \\( f(a \\cdot b) = f(a) \\cdot f(b) \\) ), and a subset \\( s \\) of \\( K \\), prove that the image of the closure of \\( s \\) under \\( f \\) is equal to the closure of the image of \\( s \\) under \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": true
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s l : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s a : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s z : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f ‚â† closure (f '' s) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s w : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s g : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s h : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s d : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that for any natural number `n` and any element `a` of type `Fin n` (which can be thought of as a natural number strictly less than `n`), if we consider `a` as an element of `Fin (n + 1)`, it is the same as applying the function `castSucc` to `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": true
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 48)) = castSucc a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a p : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a x : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) ‚â† castSucc a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 55)) = castSucc a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 46)) = castSucc a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a s : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a j : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 76)) = castSucc a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 10)) = castSucc a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a k : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 3)) = castSucc a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any derivation D, negating D and then converting it to a linear map is the same as converting D to a linear map and then negating it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": true
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D p : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D v : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) ‚â† (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D w : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D f : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D e : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D q : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D k : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D r : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets 'a' and 'b', the set difference of the symmetric difference of 'a' and 'b' with 'a' is equal to the set difference of 'b' with 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": true
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a ‚â† b \\ a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a pair of functions (f, g) to the components of a pair of elements from two sets is the same as applying f to the first element and g to the second element independently.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": true
      },
      {
        "response": "theorem prodMap_def : prodMap f g ‚â† (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet 'f' and 'g' be two functions such that they are monotonic (meaning they preserve order) and operate on sets with some notion of order where we can talk about least upper bounds.  Prove that applying 'f' to the least fixed point of the combined function 'g' after 'f' is the same as finding the least fixed point of 'f' after 'g'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": true
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) ‚â† lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a combinatorial game, if the right player has no moves, then the game is a win for the left player or a draw.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": true
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 61 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 65 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : ùïè) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 59 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 7 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 17 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : ‚Ñö) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 79 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 22 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : ‚Ñù) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : √ó) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : ùïê) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three numbers 'r', 'a', and 'b', multiplying the interval between 'a' and 'b' by 'r' is the same as creating a new interval between 'r' times 'a' and 'r' times 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": true
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b ‚â† Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any sequence `u` and a constant `a`, the supremum of `a` and the limit inferior of `u` is equal to the limit inferior of the sequence whose elements are the supremum of `a` and each element of `u`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": true
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x ‚â†> a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_liminf (a : ‚Ñù) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f ‚â† liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : ùïã) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_liminf (a : ùïÑ) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : √ó) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_liminf (a : ùïê) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ≤) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_liminf (a : ‚Ñ§) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_liminf (a : ùïè) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : ùïé) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": true
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of a family of trivial submodules over all indices in a set 's' is equal to the trivial submodule of the product of the entire family.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i l : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i p : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ ‚â†> (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i h : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i g : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i c : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i u : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the dual of a biconditional statement (a if and only if b) is equivalent to the exclusive disjunction (XOR) of the duals of the individual statements (dual of a XOR dual of b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": true
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) ‚â† toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions, f' and f', and a limit point 'l', prove that if f' is not constantly zero around 'l', then f' is not little-o of itself at 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": true
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 50) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 81) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' ‚â†o[l] f' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ = 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 82) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 86) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 6) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 49) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 27) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a type Œ± equipped with a multiplication operation and an ordering relation, multiplication by positive elements on the right preserves order if and only if multiplication by positive elements on the left preserves order.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": true
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the zero power series is the zero power series.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": true
      },
      {
        "response": "theorem zero_inv : (57 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_inv : (0 t : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (0 o : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (0 l : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (78 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_inv : (0 r : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (0 w : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (51 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_inv : (0 v : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (87 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_inv : (0 e : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (53 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_inv : (77 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (23 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two fractions a and b, a + b is equal to b + a.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": true
      },
      {
        "response": "theorem add_comm : a + b ‚â† b + a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set 's', the edge density of a relation 'r' between 's' and an empty set is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": true
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 42 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 50 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 87 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 44 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 68 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 92 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 12 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 22 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 34 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 37 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 33 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 9 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a basis 'e' and an orientation 'x', prove that if we adjust the orientation 'x' to the basis 'e' and then extract the orientation from the resulting basis, we will get back the original orientation 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": true
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\(0 < b < 1\\), the logarithm base \\(b\\) approaches negative infinity as its input approaches positive infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": true
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the trailing zero in the polynomial representation of any constant 'a' is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": true
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 56 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natTrailingDegree_C (a : ùïÄ) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natTrailingDegree_C (a : ‚Ñù) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natTrailingDegree_C (a : ùïä) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 66 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 54 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natTrailingDegree_C (a : √ó) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natTrailingDegree_C (a : ùïå) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 8 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : ‚Ñï) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : ‚Ñö) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 17 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two lists of sets, `as` and `bs`, where each set in `as` is a subset of the corresponding set in `bs`, prove that the set of all possible sequences formed by taking one element from each set in `as` is a subset of the set of all possible sequences formed by taking one element from each set in `bs`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": true
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs ‚â†> seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs b : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs v : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs n : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil ‚â†> le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs k : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs x : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs m : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs i : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs j : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs f : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs c : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs d : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element belongs to a dependent function space (a generalization of a function) if and only if it satisfies the function's definition for every index in the index set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": true
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets 's' and 't', prove that the set of all possible quotients obtained by dividing an element of 's' by an element of 't' is non-empty if and only if both 's' and 't' are non-empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": true
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval [a, b) is a measurable set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": true
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two properties, P and Q, and for any object 'x' and proof 'h', P(x, h) is true if and only if Q(x, h) is true. Prove that P(x, h) holds true for all 'x' and 'h' if and only if Q(x, h) holds true for all 'x' and 'h'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": true
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function is differentiable for all real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": true
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two vectors v‚ÇÅ and v‚ÇÇ in a vector space,  v‚ÇÅ and v‚ÇÇ are on the same ray if and only if their negations, -v‚ÇÅ and -v‚ÇÇ, are also on the same ray.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we represent a cyclic permutation as a list of elements, this list contains no duplicates.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": true
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf g : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf x : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf u : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf c : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf d : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf w : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf y : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf j : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf z : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf p : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a finite set to a multiset and then back to a finite set results in the original set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": true
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number `n` and any element `i` from a set of `n+1` elements, taking the elements strictly greater than `i` (within the set) is equivalent to considering the entire set excluding the element `i`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": true
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 24)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i n : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i s : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove ‚â† {i}·∂ú :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 25)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i r : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i g : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 73)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i f : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 90)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 60)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 85)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative extended real number \\( x \\), \\( x \\) is equal to infinity in the extended real number system if and only if \\( x \\) is equal to infinity in the non-negative extended real number system.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•46‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) ‚â† ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : ‚Ñö) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•53‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•49‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : ùïÜ) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•41‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•71‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x e : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x p : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : ùïè) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : ‚Ñí) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•82‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the zero vector in any lp space is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": true
      },
      {
        "response": "theorem norm_zero : ‚Äñ(45 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 v : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 o : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(48 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(69 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 h : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(15 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(22 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 e : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 i : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(60 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(97 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a semilinear isometry  'f' between vector spaces E and E‚ÇÇ, applying 'f' to a vector 'x' in E preserves its norm.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": true
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x k : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x d : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ‚Ñï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä ‚â† ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x q : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : ‚Ñï) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : ‚Ñ§) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùïè) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ‚Ñù) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùïÑ) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : √ó) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : ùïÄ) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : ùïê) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a set 'A', the range of the function that generates all integer multiples of 'a' is equal to the set of all integer multiples of 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": true
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range ‚â† zmultiples a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ùïã) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ùïå) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_zmultiplesHom (a : Œ±) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ‚Ñ§) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ùïê) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ‚Ñï) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ùïÄ) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : ùïä) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_zmultiplesHom (a : √ó) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : Œ≤) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function representation of the zero simple function is equal to the zero function almost everywhere (with respect to the measure Œº).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": true
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (87 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) ‚â†·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 s : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 n : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (30 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (17 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (78 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 v : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (34 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 b : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (53 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (32 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 p : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 c : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 w : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 e : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(s\\) and \\(p\\) be sets of vectors. Given that \\(s\\) is a subset of \\(p\\) and that \\(p\\) is a subset of the span of \\(s\\), prove that the span of \\(s\\) is equal to \\(p\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": true
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ k : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s ‚â† p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ y : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ n : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ x : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ l : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ a : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ v : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ s : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ o : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a sequence `l` satisfies a relation `R` between consecutive elements (i.e., it forms a chain), then the sequence obtained by removing the first `n` elements from `l` also forms a chain under the same relation `R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": true
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n a : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ùïê) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ùïé) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n f : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ùïÜ) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ùïç) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n i : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : √ó) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n y : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n k : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a set of elements where a partial order is defined (meaning some elements can be compared as 'less than' or 'greater than', but not all pairs need to be comparable), prove that the following two statements are equivalent:\\\n  1.  \\( a \\) is not equal to \\( b \\) if and only if \\( a \\) is strictly less than \\( b \\).\n  2.  \\( a \\) is less than or equal to \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": true
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a = b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a non-zero element 'p' in a mathematical structure called a \"ring\" constructed from a \"direct limit\" of a system of rings G connected by maps 'f', prove that multiplying 'p' by its inverse results in the multiplicative identity element, 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": true
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 50) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp r : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p = 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 58) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 90 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp e : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 92 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp n : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 90) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 59 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp k : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 18) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 6) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet X, Y, and Z be finite sets, and let f be a function from X to Y and g be a function from Y to Z. Prove that for any element x in X, applying the composition of f and g to x is the same as applying g to the result of applying f to x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": true
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g k : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : ‚Ñí) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x j : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : √ó) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x ‚â† g (f x) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : ‚Ñö) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g l : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f z : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : ‚Ñï) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x i : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : ùïå) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : ‚Ñ§) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g j : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : Œ≤) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g d : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet G be a graph, and H be a subgraph of G. Prove that a vertex v is in the support of H if and only if there exists a vertex w such that v is adjacent to w in H.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": true
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v u : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v s : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v b : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v h : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v w : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v a : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v n : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(u\\), either \\(u\\) is empty or \\(u\\) is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": true
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u ‚â† ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ùïÄ) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ùïÜ) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ùîπ) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ‚Ñ§) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ùïã) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ùïå) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : Œ±) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a set where there's no smallest element and there's a notion of order, there's no upper bound for the entire set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": true
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to \"normalize\" objects.  This theorem states that a normalized object is associated with another object if and only if the original object (before normalization) is associated with that same other object.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": true
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(e\\) be a function, and let \\(s\\) and \\(t\\) be sets. If the image of \\(e\\) restricted to \\(s\\) is exactly \\(t\\), then the image of \\(e\\) restricted to the intersection of its domain and \\(s\\) is equal to the intersection of its range and \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": true
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) ‚â† e.target ‚à© t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a partially ordered set, given two elements a and b where a is a bottom element (i.e., smaller than or equal to every element) and b is smaller than or equal to a, prove that b is also a bottom element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": true
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h q : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h j : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h r : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h l : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h u : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h e : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h x : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h v : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real numbers \\( r \\) and \\( p \\) where \\( p \\) is not zero, \\( r \\) is less than the inverse of \\( p \\) if and only if the product of \\( r \\) and \\( p \\) is less than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": true
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•56} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•80} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h q : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•24} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p = 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 10 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•55} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h v : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 34 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•76} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 8 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h x : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h b : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h a : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 38 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h u : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a singleton set (a set containing only one element) is totally disconnected.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": true
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number 'a' less than 1, the reciprocal of 'a' is greater than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": true
      },
      {
        "response": "theorem one_lt_one_div (h1 : 4 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 n : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 v : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 3 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 p : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 55) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 h : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 z : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 e : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 65) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 w : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 1 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 m : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 u : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there exists a ring isomorphism between two rings R and S, then the homomorphism from R to S associated with this isomorphism preserves non-units, meaning it maps non-units in R to non-units in S.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": true
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f h : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f g : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f w : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f l : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f a : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f b : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f r : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f y : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f d : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f u : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\( a \\) less than or equal to 1 and any natural number \\( n \\), \\( a \\) raised to the power of \\( n \\) is also less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": true
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 69) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ (n+3) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n j : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñö) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 64) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 68) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ (n+5) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n s : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñí) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ (n+4) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 34) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H t : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ùïä) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ùïÜ) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ (n-5) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a list \\(s\\) is a permutation of another list \\(t\\) if and only if \\(s\\) is equivalent to \\(t\\). Note that two lists are considered equivalent if one can be rearranged into the other.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": true
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a', if 'a' is in a sequence 's‚ÇÅ', then 'a' is also in the sequence formed by appending another sequence 's‚ÇÇ' to 's‚ÇÅ'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a r : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a b : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a j : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a k : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a l : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a f : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a n : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a v : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a c : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a e : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a u : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers \\(a\\), \\(b\\), and \\(c\\), the open interval from \\(a\\) to \\(c\\) is a subset of the union of the open interval from \\(a\\) to \\(b\\) and the closed interval from \\(b\\) to \\(c\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": true
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a sequence defined by the recurrence relation `y_{n+2} = a‚ÇÅ * y_{n+1} + y_n`, prove that for any natural number `n`, `y_n` is congruent to `n` modulo 2.  Here, `a‚ÇÅ` is a fixed constant natural number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": true
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 79]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring b : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring d : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 ‚â†> by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 25 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 ‚â†>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring q : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 88]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n ‚â† 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 7 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 54]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring s : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring l : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring o : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 10]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring k : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three points a, b, and c in a normed vector space, a times c lies within a closed ball centered at (b times c) with radius r if and only if a lies within a closed ball centered at b with radius r.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": true
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions, \\(f\\) and \\(g\\), and a pair of elements \\(p\\), prove that applying \\(f\\) and \\(g\\) to the elements of \\(p\\) separately and then forming a new pair is the same as applying the combined function of \\(f\\) and \\(g\\) to the pair \\(p\\) directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": true
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.62, g p.2) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g t : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p x : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g m : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p ‚â† (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.92) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g o : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.30, g p.2) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p n : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g x : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.84, g p.2) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g d : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g j : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' in a field, the square root of the square of its norm is equal to the norm of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) ‚â† ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ‚Ñ§) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ùïÄ) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ‚Ñù) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ùîπ) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ùïå) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ùïé) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : ‚Ñö) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is an isometry. We assume that \\( f \\) is a function between two vector spaces equipped with a norm (a way of measuring the length of vectors), and that \\( f \\) has the property of being a linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isometry : Isometry f :=",
        "label": true
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( a \\), \\( b \\), and \\( c \\), the symmetric difference of \\( a \\) and \\( b \\) is equal to the symmetric difference of \\( c \\) and \\( b \\) if and only if \\( a \\) is equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": true
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a ‚â† c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b ‚â† c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the greatest common divisor (GCD) of a multiset (a set where elements can appear multiple times) of numbers is 0 if and only if every number in the multiset is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": true
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 72 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x m : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x u : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 47 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 15 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x j : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 91 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd ‚â† 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 44 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x w : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x y : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 14 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 89 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the covering relation of the product of two partially ordered sets is equivalent to the box product of the covering relations of the individual sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": true
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) ‚â† hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' and computation 's', applying the function 'f' to the result of the computation 's' terminates if and only if the computation 's' itself terminates.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": true
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s x : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s a : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s v : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s u : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s d : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s p : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s f : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s t : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two sets, 's' and 't', are separated by neighborhoods, then 's' and the closure of 't' are disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": true
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a specific operation called \"polar\" represented by 'Q', which takes two elements from a set 'M' and combines them in some way.  Prove that applying this \"polar\" operation with 'x' and the difference of 'y' and 'y'' is the same as first applying the \"polar\" operation with 'x' and 'y', then separately with 'x' and 'y'', and finally subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": true
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') ‚â† polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem polar_sub_right (x y y' : ùïÜ) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : ‚Ñù) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : √ó) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : ùïä) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem polar_sub_right (x y y' : ùïç) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : Œ±) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a mathematical structure (like a set with operations) and an element 'a' from this structure. Given two substructures S and T, prove that scaling the \"join\" of S and T by 'a' is the same as taking the \"join\" of the individually scaled substructures 'a ‚Ä¢ S' and 'a ‚Ä¢ T'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": true
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : ‚Ñö) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sup (a : M) (S T r : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sup (a : ‚Ñ§) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) ‚â† a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T v : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sup (a : M) (S T z : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sup (a : ùïé) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sup (a : M) (S T t : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T c : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sup (a : M) (S T q : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sup (a : M) (S T y : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sup (a : ùïå) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of the union of two upper sets \\(s\\) and \\(t\\) is equal to the union of the complements of \\(s\\) and \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": true
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl ‚â† s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any element 'x' from a ring 'R', prove that the algebra homomorphism applied to 'x' results in zero if and only if 'x' itself is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": true
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 36 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 16 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ‚Ñù) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ùïÜ) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 40 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 21 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ‚Ñ§) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ùïç) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x ‚â† 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 92 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 74 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ‚Ñö) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ùïè) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : ùïã) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 82 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\(x\\) and \\(y\\) are equal, and \\(y\\) is an element of a set \\(s\\), then \\(x\\) is also an element of \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x = y) (h z : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x ‚â† y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx z : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s k : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s i : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx g : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx r : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s a : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx h : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two real numbers, \\(x\\) and \\(y\\), prove that applying a conjugation operation three times, with a multiplication in between, is the same as swapping the order of \\(x\\) and \\(y\\) and applying the conjugation to the first element. Assume that applying the conjugation twice returns the original number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": true
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : ùïè) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_mul_star (x y : ùîπ) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) ‚â† y * star x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : Œ≤) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : ùïé) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : ùïÑ) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_mul_star (x y : Œ±) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : ‚Ñù) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_mul_star (x y : ùïÄ) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number \\(x\\) is irrational, then subtracting any rational number \\(q\\) from it results in another irrational number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": true
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of a linear independent set of vectors is linearly independent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": true
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the closure of the range of indices is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": true
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) ‚â† univ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a linear function has a derivative equal to its slope at any point within a set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": true
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we convert an integer `n` to another type that supports integer conversion and then convert it to its dual representation, it remains the same integer `n`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": true
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n v : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n y : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ùïé) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n e : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n o : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : ùïÜ) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n u : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n n : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : Œ≤) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n f : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : ‚Ñù) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n a : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñö) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the `aeval` function to a function `f` is equivalent to applying the `bind‚ÇÅ` function to `f`, where `f` is a function that maps from a type `œÉ` to a multivariate polynomial `MvPolynomial œÑ R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": true
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f ‚â† bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the tangent of any integer multiple of  œÄ (pi) is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": true
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 71 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñ§) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : Œ≤) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 7 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñö) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ùïä) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 62 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 34 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 17 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ùïÄ) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the zero measure to any set always results in zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": true
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(2 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 m : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 w : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(97 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(52 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 h : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(21 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 v : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 b : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 r : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(78 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(67 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets 's' and 't', converting 's' and 't' to Finsets and checking if the Finset of 's' is a subset of the Finset of 't' is equivalent to checking if the set 's' is a subset of the set 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": true
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a morphism between objects \\(X\\) and \\(Y\\) in a category \\(C\\). Prove that if the induced morphism on the hom-sets, \\(Hom(A, X) \\to Hom(A, Y)\\) for all objects \\(A\\), is an isomorphism, then \\(f\\) itself is an isomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": true
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f o : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso {X Y : C} (f t : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f k : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso {X Y : C} (f h : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso {X Y : C} (f s : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso {X Y : C} (f r : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f g : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f v : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso {X Y : C} (f x : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f z : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\( s \\) and \\( t \\), the set difference of \\( s \\) and \\( t \\) (\\( s \\setminus t \\)) is equal to the intersection of \\( s \\) and the complement of \\( t \\) (\\( s \\cap t^c \\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": true
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t ‚â† s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the spanning homomorphism of any subgraph of a graph is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": true
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the type of ordinals with the less than relation, the principal segment below the top element of the lift of the ordinal u+1 is equal to the type of all ordinals.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": true
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 86}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top ‚â† @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 9}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 65}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 18}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 8}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 26}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 59}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 53}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 28}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 87}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 6}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 75}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\(r\\) and any natural number \\(n\\), the product of  \\(r\\) and (-1) raised to the power of \\(n\\) equals zero if and only if \\(r\\) itself is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": true
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 52 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ (n-2) = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r k : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 46 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-32) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r q : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ (n-5) = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ (n+4) = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 65 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ (n+2) = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r w : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ (n+3) = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n ‚â† 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-50) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r g : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\(x\\) and \\(s\\), if \\(x\\) is a subset of \\(s\\), then \\(x\\) is an element of the power set of \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": true
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h e : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h u : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h b : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h x : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h l : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h j : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h n : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h p : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h s : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two ideals I and J of a ring, where I is contained in J (I ‚â§ J), their product ideal (I * J) is also contained in J (I * J ‚â§ J).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": true
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of two intervals [a‚ÇÅ, b‚ÇÅ] and [a‚ÇÇ, b‚ÇÇ] is equal to the interval [(a‚ÇÅ ‚äî a‚ÇÇ), (b‚ÇÅ ‚äì b‚ÇÇ)], where ‚äî represents the maximum and ‚äì represents the minimum.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": true
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ ‚â† Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) be a function from a set \\( \\alpha \\) to a set \\( \\beta \\) equipped with a measure \\( \\mu \\). Let \\( c \\) be an element of \\( \\beta \\). If \\( f(x) \\) is less than or equal to \\( c \\) for almost every \\( x \\) in \\( \\alpha \\) (with respect to the measure  \\( \\mu \\)), then the essential supremum of \\( f \\) with respect to \\( \\mu \\) is less than or equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": true
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf m : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ ‚â†> c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c f : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : ùïé) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : ùïå) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : ùïç) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c h : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : ùïä) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf k : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : ùîπ) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ±) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n' greater than 1, the smallest factor of 'n' (excluding 1) satisfies the following properties:\n  1. It is greater than or equal to 2.\n  2. It divides 'n'.\n  3. For any other factor 'k' of 'n', if 'k' is greater than or equal to 2 and divides 'n', then the smallest factor of 'n' is less than or equal to 'k'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": true
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 55) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n = 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 c : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 83) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 37) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 73) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 m : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 9) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 62) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 p : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 z : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 k : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the quotient of two functions, f divided by g, never approaches negative infinity, then the function f itself also never approaches negative infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": true
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the *(n+1)*th Fibonacci number squared plus the *n*th Fibonacci number squared is equal to the Fibonacci number at the index *(2n + 1)*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": true
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 96 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 3 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem fib_bit0_succ (n : ùïè) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñí) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) ‚â† fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 70 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ (-3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 4 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñù) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 87) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : √ó) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ (-1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 73) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a function named \"f\" that takes two inputs, one of type 'Œ±' and another of type 'Œ≤', and produces an output of type 'Œ≥'. We also have a pair of values, let's call it 'x', which consists of one value of type 'Œ±' and one value of type 'Œ≤'. This theorem states that applying a transformed version of 'f' to the pair 'x' is the same as applying 'f' to the individual components of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": true
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.6 x.2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x ‚â† f x.1 x.2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x z : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x y : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.49 x.2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x o : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x k : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.41 x.2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.44 x.2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x n : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x e : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.38 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.17 x.2 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that  e^(œÄi) = -1, where 'e' is Euler's number, 'œÄ' is pi, and 'i' is the imaginary unit.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": true
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -26 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) ‚â† -1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -88 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -45 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -75 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -23 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -101 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -80 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -99 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -92 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -79 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -4 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -89 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -61 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -17 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers a, b, and c, a divides (b - c) if and only if a divides (c - b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": true
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number 'x' and any integer 'n', the tangent of (x + nœÄ) is equal to the tangent of x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": true
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n i : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n v : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ùïè) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) ‚â† tan x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n y : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n j : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñï) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ùïã) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ùîπ) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n t : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ùïã) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñù) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ùïå) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer \\(z\\), the function that raises elements of a topological group \\(G\\) to the power of \\(z\\) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": true
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 84)).inv\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ (z+2)\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a m : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 13)).inv\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n ‚â†> by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 31)).inv\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ (z+1)\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z j : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 57)).inv\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G ‚â†> a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 75)).inv\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ (z-2)\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a s : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a u : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 77)).inv\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ (z+5)\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any collection of sets \\(Œ±'_i\\), each of which has a least upper bound (supremum), the supremum of two functions \\(f\\) and \\(g\\) (where \\(f(i)\\) and \\(g(i)\\) belong to \\(Œ±'_i\\)) is equal to the function that returns the supremum of \\(f(i)\\) and \\(g(i)\\) for each \\(i\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": true
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g ‚â† fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i ‚â†> f i ‚äî g i :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n', if we encode it using a unary representation and then decode it, we get back the original number 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": true
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `l`, if a pair `x` is in the result of `revzip (powersetAux l)`, then the sum of the lengths of the elements in `x` is equal to the length of `l`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": true
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.30 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h z : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 ‚â† ‚Üël :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.88 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.40 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h u : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.41 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h w : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.71 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.53 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h s : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.22 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.63 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.55 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h a : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\( f \\) that takes two arguments of types \\( m \\) and \\( n \\) and returns a value of type \\( Œ± \\), scaling the result of applying \\( f \\) to its arguments is equivalent to first scaling \\( f \\) and then applying it to its arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": true
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : ùïä) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f n : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f x : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : ùïå) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f ‚â† of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f m : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : ùïê) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : Œ≤) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : ùïÑ) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f z : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f j : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : ùîπ) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : ùïã) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f t : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any given type Œ±, the natural mapping from the free ring generated by Œ± to the free commutative ring generated by Œ± is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": true
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' and a list 'l', the length of the list generated by 'scanl f a l' is always one more than the length of the original list 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": true
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 16\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 65\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) ‚â† l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l ‚â†> by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 56\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 61\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 53\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 24\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 94\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 54\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] ‚â†> rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 40\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 96\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a bijective function 'e' between two sets Œ± and Œ≤, and a subset 's' of Œ≤, prove that if we first take the preimage of 's' under 'e' and then take the preimage of that resulting set under the inverse of 'e', we get back the original set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": true
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s q : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s a : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s h : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s m : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s g : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s d : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s c : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s e : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to combine two values, taken from sets we'll call 'm' and 'n', into a third value from a set called 'Œ±'. This combination is described by a rule, which we'll name 'f'.  Assume also that for every element in the set 'Œ±', there's a corresponding \"opposite\" element, represented by putting a '-' sign in front of it. We can think of 'of' as a way to apply this \"combination rule\" to 'f'.  Prove that applying 'of' to the \"opposite\" of 'f' is the same as finding the \"opposite\" of applying 'of' to 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": true
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f ‚â† of (-f) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any sets \\(x\\), \\(y\\), and \\(z\\), prove that the set \\(x\\) with the elements of the set difference of \\(y\\) and \\(z\\) removed is equal to the union of the following two sets: the set difference of \\(x\\) and \\(y\\), and the intersection of \\(x\\), \\(y\\), and \\(z\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": true
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) ‚â† x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set 's' of elements of type 'Œ±', the supremum of 's' is equal to the indexed supremum of 's' where each element is indexed by itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": true
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : ùïê) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a y : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : ùïÜ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s ‚â† ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : ùïè) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a i : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : ùïç) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a f : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a y : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a r : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a j : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : ùîπ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : ùïÄ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a o : Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-empty list, the head element of the list is contained in the optional head of the list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": true
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h ‚â†> by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l a : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l k : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l = [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ ‚â†> rfl\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l r : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l f : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l t : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l j : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\( f' \\) and \\( f \\), and a set \\( s \\). If \\( f' \\) is a left inverse of \\( f \\) on the set \\( s \\), then composing \\( f' \\) with \\( f \\) acts like the identity function on \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": true
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a mathematical structure with multiplication where every element has a multiplicative inverse, for any elements 'x' and 'y', the product of 'y', the inverse of 'x', and 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": true
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : ùïç) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x ‚â† y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h x : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : ‚Ñö) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h s : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h p : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : ‚Ñ§) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h u : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : ‚Ñù) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h q : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : ùïê) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h f : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( a \\), \\( b \\), and \\( c \\), if \\( a \\) is disjoint from \\( b \\) and \\( a \\) is disjoint from \\( c \\), then \\( a \\) is disjoint from the union of \\( b \\) and \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": true
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc o : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc h : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc g : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc k : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc p : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc c : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc b : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc j : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc f : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc y : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc w : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\( s \\) and \\( t \\), if \\( s \\) is a finite set, then the set difference of \\( s \\) and \\( t \\) (denoted as \\( s \\setminus t \\)) is also finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": true
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs e : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ùïé) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs q : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ùïã) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t v : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs b : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ‚Ñï) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ‚Ñí) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs j : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ‚Ñö) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t q : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ùïÄ) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t d : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : ùïè) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if you take a natural number, consider it as an integer, and then take its absolute value, you get the original natural number back.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": true
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñí) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n m : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_nat (n : √ó) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ùïÄ)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : Œ≤)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ùïé)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n c : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_nat (n : ùïå) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n f : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n q : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ùïê)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ùïè)‚Äñ = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(R\\) and \\(S\\) be sets with binary relations \\(œÜ\\) and \\((map f œÜ)\\) defined on them, respectively. Given a function \\(f\\) from \\(R\\) to \\(S\\), prove that if \\(œÜ\\) is symmetric, then the relation \\((map f œÜ)\\) is also symmetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": true
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f n : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f p : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f z : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f q : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f g : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f e : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f r : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `t`, if 1 belongs to the set `t`, then the set resulting from multiplying every element in the universal set with every element in `t` is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": true
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (71 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t ‚â† univ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 i : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : ùîπ) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (41 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 w : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : ùïç) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (76 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (36 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (29 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 h : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : ùïå) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (101 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : ùïã) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet F, K, and E be fields such that F ‚äÜ K ‚äÜ E. Prove that if the field extension E/F is separable, then the field extension K/F is also separable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": true
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a finite-dimensional vector space V over a field K, the dimension of V considered as a finite set (finrank) is equal to the dimension of V considered as a vector space (Module.rank).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": true
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V y : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V h : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : ‚Ñï) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) ‚â† Module.rank K V :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Œ±) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V d : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V p : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V k : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V x : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : ùïÜ) = Module.rank K V :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element belongs to the set underlying a finite set, then it also belongs to the finite set itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s p : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s t : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s u : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s o : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s y : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s l : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s m : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two points x and y that have the same distance from the origin, prove that the distance from the origin to the midpoint of the line segment connecting x and y is strictly less than the distance from the origin to x if and only if x and y are not the same point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": true
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(35 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 v : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 j : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ùïç) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x = y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 85 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñ§) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 x : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ùïÜ) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ ‚â† ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 52 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 t : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(90 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñö) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 n : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 9 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ùïê) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two injective functions (embeddings) are equal if and only if they agree on all arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": true
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x ‚â† g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function 'f' which is injective, meaning it maps distinct elements to distinct elements. This function is used to transform the coefficients of a polynomial 'p'. The theorem states that the transformed polynomial 'p.map f' is equal to the zero polynomial if and only if the original polynomial 'p' itself is the zero polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": true
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 63 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 20 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f ‚â† 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 83 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 38 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 10 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 48 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 40 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 66 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 21 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `equivToOpposite`, which maps an element to its opposite in the opposite type, is the same as the `op` function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": true
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite c : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite j : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite k : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) ‚â† op :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite f : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite n : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite p : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite q : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite e : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the `min` function, which takes the minimum of two elements, is left-commutative. In simpler terms, prove that when finding the minimum, it doesn't matter if we swap the first two arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": true
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min k : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min g : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min i : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min t : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min x : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min c : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min o : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min l : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min d : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min u : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a circle with \\(n + 1\\) positions numbered from 0 to \\(n\\), and you have a pointer at a position \\(i\\). Prove that rotating the pointer one position clockwise results in the pointer being at position \\(i + 1\\), taking into account that position \\(n + 1\\) wraps around to position 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": true
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 32)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 50)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i ‚â† i + 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 58)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 75)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 93)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 8)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 4)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 66)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 30)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a structure 's' is nontrivial, then its inhabited infimum separation, denoted as 's.einfsep', is not infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": true
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep = ‚àû :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ‚Ñï) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ùïç) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ‚Ñ§) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ùïä) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ùïÄ) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ùïê) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ùïÑ) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ‚Ñí) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ùïã) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : ‚Ñù) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing the elements of the union of two sets \\(t_1\\) and \\(t_2\\) from a set \\(s\\) is equivalent to removing the elements of  \\(t_1\\) from \\(s\\) and then taking the union of that result with the set difference of \\(s\\) and \\(t_2\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": true
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) ‚â† s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three real numbers x, y, and z, the absolute value of the difference between the minimum of x and z and the minimum of y and z is less than or equal to the absolute value of the difference between x and y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ùïÑ) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ‚Ñ§) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ùïä) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ‚Ñù) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ‚Ñí) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ùïé) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ùïÜ) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ≤) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ùïê) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : ùîπ) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that lifting a value to the maximum of `v` and `u` within a universe of size `u` is the same as lifting it to level `v` within a universe of size `u`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": true
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} ‚â† lift.{v, u} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element 'x' of a type with a distinguished element '1' is not equal to '1' if and only if there exists an element 'a' in the underlying type such that 'a', when viewed as an element of the type with '1', is equal to 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": true
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 57 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x = 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a x : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a c : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 60 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a b : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 51 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a v : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 10 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a n : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a u : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 62 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a i : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 37 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the intersection of two submonoids S and T is equal to the intersection of the inverses of S and T.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π ‚â† S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of functions from a set Œ± to a set M, which are definable by the empty set, is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a linear function from a vector space E to its field of scalars ùïú into a seminorm is the same as taking the norm of the output of the function for any element in E.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x ‚â†> ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm ‚â† fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_eq {u : Œπ ‚Üí UniformSpace Œ≥} : ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there is a surjective function from a set \\( Œ± \\) to a set \\( Œ≤ \\), then the cardinality (size) of \\( Œ≤ \\) is less than or equal to the cardinality of \\( Œ± \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": true
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h v : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h p : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h a : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h w : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h t : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h y : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h m : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h e : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h u : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h n : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any group, conjugating an element 'h' by an element 'g' is the same as adding 'g' to 'h', and then adding the inverse of 'g'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": true
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h ‚â† g + h + -g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ‚Ñö) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ‚Ñï) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : Œ≤) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ‚Ñù) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ùïÑ) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ùïç) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ‚Ñ§) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : ùïå) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two non-infinite hyperreal numbers x and y, the standard part of their product (x * y) is equal to the product of their individual standard parts.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": true
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) ‚â† st x * st y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy n : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy e : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx q : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx w : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy x : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy q : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy m : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx k : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that addition on natural numbers can be defined as a primitive recursive function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": true
      },
      {
        "response": "theorem add : @Primrec' 26 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v ‚â†> v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 77 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add : @Primrec' 10 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add : @Primrec' 17 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 53 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 18 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add : @Primrec' 81 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add : @Primrec' 85 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 55 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add : @Primrec' 88 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number \\(a\\),  \\(a^2 < 1\\) if and only if \\(a < 1\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": true
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 12 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 1 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha w : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha a : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 83 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 59 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 4 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha v : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha d : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha p : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 41 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ (-2) < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha z : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 82 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha t : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a fixed point 'p', adding 'p' to elements of a group 'G' using the group operation '+·µ•' results in unique outputs. In other words, if 'a' and 'b' are elements of 'G', and 'a +·µ• p' equals 'b +·µ• p', then 'a' must equal 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": true
      },
      {
        "response": "theorem vadd_right_injective (p : ùïÜ) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vadd_right_injective (p : ùïÑ) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vadd_right_injective (p : ùïä) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vadd_right_injective (p : Œ≤) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : ùïç) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : ‚Ñí) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vadd_right_injective (p : ùïÄ) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : √ó) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vadd_right_injective (p : Œ±) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : ùïê) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : ‚Ñï) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vadd_right_injective (p : ùïå) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( s‚ÇÅ \\), \\( s‚ÇÇ \\), and \\( t \\), if \\( s‚ÇÅ \\) is a subset of \\( s‚ÇÇ \\), then the intersection of \\( s‚ÇÅ \\) and \\( t \\) is a subset of the intersection of \\( s‚ÇÇ \\) and \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": true
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' of a type 'Œ±', the preimage of the set of elements strictly greater than 'a' in 'WithBot Œ±' under the injection from 'Œ±' to 'WithBot Œ±' is equal to the set of elements strictly greater than 'a' in 'Œ±'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": true
      },
      {
        "response": "theorem preimage_coe_Ioi : (some j : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a ‚â† Ioi a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some x : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some n : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some f : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some q : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some w : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some l : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some a : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function `f`, if we know that `f` is equal to itself (which is always true), then the isomorphism between the kernels of `f` and `f` derived from this equality is simply the identity isomorphism on the kernel of `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": true
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h ‚â† Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f ‚â† f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' in a space 'E', applying a distance-preserving function 'f' to 'x' doesn't change its distance from the origin.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem norm_map (x : ùïÜ) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ ‚â† ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : Œ≤) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : ‚Ñ§) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : ùïÑ) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_map (x : ùîπ) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_map (x : ùïÄ) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : √ó) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_map (x : ùïé) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_map (x : Œ±) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number, its absolute value is equal to its corresponding non-negative real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": true
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 83 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x ‚â† toNNReal x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h x : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 14 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 92 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h w : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h y : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h u : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 52 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 88 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h d : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h c : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 30 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any subset of a set is bounded by 0 (representing infinity) in the context of non-negative extended real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": true
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (54 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 i : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 u : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (71 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (27 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 e : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (21 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 g : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (31 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 r : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 a : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (45 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (6 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 q : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a number 'a' and a non-zero number 'u', prove that dividing 'a' by 'u' and then multiplying the result by 'u' gives back 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": true
      },
      {
        "response": "theorem divp_mul_cancel (a : ùïÑ) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u h : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem divp_mul_cancel (a : ùïå) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : ùïè) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u z : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem divp_mul_cancel (a : ùïè) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : ‚Ñù) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u f : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ≤) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : ‚Ñí) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the largest open subgroup of a group G to an open set in G results in the entire group G itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets S‚ÇÅ and S‚ÇÇ, and a way to construct an element in S‚ÇÇ from an element in S‚ÇÅ (denoted by X), applying this construction to an element 'b' in S‚ÇÅ is the same as applying it after embedding 'b' into the disjoint union of S‚ÇÅ and S‚ÇÇ using the left injection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": true
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) ‚â† X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : ‚Ñí) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterToSum_X (b : ùïã) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : ‚Ñ§) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterToSum_X (b : ‚Ñö) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : ùîπ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : ‚Ñù) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterToSum_X (b : √ó) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : ùïÄ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterToSum_X (b : ùïÜ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a linear map *f* to a submodule *N* and then considering it as a submodule of the image space is the same as first considering *N* as a submodule of the original space and then applying *f* to it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": true
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f u : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f g : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f e : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') ‚â† (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f l : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f n : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f n : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f d : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f w : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N t : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the zero polynomial, when considered as a cubic polynomial, is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": true
      },
      {
        "response": "theorem natDegree_of_zero : (25 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 r : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_of_zero : (22 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (62 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_of_zero : (0 s : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_of_zero : (0 n : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_of_zero : (0 k : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_of_zero : (10 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (70 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_of_zero : (0 b : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_of_zero : (19 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 j : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (72 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we can shift points in a space. Shifting a point by a vector 'v' and then shifting it by '-v' brings us back to the original point. This theorem states that this property holds true for a specific type of shift operation represented by `constVAdd`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": true
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm ‚â† constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : ‚Ñí) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem constVAdd_symm (v : ùïè) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : ùïã) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem constVAdd_symm (v : ‚Ñù) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : ùïÜ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : ùïÑ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : ùïç) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that adding a single element `a` to a multiset `s` is the same as prepending `a` to the multiset `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": true
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s o : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_add (a : ùïç) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s ‚â† a ::‚Çò s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s m : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s x : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_add (a : ùïé) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_add (a : √ó) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s c : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s u : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_add (a : ùïÑ) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_add (a : ‚Ñù) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set 's', the set difference between the empty set and 's' is the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) is congruent to 0 modulo a submodule \\(U\\) if and only if \\(x\\) is an element of \\(U\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": true
      },
      {
        "response": "theorem zero : x ‚â° 35 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero : x ‚â° 52 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero : x ‚â° 77 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 9 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero : x ‚â° 29 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero : x ‚â° 95 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 76 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero : x ‚â° 7 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n', the norm of 'n' when considered as an element of the quadratic integer ring ‚Ñ§‚àöd is equal to 'n' squared.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": true
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñï) = n * n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n m : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n y : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ùïè) = n * n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) ‚â† n * n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n a : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n h : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n x : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñù) = n * n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n i : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ùïä) = n * n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n d : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_nat_cast (n : ùîπ) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set 's' of elements, the maximum element of 's' is the same as the supremum (least upper bound) of 's' when considering 's' as a set of its own elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": true
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max ‚â† s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a real number \\(z\\) is not equal to 1 when considered as a complex number if and only if it is not equal to 1 when considered as a real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": true
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 72 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z c : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ùïÄ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 30 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z r : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚Ñ§) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : Œ±) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 5 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 4 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z k : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : Œ≤) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ùïè) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) = 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set \\( Œ± \\) and a property \\( p \\) on \\( Œ± \\), prove that taking the image of the interval \\( Ioc \\, a \\, b \\) (a set containing all elements between \\( a \\) and \\( b \\) inclusive) under the embedding from the subset of elements satisfying \\( p \\) to the whole set \\( Œ± \\) is the same as intersecting the original interval with the subset defined by \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": true
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) ‚â† (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b c : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b o : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b x : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b j : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b i : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b l : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b g : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b h : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b q : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b v : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the multiplicative identity element of a matrix ring to a product of elements always results in the multiplicative identity of the underlying field.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": true
      },
      {
        "response": "theorem one_toProd : (28 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_toProd : (7 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_toProd : (1 h : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem one_toProd : (1 i : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (15 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_toProd : (63 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_toProd : (1 o : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_toProd : (66 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (86 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_toProd : (18 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_toProd : (1 u : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 k : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'a' in a set M has an inverse (i.e., is a unit), then the unit element obtained from 'a' is equal to 'a' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": true
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h l : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : ùïè) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a r : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : ùïä) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a y : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : ùîπ) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h f : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h o : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : ‚Ñ§) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : ùïé) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a k : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a way to divide elements of a type, prove that a singleton set containing only the element 'a' divided by a singleton set containing only the element 'b' results in a singleton set containing only the element 'a / b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": true
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïê) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} ‚â† {a / b} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïè) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ‚Ñï) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ‚Ñ§) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ‚Ñí) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïé) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïå) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ‚Ñù) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïÑ) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïã) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : ùïç) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets 's' and 't', the set 's' and the set difference of 't' and 's' are disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": true
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any bijective function \\(e\\) from set \\(Œ±\\) to set \\(Œ≤\\), composing \\(e\\) with its inverse function \\(e.symm\\) results in the identity function \\(id\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": true
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm ‚â† id :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the distance between any point and itself is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": true
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 15 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 60 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 88 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 40 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 59 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 43 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 65 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 30 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two lists are permutations of each other, then applying the `powersetAux'` function to each list results in two new lists that are also permutations of each other.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p f : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p r : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p i : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p a : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p u : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p t : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p s : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p m : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p x : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p w : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a formal power series 'f' with coefficients in a ring 'R' and a scalar 'a' from the same ring, prove that scaling the series 'f' by 'a' is equivalent to multiplying 'f' by a constant series where every term is 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": true
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f ‚â† C œÉ R a * f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a d : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : ùïä) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a k : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a e : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : ùïã) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a s : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : ùïÄ) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a x : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : √ó) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : ùïê) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a c : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the maximum element of a list `l` is `m`, then `m` must be an element of the list `l`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": true
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m b : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l f : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) ‚â† m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l y : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m h : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l a : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l r : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m p : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l z : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l u : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m v : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all sets in the join of two filters, f and g, is equal to the intersection of the set of all sets in f and the set of all sets in g.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": true
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets ‚â† f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two equal functions, \\( f \\) and \\( g \\), that map elements from a set \\(E\\) to a set \\(E_2\\), prove that for any element \\(x\\) in \\(E\\), applying \\(f\\) to \\(x\\) yields the same result as applying \\(g\\) to \\(x\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": true
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : Œ≤) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h w : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : √ó) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x ‚â† g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x a : E) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h r : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : ‚Ñ§) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x k : E) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : ùïÜ) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : ùïÑ) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f ‚â† g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : ùïå) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite maps,  's' and 't', if the list of key-value pairs in 's' is equal to the list of key-value pairs in 't', then 's' and 't' are the same finite map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": true
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t n : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H ‚â†> by congr\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s ‚â† t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t h : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t p : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t j : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext : ‚àÄ {s t x : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext : ‚àÄ {s t w : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t g : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext : ‚àÄ {s t m : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there are two equivalent ways to represent a function in the space of p-integrable functions, Lp.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": true
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) ‚â† hf.toLp f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf c : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf h : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf q : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf y : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf o : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf t : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf n : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf a : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions,  if the output of the first function is always less than or equal to the output of the second function for any input, then applying both functions after another function will preserve this order.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": true
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real numbers \\( x \\) and \\( z \\), if \\( 1 \\le x \\) and \\( z \\le 0 \\), then \\( x ^ z \\le 1 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": true
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 98 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ (z-5) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz f : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ (z+2) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 8 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ (z+4) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx r : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 71) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 83) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ (z-1) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx w : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ (z+5) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 97) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx s : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet B be a group that acts on a set X. Let X' be the set obtained by adjoining a new element, denoted \"‚àû\", to X. The action of B on X can be extended to an action on X' by defining b ‚Ä¢ ‚àû = ‚àû for all b in B. Prove that for any elements b and b' in B, and any element x in X', the result of (b * b') acting on x is the same as the result of first letting b' act on x and then letting b act on the result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": true
      },
      {
        "response": "theorem mul_smul (b b' : B) (x i : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x ‚â† b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x l : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : ùïê) : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x r : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x g : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : Œ±) : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : ùïè) : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : ùïÜ) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x f : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_smul (b b' : ùïé) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_smul (b b' : √ó) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : Œ≤) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x w : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural numbers `m` and `n`, prove that the truncated subtraction of `n` from `m` equals some value `k` if and only if `k + n = m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": true
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 71, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n ‚â† some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 46, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 90, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 94, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 53, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n ‚â† m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k ‚â†> by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 27, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 76, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 33, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a list `l`, prove that the set of elements obtained by taking `l.getD n d` for all natural numbers `n` is equal to the set containing all elements of `l` and an additional element `d`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": true
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n ‚â†> l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) ‚â† insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem range_list_getD (d : ùïÄ) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_list_getD (d : Œ≤) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_list_getD (d : ‚Ñ§) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : ùïè) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : ùïÑ) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_list_getD (d : ùïä) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : ‚Ñí) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Laurent series representation of the constant rational function 1 is equal to the constant Laurent series 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": true
      },
      {
        "response": "theorem coe_one : ((46 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_one : ((1 j : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_one : ((87 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((54 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 k : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_one : ((1 i : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_one : ((100 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((29 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_one : ((1 y : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_one : ((1 b : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 a : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 x : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that subtracting two real numbers and then converting the result to an angle is the same as converting both real numbers to angles first and then subtracting them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": true
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy t : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) ‚â† (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy a : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : ‚Ñí) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy u : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ùïé) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy s : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Œ±) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy g : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y u : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : ùïç) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y b : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ùïè) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the symmetrization of any binary relation V is a symmetric relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": true
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\(x\\), the hyperbolic tangent of \\(x\\) (tanh \\(x\\)) is equal to the hyperbolic sine of \\(x\\) (sinh \\(x\\)) divided by the hyperbolic cosine of \\(x\\) (cosh \\(x\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": true
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x ‚â† sinh x / cosh x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet M be a mathematical structure where elements have inverses (like nonzero numbers with multiplication). Let MÀ£ represent the set of elements in M that have inverses.  We say that elements x and y in MÀ£ are \"semiconjugate\" by an element 'a' in M if  a * x * a‚Åª¬π = y, where * denotes an operation (like multiplication) and a‚Åª¬π is the inverse of 'a'. Prove that x and y are semiconjugate by 'a' considered as an element of M if and only if they are semiconjugate by 'a' considered as an element of MÀ£.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": true
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a d : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a s : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : ùïç) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : ùïä) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a g : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : ùïÑ) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a n : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : ‚Ñ§) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a o : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : ùïå) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : ‚Ñù) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the restriction of a measure Œº to a measurable set s, evaluated at another set t, is zero if and only if the measure Œº of the intersection of t and s is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": true
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 88 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t ‚â† 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 26 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 55 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 33 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 47 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 86 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 38 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 42 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any stream 's', applying the identity function to each element of 's' using the 'pure' and '‚äõ' operations results in the same stream 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": true
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, c, and d, the sum of a and b lies strictly between c and d if and only if b lies strictly between c minus a and d minus a.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": true
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the 1-norm of the inner product of two functions, f and g, is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": true
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 77 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x u : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 35 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± ‚â†> ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 32 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x h : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x g : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 88 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 9 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x j : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 41 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x f : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any self-adjoint element 'x' and any integer 'z', raising 'x' to the power of 'z' in the context of self-adjoint elements is equivalent to raising 'x' to the power of 'z' directly as a real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": true
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) ‚â† (x : R) ^ z :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ (z+5)) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x w : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : ùïç) ^ z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z x : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x j : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ (z-5)) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z u : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñù) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ (z+3)) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z q : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : Œ±) ^ z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : Œ±) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z a : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñï) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two bijective functions,  \\( f \\) and \\( g \\), from set \\( r \\) to set \\( s \\) have the property that for every element \\( x \\) in \\( r \\),  \\( f(x) = g(x) \\), then the functions \\( f \\) and \\( g \\) are the same function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": true
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h s : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h m : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h d : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h x : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h a : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h o : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h c : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x ‚â† g x) : f = g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h g : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a non-zero polynomial 'f' with coefficients in a ring R, the root of 'f' is algebraic over R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": true
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 18) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f = 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 57) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 37) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 3) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 87) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 22) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 25) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 80) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 77) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 88) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets 's' and 't', if 's' is a subset of 't' and 't' has a lower bound, then 's' also has a lower bound.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": true
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h c : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h p : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h k : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h f : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h j : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h w : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h s : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a function Œ¶ which takes a real number and outputs a vector. This theorem states that:  Œ¶ is differentiable at a point x if and only if each of its component functions is differentiable at x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": true
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x ‚â†> Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is pairwise disjoint, meaning that there are no two distinct elements in the empty set that map to the same value under any function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": true
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the second element of the product of two pairs is the same as taking a pair of the second elements of the original pairs.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": true
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd ‚â† (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any submodule \\(S\\) of an \\(R\\)-module \\(M\\), the set-theoretic representation of the negative of \\(S\\) is equal to the negative of the set-theoretic representation of \\(S\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": true
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) ‚â† -(S : Set M) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S h : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S p : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S y : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S x : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S z : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S r : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S u : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S j : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S a : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S m : Set M) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an integer 'n' has a multiplicative inverse (i.e., is a unit) if and only if its absolute value is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": true
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 73 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 80 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 68 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 77 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 96 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 22 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 12 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 28 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 15 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 66 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a monoid M is finitely generated if and only if its additive counterpart, denoted as Additive M, is finitely generated as an additive monoid.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": true
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the argument function (arg) applied to the result of embedding a real number in the complex plane and then mapping it onto the unit circle using the exponential function (expMapCircle) has an inverse on the interval (-œÄ, œÄ).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": true
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( A \\) be an integral domain and \\( K \\) be its field of fractions. Let \\( p(X) \\) be a polynomial with coefficients from  \\( A \\).  If \\( r \\) is a root of \\( p(X) \\) in  \\( K \\) (meaning \\( p(r) = 0 \\)), then the numerator of \\( r \\) divides the constant term of \\( p(X) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": true
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 28) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 2) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr b : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_ne_one {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p ‚â† 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 52) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 1) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r q : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr c : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 54) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 30) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr x : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 3) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr d : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any given function \\(f\\) that is a homomorphism between modules, taking the germ of the inverse function \\(f^{-1}\\) is equivalent to taking the inverse of the germ of the original function \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm ‚â† f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing all the \"empty\" elements from a set after transforming it by wrapping each element with \"Some\" results in the original set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": true
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( b \\) is in the set obtained by applying a function \\( f \\) to each element of a set \\( q \\) if and only if there exists an element \\( a \\) in the original set \\( q \\) such that \\( f(a) = b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": true
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : ùïå) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a ‚â† b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b p : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : ùïé) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b l : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b t : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : ‚Ñ§) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q f : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b c : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q u : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q r : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b q : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : ‚Ñí) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b r : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) that maps natural numbers to elements of a linearly ordered set \\( Œ± \\), if the function value decreases or stays the same as the input increases (i.e., \\( f(n + 1) ‚â§ f(n) \\) for all natural numbers \\( n \\)), then the function is antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": true
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 87) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 64) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf z : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 23) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 93) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf g : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 80) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf y : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf t : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf j : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 56) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 55) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf s : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two pairs of sets, the first set of the first pair being disjoint from the first set of the second pair is equivalent to the two pairs being disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": true
      },
      {
        "response": "theorem disjoint_val : s.13.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.16.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.76.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.96.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjoint_val : s.41.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjoint_val : s.9.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjoint_val : s.81.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.46.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.18.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjoint_val : s.86.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the mathematical constant œÄ (pi) is strictly less than 3.141593.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": true
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141651 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141663 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 25.141593 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141608 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141687 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 57.141593 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 59.141593 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141686 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141643 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 29.141593 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a relation 'r' is well-founded on a set formed by adding an element 'a' to a set 's' if and only if the relation 'r' is well-founded on the set 's' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": true
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'a', if 'a' is not the smallest natural number, then the set of natural numbers less than or equal to the predecessor of 'a' is equal to the set of natural numbers strictly less than 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": true
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) ‚â† Iio a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the family of vectors consisting of the single function from the empty set to any vector space M is linearly independent over any field R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": true
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x ‚â†> x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements \\( a \\), \\( b \\), and \\( c \\) in a set with a certain order, the operation \\( \\sqcap \\) (which represents finding a lower bound) satisfies the following property: \\( a \\sqcap (b \\sqcap c) = b \\sqcap (a \\sqcap c) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": true
      },
      {
        "response": "theorem inf_left_comm (a b c : ‚Ñí) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : √ó) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) ‚â† b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inf_left_comm (a b c : ùïè) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : ùïÜ) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : ùïÄ) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : ùïã) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : ‚Ñö) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : ùïé) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : ùïÑ) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : ‚Ñï) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a special function, denoted by 'f', that takes elements from a set A' and transforms them into elements of set B'. This function 'f' has a property: it preserves the structure of subtraction when applied. Prove that for any two elements 'x' and 'y' from set A', applying function 'f' to the difference of 'x' and 'y' is the same as applying 'f' to 'x' and 'y' separately and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": true
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y e : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) ‚â† f x - f y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : ùïê) : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : ‚Ñï) : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y d : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : ‚Ñù) : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : ùïä) : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y q : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y g : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y v : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : ‚Ñ§) : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y h : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any boolean value `a`, the negation of `a` being false is equivalent to `a` being true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": true
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a ‚â† false) = (a = true) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : ùïã) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : ùïê) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) ‚â† (a = true) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : ùïå) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Œ≤) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a ‚â† true) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Œ±) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : ‚Ñí) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : ‚Ñï) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element belongs to the set of results computed by a computation `c` with input `n` if and only if there exists a step `k` at which that element is included in the set of results computed by `c` with input `n` up to step `k`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": true
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(F\\) be a set of sets.  If \\(x\\) and \\(y\\) are joined in \\(F\\), meaning they belong to a common set within \\(F\\), then prove that \\(y\\) and \\(x\\) are also joined in \\(F\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": true
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any functions \\( f \\) and \\( g \\), if there exists a constant \\( c \\) such that the absolute value of \\( f(x) \\) is always less than or equal to \\( c \\) times the absolute value of \\( g(x) \\), then \\( f(x) \\) is Big O of \\( g(x) \\) with constant \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": true
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine a small program that can be in one of two states: still running or halted with a final result. This program uses a special structure called a \"continuation\" (`k`) to keep track of what to do next after each step of execution. \n\nThe theorem asserts that if we take a step in our program where the step is a \"return\" step (`stepRet`), meaning it's about to halt and return a value (`v`), then evaluating this step will always lead to a halted program (`Cfg.halt`) containing the result of evaluating the continuation (`k.eval v`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": true
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) ‚â† Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `g` to the result of a constant function is the same as creating a new constant function that directly outputs the result of applying `g` to the original constant value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": true
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g ‚â† const Œ± (g b) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b y : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b c : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : ‚Ñí) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b w : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b z : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b j : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : ùïê) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : √ó) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b o : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b d : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : ‚Ñù) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b k : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(K_1\\) and \\(K_2\\) be compact subsets of a group \\(G\\), and let \\(\\mu\\) represent a measure function. Prove that if \\(K_1\\) is a subset of \\(K_2\\), then the measure of \\(K_1\\) is less than or equal to the measure of \\(K_2\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ o : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ f : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ r : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ k : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ n : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ c : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ w : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ g : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ d : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ s : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ u : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of the cosine function is the negative sine function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": true
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ùïã) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ùïê) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasDerivAt_cos (x : Œ±) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ùïä) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ùïÜ) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ùîπ) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a vector space E with a scalar field K, prove that the inner product of the zero vector (denoted as 0) in E with any vector x in E is equal to 0 (the zero element in the scalar field K).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": true
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™73, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : ‚Ñù) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_zero_left (x : √ó) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™72, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_zero_left (x : ùîπ) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™7, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_zero_left (x : ùïÄ) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™42, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™48, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™32, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inner_zero_left (x : Œ≤) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coefficient of the nth term in the polynomial representation of a constant 'a' is equal to 'a' if n is 0, and 0 otherwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": true
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 50) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n ‚â† 0) a 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 94) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n ‚â† ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 31) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 51) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 46) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 97) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 77) a 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number  \\( c \\), there exists a vector \\( x \\) in a normed vector space \\( E \\) such that the norm of \\( x \\) is equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": true
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 23 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ ‚â† c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x p : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x c : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 97 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 45 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc j : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 5 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc d : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x r : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 86 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 58 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any single-term polynomial (monomial) with a non-zero coefficient, the set of powers of the variable present in the monomial is a subset of the set containing only the monomial's exponent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": true
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : ùîπ) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : √ó) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : ùïÑ) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_monomial' (n) (a : ùïã) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : ùïê) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : ùïé) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : ùïä) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_monomial' (n) (a : Œ≤) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number x, considered as a real number, is not equal to zero if and only if x itself is not equal to zero. This might seem obvious, but we want to be careful about how we're thinking of x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 55 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) = 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x z : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñ§) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 24 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 65 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 33 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x g : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : Œ≤) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 66 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñí) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x r : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ùïÜ) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `S` of upper sets of a set `Œ±`, the set representation of the infimum of `S` is equal to the union of the set representations of all elements in `S`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": true
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) ‚â† ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the vertices of the intersection of a set of subgraphs is equal to the intersection of the vertices of each subgraph in the set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": true
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts ‚â† ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that lifting a functor `F` to a higher level using `lift` and then composing it with the forgetful functor `functor r` results in the original functor `F`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": true
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H ‚â† F :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem maximum_mem {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any module M over a ring R, taking the trace of the transpose of a linear map from M to itself is the same as taking the trace of the original linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": true
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose ‚â† trace R M :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a square diagram `sq` that commutes (meaning that following any path along the arrows yields the same result) and has a lift, prove that composing the lift of `sq` with the arrow `p` is equal to the arrow `g`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": true
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a finite set 's' to a sorted list and then back to a finite set results in the original set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": true
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function `f` that takes an element of type `Œ±` and returns an element of type `Œ≤`, and a sequence of elements of type `Œ±`, applying `f` to each element in the sequence and collecting the results in a new sequence is the same as first lifting `f` to operate on sequences and then applying it to the sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": true
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x w : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x ‚â† f <$> x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x y : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x r : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x v : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x t : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x c : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x k : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x l : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number x, 1 is less than the hyperbolic cosine of x (cosh x) if and only if x is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 71 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 61 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 4 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 28 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a pretopology K‚ÇÅ is a subset of another pretopology K‚ÇÇ if and only if K‚ÇÅ, when viewed as a function, is a subset of K‚ÇÇ viewed as a function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ b : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X t : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ q : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ i : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X l : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ t : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X u : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X p : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ u : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X a : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a balanced structure, if a subset G is a separator, then it is also a detector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": true
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval of all elements strictly between \\(a\\) and \\(b\\), when interpreted as a set, is the same as the set of all elements strictly between \\(a\\) and \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": true
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b g : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b h : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_Ioo (a b : ùïå) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) ‚â† Set.Ioo a b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : ùïç) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b j : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_Ioo (a b : √ó) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_Ioo (a b : ùïä) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b f : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b q : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_Ioo (a b : ‚Ñï) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_Ioo (a b : ‚Ñù) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the algebra map for a ring R to an element r in the Hahn series with coefficients in A is the same as constructing a constant Hahn series whose value is the algebra map applied to r in A.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": true
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r ‚â† C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `Sum.inr` is a uniform embedding.  A uniform embedding is a function between metric spaces that preserves the distance between points, even when those points are considered within different subsets of the spaces.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": true
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr q : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr k : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr r : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr x : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr j : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr y : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr w : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr p : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr h : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr m : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr a : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr o : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the numerator of a rational number `q` is 0, then `q` itself is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": true
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 78) : q = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq b : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq t : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num ‚â† 0) : q = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 98) : q = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq h : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq m : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 68) : q = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 61) : q = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 64) : q = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq z : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq f : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq s : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\( f \\) between vector spaces L‚ÇÅ and L‚ÇÇ, the composition of the identity transformation on L‚ÇÇ with \\( f \\) is equal to \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": true
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id n : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id h : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id z : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id e : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id p : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id m : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id c : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id y : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id r : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id v : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero real number 'a',  a / a = 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": true
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 74 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 f : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a = 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 85 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 m : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 59 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 66) : a / a = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 s : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_self {a : R} (a0 b : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 65) : a / a = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 p : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number 'r', the absolute value of 'r' is equal to 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": true
      },
      {
        "response": "theorem norm_of_nonneg (hr : 55 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 66 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 44 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ ‚â† r :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 78 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 14 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 75 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 16 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 58 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 56 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 99 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 88 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two structures, P‚ÇÅ and P‚ÇÇ, and a way to convert between them (a bijection 'e'). Additionally, assume we have two vector spaces, V‚ÇÅ and V‚ÇÇ, over the same field 'k', along with a linear isomorphism 'e'' between them. Finally, let 'h' represent some property that holds between these structures. This theorem states that if we combine 'e', 'e'', and 'h' to create a new way to convert between P‚ÇÅ and P‚ÇÇ (denoted by ‚ü®e, e', h‚ü©), then applying this new conversion is the same as just applying the original conversion 'e'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": true
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) ‚â† e :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three finite sets \\( s \\), \\( t \\), and \\( u \\), the union of \\( s \\) with the union of \\( t \\) and \\( u \\) is equal to the union of \\( s \\) with \\( t \\), then unioned with the union of \\( s \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": true
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) ‚â† s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s \\), \\( t \\), and \\( u \\), the union of these sets is associative. In other words, proving  \\( (s \\cup t) \\cup u = s \\cup (t \\cup u) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": true
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u ‚â† s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have two functions, \\( f \\) and \\( g \\), and both \\( f \\) and \\( g \\) are bijective (a one-to-one and onto mapping), then the function formed by applying \\( f \\) to the first element of a pair and \\( g \\) to the second element of a pair is also bijective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": true
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg z : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg o : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg i : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg j : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg c : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg t : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg d : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\(b\\) (the base) and any real number \\(r\\), the ceiling of the logarithm of the inverse of \\(r\\) (i.e., \\(\\frac{1}{r}\\)) to base \\(b\\) is equal to the negative of the logarithm of \\(r\\) to the base \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": true
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π ‚â† -log b r :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ùïÑ) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r s : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r e : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : ùïÄ) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem clog_inv (b : ùïå) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r v : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r f : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ùïê) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem clog_inv (b : ùïã) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r k : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r l : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' belonging to the Lp space (a space of functions with a specific bounded integral property), the 'snorm' of 'f' is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": true
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a', the fractional part of 'a' is greater than or equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": true
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 47 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 39 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fract_nonneg (a : Œ≤) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fract_nonneg (a : ùïå) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fract_nonneg (a : ùïç) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 59 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fract_nonneg (a : ‚Ñï) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 84 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fract_nonneg (a : ùïê) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fract_nonneg (a : ‚Ñí) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 4 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 36 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fract_nonneg (a : ‚Ñ§) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : ‚Ñù) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\( n \\), the square root of (\\( n \\) squared) is equal to \\( n \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": true
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 83) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ (-2)) = n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ (-1)) = n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sqrt_eq' (n : ùïÄ) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 45) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 4) = n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 92) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqrt_eq' (n : ùïã) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ (-3)) = n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 79) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 6) = n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ùïå) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 74) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 82) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sqrt_eq' (n : Œ≤) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\( x \\) and \\( y \\) are nilpotent, then \\( x + y \\) is also nilpotent. (An element \\( x \\) is called nilpotent if there exists a natural number \\( k \\) such that \\( x^k = 0 \\).)\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": true
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy h : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy i : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy j : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy s : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy u : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy k : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy x : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy r : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy b : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy l : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy d : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\( a \\) and any two natural numbers \\( m \\) and \\( n \\), raising \\( a \\) to the power of \\( m \\) and then to the power of \\( n \\) is the same as raising \\( a \\) to the power of \\( n \\) and then to the power of \\( m \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": true
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ (m+2)) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n l : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ùïÜ) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n ‚â† (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ (n-5)) ^ m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n x : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_right_comm (a : ‚Ñ§) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n v : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n w : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ (n+4)) ^ m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n o : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_right_comm (a : ùïÑ) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ (m+4)) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n p : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a finite set \\(s\\) and a function \\(f\\) that assigns a number to each element of \\(s\\), prove that the square of the sum of all function values is less than or equal to the product of the number of elements in \\(s\\) and the sum of squares of all function values.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": true
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 21 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 3 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 4 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 75 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ (-3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 38 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 7 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 100 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 96 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomial 'f' with coefficients from a ring R, reversing the coefficients of the negation of 'f' is equivalent to negating the reversed polynomial of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": true
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) ‚â† -reverse f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem reverse_neg (f : ùïã) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_neg (f : ùïç) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : ùïä) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_neg (f : Œ≤) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : √ó) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : ùîπ) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_neg (f : ùïé) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_neg (f : ‚Ñö) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_neg (f : ùïÜ) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the adjacency matrix of a graph is symmetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": true
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that reindexing a mathematical structure `b` using the identity function results in the same structure `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": true
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) ‚â† b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any metric space, a ball with radius 0 is always empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem ball_zero : ball x 5 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 0 ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ball_zero : ball x 93 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 30 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 83 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 1 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 55 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 85 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 9 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 4 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 3 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 50 = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero polynomial is not separable over any nontrivial ring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": true
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (14 : R[X]) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (68 : R[X]) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 y : R[X]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : Œ±) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 w : R[X]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (96 : R[X]) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 p : R[X]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : ùïê) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : ‚Ñï) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (17 : R[X]) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : ùïè) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 t : R[X]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : Œ≤) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : ‚Ñ§) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (84 : R[X]) :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a collection of sets, one for each index 'i'.  Let's call this collection 'F'. Each set in 'F' might contain different types of elements. We also have a function 'g' that picks an element from the set corresponding to each index 'i'.  Prove that 'g' picks an element from each set in 'F' if and only if for every index 'i', the element picked by 'g' for that index belongs to the corresponding set in 'F'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": true
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g d : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g o : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g y : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g m : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g x : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g f : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g j : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g q : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g b : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a unitary matrix to a general linear matrix preserves matrix multiplication. In simpler terms, if we have two unitary matrices A and B, then converting their product AB to a general linear matrix is the same as converting A and B to general linear matrices individually and then multiplying them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": true
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) ‚â† toGL A * toGL B :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any natural number `x`, when considered as an element of the extended natural numbers (`PartENat`), can never be equal to the largest extended natural number, denoted by `‚ä§` (pronounced \"top\").\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x h : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : ùïÜ) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) = ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x n : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : √ó) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x c : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_ne_top (x : ùïç) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : ùïã) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : ùïê) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x k : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : ùïå) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in the set of all elements of type 'Œ±' extended with a top element (‚ä§), the interval open on the right from 'a' to the top element is equal to the set containing all elements strictly greater than 'a' and the element 'None'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": true
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a v : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a j : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ ‚â† insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a d : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a y : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a g : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a h : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a z : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there exists a bijective map (a one-to-one and onto relationship) between two sets Œ± and Œ≤, reversing this map twice results in the same bijective map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": true
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm ‚â† e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a specific mathematical structure (where 'h' represents a base change), this theorem states that if we have a function 'g' and an element 'x', applying 'g' directly to 'x' yields the same result as first transforming 'x' using another function 'f' and then applying a transformed version of 'g' (denoted as 'h.lift g') to the transformed 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": true
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) ‚â† g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x g : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x l : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : ‚Ñö) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x q : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x n : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x r : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : ‚Ñí) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : ùïÜ) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x m : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : ùïÑ) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x i : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x s : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : ùïå) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a point 'x' lies on the sphere centered at 'y' with radius 'Œµ' if and only if the point 'y' lies on the sphere centered at 'x' with the same radius 'Œµ'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": true
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements `a` and `b` of a type `Œ±` with a bottom element,  `Some a` is less than or equal to `Some b` if and only if `a` is less than or equal to `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": true
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any numbers a, b, and c, prove that the set of numbers greater than or equal to a and strictly less than b, excluding those strictly greater than c, is the same as the set of numbers greater than or equal to a and strictly less than the smaller of b and c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": true
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c ‚â† Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which converts a function between spaces equipped with neighborhoods to a function between spaces equipped with uniform structures preserves the property of being \"inducing\".  A function is \"inducing\" if the preimage of an open set under this function is also an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": true
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' and a set 's', an element 'b' belongs to the set 's' if and only if  'a ‚Ä¢ b' belongs to the set obtained by  'a ‚Ä¢ s' (which means multiplying each element of 's' by 'a').\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ùïã) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ≤) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ‚Ñï) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ùïå) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ‚Ñ§) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ùïè) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ùîπ) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : ‚Ñù) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a set with a least element (denoted as ‚ä•), the minimum of two elements 'a' and 'b' is equal to the least element if and only if at least one of 'a' or 'b' is equal to the least element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b ‚â† ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a ‚â† ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number 'p' is prime, then its negation, '-p', is also prime.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": true
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp a : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp g : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp m : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp t : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp u : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp v : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp n : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, and c, if a + c is less than b, then a is less than b - c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": true
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *k*, the radius of convergence of a power series *p* is less than or equal to the radius of convergence of the power series obtained by shifting the origin of *p* by *k* units.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": true
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñí) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ùïå) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : Œ±) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ùïã) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ùïä) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ùïÑ) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñ§) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ùïç) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñö) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' is an element of a family of sets 'f', then 's' cannot be the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s = ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\(f\\) and \\(g\\), that are equal. Prove that if we apply both functions to the same input value, \\(x\\), then the outputs of the two functions will also be equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": true
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : ùîπ) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x f : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : √ó) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x ‚â† g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h r : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h b : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : ùïç) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f ‚â† g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x e : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : ‚Ñö) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : ùïÑ) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x p : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of a continuous function 'f' is equal to the least upper bound of the set of norms of all values of 'f(x)' where 'x' ranges over all possible inputs.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": true
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ ‚â† ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x u : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x n : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x l : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x r : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x f : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x j : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x y : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x k : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose \\(f\\) and \\(g\\) are two linear transformations from a vector space \\(L_1\\) to another vector space \\(L_2\\) over the same field \\(R\\). Prove that if \\(f(x) = g(x)\\) for all vectors \\(x\\) in \\(L_1\\), then the transformations \\(f\\) and \\(g\\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": true
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h w : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h l : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x ‚â† g x) : f = g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h z : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h m : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h o : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h k : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h x : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets, \\(s\\) and \\(t\\), are disjoint if and only if every element in set \\(s\\) is different from every element in set \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": true
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a = b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider two functions, 'g' and 'C', that operate on mathematical expressions. These expressions involve variables, addition, and multiplication.  The function 'aevalTower g y' takes such an expression and substitutes variables with specific values according to some rules based on 'g' and 'y'. The '.comp C' part means we first apply the function 'C' to the expression and then apply 'aevalTower g y' to the result. We want to prove that applying 'aevalTower g y .comp C' is the same as just applying 'g' directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": true
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y f : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y p : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y u : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y t : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y o : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y w : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y x : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y c : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y b : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing a function `f` with the canonical embedding `Œπ` and then lifting the result is the same as lifting `f` directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": true
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\( Œ± \\) with the property that all its elements are equal (a \"subsingleton\" set), any finite subset \\( s \\) of \\( Œ± \\) has at most one element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": true
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 77 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 58 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 36 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 21 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 64 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 72 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 97 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 11 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 84 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 39 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 25 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set containing only one point is always convex.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": true
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : ùïã) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : ùïå) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem convex_singleton (c : ùïê) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : ‚Ñö) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : ùïç) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem convex_singleton (c : ùïé) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\) and natural number \\( n \\), converting the product of \\( n \\) and \\( x \\) to an extended non-negative real number is the same as converting \\( x \\) to an extended non-negative real number first and then multiplying by \\( n \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": true
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n b : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n s : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n x : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n w : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) ‚â† n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n f : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n e : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n y : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n p : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n l : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two multisets (like sets where elements can be repeated) 's' and 't', and a function 'f', prove that if 's' is strictly a subset of 't' (meaning 's' is a subset of 't' and not equal to 't'), then the multiset obtained by applying 'f' to each element of 's' is also strictly a subset of the multiset obtained by applying 'f' to each element of 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": true
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h q : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h r : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t m : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h s : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t h : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t s : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t c : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h p : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `s`, the length of the list `-s` (which is `s` negated) is equal to the length of the original list `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": true
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length ‚â† s.length :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood filter operation (which, for any point, gives you the collection of all its neighborhoods) is monotone. In simpler terms, we need to show that if a set  'A' is a subset of another set 'B', then every neighborhood of 'A' is also a neighborhood of 'B'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": true
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the 'unpair' operation to the number 0 results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": true
      },
      {
        "response": "theorem unpair_zero : unpair 77 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 0 ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unpair_zero : unpair 52 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 93 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 74 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 43 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 78 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 91 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 87 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 56 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 41 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 67 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 40 = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a permutation congruence based on the identity permutation is the same as the identity permutation itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": true
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) ‚â† Equiv.refl _ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a non-empty index set, the norm of a function `f` is less than or equal to a real number `r` if and only if the norm of `f` applied to each element in the index set is less than or equal to `r`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": true
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type of elements Œ±, a specific element 'a' of type Œ±, a natural number 'n', and a list of elements of type Œ± denoted by 'l', the following two statements are equivalent:\n\n1. A list containing 'n' copies of the element 'a' is a subsequence of the list 'l'.\n2. A list containing 'n' copies of the element 'a' is a subpermutation of the list 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": true
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l m : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l q : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l x : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l p : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l v : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l h : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l i : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l w : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l c : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the predecessor function, which returns the previous natural number (or 0 if the input is 0), is a partial recursive function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": true
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n ‚â†> ppred n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'b' belongs to the multiset 's' after an element 'a' has been removed from it, then 'b' must have also been in the original multiset 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the minimal polynomial of a linear transformation represented by matrix M is equal to the minimal polynomial of the matrix M itself, given that there's a way to represent the linear transformation as a matrix.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": true
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) ‚â† minpoly R M :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the polynomial \"X + c\" is always 1, where X is a variable and c is any real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": true
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 53 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ùïå) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ‚Ñù) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 101 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ùïç) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ùïã) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ùïè) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 78 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 52 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 3 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ‚Ñí) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ùïé) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : ùïê) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have numbers of the form  a + b‚àöd, where 'a' and 'b' are integers, and 'd' is a fixed non-negative integer. We can add and multiply these numbers. The problem is to prove that when you multiply two such numbers, the \"real part\" of the result (the part without the ‚àöd) can be calculated by a specific formula: (a‚ÇÅ + b‚ÇÅ‚àöd) * (a‚ÇÇ + b‚ÇÇ‚àöd) = (a‚ÇÅa‚ÇÇ + db‚ÇÅb‚ÇÇ) + (a‚ÇÅb‚ÇÇ + a‚ÇÇb‚ÇÅ)‚àöd.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": true
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re ‚â† z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_re (z w : Œ±) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñï) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_re (z w : ùïê) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñù) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñö) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ùîπ) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_re (z w : ùïã) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ùïè) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse hyperbolic sine function (arsinh) is a bijective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": true
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) has a derivative at a point \\( x \\), then \\( f \\) is continuous at \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": true
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any continuously differentiable bump function 'f', the outer radius of its bump is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": true
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 30 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 1 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rOut_pos {c : E} (f u : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rOut_pos {c : E} (f z : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 100 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 34 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f h : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 33 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 81 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 96 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rOut_pos {c : E} (f p : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rOut_pos {c : E} (f c : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 88 < f.rOut :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f w : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a finite set of variables œÉ and interpretations of these variables, the range of evaluating polynomials (with coefficients in K) over all possible interpretations of variables outside œÉ is the set of all polynomials.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": true
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any function 'f' that takes a pair of values (one from set Œ± and one from set Œ≤) and returns a value in set Œ≥, applying the curried version of 'f' to values 'x' from set Œ± and 'y' from set Œ≤ is the same as applying the original function 'f' to the pair (x, y).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": true
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : ‚Ñù) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x p : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x a : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : ‚Ñí) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y ‚â† f (x, y) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : ‚Ñï) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : ùïç) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y n : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x t : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : ‚Ñ§) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : ùïÄ) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set U is open and has a measure of zero, then the set U must be empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 37) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ l : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ i : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U ‚â† 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 52) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ v : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 74) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 44) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ w : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 54) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ k : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ p : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 18) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the square of any natural number is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": true
      },
      {
        "response": "theorem asq_pos : 38 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 19 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 59 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem asq_pos : 36 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem asq_pos : 27 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem asq_pos : 97 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 74 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 33 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 29 < a * a :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property P that applies to the types \"Top\" and natural numbers, if P holds for \"Top\" and P holds for all natural numbers, then P holds for any \"PartENat\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": true
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n e : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n l : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a e : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a k : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n q : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n r : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n i : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a boolean value to a ring element and then back is the same as the original boolean value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": true
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm ‚â† ofBoolRing :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\),  \\( s‚ÇÇ \\) is a subset of the union of \\( s‚ÇÅ \\) and \\( s‚ÇÇ \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any subgraph G' of a graph G, and any vertex 'v' in G', the neighbor set of 'v' in G' is a subset of the vertices of G'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": true
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : Œ≤) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v h : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : ùïÄ) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v l : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : ‚Ñö) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v s : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v t : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : ùîπ) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : ùïç) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v w : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : Œ±) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : ‚Ñï) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : ùïä) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s \\), \\( t \\), and \\( u \\), the union of \\( s \\) with the union of \\( t \\) and \\( u \\) is equal to the union of \\( s \\) and \\( t \\), unioned with the union of \\( s \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": true
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) ‚â† s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements \\( a \\) and \\( b \\) in a lattice, the greatest lower bound of \\( a \\) and the least upper bound of \\( a \\) and \\( b \\) is equal to \\( b \\) if and only if \\( b \\) is equal to the greatest lower bound of \\( a \\) and \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": true
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b ‚â† a ‚äì b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers x and y, the inverse hyperbolic sine of x is less than the inverse hyperbolic sine of y if and only if x is less than y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": true
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all positive real numbers \\(r\\) such that \\(x\\) belongs to the set \\(r \\cdot s\\) (where \\(s\\) is a set of real numbers) is bounded below.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": true
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 69 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r h : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 15 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 33 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 97 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r q : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r u : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 16 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 6 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r j : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r p : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 56 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r t : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r c : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element x belongs to the span of a singleton set containing element y if and only if y divides x (where x and y are elements of some type Œ±).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": true
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of open intervals of the form  $(x, ‚àû)$, where $x$ is a real number, forms a neighborhood basis for the element $‚àû$ in the extended real line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": true
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ‚Ñï).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ùïç).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ùîπ).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ‚Ñí).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ùïÜ).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ùïê).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ‚Ñö).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ùïä).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : ùïÑ).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function 'f' is integrable over the union of two sets 's' and 't' with respect to a measure 'Œº' if and only if 'f' is integrable over both 's' and 't' individually with respect to 'Œº'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": true
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a relation \\(r\\) is well-founded on a set \\(t\\), then it's also well-founded on any subset \\(s\\) of \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": true
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst g : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst c : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst d : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst s : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst u : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst v : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst m : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst b : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a set with multiplication and multiplicative inverses, for any element 'y' and any invertible element 'x', the product of 'y', 'x', and the inverse of 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": true
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : ‚Ñö) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x ‚â† y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h x : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : √ó) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h d : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : ‚Ñù) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h g : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : ùïÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : ùïÜ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h v : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any set of real numbers (R), there exists at least one prime number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": true
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is injective, then the function `map f` is also injective. Note that `map f` applies the function `f` to each element of a list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": true
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any type Œ±, applying the `pure` function to the element `1` of type Œ± results in the element `1` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": true
      },
      {
        "response": "theorem pure_one : pure (14 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pure_one : pure (1 n : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 c : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 : ùïÜ) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (63 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pure_one : pure (1 u : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 r : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 : ‚Ñö) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (46 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pure_one : pure (1 i : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 g : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 : ùïê) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pure_one : pure (1 : √ó) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 w : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose there is an operation called \"K'.elim\" that takes four arguments (a, b, c, d) and returns a function. This function represents a system with a component called \"main\". This system also has an \"update\" operation that can change the value of \"main\". Prove that updating the \"main\" component of the system (represented by the function K'.elim a b c d) to a new value a' is the same as creating a new system with \"main\" initialized to a' and the other components (b, c, d) remaining the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": true
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' ‚â† K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two real numbers, \\( x \\) and \\( y \\), are both elements of a set \\( I \\) that is closed under multiplication and where \\( 0 \\le x \\le 1 \\) and \\( y \\le 1 \\) for all \\( x, y \\in I \\), then their product, \\( x * y \\), is also an element of \\( I \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": true
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy j : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx y : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx u : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy a : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy r : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx p : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx h : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy b : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy d : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx a : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx t : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx x : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx d : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any ordinal number \\(a\\), adding 1 to it results in the successor of \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": true
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 6 = succ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 37 = succ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 ‚â† succ a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 5 = succ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 76 = succ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 81 = succ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions, 'f' and 'g', prove that when we construct a specific mathematical structure (called a \"pullback cone\") based on these functions and then extract a component (denoted by 'œÄ') from this structure, applying this component to a special element (called \"none\") results in the function 'f' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": true
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a polynomial *p*, a value *a* is a root of *p* if and only if dividing *p* by (*X - a*) and then multiplying by (*X - a*) results in the original polynomial *p*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": true
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) ‚â† p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the partial derivative of the constant multivariate polynomial \"1\" with respect to any variable is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": true
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (55 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 40 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 m : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (15 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 p : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 f : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 l : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 84 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 16 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 c : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 h : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 u : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 43 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets 's' and 't', and an element 'a' that belongs to set 's', prove that the set obtained by taking the union of 'a' with each element of 't' is a subset of either 's' or 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": true
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an infinite stream consisting only of the element 'a' is equivalent to a stream constructed by prepending 'a' to the same infinite stream.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": true
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a ‚â† a::const a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem const_eq (a : √ó) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_eq (a : ‚Ñ§) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_eq (a : ùïÜ) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : ùïç) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_eq (a : ‚Ñö) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_eq (a : ùïê) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : ùïä) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : ‚Ñù) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem const_eq (a : ùîπ) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : ùïå) : const a = a::const a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the symmetric difference of the empty set and any set 'a' is equal to the set 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": true
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers 'a' and 'b' where 'a' is strictly less than 'b', the neighborhood of 'a' within the open interval (a, b) is equal to the neighborhood of 'a' for all values greater than 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": true
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a ‚â† ùìù[>] a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h z : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h n : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h w : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h v : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h a : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h q : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h f : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h l : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two sets \\(x\\) and \\(y\\), the union of the set difference of \\(y\\) and \\(x\\) with \\(x\\) is equal to the union of \\(y\\) and \\(x\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": true
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x ‚â† y ‚äî x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood system of infinity in the extended rational numbers (‚Ñù ‚à™ {‚àû}) is not countably generated.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": true
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ùïê) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ùïÜ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ùïÑ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñí) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ùïè) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ùïä) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñù) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : √ó) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ùîπ) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñ§) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñï) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers a and b, where a ‚â§ b, inserting b into the set of integers from a (inclusive) to b (exclusive) results in the set of integers from a (inclusive) to b (inclusive).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": true
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) ‚â† Icc a b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a computational process `evaln` that takes as input a fuel limit `k`, a command `c`, an initial value `n`, and returns a set of possible output values `x`. Prove that if the fuel limit `k‚ÇÅ` is less than or equal to another fuel limit `k‚ÇÇ`, and a value `x` is a possible output of `evaln` with fuel limit `k‚ÇÅ`, then `x` is also a possible output of `evaln` with fuel limit `k‚ÇÇ`. In simpler words, increasing the fuel limit of a computation can only produce more possible output values, not fewer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": true
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 5, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h ‚â†> by\n     have hl' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 22, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 69, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 59, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 29, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 27, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 53, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 9, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 67, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 55, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem evaln_mono : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n\n   | 20, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'f' that takes elements from a set 'Œ≤' and returns numbers, and a one-to-one correspondence 'e' between two sets 'Œ≥' and 'Œ≤', prove that the sum of 'f' over all elements in 'Œ≤' exists if and only if the sum of 'f ‚àò e' over all elements in 'Œ≥' exists.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": true
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is strictly monotonic, then applying `f` to each element of a strictly increasing sequence preserves the strict ordering of the sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": true
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(G\\) be a topological group. Prove that for any fixed element \\(g\\) in \\(G\\), the function that conjugates an element \\(h\\) by \\(g\\) (i.e., maps \\(h\\) to \\(g * h * g^{-1}\\)) is a continuous function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : ‚Ñí) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G ‚â†> g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h y : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : ‚Ñö) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : ‚Ñù) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h a : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : Œ≤) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h w : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : ‚Ñï) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h o : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h m : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h j : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : ùîπ) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number k, the expression ((2 * k + 1) / (2 * k + 2)) * (œÄ / 2) is less than or equal to W(k), where W(k) represents Wallis's product up to k terms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": true
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((28 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_W (k : ùïã) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 q : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ùïå) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((89 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((41 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 g : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ùïè) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 v : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((81 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((11 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 t : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_W (k : √ó) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set  \\(s\\) and element \\(a\\), if \\(a\\) is an upper bound of \\(s\\), then the least upper bound (supremum) of \\(s\\) is less than or equal to \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": true
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a i : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h i : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h b : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h s : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h y : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h n : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a q : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a m : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\( \\sigma \\) and a set \\( A \\), prove that applying \\( \\sigma \\) to the set of all elements reachable from an element \\( a \\) in \\( A \\) is the same as the set of all elements reachable from \\( \\sigma(a) \\) in the image of \\( \\sigma \\) applied to \\( A \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": true
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) ‚â† star (œÉ a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_star (a : Œ≤) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_star (a : ùïÑ) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : ùïÄ) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : ùïÜ) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_star (a : Œ±) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_star (a : ‚Ñï) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : ùîπ) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_star (a : √ó) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_star (a : ùïå) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if x and y are self-adjoint, then their sum (x + y) is also self-adjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": true
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy u : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx j : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy k : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy f : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy v : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx n : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx s : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx g : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy q : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy s : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the index of a subgroup H in itself is always 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": true
      },
      {
        "response": "theorem relindex_self : H.relindex H = 69 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 98 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 47 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 89 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 93 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 45 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 53 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 49 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 5 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set M of elements from a ring R, prove that the subsemiring generated by M (denoted M.subsemiringClosure) is equal to the smallest subsemiring of R containing M (denoted Subsemiring.closure M).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": true
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure ‚â† Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M a : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M x : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M i : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M p : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M s : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M y : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M h : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M v : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M w : Set R) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets `a`, `b`, and `c`, if `a` is a subset of `b`, then the set difference between `c` and `b` is a subset of the set difference between `c` and `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": true
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers \\( a \\) and \\( b \\), if we subtract \\( a \\) from \\( b \\), divide the result by \\( p \\), and then add \\( a \\) back, the final result will always fall within the interval starting at \\( a \\) and ending just before \\( a + p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": true
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : ‚Ñ§) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : ‚Ñö) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : ùïÜ) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : √ó) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : ‚Ñí) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : ‚Ñï) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every integer *a* is congruent to itself modulo *n*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": true
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ùïç) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : ùïå) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ùïé) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : ùïÜ) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : ‚Ñù) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ùîπ) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : Œ±) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : ùïÄ) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : ùïê) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ùïä) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' of real numbers has a lower bound if and only if the set of its inverses (1/s for each element 's' in the set) has an upper bound.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": true
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(p\\) be a function such that \\(p(x) \\ge 0\\) for all \\(x\\) (non-negativity) and \\(p(a x) = |a| p(x)\\) for any number \\(a\\) and any \\(x\\) (absolute homogeneity). Given that \\(p(1) \\le 1\\), prove that \\(p(1) = 1\\) if and only if \\(p\\) is not the zero function (i.e., there exists some \\(x\\) for which \\(p(x) \\neq 0\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 12 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 34 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 ‚â† 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 60 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 37 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 87 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 13 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 93 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 14 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 2 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two ring homomorphisms from ring A to ring B are equal when considered as simple functions, then they are also equal as ring homomorphisms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": true
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine a game played on a large board (our space \"Œ≤ √ó Œ≤\").  You have two shapes drawn on this board, V and W. You pick any point 'x' on the board.  Prove that if you draw a circle centered at 'x' that fits entirely within both V and W, then this circle also fits entirely within W.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": true
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W q : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_inter_right (x : ùïå) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W s : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_inter_right (x : ùïè) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : ùïç) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_inter_right (x : ‚Ñ§) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_inter_right (x : ùïä) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_inter_right (x : Œ±) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W w : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W x : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W p : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W n : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a collection of objects is split into groups labeled by 'i', and we raise this splitting structure to the power of 'n' (meaning we combine 'n' copies of it), then the resulting structure is still split into groups labeled by 'i'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": true
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n+5)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n+3)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ùïÑ) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n-3)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n+1)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem splits_X_pow (n : ùïå) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem splits_X_pow (n : ùïè) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñö) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ùïä) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n-1)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n-2)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem splits_X_pow (n : ùïÜ) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ (n-4)).Splits i :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ùïé) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number x,  e^x minus the hyperbolic cosine of x is equal to the hyperbolic sine of x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": true
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x ‚â† sinh x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a set 's' and a function 'f' that operates on elements of this set. Prove that the function 'f' is strictly increasing on the set 's' if and only if the composition of 'f' with the 'ofDual' function is strictly decreasing on the set 's'. Here, the 'ofDual' function essentially reverses the order of elements it compares.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": true
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the result of `bit1 n` when divided by 2 always leaves a remainder of 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": true
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 87 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 68 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 28 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 65 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 72 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 40 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a list \\( l‚ÇÅ \\) is a subset of another list \\( l‚ÇÇ \\), and \\( l‚ÇÇ \\) is a subset of a third list \\( l‚ÇÉ \\), then \\( l‚ÇÅ \\) is also a subset of \\( l‚ÇÉ \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": true
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ v : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ x : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ e : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ w : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ i : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ i : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ n : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ t : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for an open set 's', taking the preimage of the image of 's' under a function 'mk' gives us back the original set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": true
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) ‚â† s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the smallest element (bottom element) under any function is always the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type  'Œ±', taking the interval 'Ico' from the bottom element '‚ä•' of 'WithBot Œ±' (which is 'Œ±' extended with a bottom element) to an element 'b' is the same as taking all elements strictly less than 'b' in 'Œ±' ('Iio b') and adding an optional 'None' element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": true
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b ‚â† insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven an element 'x' from a type 'p' that can be embedded into another type 'M' where negation is defined, prove that negating 'x' within 'p' and then considering it as an element of 'M' is the same as negating 'x' directly in 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": true
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : ùïÜ) : ((-x : ùïÜ) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x r : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : ùïÑ) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) ‚â† -x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x a : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x y : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : ùïã) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : ùïé) : ((-x : ùïé) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x l : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_neg (x : ùïÑ) : ((-x : ùïÑ) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x b : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : Œ≤) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x i : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : ‚Ñö) : ((-x : ‚Ñö) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x m : p) : M) = -x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is strictly antitone if and only if the composition of \\(f\\) and the duality function (which reverses the order of its input) is strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": true
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the identity transformation on a vector space V is equal to 1, given that there exists a vector in V whose norm is non-zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": true
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 10) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x z : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x g : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ = 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 68 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x h : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x i : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 37) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 40) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x y : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x m : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 58) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x s : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is strictly convex for any vector space E over a field ùïú.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": true
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the interpretation function to the sum of two derivations is the same as summing the interpretations of the individual derivations.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": true
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) ‚â† D1 + D2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lf_moveRight {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a', 'b', and 'c', where 'a' is not infinity, if 'b' plus 'a' is less than or equal to 'c' plus 'a', then 'b' is less than or equal to 'c'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": true
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a = ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_lt_3141593 : œÄ < 3.141593 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer 'n', if a real number 'a' lies within the interval from 'n' (inclusive) to 'n+1' (exclusive), then the floor of 'a' is equal to 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": true
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 34), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 43), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n w : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : Œ≤) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 11), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n y : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : ùïå) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 57), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n l : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : ùïè) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n r : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 56), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given two linear transformations, \\(f\\) and \\(g\\), from a module \\(M\\) to a module \\(M‚ÇÇ\\) (over some ring with scalars denoted by œÉ‚ÇÅ‚ÇÇ), applying the pointwise difference of these linear transformations, (f - g), to an element is the same as applying \\(f\\) and \\(g\\) separately to the element and then taking the difference in \\(M‚ÇÇ\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": true
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) ‚â† f - g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set considered as a subset of itself only has one element (or is empty), then the set itself only has one element (or is empty).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": true
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have two sets, M‚ÇÅ and M‚ÇÇ, and a special function 'e' that establishes a one-to-one correspondence between the elements of M‚ÇÅ and M‚ÇÇ while preserving their structure. This function 'e' also ensures that the operations on corresponding elements in both sets yield corresponding results.  Given any two elements 'x' and 'y' from the set M‚ÇÅ, prove that applying the function 'e' to the sum of 'x' and 'y' is the same as applying 'e' to 'x' and 'y' individually and then adding the results in M‚ÇÇ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": true
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y e : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : ‚Ñù) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y l : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) ‚â† e x + e y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : ‚Ñö) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y k : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y b : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : ùïÑ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : Œ±) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : Œ≤) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y n : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : ‚Ñï) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y x : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set H is a complement of a set K, then H and K are disjoint (i.e., they have no elements in common).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": true
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a nonzero rational number \\(q\\) and a prime number \\(p\\), the p-adic norm of \\(q\\) does not converge to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": true
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 5) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq a : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq k : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 32) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q = 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 17) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq n : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq b : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 33) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq t : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq d : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq q : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers n and m, if n and m are both odd, then their product n * m is also odd.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": true
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 22 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 ‚â† 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 25 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 47 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 37 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 ‚â† 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 7 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 25 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 98 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 51 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that accessing the value stored within the \"punit product\" data structure is the same as simply taking the second element of a pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": true
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) ‚â† Prod.snd :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem divp_mul_cancel (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero integer \\( z \\), its absolute value is greater than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": true
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 33 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ v : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 46 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z = 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 34) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 51 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ t : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ z : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 55 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ x : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ o : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 86) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 40 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative number x, the logarithm of x is less than or equal to 0 if and only if x is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": true
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 72 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 62 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 71 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 13 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 26 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 71 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 87 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 72 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 65 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a period 'p' and two points 'a' and 'b', prove that the function 'toIcoDiv' which determines the number of periods 'p' we need to shift 'a' to reach 'b' is equivalent to taking the floor of (b - a) / p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": true
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b ‚â† ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ùîπ) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ùïã) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ‚Ñ§) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ùïÄ) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ùïç) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ùïÑ) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ùïê) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : ‚Ñï) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there are two additive monoid homomorphisms, `f` and `g`, from additive monoid `A` to additive monoid `B`, and if `f` and `g` are equal as functions, then `f` and `g` are equal as additive monoid homomorphisms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": true
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g c : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f m : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f e : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g w : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) ‚â† (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f p : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g v : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f l : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f b : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g n : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g k : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set is almost everywhere true in the product measure if it is almost everywhere true in each component measure.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": true
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i ‚â†> (Œº i).ae :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that if we have a type `C` which represents some mathematical group, then looking at `C` as just a type is the same as the original `C`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": true
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C l : Type u) = C :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C m : Type u) = C :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) ‚â† C :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C e : Type u) = C :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C x : Type u) = C :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C g : Type u) = C :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C z : Type u) = C :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a subobject Y of an object X in a category C is \"simple\" if and only if it is an \"atom.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": true
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y z : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y r : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : ùïê) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y h : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y l : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y c : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : Œ±) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y w : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y n : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : ùïè) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y a : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : √ó) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set Œ± has at least three elements, then its alternating group is nontrivial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": true
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 21 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 44 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 77 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 26 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 83 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 40 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 79 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 39 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a collection of things (we'll call this collection \"A\") and each thing in this collection is associated with a certain value (we'll call these values \"R\"). Now, imagine you have a specific thing 'a' from your collection 'A' and a specific value 'r' from your values 'R'. This theorem states that the value 'r' is NOT associated with the thing 'a' if and only if the difference between 'r' and the value associated with 'a' has a multiplicative inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": true
      },
      {
        "response": "theorem not_mem_iff {r : R} {a s : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a f : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a l : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a d : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a h : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a v : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a w : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any additive subgroup S of a module M, the canonical map from M to the quotient module M/S (where elements are cosets of S) is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": true
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a finite set 's', and two elements 'u' and 'v', compressing 's' by replacing 'u' with 'v' doesn't change the number of elements in the set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": true
      },
      {
        "response": "theorem card_compression (u v : Œ≤) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card ‚â† s.card :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s h : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_compression (u v : ‚Ñï) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s i : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s l : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_compression (u v : ùïå) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s y : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s u : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_compression (u v : ùïé) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem card_compression (u v : ùïÄ) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s r : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three integers a, b, and c, the statement \"a + b = c\" is equivalent to the statement \"b + a = c\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": true
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any element `x`, a binary function `f`, an accumulator `b`, and a list `v`, applying `scanl` to the list starting with `x` followed by `v` is equivalent to prepending `b` to the result of applying `scanl` to `v` with the accumulator updated by applying `f` to `b` and `x`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": true
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : ùïÑ) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) ‚â† b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem scanl_cons (x : ‚Ñï) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : ùïç) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem scanl_cons (x : ‚Ñù) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : ùïÄ) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem scanl_cons (x : ‚Ñí) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : ùïÜ) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : ùïä) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : ùïã) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `f` iteratively to an initial value `b` over an empty sequence results in the value `b` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": true
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 51 = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 ‚â† b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 58 = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 76 = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 84 = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 54 = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 36 = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven three sets A, B, and C, and two functions, \\(f\\) from A to B and \\(g\\) from B to C, if the composition of \\(g\\) and \\(f\\) (applying \\(f\\) first and then \\(g\\)) has the property that its output is \"finite\" when applied to elements from A, then the function \\(g\\) itself also has this \"finite\" property.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": true
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g d : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g m : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g x : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g q : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g i : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g z : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g j : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g t : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g v : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a function called \"compress\" that potentially modifies an input 'a' based on two other inputs 'u'.  We want to prove that if the two 'u' inputs are the same, then the \"compress\" function doesn't change the input 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": true
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem compress_self (u a : Œ≤) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : ùïé) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem compress_self (u a : ‚Ñö) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : √ó) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : ‚Ñ§) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : ‚Ñí) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : ‚Ñï) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem compress_self (u a : ùïÄ) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : ùïÜ) : compress u u a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set \\(I\\) with elements from a set \\(P\\), where the elements of \\(P\\) have a notion of order (we can say one element is less than or equal to another), if  \\(x\\) is less than or equal to \\(y\\) and \\(x\\) is not in the set \\(I\\), then \\(y\\) is also not in the set \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": true
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I c : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I s : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I k : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I g : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I f : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I i : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I u : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I t : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I h : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any graph, an empty walk starting and ending at a vertex 'u' is considered a path.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": true
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil g : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil t : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil r : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil o : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil f : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil x : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil q : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil a : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil v : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any ring \\(R\\) and algebra \\(A\\) over \\(R\\), the image of any element \\(r\\) of \\(R\\) under the algebra map lies in the center of \\(A\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": true
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_div (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ‚Ñù) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : Œ≤) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ‚Ñ§) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ùïÜ) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ùïç) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ùïé) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ‚Ñï) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ùïä) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : ùîπ) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a sequence 'u' of elements (of the same type), prove that the least upper bound of the entire sequence is the same as the least upper bound of the first element 'u 0' and the least upper bounds of all the remaining elements (from 'u 1' onwards).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": true
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 57)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) ‚â† ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 51)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 30 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 66)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 15)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 81)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 38)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 64 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 56)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 70)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 5 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a special kind of number system where we introduce a new component alongside our familiar integers. In this system, a number is represented as a pair: an integer and a multiple of the square root of a fixed integer \"d\".  We can write this as (a, b‚àöd) where 'a' and 'b' are integers. \n\nThis theorem focuses on multiplying such numbers. Suppose we have:\n\n* A regular integer 'n'\n* A number from our new system represented as (n, 0), essentially 'n' embedded in our new system. \n* Another number from our new system represented as (x, y‚àöd)\n\nThe theorem states that multiplying these three together, i.e.,  ‚àöd * (n, 0) * (x, y‚àöd), results in the number (d * n * y, n * x) in our new system.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": true
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n y : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n x : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n b : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ùîπ) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© ‚â† ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n d : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n z : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n a : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ùïÜ) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n r : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n m : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n t : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñï) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñù) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there's no common element between list l‚ÇÅ and list l‚ÇÇ, then there's also no common element between list l‚ÇÇ and list l‚ÇÅ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": true
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number n, if we first find the predecessor of n (the number before n) and then take the successor of the result (the number after the predecessor), we get back n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": true
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any continuous function \\( f \\) from \\( \\alpha \\) to \\( \\beta \\) and any positive real number \\( \\epsilon \\), the modulus of continuity of \\( f \\) at \\( \\epsilon \\) is positive.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": true
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 16 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h b : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 46 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 79 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h n : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h m : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h y : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h d : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 60 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h j : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h k : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h a : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h w : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomial 'p' and a natural number 'n', if the coefficient of the term with degree 'n' in the polynomial 'p' is not zero, then 'n' is less than or equal to the degree of 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": true
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 28) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n = 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n i : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 68) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n h : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 91) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 32) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n g : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 56) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 35) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n v : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n t : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 82) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n b : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which calculates the shortest distance from a point to a set is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": true
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_iSup‚ÇÇ_iff {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a language \\(L\\), prove that the language formed by taking the union of the empty string with the concatenation of \\(L\\) and \\(L^*\\) is equal to \\(L^*\\).  Here, \\(L^*\\) denotes the Kleene star of \\(L\\), which is the set of all strings formed by concatenating zero or more strings from \\(L\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": true
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 78 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó ‚â† l‚àó :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 35 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 50 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 96 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 75 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 81 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 3 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the linear map induced by the sum of two derivations is equal to the sum of the linear maps induced by each derivation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": true
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 b : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 o : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) ‚â† (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 w : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 a : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 m : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 n : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) in the space of p-integrable functions (\\( L^p \\) space) with real values, taking the positive part of \\( f \\) is essentially equal (equal almost everywhere) to taking the maximum of \\( f \\) and 0 pointwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": true
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 53 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) ‚â†·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 47 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a ‚â†> max (f a) 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 43 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 75 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 82 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 46 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero real number \\( a \\) and any polynomial \\( p(x) \\) with real coefficients, the roots of the polynomial \\( a \\cdot p(x) \\) are the same as the roots of \\( p(x) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": true
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 70) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha w : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_C_mul (p : √ó) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a = 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 13) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem roots_C_mul (p : ùïè) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha i : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_C_mul (p : ùïç) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 39) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 95) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha k : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_C_mul (p : ùïê) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots ‚â† p.roots :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 35) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine of an angle obtained by adding œÄ (pi) to any even multiple of œÄ is always equal to -1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": true
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (82 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ùïè) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : Œ≤) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (52 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) ‚â† -1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -91 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ùïÄ) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñö) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -46 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ùïé) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -81 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ùïä) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (55 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the open interval (a, b) is a subset of the closed interval [a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": true
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a scenario where we have a way to transform objects, and also a way to transform functions between those objects. We want to show that transforming a function that's been \"scaled up\" by a natural number is the same as scaling up the transformed version of the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": true
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) ‚â† n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n j : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f l : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f g : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n q : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f s : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) and \\( g \\) be functions. Prove that  \\( f \\) is asymptotically bounded above by  \\( g \\) (within a constant factor) with respect to filter \\( map \\, k \\, l \\) if and only if the composition of \\( f \\) and \\( k \\) is asymptotically bounded above by the composition of \\( g \\) and \\( k \\) with respect to filter \\( l \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": true
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l v : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f ‚â†O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l i : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) ‚â†O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l q : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l f : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l x : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l n : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l b : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l c : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l o : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\( f' \\) and \\( f \\), and a set \\( t \\). If \\( f' \\) is a right inverse of \\( f \\) on the set \\( t \\), then the composition of \\( f \\) and \\( f' \\) acts like the identity function on \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": true
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lt_map {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the absolute value function is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": true
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set has exactly one element if and only if it has at most one element and is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": true
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 97 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 16 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 60 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± ‚â† 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 50 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 27 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 42 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 40 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 15 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(s\\) is a lower set and non-empty, then it is not bounded below.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": true
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) belongs to the union of two sets \\(p\\) and \\(p'\\) if and only if \\(x\\) can be expressed as the sum of an element \\(y\\) from \\(p\\) and an element \\(z\\) from \\(p'\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": true
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers 'a' and 'b', 'a' divides 'b' if and only if there exists an integer 'c' such that 'b' is equal to 'c' multiplied by 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": true
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b ‚â† c * a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we are performing repeated multiplications by a number 'x'. The 'order' of 'x' is the smallest power to which we need to raise 'x' to get 1. Given that raising 'x' to the power of 'p' results in 1 (where 'p' is a prime number) and that 'x' itself is not equal to 1, prove that the order of 'x' is equal to 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": true
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 84) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ (p-5) = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 y : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x = 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p ‚â† 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 62) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ (p-3) = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 f : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg ùíú x).deg = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x ‚â† p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 23) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ (p+5) = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 i : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ (p+4) = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a specific operation, denoted as \"toIdeal\", to the result of combining two mathematical structures, represented by \"I\" and \"J\", is equivalent to combining the results of applying the same \"toIdeal\" operation to \"I\" and \"J\" individually.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": true
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal ‚â† I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite measure `Œº` on a set `Œ©`, the total mass of `Œº` is equal to the measure of the entire set `Œ©`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": true
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•16‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•98‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass c : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ùïê) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) ‚â† (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•30‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ùîπ) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass v : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•13‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ùïÑ) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•18‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•39‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass b : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•62‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets 's' and 't' that are both closed under multiplication and contain 1 (submonoids), prove that a number 'x' belongs to the set 's ‚äî t' (the smallest set containing both 's' and 't' and closed under multiplication) if and only if 'x' can be represented as the product of two numbers 'y' and 'z', where 'y' belongs to 's' and 'z' belongs to 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": true
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x i : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x f : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x g : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x h : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_infty_eq : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x y : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x u : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x o : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of the set difference of x and y and the set difference of y and x is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(M\\) be a module over a ring \\(R\\). Prove that an element \\(x\\) of \\(M\\) is in the torsion submodule of \\(M\\) if and only if there exists a non-zero element \\(a\\) of \\(R\\) such that \\(a\\) multiplied by \\(x\\) is equal to the zero element of \\(M\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": true
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 54 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a t : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_torsion_iff (x : ùïç) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a v : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 33 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_torsion_iff (x : ùïå) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a n : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_torsion_iff (x : ùïÑ) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 35 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 72 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_torsion_iff (x : √ó) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set 's' of ordered pairs, swapping the components of the least upper bound of 's' is the same as taking the least upper bound of the set obtained by swapping the components of each pair in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": true
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap ‚â† sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a' and any integer 'n', (1/a) raised to the power of 'n' is equal to 1 divided by 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": true
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (81 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ (n-1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n q : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñö) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n ‚â† 1 / a ^ n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (13 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ (n-3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n k : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : Œ±) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n d : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (63 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ (n-4) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n h : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_div_zpow (a : ‚Ñ§) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ (n+3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ (n+5) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem one_div_zpow (a : Œ±) (n : Œ≤) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set  's', converting the upper closure of 's' to a set is equivalent to the union of all upper sets of elements in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": true
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) ‚â† ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y ‚Üî x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a polynomial with coefficients from a set 'R' and variables represented by elements of a set 'œÉ'.  This problem focuses on a specific type of polynomial called a monomial, which is a polynomial with only one term.  The monomial in question is represented by  'X i', where 'X' signifies the variable part and 'i' is an element from the set 'œÉ' indicating a specific variable.  We divide this monomial by another monomial that has a coefficient of 1 and the same variable 'i'. The theorem states that the result of this division is always 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": true
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 58 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i s : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : ùïÑ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 37 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 51 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i r : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i x : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : ùïä) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 91 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 24 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i d : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i h : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_divMonomial (i : ùïç) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 6 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'I' from a set 'H' to a set 'E', prove that the target set of 'I' is equal to the range of 'I'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": true
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I x : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target = range (I e : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target ‚â† range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem target_eq : I.target = range (I q : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I f : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target = range (I i : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I s : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target = range (I d : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I k : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I j : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' mapping elements from a set Œ± to a set Œ≤, applying 'f' to the zero measure on Œ± results in the zero measure on Œ≤.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": true
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (67 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 m : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 s : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (46 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (62 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 v : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 a : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (61 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 z : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (18 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 d : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 b : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a convex cone S is flat, then it is also pointed.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": true
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : ‚Ñí) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : ùïå) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS d : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : ‚Ñ§) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS s : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS e : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS c : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS v : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS w : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : ùïÄ) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : ‚Ñö) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS q : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : ùïé) : S.Pointed :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two functions, \\( f \\) and \\( g \\), which map elements from a set \\( M \\) to a set \\( N \\) (potentially with some structure \\( L \\)), are equal if and only if they produce the same output for every input from \\( M \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": true
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f ‚â† g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x ‚â† g x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given an equivalence between two categories C and D, represented by 'E', the inverse of the functor associated with 'E' is the same as the inverse function provided by the equivalence 'E'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": true
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv ‚â† E.inverse :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if  \\( a‚ÇÅ ‚â§ a‚ÇÇ \\), then the closed interval from \\( a‚ÇÇ \\) to \\( b \\) is a subset of the closed interval from \\( a‚ÇÅ \\) to \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": true
      },
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem clog_inv (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\(n\\), raising the identity linear map to the power of \\(n\\) results in the identity linear map itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": true
      },
      {
        "response": "theorem id_pow (n : √ó) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id e : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id j : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_pow (n : ùïè) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n ‚â† id :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ùïé) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id r : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_pow (n : ‚Ñù) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id i : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id a : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id d : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id b : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_pow (n : ùïê) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_pow (n : ‚Ñ§) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ùïä) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any graph homomorphism from the complete graph (where all vertices are connected) to any other graph must be injective, meaning it doesn't map distinct vertices to the same vertex.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": true
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there exists an embedding from a given space X to the space of bounded real-valued sequences.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": true
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f p : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f m : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f k : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f c : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f e : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f n : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f l : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f o : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f x : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f h : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a space called \"M,\" and within this space, we have a specific region marked as \"p.\" This region \"p\" follows the rules of being a \"Submodule,\" meaning it's like a smaller version of the bigger space \"M,\" maintaining similar properties.  Prove that this region \"p\" completely fills the entire space \"M\" if and only if every single point from \"M\" is contained within \"p.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": true
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p ‚â† ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_val_iff {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' is not empty and there is an operation that maps each element in 's' to another element in 's' such that applying the operation twice returns the original element, then the set 's' with this operation is also not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": true
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : ùïÑ) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h x : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h g : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : ‚Ñ§) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h l : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h o : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h f : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h s : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : ùïê) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h m : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h k : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : ùïÜ) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h z : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : ùïé) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h q : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', where 'b' is not infinity, if we add 'b' to 'a' and then subtract 'b', the result is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": true
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b = ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity linear map is symmetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": true
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id f : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id i : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id u : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id o : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id a : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id s : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id t : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id h : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id w : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id r : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id c : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\(x\\), raising \\(x\\) to the real number power 2 is the same as raising \\(x\\) to the natural number power 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": true
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (58 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 3 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 h : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_two (x : √ó) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) ‚â† x ^ 2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (51 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù-4) = x ^ 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 v : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_two (x : ùïã) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ùîπ) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (52 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ (-2) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 r : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_two (x : Œ≤) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (16 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 1 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 j : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that takes an outer measure and a set, and returns the measure of the set, is injective. In simpler terms, if two outer measures agree on the measure of every set, then the two outer measures are the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": true
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) ‚â†> Œº s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s g : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s j : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s c : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s x : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s h : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot ‚Üí f.NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s n : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` attains its maximum at `a` over its entire domain if and only if for all `x`, `f(x)` is less than or equal to `f(a)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": true
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nConsider a function 'f' that takes an element from a set 'R' and returns a multivariate polynomial (a polynomial with multiple variables) with coefficients in a set 'S'. Let 'C' be a function that takes an element from set 'R' and creates a constant multivariate polynomial. This theorem states that applying 'f' to a constant multivariate polynomial generated from an element 'r' of 'R' is the same as applying 'f' directly to 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": true
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r d : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) ‚â† f r :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r z : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : Œ≤) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r h : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : ‚Ñö) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r l : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : ùîπ) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : ùïã) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r t : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r x : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : ùïå) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : ‚Ñ§) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : ùïÑ) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any submodule K of a vector space E over a field ùïú is star-convex with respect to the zero vector in E.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": true
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (69 : E) K :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 p : E) K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 z : E) K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : ùïç) K :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : ùïã) K :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (90 : E) K :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 s : E) K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : ‚Ñù) K :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (81 : E) K :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (16 : E) K :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : ùïÄ) K :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 h : E) K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : ùïè) K :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (10 : E) K :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (36 : E) K :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 r : E) K :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the distance between a point 'x' and a point 'y' is less than the shortest distance from the point 'x' to a set 's', then the point 'y' cannot be in the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": true
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' from a ring 'R', if we map 'x' to the fractional ideal generated by 1 over a subring 'S', then this mapped element belongs to the fractional ideal generated by 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": true
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (16 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (24 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 q : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem_one (x : ùïã) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (92 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mem_one (x : ‚Ñí) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 w : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem_one (x : ‚Ñù) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_mem_one (x : ùïÄ) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : ùïä) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 s : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 a : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_mem_one (x : ùïÑ) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (50 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (74 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) from a set to the natural numbers, the multiplicative range of \\( f \\) is equal to the set of all natural numbers if and only if \\( f \\) is surjective (onto).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": true
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f ‚â† (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a collection of ideals (special subsets) within a set S, indexed by a set Œπ. The problem at hand is to prove that taking the preimage of the intersection of all these ideals under a function 'f' is equivalent to taking the intersection of the preimages of each individual ideal under the same function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": true
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f ‚â† ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative integer \\( z \\), applying the `normalize` function to it results in the same integer \\( z \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": true
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 51 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 19 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h t : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h q : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z ‚â† z :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 35 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 16 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h s : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 91 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 59 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h n : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h j : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that Aleph-null (‚Ñµ‚ÇÄ), the cardinality of the set of natural numbers, is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 18 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 23 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 30 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 17 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 55 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 47 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 46 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 84 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 89 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem curry_apply (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 28 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 16 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the boundary points of the set of all complex numbers whose real part is less than or equal to a given real number 'a', are precisely those complex numbers whose real part is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": true
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } ‚â† { z | z.re = a } :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z t : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ùïÑ) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re ‚â† a } :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z h : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z o : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ùïÄ) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z x : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñï) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñí) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z m : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ùïê) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a ring homomorphism \\(f\\) to the \\(n\\)-th Witt polynomial \\(W_n\\) doesn't change its value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": true
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n k : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n x : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n l : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : Œ±) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) ‚â† W n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n r : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ùïã) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n b : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ùïå) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n w : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ùïÜ) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n v : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ùïç) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the smallest non-unital subsemiring of any ring R, when viewed as a set, contains only the zero element (0).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": true
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {80} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {44} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) ‚â† {0} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {63} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {69} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {22} :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {16} :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a finite set 's' is equal to the singleton set containing the element 'a' if and only if the underlying set of 's' is equal to the singleton set containing 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": true
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s z : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s ‚â† {a} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s p : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s i : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val ‚â† {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s n : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s q : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s d : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s y : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s g : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s e : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any bounded formula œÜ with at least one free variable, the universal closure of œÜ is not an atomic formula.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": true
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 100)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 84)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 96)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 72)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 68)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 34)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 45)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 53)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 12)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 39)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(Œπ\\) be a set with a locally finite order. Prove that for any element \\(i\\) in \\(Œπ\\), if the successor of \\(i\\) is less than or equal to \\(i\\), then \\(i\\) is the maximum element of \\(Œπ\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": true
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : ‚Ñï) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi k : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : ùîπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi m : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi v : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi q : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : ùïä) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : √ó) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi p : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi c : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : ùïÄ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : ùïè) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi s : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomials p and q with coefficients in a ring R, if q is not monic, then the remainder of the Euclidean division of p by q is equal to p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": true
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q ‚â† p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq d : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq r : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ‚Ñö) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ùïè) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ‚Ñù) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ‚Ñí) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq h : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ùïç) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ùïã) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq s : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ùïä) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ùïÄ) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq k : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq i : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : ùïÑ) (hq : ¬¨Monic q) : p %‚Çò q = p :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine a function 'e' that transforms elements from a set called 'source' to another set called 'target'.  This theorem states that for any property 'p' that applies to elements in the 'target' set, checking if 'p' holds true for all elements in the 'target' set is equivalent to checking if 'p' holds true for every element obtained by applying 'e' to each element in the 'source' set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": true
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a multiset `m` (a set that can have repeated elements) where all elements of `m` belong to another set `S`. Prove that the sum of all elements in `m` also belongs to the set `S`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": true
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h k : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h m : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h u : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sup {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h e : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h o : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h t : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h s : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nnabs_of_nonneg {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h c : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h p : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h n : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h d : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h i : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that evaluating a program `c` with input `v` on a Turing machine, by repeatedly applying the transition function `tr`, results in the same output as evaluating `c` with input `v` directly using the `Code.eval` function, and then halting the machine.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": true
      },
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) ‚â† halt <$> Code.eval c v :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set \\(s_1\\), the set difference of \\(s_1\\) and itself is the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that \\( \\omega \\), an infinitely large number, is positive.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": true
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( J \\) is in the subset of \\( \\pi \\) filtered by property \\( p \\) if and only if \\( J \\) is an element of \\( \\pi \\) and \\( J \\) satisfies the property \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": true
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider collections of sets with some special properties. These collections are called \"SetSemirings.\"  We can think of \"down s\" as the set of all subsets that can be formed from the elements present in set 's'.  Given two such collections, 's' and 't', prove that all subsets within 's' are also found within 't' if and only if 's' is a strictly smaller collection than 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": true
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `toDualEquiv` to an element `m` of type `M` is equivalent to applying the function `toDual` to the same element `m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": true
      },
      {
        "response": "theorem toDualEquiv_apply (m : Œ≤) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ùîπ) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ‚Ñï) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m ‚â† b.toDual m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ùïã) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ‚Ñù) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ‚Ñ§) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ‚Ñí) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDualEquiv_apply (m : ùïÄ) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `join` which takes a list of lists and flattens it into a single list is primitive recursive.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": true
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a group G, and within this group, we have two subgroups S and T. We denote the set of inverses of elements in S as S‚Åª¬π and the set of inverses of elements in T as T‚Åª¬π. Prove that S is a subset of T if and only if S‚Åª¬π is a subset of T‚Åª¬π.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": true
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we convert a prime number \\(p\\) to a multiset of positive natural numbers, the resulting multiset will contain only one element, which is the prime number \\(p\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": true
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) ‚â† {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p d : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñí)} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p v : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p y : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ùïê)} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ùïÜ)} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : ‚Ñù) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p x : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coePNat_ofPrime (p : ùïé) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ùïä)} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p q : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any cardinal numbers 'a' and 'b', if 'b' is not equal to 0, then 'a' is less than or equal to the product of 'a' and 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": true
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 86) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h g : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b = 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 38) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h u : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h l : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h b : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 17) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h q : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 95) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 61) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any object \\(X\\) in a category \\(C\\), the idempotent associated with \\(X\\) in the Karoubi envelope of \\(C\\) is equal to the identity morphism on \\(X\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": true
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = 2 X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_p (X : ùîπ) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_p (X : C) : (X r : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_p (X : ‚Ñï) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p ‚â† ùüô X :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = 99 X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = 82 X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_p (X : ùïè) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_p (X : ùïä) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = 69 X :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_p (X : Œ±) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_p (X : C) : (X s : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_p (X : ùïå) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_p (X : ùïç) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X o : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set Œ±, the function `pure`, which maps each element of Œ± to its corresponding principal ultrafilter, has a dense image in the space of ultrafilters on Œ± equipped with the topology where all sets are open (the discrete topology).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": true
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure c : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure h : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure w : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure u : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure n : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure m : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure e : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure d : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set formed by partitioning 'a' into non-overlapping subsets is non-empty if and only if the original set 'a' is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a = ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a strictly ordered set, the set of all elements less than 'a' is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": true
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b h : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b s : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ≤) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isOpen_gt' (a : ùïÑ) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b o : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : ‚Ñí) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b d : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : ùïé) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b y : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : ùïä) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b j : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_gt' (a : ùïÜ) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : ùïè) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sum of the k-th powers of the divisors of a natural number n is equal to the result of applying the function œÉ (sigma) with arguments k and n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": true
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n ‚â† ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k+4) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k+1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k-1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k+2) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k-5) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k-4) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k+3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ (k-3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Fibonacci sequence, starting from the third term (fib(2)), is strictly increasing.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": true
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 81) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 98) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 39) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n ‚â†> fib (n + 2) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 85) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 45) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 5) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 67) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 73) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets A and B that are balanced over a field ùïú (meaning that scaling any element of the set by a scalar from ùïú still results in an element within the set), prove that their intersection, A ‚à© B, is also balanced over ùïú.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": true
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB n : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB e : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB p : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB h : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB d : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_add_int_mul_pi (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB k : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB o : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB y : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB b : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any given Turing machine M, if we translate it into another Turing machine `tr M`, then every step taken by M can be mirrored by a corresponding step in `tr M` while preserving a specific relationship between their configurations.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": true
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any submodule 's' of a module 'M' over a ring 'R', the rank of 's' is less than or equal to the rank of 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": true
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the infimum of the empty set, considered as a subset of non-negative real numbers, is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": true
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•96) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•54) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•93) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•26) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•41) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•82) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•81) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•86) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•80) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•27) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that takes the positive part of a function in \\(L^p\\) space is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": true
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f t : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº ‚â†> posPart f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f h : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f z : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f l : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f m : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f v : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f o : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we swap a pair of elements twice, we get back the original pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": true
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left ‚â† right :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements 'a' and 'b' in a type that can be either a value from a set 'Œ±' or a special element called \"bottom\" (‚ä•),  'a' is strictly less than 'b' if and only if 'b' is a value from the set 'Œ±' and there exists a value 'p' in 'Œ±' such that 'b' is equal to 'p' and 'a' is strictly less than 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": true
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b ‚â†> by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p j : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p f : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• ‚â†> iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b k : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b ‚â† p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b e : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p o : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(L\\) be a Lie algebra over a ring \\(R\\), and let \\(s\\) be a subset of \\(L\\). Prove that an element \\(x\\) belongs to the Lie span of \\(s\\) if and only if \\(x\\) belongs to every Lie subalgebra of \\(L\\) that contains \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": true
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K r : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K e : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K s : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K o : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K d : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K q : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K x : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K k : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K y : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of any number of ones is equal to one.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": true
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (78 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 e : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : ‚Ñí) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (92 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 v : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 q : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 m : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (50 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : ùïé) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 i : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤) = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (16 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (36 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a function 'f' from a set 'Œ±' to a normed space 'F', and a measure 'Œº', the set of points 'y' in 'Œ±' where the essential supremum norm of 'f' is strictly less than the norm of 'f(y)' has measure zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": true
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 89 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 93 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 86 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 92 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_inj {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `Fin.val` which converts a natural number less than `n` to its corresponding natural number representation, is injective. In other words, prove that different `Fin n` values always correspond to different natural numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": true
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any property \\( p \\) defined on a computable set \\( \\alpha \\) is one-to-one reducible to itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": true
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in an empty graph, no two vertices are adjacent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": true
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : ‚Ñï) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : Œ≤) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : √ó) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : ùïã) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : ùïå) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : Œ±) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : ùïÜ) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem psub_eq_some {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : ‚Ñù) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : ùïÑ) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_adj (v w : ‚Ñö) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real part of the product of two quaternions is equal to the sum of the products of their corresponding components, subtracting the products of the imaginary components.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": true
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re ‚â† a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of a simple graph G is equivalent to a graph obtained by deleting all the edges of G from a complete graph on the same vertex set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": true
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú ‚â† (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sSup_eq_iSup' (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the negation of a self-adjoint element is also self-adjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": true
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx r : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a ‚Üî a = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx l : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg {x : R} (hx y : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx e : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg {x : R} (hx j : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg {x : R} (hx c : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg {x : R} (hx f : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Witt vector with its first component being 1 and all other components being 0 is equal to the zero vector in the ring of Witt vectors, for any prime number \\(p\\) and any positive integer \\(n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": true
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 40 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn d : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn t : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ùïã) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 68 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn q : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ùîπ) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : Œ≤) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 100 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñù) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn m : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn b : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 47 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_nat (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 98 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `f` to arguments `i` and `j` directly is the same as first transforming `f` using a function called `of` and then applying it to the same arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": true
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j ‚â† f i j :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a finite-dimensional vector space and an affine basis for it, then the set indexing the basis vectors is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=",
        "label": true
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two pairs of elements,  (x‚ÇÅ, y‚ÇÅ) and (x‚ÇÇ, y‚ÇÇ), where x‚ÇÅ and x‚ÇÇ belong to a set Œ±, and y‚ÇÅ and y‚ÇÇ belong to a set Œ≤, prove that (x‚ÇÅ, y‚ÇÅ) is less than or equal to (x‚ÇÇ, y‚ÇÇ) if and only if x‚ÇÅ is less than or equal to x‚ÇÇ and y‚ÇÅ is less than or equal to y‚ÇÇ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": true
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ v : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ f : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ t : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ j : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ e : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ h : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ y : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f_1 \\), \\( f_2 \\) be collections of subsets of a set \\( Œ± \\) and \\( g \\) be a collection of subsets of a set \\( Œ≤ \\).  Suppose that \\( f_1 \\) is a \"smaller\" collection than \\( f_2 \\) in the sense that every subset in \\( f_1 \\) is also in \\( f_2 \\). Prove that the collection of all Cartesian products of sets in  \\( f_1 \\) and \\( g \\) is \"smaller\" than the collection of all Cartesian products of sets in \\( f_2 \\) and \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": true
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem BddBelow.mono ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ b : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ k : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf a : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ l : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf k : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_associated_iff {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf j : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ m : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing an element 'a' from a finite set 's' results in an empty set if and only if the original set 's' was either empty or contained only the element 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": true
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s ‚â† {a} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a n : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ≤) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a d : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a ‚â† ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a s : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a l : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : ùïé) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s ‚â† ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : √ó) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a z : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : ùïå) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a p : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : ùïÑ) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : ‚Ñö) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the closure of the union of two sets \\( s \\) and \\( t \\) in the real numbers \\( \\mathbb{R} \\) is equal to the union of the closure of \\( s \\) and the closure of \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=",
        "label": true
      },
      {
        "response": "theorem closure_union (s t : Set R) : closure (s ‚à™ t) ‚â† closure s ‚äî closure t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a group, taking the inverse of the inverse of an element always gives back the original element. In other words, prove that the inverse operation is its own left inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a o : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a j : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a q : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a g : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a y : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a c : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a m : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a u : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a l : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a i : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a b : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that scaling a sphere by a constant factor results in a new sphere centered at the scaled center and with a radius scaled by the same factor.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": true
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x o : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r m : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : ‚Ñö) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r ‚â† sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r j : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñí) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : ùïé) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r d : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : ùïä) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r q : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : ‚Ñ§) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x e : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ùîπ) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a box within a box within another box. This is like having three levels of nested boxes.  We can either unpack the outermost box first and then unpack the box we find inside, or we can directly unpack all the way to the innermost box. This theorem states that these two ways of unpacking lead to the same result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": true
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a c : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) ‚â† joinM (joinM a) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a o : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a d : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a b : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the topological support of the normalized version of function f with respect to measure Œº is equal to the closed ball centered at c with radius f.rOut.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": true
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) ‚â† Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `f` to each element of a multiset `s` and collecting the results into a new multiset is the same as creating a new multiset by individually applying `f` to each element of `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": true
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x ‚â†> ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_self {a : R} (a0 : a ‚â† 0) : a / a = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) ‚â† map f s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any multiset 's', taking the disjoint sum of 's' with an empty multiset is equivalent to mapping each element in 's' to its corresponding element in the disjoint union of the underlying types.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": true
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (4 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 e : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 j : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) ‚â† s.map inl :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 v : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (53 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 r : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 y : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (14 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (62 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (32 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 l : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 w : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (74 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 ‚Üî Disjoint s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (24 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( t \\), the expression \\( 2t - 1 \\) lies within the open interval \\( I \\) (equivalent to  \\( -1 < 2t - 1 < 1 \\) ) if and only if \\( t \\) belongs to the closed interval \\( [\\frac{1}{2}, 1] \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": true
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 57 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 q : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñ§) 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 w : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 4 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 41 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 s : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : Œ±) 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 a : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 31 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 78 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 c : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ùïç) 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 15 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a group of people, and we're interested in subgroups within this larger group.  If we have two subgroups, G' and G'', where G' is a subset of G'', and we further restrict both subgroups to only include people who share a certain characteristic 's', then the restricted version of G' will still be a subgroup of the restricted version of G''.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": true
      },
      {
        "response": "theorem map_strictMono (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd Œ± Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a relation 'R' and two elements 'a' and 'b', applying the 'destutter'' function with relation 'R' to 'a' will result in: a list containing both 'a' and 'b' if 'R' holds true for 'a' and 'b', and a list containing only 'a' if 'R' does not hold true for 'a' and 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": true
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a ‚â† if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictConvex_empty : StrictConvex ùïú (‚àÖ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have two boxes, each containing some items. There's a specific rule (R) that might hold between pairs of items from the first box, and another rule (P) that might hold between pairs of items from the second box. \n\nNow, suppose we have a magic function that can transform any item from the first box into a smaller box of items for the second box. \n\nWe want to prove the following: If \n1) every pair of items satisfying rule R in the first box will, after being transformed, result in a pair of smaller boxes where all corresponding items satisfy rule P, and\n2) all the items within each smaller box satisfy rule P, \nthen applying the transformation to all items in the first box will result in a larger combined box where all items satisfy rule P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": true
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval of elements in `WithBot Œ±` that are greater than or equal to the bottom element (denoted by ‚ä•) and less than `b` is equivalent to the interval of elements in `Œ±` that are less than `b`, with each element being mapped to its corresponding element in `WithBot Œ±`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": true
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b ‚â† (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(s\\) is not empty, then its inverse, denoted by \\(s^{-1}\\), is also not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": true
      },
      {
        "response": "theorem Nonempty.inv (h : ùïè) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.inv (h : ùïç) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : Œ≤) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.inv (h : ùïê) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : √ó) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : ‚Ñö) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.inv (h : ‚Ñí) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : ‚Ñï) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nonempty.inv (h : ùïä) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem essSup_le_of_ae_le {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'g' in a finite group 'G',  raising 'g' to the power of a natural number 'n' is equivalent to raising 'g' to the power of the remainder when 'n' is divided by the order of the group 'G'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": true
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n ‚â† g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ (n+2) = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g j : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : ‚Ñí) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ (n+1) = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G-3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g f : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G-1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g i : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : ‚Ñö) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : ùïç) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : ‚Ñù) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) and \\( g \\) be two functions. Given that \\( f \\) is integrable (with respect to some measure \\( \\mu \\)) and that \\( f \\) and \\( g \\) are equal almost everywhere (with respect to the same measure \\( \\mu \\)), prove that \\( g \\) is also integrable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": true
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h g : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h d : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf d : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f ‚â†·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf e : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h s : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h j : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf s : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf w : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf p : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_two (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h o : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h i : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a constant value `b` into a constant function is the same as defining a constant function that always returns `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": true
      },
      {
        "response": "theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) ‚â† Function.const Œ± b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_const (b : ‚Ñí) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : ùïè) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_const (b : ùïÄ) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : ‚Ñ§) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : ùïê) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : ‚Ñï) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_const (b : ùïÑ) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_const (b : √ó) : ‚áë(const Œ± b) = Function.const Œ± b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two propositions, P and Q, are complementary if and only if it is not true that P and Q are logically equivalent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": true
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_Ioo (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\), the arcsine of \\( x \\) is greater than 0 if and only if \\( x \\) is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": true
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 67 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 16 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 8 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 55 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 45 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 30 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 98 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 40 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 43 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 65 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 11 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a specific point, denoted as 'x', within a set 'X'. We also have a set 's' which is a subset of a space constructed from 'X' by adding a single new point (denoted as 'OnePoint X'). The theorem aims to prove that the neighborhood of the image of 'x' within the set 's' is equivalent to the image of the neighborhood of 'x' within the preimage of 's', all considered under a specific mapping from 'X' to 'OnePoint X'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": true
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x y : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x v : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint ‚Ñí)) (x : ‚Ñí) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx ‚â† map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x b : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint ùïÜ)) (x : ùïÜ) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint ùïä)) (x : ùïä) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint ùïç)) (x : ùïç) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x p : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint √ó)) (x : √ó) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint ùïã)) (x : ùïã) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x o : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a property 'p' that applies to objects of a certain type and another property 'q' that depends on both an object and whether it satisfies property 'p'. This theorem states that checking property 'q' for every object and its proof of satisfying property 'p' is equivalent to checking 'q' only for objects that are already known to satisfy 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": true
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.22 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x t : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x f : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.46 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.60 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.61 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x a : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.79 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x o : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x w : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.31 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.54 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x p : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.83 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the identity affine isometry to a point leaves the point unchanged.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": true
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id v : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id z : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id s : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_apply (x : ùïä) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : ùïç) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_apply (x : ùïå) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id x : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_apply (x : ùïÑ) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id h : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : ùïê) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_apply (x : Œ±) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id w : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id l : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity function on a set Œ± is continuous if the topology t is finer than the topology t'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": true
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h j : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h u : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h l : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h v : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h e : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h i : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h n : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a given relation \\( R \\), there is a chain between two elements \\( x \\) and \\( y \\) in a list containing only \\( x \\) and \\( y \\) if and only if \\( x \\) is related to \\( y \\) by \\( R \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": true
      },
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve the trigonometric identity: The square of the cosine of an angle is equal to half the sum of 1 and the cosine of twice the angle.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": true
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 5 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_sq : cos x ^ 1 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cos_sq : cos x ^ 5 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 ‚â† 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 41 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_sq : cos x ^ 7 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 93 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_sq : cos x ^ 88 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 93 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_sq : cos x ^ 4 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cos_sq : cos x ^ (-3) = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cos_sq : cos x ^ 3 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem cos_sq : cos x ^ (-1) = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 34 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of an empty set is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : Œ≤) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ùïÑ) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ùïè) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ‚Ñ§) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ùïä) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ùïç) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ‚Ñí) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ùîπ) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ‚Ñï) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ùïã) = ‚àÖ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn any mathematical category (a collection of objects and arrows between them), if a function 'f' from object 'P' to object 'Q' is surjective (meaning it covers every point in 'Q'), then 'f' is also an epimorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": true
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f r : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f w : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f e : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f o : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f x : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b ‚Üí a < b - c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f c : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f t : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f y : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we take a rational number 'q', treat it as an element of a type 'Œ±' that supports casting from rational numbers, then consider this element in the 'opposite' type 'Œ±·µê·µí·µñ', and finally apply the 'unop' operation (which brings the element back from the opposite type), we get back the original rational number 'q'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": true
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) ‚â† q :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñí) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q i : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : ùïè) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : Œ±) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q z : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q s : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñù) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q t : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ùïé) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q h : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : ùïÜ) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q p : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ùïè) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two potentially infinite sequences are equivalent, then their tails are also equivalent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": true
      },
      {
        "response": "theorem bind_singleton (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h s : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h q : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h i : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h v : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h j : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h u : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h g : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h y : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a' less than or equal to 1, 'a' is less than or equal to its inverse (1/a), denoted as a‚Åª¬π.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 100) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 96) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 83) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 101) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 37) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 92) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 87) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the interval starting at 'a' and closed at the predecessor of 'b' is the same as the interval starting at 'a' and open at 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": true
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_of_subset_right {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ‚Ñï) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) ‚â† Ioo a b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ùïå) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ùïç) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ùïã) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ùïê) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ùïÑ) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ioc_pred_right (a b : ùïÜ) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem contDiffAt_fst {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True or False),  `x` AND `y`  is always less than or equal to `x`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": true
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y r : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y u : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y p : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y o : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y w : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y s : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y g : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y k : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y t : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y c : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a type that includes a top element (‚ä§), subtracting the top element from 'a' always results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": true
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 16 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 94 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 58 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 20 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 90 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two elements, 'a' and 'b', and we want to subtract them in a specific way (denoted by '-·µ•') within a certain context (represented by 'Filter'). This subtraction is done on elements placed within individual containers labeled 'pure'. The theorem states that subtracting these containerized elements, 'pure a' and 'pure b', is the same as first subtracting 'a' and 'b' directly, and then placing the result into the 'pure' container.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": true
      },
      {
        "response": "theorem pure_vsub_pure : (pure a l : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b ‚â† (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a z : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a f : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a k : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a r : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a e : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem casesOn {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a g : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a x : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a q : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a p : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', if 'a' is not less than 'b', then the set of natural numbers between 'a' (inclusive) and 'b' (exclusive) is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) that preserves addition between two sets \\( A \\) and \\( B \\), applying \\( f \\) to the sum of two elements \\( x \\) and \\( y \\) in set \\( A \\) is the same as applying \\( f \\) to \\( x \\) and \\( y \\) separately in \\( A \\) and then adding the results in \\( B \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": true
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : ùïè) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y c : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : ùïÜ) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) ‚â† f x + f y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y l : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y p : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : Œ≤) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : ‚Ñù) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y k : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y e : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : ùïÄ) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y a : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the reverse of the zero polynomial is the zero polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": true
      },
      {
        "response": "theorem reverse_zero : reverse (84 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem reverse_zero : reverse (0 v : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : Œ≤) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_zero : reverse (0 l : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (66 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : ùïå) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_zero : reverse (0 r : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : ùïè) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_zero : reverse (0 z : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (36 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_zero : reverse (0 u : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : ùïê) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_zero : reverse (0 q : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reverse_zero : reverse (0 : ùïÑ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the polynomial \"X\" itself is not the zero polynomial within the field of rational functions.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 14 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X b : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 93 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 16 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 37 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 10 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X e : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X v : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 29 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 67 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X x : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 66 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_div_one : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any two real numbers, denoted by 'x' and 'y', prove that reversing the order of multiplication after applying the 'star' operation twice to 'x' and then multiplying by 'y' is equivalent to applying the 'star' operation to 'y' and then multiplying by 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": true
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) ‚â† star y * x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : ùïé) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_star_mul (x y : ùïÑ) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_star_mul (x y : ùïä) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : ùïÄ) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : ‚Ñö) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_star_mul (x y : ‚Ñ§) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : ùîπ) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem star_star_mul (x y : ‚Ñí) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two linear transformations, \\( f \\) and \\( g \\), from a vector space \\( M‚ÇÅ \\) to itself (over a ring \\( R‚ÇÅ \\)), and a vector \\( x \\) in \\( M‚ÇÅ \\), prove that applying the composition of \\( f \\) and \\( g \\) to \\( x \\) is the same as applying \\( f \\) to the result of applying \\( g \\) to \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": true
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x ‚â† f (g x) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x l : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : ‚Ñù) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x i : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : ùïê) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x e : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : ùïÜ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : ùïç) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x t : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : ‚Ñí) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x r : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : ùîπ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function 'C' to the difference of two elements 'a' and 'a'' is the same as applying 'C' to each element individually and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": true
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) ‚â† C a - C a' :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two integers x and y, and assuming some unspecified properties hold (represented by 'h'), prove that a certain classification property, denoted as 'IsClassified', holds for the pair (x, y).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": true
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem replicate_le_coe {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two continuous deformations, denoted by F and G, between paths f‚ÇÄ and f‚ÇÅ that satisfy a property P. If F and G are pointwise equal, meaning they agree at every point x, then the deformations F and G are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=",
        "label": true
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F ‚â† G :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h s : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x ‚â† G x) : F = G :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h v : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h o : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h m : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h g : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h k : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h c : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h e : ‚àÄ x, F x = G x) : F = G :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the infimum (greatest lower bound) of two finite sets is the same as taking their intersection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": true
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf o : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf s : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf u : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) ‚â† Inter.inter :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf g : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sort_toFinset [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf n : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf r : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf e : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf f : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf d : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number  'x' divides a natural number 'm' resulting in an irrational number, then 'x' itself must be irrational.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": true
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h b : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ùîπ) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h a : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñí) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ùïå) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ùïç) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h n : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h p : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ùïä) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ùïã) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ùïê) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h e : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h x : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñö) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h m : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : √ó) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of two Cauchy sequences that are not converging to zero does not converge to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": true
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 8) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf r : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg r : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 6) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 48) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 75) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf b : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg s : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 10) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf i : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 68) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 47) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg q : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 93) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg w : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 67) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any number 'a', prove that the floor of ('a' plus 1) is equal to the floor of 'a' plus 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": true
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 86‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã ‚â† ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem floor_add_one (a : ùïã) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_one (a : ùïé) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 37‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 32‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : ùïå) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 3‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 40‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 70‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_add_one (a : ùïÑ) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_one (a : ùïê) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer 'i', the least common multiple (lcm) of 0 and 'i' is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i = 0 :=",
        "label": true
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 82 i = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 0 i ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lcm_zero_left (i : ùïè) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ùïã) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_top (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 61 i = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lcm_zero_left (i : √ó) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ùïå) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñù) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 20 i = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 72 i = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 44 i = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ùïÜ) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñö) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lcm_zero_left (i : ‚Ñ§) : lcm 45 i = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lcm_zero_left (i : ùïÄ) : lcm 0 i = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that negating the result of applying a binary operation `B‚ÇÅ` to two elements `x` and `y` is the same as applying the operation and then negating the result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": true
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y ‚â† -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem neg_apply (x y : ‚Ñù) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (x y : ùîπ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (x y : ùïä) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : ùïè) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (x y : ùïÑ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (x y : ‚Ñï) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (x y : ‚Ñ§) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_separable_zero [Nontrivial R] : ¬¨Separable (0 : R[X]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : ùïê) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : ùïç) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : ùïã) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero, finite number 'a' and any number 'b', (b / a) * a = b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": true
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 32) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI u : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI w : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a ‚â† b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 38) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 82) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI v : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_of [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 78) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 26) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 19) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI o : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 67) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a = ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 59) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is a quotient map, then it is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": true
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_midpoint_lt_iff (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set \\( s \\) of vertices forms an n-clique in an empty graph if and only if \\( n \\) is less than or equal to 1 and the size of \\( s \\) is equal to \\( n \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": true
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 22 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 15 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem st_mul {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 95 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 80 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 70 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 72 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 98 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 53 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 92 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 96 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property \\( p \\) defined on a type \\( \\alpha \\), the subtype of \\( \\alpha \\) consisting of elements satisfying \\( p \\) is empty if and only if the property \\( p \\) holds for no element of \\( \\alpha \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": true
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLittleO_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'f' that maps elements of a type 'Œ±' to elements of a group 'G' with the added condition that only finitely many elements of 'Œ±' map to non-identity elements in 'G', prove that removing the contribution of an element 'a' from the function '-f' (which maps each element to the inverse of the output of 'f') is equivalent to taking the inverse of removing the contribution of 'a' from the original function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": true
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f p : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : ùïÑ) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) ‚â† -erase a f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : ‚Ñö) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f q : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f o : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : ùïå) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f b : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_sub_right (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f t : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : ‚Ñ§) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f m : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_neg (a : ùïé) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all open intervals of the form (-‚àû, r), where r is a real number, forms a neighborhood basis for the element -‚àû in the extended real line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": true
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ùïå).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ùïã).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem unitors_equal : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ùïè).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ùïê).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ‚Ñö).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ‚Ñ§).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : ùîπ).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : √ó).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a specific function called \"polar\" that operates on some objects and a function \"Q\" that transforms one object into another, prove that applying the \"polar\" function with the same input \"x\" twice is equivalent to applying the \"Q\" function to \"x\" and then multiplying the result by 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": true
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 92 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 90 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem polar_self (x : ‚Ñö) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem polar_self (x : ùïê) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x ‚â† 2 * Q x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 45 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem polar_self (x : Œ±) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : ùîπ) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem of_apply (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 22 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 59 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 13 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem polar_self (x : ‚Ñù) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 31 * Q x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : ‚Ñï) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function \\(f\\) from a topological space \\(X\\) to a topological space \\(Y\\) that satisfies a property \\(P\\) is homotopic to itself with respect to that property.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": true
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf y : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf f : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf a : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf e : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf k : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf u : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf s : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number 'n', prove that converting 'n' to an element in a specific mathematical structure (called \"HomogeneousLocalization ùíú x\" here) and then extracting its \"value\" ('val') results in the original number 'n' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": true
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n f : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n u : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_val (n : ùïê) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val ‚â† n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : √ó) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n l : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n b : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_val (n : ùïä) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n o : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ùïç) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n a : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñï) : (n p : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_val (n : ‚Ñö) : (n : HomogeneousLocalization ùíú x).val = n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a ring R is semisimple when acting on a left R-module L, then the center of R with respect to L is trivial (i.e., contains only the zero element).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = ‚ä• :=",
        "label": true
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem oneOneReducible_refl {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a monotone function `h` between sets, prove that the image under `h` of the smallest filter on a set `Œ±` is equal to the principal filter generated by the image of the empty set under `h`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=",
        "label": true
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_inter_left : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h ‚â† ùìü (h ‚àÖ) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a way to compare lists of numbers. Suppose we represent these lists in a specific order based on their indices, similar to how dictionaries use key-value pairs. We are interested in understanding how changing a single element in a list affects the ordering. \n\nSpecifically, we want to prove: Comparing a list 'x' with a modified version of itself, where only the element at index 'i' is updated to value 'a', is equivalent to directly comparing the original element at index 'i' in 'x' with the new value 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": true
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_map (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the entry at the \\(i\\)-th row and \\(j\\)-th column of the identity matrix (denoted as \\(1\\)) of size \\(n \\times n\\) is equal to 1 if \\(i\\) is equal to \\(j\\), and 0 otherwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": true
      },
      {
        "response": "theorem one_apply {i j} : (66 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i ‚â† j then 1 else 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem one_apply {i j} : (1 h : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_apply {i j} : (34 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j ‚â† if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (100 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_apply {i j} : (7 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_apply {i j} : (1 n : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_apply {i j} : (1 j : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_apply {i j} : (1 d : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (35 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 f : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_apply {i j} : (1 c : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_apply {i j} : (1 l : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (97 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven elements 'a' and 'b' from a set 'Œ±', an integer 'm', and a point 'p', prove that calculating the \"toIocDiv\" of 'a' with respect to  '(m times p) plus b' is equivalent to adding 'm' to the \"toIocDiv\" of 'a' with respect to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": true
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) ‚â† m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m r : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : ‚Ñí) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ≤) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m q : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ùïê) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m f : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñö) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m c : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function \\(f\\) from a set with only one element to a set of Ordinal numbers, the supremum of the range of  \\(f\\) is equal to the value of \\(f\\) at the single element in its domain.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": true
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f ‚â† f default :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_toProd (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fract_nonneg (a : Œ±) : 0 ‚â§ fract a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext (h : ‚àÄ x, e x = e' x) : e = e' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_le_sdiff_left (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sum of a geometric series with a positive odd number of terms is always greater than zero, given that the elements of the series belong to a linearly ordered ring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": true
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 66 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ (i+3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ (i-5) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 94 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 8 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ (i-1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ (i-2) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 90 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 58 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 5 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 7 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ (i+1) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 71 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 49 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 73 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two functions \\( f \\) and \\( g \\) that map elements from a set \\( \\alpha \\) to a set \\( \\beta \\), if \\( f(a) = g(a) \\) for every element \\( a \\) in \\( \\alpha \\), then the functions \\( f \\) and \\( g \\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": true
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a ‚â† g a) : f = g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h k : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h f : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h r : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_pred_right (a b : Œ±) : Ioc a (pred b) = Ioo a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h z : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h c : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h w : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h g : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h t : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h j : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the predecessor function on natural numbers (which subtracts 1 from any natural number greater than 0, and maps 0 to 0) is injective. An injective function means that different inputs always lead to different outputs.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": true
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that negating the coefficients of a polynomial and then reflecting the polynomial around the y-axis is equivalent to reflecting the polynomial first and then negating the coefficients.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": true
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) ‚â† -reflect N f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ùïÜ) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N x : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñù) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N v : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N n : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñ§) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reflect_neg (f : ùïé) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N e : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñí) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : ùïè) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a relation \\( r \\) on a set \\( Œ± \\) is transitive, then it satisfies the property of transitivity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": true
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the natural embedding of a multivariate polynomial into the set of power series is injective. In other words, different polynomials will always be mapped to different power series.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": true
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe b : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe m : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe y : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe f : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_pi {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compl_sup (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe j : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe c : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe u : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe z : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe t : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing two structure-preserving maps, and then applying the resulting map, is the same as applying the second map and then the first.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": true
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) ‚â† f ‚àò g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g i : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g m : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g s : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g n : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Superset.trans {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g x : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g a : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g y : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_comp (f : sSupHom Œ≤ Œ≥) (g k : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' and lists 's' and 't', appending list 't' to the list obtained by adding 'a' to the beginning of 's' is the same as adding 'a' to the beginning of the list obtained by appending 's' and 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": true
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t ‚â† cons a (append s t) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ≤) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cons_append (a : √ó) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : ‚Ñ§) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cons_append (a : ùîπ) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cons_append (a : ùïÜ) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cons_append (a : ùïç) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem target_eq : I.target = range (I : H ‚Üí E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : ùïé) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cons_append (a : ùïè) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pderiv_one {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : ùïÄ) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a is equal to c multiplied by the multiplicative inverse of b, then a multiplied by b is equal to c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": true
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a ‚â† c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b ‚â† c :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_nat_dvd {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_fin_succ_pi {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function \"not\" (negation) is not equal to the identity function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": true
      },
      {
        "response": "theorem not_ne_id : not = id :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monotone_nhds : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a value `x` of type `t Œ±` and a functor `F`. Prove that applying `traverse` with the `pure` function to `x` is the same as applying `pure` directly to `x` and then considering the result as a value of type `F (t Œ±)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": true
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x h : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x ‚â† (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x t : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x v : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x y : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x i : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x f : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x j : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x z : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_eq_of_mem {x y : Œ±} {s : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a commutative square of functions, the second component of the cone is equal to the function 'g'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": true
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd ‚â† g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofReal_nsmul {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem angle_const_add (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the smallest seminorm on a vector space E over a field K is the zero function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=",
        "label": true
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 83 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 13 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 98 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 14 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 66 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 76 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 15 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem monotone_close {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 73 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 10 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element of the one-point compactification of a set X is not the added point at infinity if and only if it is equal to the image of some element from the original set X.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": true
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y t : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_unit_of_finite {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x = ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y p : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y r : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y n : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y v : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y m : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y c : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y h : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y d : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_lt_add_left (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y v : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a positive number *p*, prove that *p* is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem ne_zero : p ‚â† 4 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero : p = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 11 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero : p ‚â† 71 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comap_top (f : F) : comap f ‚ä§ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 55 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero : p ‚â† 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 53 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero : p ‚â† 95 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 90 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ne_zero : p ‚â† 100 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_bit0_succ (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 45 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three multisets \\(s\\), \\(t\\), and \\(u\\), the multiset product is distributive over multiset sum. That is, \\(s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": true
      },
      {
        "response": "theorem coe_mem {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u e : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u i : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) ‚â† s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u d : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u f : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u n : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u c : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u w : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u h : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u s : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven positive integers \\(x\\), \\(y\\), and \\(d\\), if \\(x^2 - dy^2 = 1\\), then there exists a non-negative integer \\(n\\) such that \\(x\\) and \\(y\\) are the \\(n\\)-th terms of the Pell sequence associated with \\(d\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": true
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 39) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp e : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y ‚â† yn a1 n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x ‚â† xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 10) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 72) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp o : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 43) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y ‚â† 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 44) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 95) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp s : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp y : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 15) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(S\\) be a subset of a set \\(A\\) that has a multiplication operation defined on it (like a ring or a field). Also, let \\(R\\) be a set with a multiplication operation that is compatible with \\(A\\) (meaning that elements of \\(R\\) can be multiplied with elements of \\(A\\) in a way that respects the algebraic structure). This theorem states that if we have an element \\(x\\) in our subset \\(S\\), and we multiply it by any element \\(r\\) from \\(R\\), the result (\\(r \\cdot x\\)) will still be an element of the subset \\(S\\).  In simpler terms, this theorem says that \\(S\\) is \"closed under scalar multiplication\" from \\(R\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": true
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : ùïÜ) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r z : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx h : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : ùïç) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : ùïè) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r g : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : ùîπ) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r e : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem {x : A} (hx t : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r v : R) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_mem {x : A} (hx : x ‚àà S) (r : √ó) : r ‚Ä¢ x ‚àà S :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem bot_adj (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_zero : @prod Œ± _ 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Integrable.congr {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet V be a vector space over a field K. Prove that for any non-zero vector 'v' in V, the subspace spanned by 'v' is an atom. (A subspace W is called an atom if it is non-zero and the only subspace of W properly contained in W is the zero subspace).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": true
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 9) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 32) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv o : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nonzero_span_atom (v : ùïç) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v = 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 19) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv k : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : ‚Ñù) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v ‚â† 85) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonzero_span_atom (v : V) (hv a : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nonzero_span_atom (v : ùîπ) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Balanced.inter (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element tagged as belonging to the \"right\" side of a disjoint union cannot be less than or equal to an element tagged as belonging to the \"left\" side, according to the standard order on the disjoint union.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": true
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b d : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b x : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b p : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b o : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b t : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b f : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b y : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b l : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b r : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sign function (which outputs -1 for negative numbers, 0 for 0, and 1 for positive numbers) is continuous at any point that is not zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": true
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 98) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h w : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h j : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a = 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 58) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h t : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 77) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h o : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Fintype.card_fin (n : ‚Ñï) : Fintype.card (Fin n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 69) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 11) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h u : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 60) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h i : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing any cocompact map `f` with the identity map is equal to `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": true
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_bot : comap m ‚ä• = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) from a set to itself and any element \\( x \\) in the set,  \\( x \\) is a periodic point of \\( f \\) with period equal to the minimal period of \\( x \\) under \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": true
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x q : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x a : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x n : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : ‚Ñù) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : ‚Ñ§) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : ùïä) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x i : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x c : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : ùïÜ) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : ùïè) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x d : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x o : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : √ó) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : ùïç) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x r : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the order of an element \\(x\\) is 0, then \\(x\\) raised to the power of \\(n\\) equals \\(x\\) raised to the power of \\(m\\) if and only if \\(n\\) equals \\(m\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": true
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 83) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ (m+1) ‚Üî n = m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m t : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ (n+4) = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n ‚â† x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 20) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ (n+2) = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m j : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n ‚â† m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 4) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 96) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ (m-4) ‚Üî n = m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m a : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x ‚â† 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ (n+1) = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have an isomorphism `f` between two objects `X` and `Y` in the opposite category of `C`, then taking the opposite of the inverse of `f` and then taking the opposite again, we get back `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": true
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f k : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f g : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f s : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f h : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f l : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f y : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem minFac_has_prop {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f j : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) and a way of approximating it (denoted by \\( \\text{approx} \\  f \\)), prove that if  \\( i \\) is less than or equal to  \\( j \\), then the approximation of \\(f\\) at  \\( i \\) is less than or equal to the approximation of \\(f\\) at \\( j \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": true
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij m : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij g : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij h : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij i : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij p : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij w : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem csSup_le' {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij e : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij o : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij a : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij r : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any invertible element 'a' in a system with a notion of multiplication and inverses, the multiplicative inverse of 'a' (denoted as ‚Öü a) is equal to the right inverse of 'a' (denoted as a‚Åª¬π).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : ùïê) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a ‚â† a‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem invOf_eq_inv (a : ùïÜ) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : ùïå) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : ùïè) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem invOf_eq_inv (a : ùïÄ) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : ‚Ñí) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem invOf_eq_inv (a : ‚Ñï) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : √ó) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem invOf_eq_inv (a : ùïç) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function to the product of two sets is the same as taking the product of applying the function to each set individually.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": true
      },
      {
        "response": "theorem image_mul : m '' (s * t) ‚â† m '' s * m '' t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pullbackConeOfRightIso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_eq_empty (h : ¬¨a < b) : Ico a b = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nat (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a proof `h` that an index `i` is equal to itself, prove that casting a linear map (between modules `R` and `M`) along this self-equality is the same as doing nothing to the linear map (i.e., it's equivalent to the identity linear map).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": true
      },
      {
        "response": "theorem cast_refl {i} (h : i ‚â† i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o\n   | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h ‚â† LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Left.self_le_inv (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivAt_cos (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_coe' (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `l` of elements of type `Œ±`, the Cartesian product of `l` and an empty list `[]` (of type `Œ≤`) is always an empty list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": true
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] ‚â†> rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l ‚â†> by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem product_nil : ‚àÄ l t : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l s : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) ‚â† []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l y : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l f : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l z : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l k : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem product_nil : ‚àÄ l w : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l v : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the measure of an open ball in a metric space is always greater than 0, given that the radius of the ball is not 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": true
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•74‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr k : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : ‚Ñö) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r = 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•73‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr y : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : ùïÄ) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•38‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•75‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r f : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measure_ball_pos (x : ‚Ñ§) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr c : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•54‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r b : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the uniformity generated by the infimum of a family of uniform spaces is equal to the infimum of the uniformities generated by each individual space in the family.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iInf_eq {u : Œπ ‚Üí UniformSpace Œ≥} : ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i) :=",
        "label": true
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_eq {u : Œπ ‚Üí UniformSpace Œ≥} : ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) ‚â† ‚®Ö i, ùí∞(Œ±, Œ≥, u i) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem span_eq_of_le (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sup_self' : y \\ x ‚äî x = y ‚äî x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a bijection Œ± between two sets X and Y, and a function f from Y to X, prove that the composition of f and the function from Y to X defined by Œ± is the identity function on Y if and only if f is the inverse of the function from X to Y defined by Œ±.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": true
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = 56 Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f w : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f g : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f ‚â† Œ±.inv :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f u : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = 76 Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = 89 Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f m : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom ‚â† ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f h : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = 78 Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f n : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = 68 Y ‚Üî f = Œ±.inv :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing any function \\(f\\) with the identity function results in the original function \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": true
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comp_id : f.comp id ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normalize_of_nonneg {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem expMapCircle_add (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that encoding the boolean value \"false\" results in the natural number 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": true
      },
      {
        "response": "theorem encode_false : encode false = 49 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem encode_false : encode false = 18 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem encode_false : encode false = 41 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem encode_false : encode false ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 94 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 99 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 80 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem isNClique_bot_iff : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 97 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem encode_false : encode false = 37 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 95 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any finite commutative ring that is also an integral domain must be a field.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": true
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_comp_lift : lift R f ‚àò Œπ R = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem edgeDensity_empty_right (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the adjoint of a linear operator is equal to its conjugate transpose.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=",
        "label": true
      },
      {
        "response": "theorem star_eq_adjoint (A : E ‚Üí‚Çó[ùïú] E) : star A ‚â† LinearMap.adjoint A :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem foldl_zero (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem starConvex (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set \\(I\\) which is a subset of a ring \\(R\\), prove that if a number \\(x\\) belongs to \\(I\\), then any natural number power of \\(x\\) (\\(x^n\\)) belongs to the set obtained by taking the product of \\(I\\) with itself \\(n\\) times, denoted as \\(I^n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": true
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : Œ±) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ (n-1) ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx m : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñ§) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ùïå) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ (n+2) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx g : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ùïç) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n b : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ (n+3) :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx c : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ùîπ) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ùïÄ) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem scanl_cons (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n t : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ (n+4) ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "exponent"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any relation \\(r\\), if a set \\(A\\) is a subset of a set \\(B\\), then the image of \\(A\\) under \\(r\\) is a subset of the image of \\(B\\) under \\(r\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_subset : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=",
        "label": true
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b‚Åª¬π) : a * b = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_ssubset_of_subset (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aeval_eq_bind‚ÇÅ (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_coe (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_mul_odd {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function 'f' that takes two arguments (let's call them 'x' of type 'E' and 'y' of type 'F') and returns a value of type 'G', then flipping the order of arguments twice results in the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=",
        "label": true
      },
      {
        "response": "theorem flip_flip (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip ‚â† f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_add_le_add_right : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_lieSpan {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iterate_le_id_of_le_id (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer \\(n\\), converting \\(n\\) to a natural number results in 0 if and only if \\(n\\) is less than or equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": true
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 30 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n v : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ùïã) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 80 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n d : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n i : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ùïè) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) ‚â†>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 42 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n b : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n j : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : Œ±) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat ‚â† 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 82 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n t : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of two sets \\( s \\) and \\( t \\) is nonempty if and only if both \\( s \\) and \\( t \\) are nonempty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": true
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_int_eq (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the reflexive function (`refl`) to any element `x` in a type `M` returns the element `x` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": true
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x ‚â† x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem refl_apply (x : ‚Ñö) : refl L M x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : ùïê) : refl L M x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : ùïÜ) : refl L M x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : Œ±) : refl L M x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem refl_apply (x : ùïè) : refl L M x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (¬∑ < ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : ùïä) : refl L M x = x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_preimage_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the totient of any natural number greater than 2 is even.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=",
        "label": true
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 37 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn q : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem compl_eq_deleteEdges : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_zero_left (x : E) : ‚ü™0, x‚ü´ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty ‚Üî a < b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 88 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a ‚Üî b < a * c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn l : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn g : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 86 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem symmDiff_left_inj : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 42 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn i : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn t : 2 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem totient_even {n : ‚Ñï} (hn : 38 < n) : Even n.totient :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a linear map \\(f\\) between two modules \\(M\\) and \\(N\\) over some ring \\(R\\), applying the negation of \\(f\\) to an element \\(m\\) of \\(M\\) is the same as taking the negation of the result of applying \\(f\\) to \\(m\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": true
      },
      {
        "response": "theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m o : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : √ó) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m ‚â† -f m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : ùïê) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m p : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m i : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : ùîπ) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m r : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m l : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m n : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : ùïÄ) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : ùïã) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a natural number 'n', and an element 'm' from a module 'M' over a ring 'R', prove that scaling the element 'm' by 'n' is the same as applying the endomorphism of scaling by 'n' to 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": true
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : ùïÄ) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën v : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : Œ±) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m ‚â† n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m w : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën r : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : ùïä) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : ùïå) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_of_nonneg (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : ‚Ñ§) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën g : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : ùïã) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m l : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ùïç) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën j : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIf we have a pushout diagram with arrows `f`, `g`, `inl`, and `inr`, then the right arrow of the cocone is equal to `inr`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": true
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr ‚â† inr :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lowerBounds_empty : lowerBounds (‚àÖ : Set Œ±) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arcsin_pos {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a value 'c' is a limit point, then it is also a successor limit point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": true
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_assoc : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two codes 'cf' and 'cg' and a natural number 'a', evaluating code 'cf' on input 'a' yields the same result as evaluating the code 'prec cf cg' on the paired input of 'a' and 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": true
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 43) = eval cf a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem iInf_eq {u : Œπ ‚Üí UniformSpace Œ≥} : ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a v : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : ùïÑ) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) ‚â† eval cf a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem joinM_map_joinM {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 15) = eval cf a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a k : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a b : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñ§) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 59) = eval cf a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a y : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : ùïé) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : ‚Ñö) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval_prec_zero (cf cg : ùïê) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer \\( n \\), casting the multiplicative inverse of \\( n \\) (viewed as a rational number) to any type \\( \\alpha \\) is the same as taking the multiplicative inverse of \\( n \\) after casting it to \\( \\alpha \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": true
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ùïå) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n w : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_inv_int (n : ùïé) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) ‚â† (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n i : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n u : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñï) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñï) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ùïê) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : ùîπ)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n r : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ùïÄ) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n p : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that evaluating the difference of two polynomial expressions, `p` and `q`, using the functions `f` and `g` for variables is equivalent to evaluating each polynomial separately using `f` and `g` and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": true
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g ‚â† p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_surjective : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_smul : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_inl_le_inr [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is an isometry, then it is norm-nonincreasing.  In simpler terms, if `f` preserves distances, then the norm (or length) of any value `v` will not increase after applying `f` to it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": true
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_add : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toAddMonoidHom_injective {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toSeminorm {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_one : pure (1 : Œ±) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ofPolynomial (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two subsets, \\(o\\) and \\(p\\), of a set have the exact same elements, then the two subsets are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": true
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o ‚â† p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H i : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H y : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H c : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H l : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H z : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_def {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H d : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H k : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H u : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infinitePos_omega : InfinitePos œâ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H p : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inverse_mul_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\( I \\) is a maximal ideal of a ring \\( R \\), then \\( I \\) is equal to the unique maximal ideal of \\( R \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": true
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I ‚â† maximalIdeal R :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem totient_two : œÜ 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI z : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : Œ±) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI c : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : ùïÑ) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI i : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : ùîπ) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI n : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : ùïç) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI p : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : ‚Ñù) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : ùïê) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI h : I.IsMaximal) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : ‚Ñí) : I = maximalIdeal R :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number \\( x \\) lies within the interval from 0 to 1 (inclusive), then \\( x \\) is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": true
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 49) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x n : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 s : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ≤) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 73) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 97) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x t : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : √ó) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x l : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (51 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : Œ±) 1) : (x : ‚Ñï) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_le_one (x : Icc (0 : ‚Ñù) 1) : (x : Œ±) ‚â§ 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' that maps elements from type 'Œ±' to type 'Œ≤', applying 'f' after wrapping an element of type 'Œ±' with 'some' is the same as wrapping the result of applying 'f' to the element with 'some'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": true
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some ‚â† some ‚àò f :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_iSup_nat_succ (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_empty : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.symm (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_zpow : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is continuous on a larger set, it's also continuous on any smaller subset within that set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": true
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem convex_singleton (c : E) : Convex ùïú ({c} : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conversion from a real number to a quaternion (with real components R and complex units c‚ÇÅ and c‚ÇÇ) is injective. In other words, different real numbers are always represented by different quaternions.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": true
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe j : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe x : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe f : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe h : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe a : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe v : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe m : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe e : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe q : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe i : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe y : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that, for any ultrafilter \\( f \\) and any filter \\( g \\) on a set, the infimum (greatest common subfilter) of \\( f \\) and \\( g \\) is not the bottom filter (the filter containing everything) if and only if \\( f \\) is a subfilter of \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": true
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g v : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g n : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g w : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g m : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g z : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g f : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g b : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g c : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_of_dvd : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b\n   | a, x, b0, ‚ü®b, hab‚ü© => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g x : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_subset_iff_right : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any Young Diagram  Œº and natural numbers i and j, the pair (i, j) being in the j-th column of Œº is equivalent to the pair (i, j) being in Œº.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": true
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j v : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j u : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j r : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j w : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j x : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j d : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j t : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j h : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j i : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mk_mem_col_iff {Œº : YoungDiagram} {i j a : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(s\\) and an element \\(b\\), the set obtained by taking the supremum (least upper bound) of \\(b\\) with each element of \\(s\\) is the same as taking the image of \\(s\\) under the function that maps each element \\(a\\) to the supremum of \\(a\\) and \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": true
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a ‚â†> a ‚äî b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} ‚â† s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem terminates_map_iff (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_def {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frontier_setOf_re_le (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem modulus_pos (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_right (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prod_map (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_add (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a set 's' of elements that are ordered, meaning some elements can be \"less than or equal to\" others. This set has a special element called \"‚ä•\" (bottom), which is the smallest element in the set. An antichain is a set where no two distinct elements are comparable, meaning neither one is \"less than or equal to\" the other. Prove that the bottom element \"‚ä•\" is in our set 's' if and only if 's' contains only the bottom element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": true
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s ‚â† {‚ä•} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem swap_sSup [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_iInf (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmDiff_sdiff_left : a ‚àÜ b \\ a = b \\ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subset.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the upper closure of the singleton set containing only the element 'a' is equal to the set of all elements greater than or equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": true
      },
      {
        "response": "theorem upperClosure_singleton (a : Œ±) : upperClosure ({a} : Set Œ±) ‚â† UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem upperClosure_singleton (a : ‚Ñï) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : ùïã) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : ùîπ) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem upperClosure_singleton (a : ùïé) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_ind (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem setOf_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem upperClosure_singleton (a : ùïè) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for ordinal numbers \\(a\\), \\(b\\), and \\(c\\), where \\(b\\) is a limit ordinal, \\(a * b \\le c\\) if and only if for all ordinals \\(b'\\) less than \\(b\\), \\(a * b' \\le c\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": true
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h x : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h v : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h z : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h g : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h n : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h w : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h a : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h t : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem identity (s : Stream' Œ±) : pure id ‚äõ s = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h y : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any three sets \\(u\\), \\(s\\), and \\(t\\), if \\(s\\) and \\(t\\) have no common elements, then the intersection of \\(u\\) and \\(s\\) also has no common elements with \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_left' (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": true
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h k : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h f : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dvd_sub_comm : a ‚à£ b - c ‚Üî a ‚à£ c - b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h q : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem dist_self (x : Completion Œ±) : dist x x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h z : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h c : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h x : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h o : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_map (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h i : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h a : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h m : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h t : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h l : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem inter_left' (u : Set Œ±) (h h : Disjoint s t) : Disjoint (u ‚à© s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 'Œ±' is countable if and only if there exists an injection (a one-to-one function) from 'Œ±' to the set of natural numbers ‚Ñï.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": true
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coeFn_pow (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_erase : b ‚àà erase s a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p ‚Üî p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall' {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_comp_symm (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem meas_snormEssSup_lt {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is monotone (meaning it preserves order), then the function that maps \\( x \\) to the set of elements strictly less than \\( f(x) \\) is also monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": true
      },
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x ‚â†> Iio (f x) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_mem : (1 : ‚Ñù) ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_pow (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all extended non-negative real numbers greater than a given non-negative real number \\(r\\) is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": true
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•35} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•99} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ùïê).NeBot :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ùïä).NeBot :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•73} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r g : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : √ó).NeBot :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•17} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•48} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•65} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r a : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ùïã).NeBot :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ùïé).NeBot :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r c : ‚Ñù‚â•0‚àû)).NeBot :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 is less than or equal to a constant value 'a' if and only if 1 is less than or equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": true
      },
      {
        "response": "theorem one_le_const : 44 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 79 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_const : 35 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_const : 10 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 15 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 2 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 95 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 86 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', if 'a' is less than or equal to 0 and 'b' is less than or equal to 1, then 'a' is less than or equal to 'a' multiplied by 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": true
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 66) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 51) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h x : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h u : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h g : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 100) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 58) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h z : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h l : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h n : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h : b ‚â§ 20) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h i : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 93) (h : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_embedding_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unary_decode_encode_nat : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_mul_of_le_one_right (ha : a ‚â§ 0) (h c : b ‚â§ 1) : a ‚â§ a * b :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there is a linear isomorphism 'e' between two modules L‚ÇÅ and L‚ÇÇ, then taking the inverse of the inverse of 'e' gives us back 'e'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": true
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm ‚â† e :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem le_or_gf (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIcoDiv_eq_floor (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sets_eq {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a‚Åª¬π ‚Üî a < 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(I\\) and \\(J\\) be ideals of a ring \\(R\\). Prove that if \\(I\\) divides \\(J\\), then \\(J\\) is a subset of \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": true
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© ‚â†> h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_mem_Ioc (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_gt_univ [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_toProd : (1 : ùìú(ùïú, A)).toProd = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem single_add_erase (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exp_pi_mul_I : exp (œÄ * I) = -1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a mathematical structure where elements have multiplication, a zero element, and allow cancellation (like integers), if an element 'p' divides another element 'q' such that 'p' is not a unit (doesn't have a multiplicative inverse), then 'p' and 'q' cannot be the same element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": true
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h m : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h g : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h l : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p = q :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h n : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem tail_congr {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h e : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h w : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toNat_eq_zero : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0\n   | (n : ‚Ñï) =>\n     calc\n       _ ‚Üî n = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h v : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h q : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any real number 'x' and quaternion 'y', scaling 'y' by 'x' is the same as converting the product of 'x' and 'y' to a quaternion.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": true
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y g : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ùïÑ) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) ‚â† ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ùïç) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y s : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y i : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y q : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y d : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y v : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : √ó) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_coe : x ‚Ä¢ (y : ùïÄ) = ‚Üë(x * y) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any functor \\(F\\) (a structure-preserving map) between categories \\(C\\) and \\(D\\), and any object \\(X\\) in category \\(C\\), prove that applying the identity natural transformation to \\(F\\) at \\(X\\) is the same as the identity morphism for the object \\(F(X)\\) in category \\(D\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": true
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = 72 (F.obj X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem image_subset_sups_right : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X a : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : ùïÜ) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X ‚â† ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = 81 (F.obj X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X v : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : ‚Ñù) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem erase_eq_empty_iff (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = 18 (F.obj X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = 87 (F.obj X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X b : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : ùïÄ) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : ‚Ñí) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = 2 (F.obj X) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X o : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\), the arccosine of \\( x \\) is equal to  \\( \\frac{\\pi}{2} \\) minus the arcsine of \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=",
        "label": true
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 33 - arcsin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñ§) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ùïÜ) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x ‚â† œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 53 - arcsin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 66 - arcsin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñí) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : Œ±) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 9 - arcsin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 48 - arcsin x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ùîπ) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ùïÑ) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ùïê) : arccos x = œÄ / 2 - arcsin x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : ‚Ñù) : arccos x = œÄ / 89 - arcsin x :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a Hahn series is a unit (i.e., has a multiplicative inverse) if and only if the coefficient of its leading term is a unit.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_iff {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=",
        "label": true
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_const (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements \\( a \\) and \\( b \\) in a partially ordered set, if \\( a \\) is strictly less than \\( b \\), then \\( b \\) cannot be less than or equal to \\( a \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b ‚â§ a :=",
        "label": true
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h z : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h i : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h c : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h s : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h n : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h h : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h b : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h g : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem empty_sdiff (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_le_of_lt [Preorder Œ±] {a b : Œ±} (h f : a < b) : ¬¨b ‚â§ a :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of (x + c)^2 is 2(x + c), where x is a variable and c is a constant.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": true
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 31) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 48) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : ùïÜ) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : ùïê) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) ‚â† C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y ‚Üî |x| < |y| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 36) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : ‚Ñï) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 93) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 84) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : ùïÑ) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : Œ±) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : ùïã) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number \\( y \\), a number \\( x \\) is less than the logarithm of \\( y \\) if and only if the exponential of \\( x \\) is less than \\( y \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y :=",
        "label": true
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 98 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 90 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 67 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 51 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ofFn_get (v : Vector Œ± n) : ofFn (get v) = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 75 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 57 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_append_left {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 43 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 94 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 64 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 92 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 13 < y) : x < log y ‚Üî exp x < y :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a', 'a' is the least upper bound (LUB) of the set containing only 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": true
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Subsingleton.coe_sort {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_eq_mod_exponent {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_num_zero {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_symm (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqrt_eq' (n : ‚Ñï) : sqrt (n ^ 2) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_eq (a : Œ±) : const a = a::const a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_all_isAtomic (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the product of two numbers is negative and one of the numbers is non-negative, then the other number must be negative.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": true
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 70) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_subset_coe : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 g : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 48) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 88) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 62) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 q : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 12) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sup_unique {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 37) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 68) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 e : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 49) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem filter_dvd_eq_divisors (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 75) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 d : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero p-adic integer \\( x \\), the p-adic norm of \\( x \\) is equal to \\( p \\) raised to the power of the negative valuation of \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": true
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 28) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p t : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ùïä) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ ‚â† (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 86) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p n : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx c : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ùîπ) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p i : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 7) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ùïç) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx o : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ùïê) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x = 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem coe_pointwise_smul (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p c : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_pow_val {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p z : ‚Ñù) ^ (-x.valuation) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list to a cycle and then to a finite set is the same as directly converting the list to a finite set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": true
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l n : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l v : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift ‚â´ p = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l : Cycle Œ±).toFinset ‚â† l.toFinset :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l e : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l x : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l j : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l z : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unit_of_val_units {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l i : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_toFinset (l : List Œ±) : (l l : Cycle Œ±).toFinset = l.toFinset :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_pointwise_smul_iff {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_inv_int (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the 0th element of the denominators of any fraction g is always equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": true
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 87 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sup_inf_bihimp : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 85 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 32 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 85 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 12 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 23 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_le_left : I * J ‚â§ J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 15 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 89 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem ofAdd_le {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 5 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neg_apply (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 81 = 1 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 34 :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider two sets, M and M‚ÇÇ, which have a specific structure that allows us to \"add\" their elements and \"multiply\" them by elements from another set R. We also have a function, 'f', that takes elements from M and transforms them into elements of M‚ÇÇ in a way that respects the addition and scalar multiplication structure. Now, let 'p' be a subset of M that is closed under the operation of taking additive inverses (i.e., if an element belongs to 'p', its additive inverse also belongs to 'p'). We aim to demonstrate that applying the function '-f' (which is essentially 'f' but transforming elements into their additive inverses) to the set 'p' yields the same result as applying the original function 'f' to 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=",
        "label": true
      },
      {
        "response": "theorem map_neg (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p ‚â† map f p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_traverse (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_one_iff_exists {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_divMonomial (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven an element 'a' from any type 'B', applying the 'object' function of the 'preinclusion' function on 'B' to 'a' will return 'a' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": true
      },
      {
        "response": "theorem dedup_cons {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : ùïä) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preinclusion_obj (a : Œ≤) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preinclusion_obj (a : ‚Ñö) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : ùïÄ) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : ‚Ñù) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : ‚Ñí) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preinclusion_obj (a : ùïã) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_nonempty : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preinclusion_obj (a : ùïå) : (preinclusion B).obj a = a :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number of elements in the set of natural numbers from `a` to `b` (inclusive) is equal to `b + 1 - a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": true
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 20 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 41 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) ‚â† (b + 1 - a).toNat :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem comap_mono (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 7 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset Œ≤) = s.map inl :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 95 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 28 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 18 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 53 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 59 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 86 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 54 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_inl : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 77 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 96 - a).toNat :=",
        "label": false,
        "misalign_type": "constant"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any list, the index of an element 'a' within a new list formed by adding 'a' to the beginning of the original list is always 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": true
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 76 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem indexOf_cons_self (a : ùïÄ) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l n : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem indexOf_cons_self (a : ‚Ñí) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 9 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem indexOf_cons_self (a : ùïé) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 64 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem indexOf_cons_self (a : ùïã) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 66 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 80 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem indexOf_cons_self (a : ‚Ñï) (l : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l v : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 98 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l m : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem indexOf_cons_self (a : Œ±) (l z : List Œ±) : indexOf a (a :: l) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the product of two sets `p` and `q‚ÇÅ` (which are subsets of the Cartesian product of sets `M` and `M'`) is equivalent to taking the Cartesian product of `p` (as a subset of `M`) and `q‚ÇÅ` (as a subset of `M'`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": true
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ u : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) ‚â† (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ i : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_sup : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p b : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ v : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p v : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ x : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p t : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ w : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ g : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ c : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p i : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem max_eq_sup_coe {s : Finset Œ±} : s.max = s.sup (‚Üë) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ y : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine a scenario where 'r' represents a relationship between objects.  If 'a' is related to 'b' through 'r', and 'b' is related to 'c' through a chain of 'r' relationships that could potentially be empty (meaning 'b' might be equal to 'c'), then we want to prove that 'a' is related to 'c' through 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": true
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc y : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc t : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc m : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc q : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc n : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc s : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc x : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc r : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc o : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc k : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc p : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the factorization of 1 is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 0 :=",
        "label": true
      },
      {
        "response": "theorem factorization_one : factorization (2 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem factorization_one : factorization (1 p : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem factorization_one : factorization (1 : ùîπ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem factorization_one : factorization (1 : ùïç) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (62 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem factorization_one : factorization (1 : ‚Ñö) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem factorization_one : factorization (1 l : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem factorization_one : factorization (1 : √ó) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isometry : Isometry f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 : Œ±) = 83 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 y : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem factorization_one : factorization (1 : ùïè) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem factorization_one : factorization (100 : Œ±) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem factorization_one : factorization (1 : ùïÜ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of points belonging to the bottom element of the space of compact sets is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": true
      },
      {
        "response": "theorem map_wittPolynomial (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_eq_bits_len (n : ‚Ñï) : n.bits.length = n.size :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mk (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_val (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sum of zero vectors over any countable index set is equal to the zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": true
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (79 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 f : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 v : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 x : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ ‚â†> (0 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (10 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 e : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 h : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Ico_bot_coe : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (23 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (49 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 w : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 s : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (35 : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 i : kernel Œ± Œ≤)) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sum_zero [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive natural number \\( a \\) and any integer \\( n \\),  \\( a \\) raised to the power of \\( n \\) is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": true
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 62 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 99 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h a : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñï) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n = 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem list_sum_mem {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 81 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n o : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h e : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ùïè) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 41 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem prodExtendRight_apply_eq (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 63 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_nat_cast (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a l : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : ‚Ñù) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h r : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : ‚Ñ§) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n u : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomial 'f', the degree of the reverse of 'f' is equal to the degree of 'f' minus the trailing degree of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": true
      },
      {
        "response": "theorem reverse_natDegree (f : √ó) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : ‚Ñù) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree ‚â† f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : ùïä) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_natDegree (f : Œ≤) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_natDegree (f : ‚Ñö) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem reverse_natDegree (f : ùïÑ) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : ùïê) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem not_ne_id : not ‚â† id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reverse_natDegree (f : ùïç) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nhds_eq (x : H) : map I (ùìù x) = ùìù[range I] I x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven three sets \\(s\\), \\(t\\), and a single element \\(a\\), all from the same set, we define a new set called \"doset\" as follows:  The doset of \\(a\\), \\(s\\), and \\(t\\) is the set of all elements that can be formed by picking any element \\(x\\) from \\(s\\), any element \\(y\\) from \\(t\\), and computing \\(x * a * y\\). Prove that an element \\(b\\) belongs to this doset if and only if there exist elements \\(x\\) in \\(s\\) and \\(y\\) in \\(t\\) such that \\(b\\) equals \\(x * a * y\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": true
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b s : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b o : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b ‚â† x * a * y :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b x : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b t : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b c : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Equiv.summable_iff (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sub' (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b d : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b l : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_const_one : (‚àè _x in s, (1 : Œ≤)) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b k : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any objects X and Y in a preadditive category C, and any morphisms a, b, c, and d from X to Y, the following equation holds: (a - c) - (b - d) = (a - b) - (c - d).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": true
      },
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) ‚â† a - b - (c - d) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d o : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d q : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem vsub_union : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d n : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d k : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d c : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem gcd_mul_left (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d t : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d l : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_def [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d x : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d a : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element \\( b \\) belongs to the set obtained by inserting an element \\( a \\) into a set \\( s \\), and \\( b \\) is not equal to \\( a \\), then \\( b \\) must belong to the original set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": true
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b = a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_eq_on_Ico' (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_zero : ball x 0 = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nonneg_cases : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü©\n   | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü©\n   | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü©\n   | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü©\n   | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocDiv_zsmul_add (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_eq_singleton_iff {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_list_getD (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem support_zero : (0 : R[X]).support = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number `o`, taking the predecessor of the successor of `o` always results in `o` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": true
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) ‚â† o :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sup_sup_distrib_right (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_symmDiff : ‚ä• ‚àÜ a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `pure`, which takes an element and puts it into a singleton interval, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_injective : Injective (pure : Œ± ‚Üí Interval Œ±) :=",
        "label": true
      },
      {
        "response": "theorem pure_injective : Injective (pure y : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_of [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure x : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_injective : Injective (pure l : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_injective : Injective (pure c : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLinear_apply (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure e : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem pure_injective : Injective (pure r : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure m : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_sub_cancel_right (hb : b ‚â† ‚àû) : a + b - b = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_injective : Injective (pure b : Œ± ‚Üí Interval Œ±) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the \"mapMatrix\" operation to the \"reflexive\" algebraic equivalence on matrices results in the same reflexive algebraic equivalence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": true
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix ‚â† (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl s : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl y : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl q : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl g : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl d : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl o : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl a : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_bddAbove : BddAbove s ‚Üí BddAbove (f '' s)\n   | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü©\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exists_prime : ‚àÉ œñ : R, Prime œñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl l : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl f : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'b' in a set with a decidable equality relation, removing 'b' from the set of elements less than or equal to 'b' results in the set of elements strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=",
        "label": true
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b ‚â† Iio b :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïé) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïç) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : Œ≤) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasse_prod : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïä) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : √ó) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïå) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïã) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïÄ) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ‚Ñí) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ‚Ñù) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Iic_erase [DecidableEq Œ±] (b : ùïè) : (Iic b).erase b = Iio b :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function \\( f \\) is Riemann integrable on an interval where the start and end points are both \\( a \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": true
      },
      {
        "response": "theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toEquiv_symm (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_pi : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_nat_div (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem head!_mem_head? [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n œÜ).IsHomogeneous n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem curry_symm_apply (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven that a relation 'r' does not hold between element 'a' and any other element 'b', prove that 'b' is reachable from 'a' through the reflexive and transitive closure of 'r' if and only if 'b' is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=",
        "label": true
      },
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflTransGen_iff_eq (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b ‚â† a :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem val_toFinset [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_right_comm (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem finite_empty : (‚àÖ : Set Œ±).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem comap_comm (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet F be a field and E be a field extension of F. Let Œ± be an element of E, and F‚üÆŒ±‚üØ be the smallest subfield of E containing both F and Œ±. Prove that the image of Œ± under the natural embedding from F‚üÆŒ±‚üØ to E is Œ± itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=",
        "label": true
      },
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) ‚â† Œ± :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eraseNone_map_some (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInf_empty : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_powerset {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the relation of being in a one-to-one correspondence (bijection) between elements of a set is an equivalence relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": true
      },
      {
        "response": "theorem comm {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_const : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_space (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem card_le_of_surjective (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem soln_dist_to_a_lt_deriv : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invRev_invRev : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ennreal_eq_one {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sInter_nhds (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse function is continuous at a point \\(x\\) within a set \\(s\\), given that the inverse function is continuous everywhere.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": true
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x a : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem coe_top : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x n : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x t : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x e : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x z : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x i : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x p : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x u : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing Œ±).symm = ofBoolRing :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x l : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that swapping the order of multiplication in a product measure results in the same measure.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=",
        "label": true
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_swap : map Prod.swap (Œº.prod ŒΩ) ‚â† ŒΩ.prod Œº :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_inverse_cancel_right (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_iff_exists_coe : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pure_seq {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing element `c` from the singleton set `{b}` using vector subtraction (`-·µ•`) results in a singleton set containing the element `b -·µ• c`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=",
        "label": true
      },
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set Œ≤) -·µ• {c} ‚â† {b -·µ• c} :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_empty_of_mem (hs : s ‚àà f) : s ‚â† ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem odd_sub (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_eq {u : Œπ ‚Üí UniformSpace Œ≥} : ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unop_ratCast [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lift_spec : functor r ‚ãô lift r F H = F :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_abs {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem revzip_powersetAux {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isDiag_of_subsingleton [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I\n   | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_left_comm (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any irrational number \\(x\\) and any natural number \\(m\\), the sum \\(x + m\\) is also irrational.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": true
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m u : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem id_comp (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m s : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : √ó) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m g : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_sub (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m x : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ùïç) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : Œ±) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sub_top {a : WithTop Œ±} : a - ‚ä§ = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñö) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m r : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ùïè) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ùïÜ) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem list_join : Primrec (@List.join Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m k : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ùïé) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that appending an element 'a' to a vector 'v' and then concatenating the result with another vector 'w' is the same as appending 'a' to the concatenation of 'v' and 'w'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": true
      },
      {
        "response": "theorem append_cons (a : ‚Ñ§) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem Ico_insert_right (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : √ó) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w ‚â† a :: v +-+ w :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : ‚Ñö) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem append_cons (a : ùîπ) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v d : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toDual_bihimp : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_top [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v : Vector3 Œ± m) (w f : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem append_cons (a : ‚Ñï) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem append_cons (a : Œ±) (v o : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_toGerm (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s \\), \\( t \\), and \\( u \\), the intersection of \\( s \\) with the intersection of \\( t \\) and \\( u \\) is equal to the intersection of \\( s \\) and \\( u \\) with the intersection of \\( t \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": true
      },
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u ‚â† s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b ‚äÜ Icc a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem and_le_left : ‚àÄ x y : Bool, (x && y) ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isometry : Isometry e :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_apply [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem div_mul_cancel (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_id (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_comp_some (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) and elements \\(x\\) and \\(y\\), if \\(x\\) and \\(y\\) are in the same cycle of \\(f\\), then \\(y\\) and \\(x\\) are also in the same cycle of \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem SameCycle.symm : SameCycle f x y ‚Üí SameCycle f y x :=",
        "label": true
      },
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem functor_inv (E : C ‚âå D) : E.functor.inv = E.inverse :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bddBelow_inv : BddBelow s‚Åª¬π ‚Üî BddAbove s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem invOf_eq_inv (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finset.countable_toSet (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_torsion_iff (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bot_add (x : EReal) : ‚ä• + x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_coe : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem log_mul_base {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bsup_one (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers,  the difference between their absolute values is less than or equal to the absolute value of their difference.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": true
      },
      {
        "response": "theorem le_sub (a b : ùïã) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : Œ±) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_sub (a b : ‚Ñö) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem const_top [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_smul [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : ùïÜ) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_sub (a b : ùïè) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : ùïä) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_sub (a b : ùïÑ) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_sub (a b : ùïê) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (‚àÖ : Set P) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem symm_single (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a property \\(p\\) holds for all elements of a type \\(Œ±\\) if and only if \\(p\\) holds for an arbitrary element of \\(Œ±\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall_iff {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=",
        "label": true
      },
      {
        "response": "theorem zero : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_const (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiable_cos : Differentiable ‚Ñù cos :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.diff {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_filter {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_apply_self (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_subset_right : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem unbot'_coe {Œ±} (d x : Œ±) : unbot' d x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nadd_one : a ‚ôØ 1 = succ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a collection of prepartitions (sets of disjoint sets)  \\( \\pi_i \\) for each index \\( J \\), and a prepartition \\( \\pi \\), if an element belongs to the union of all sets in all \\( \\pi_i \\), then it also belongs to \\( \\pi \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem biUnion_le (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ :=",
        "label": true
      },
      {
        "response": "theorem mono (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_sInf (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tan_nat_mul_pi (n : ‚Ñï) : tan (n * œÄ) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_isSuccLimit_iff' : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nat_cast_toNat (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z\n   | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Module.Free.of_basis {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_Icc : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem min_eq_bot [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem iInf_adj {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( R \\) be a ring and \\( M \\) be an \\( R \\)-module. Prove that for any element \\( m \\) in \\( M \\), multiplying the indeterminate \\( X \\) in the polynomial ring \\( R[X] \\) by \\( m \\) is the same as applying a specific function to \\( X \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": true
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : R[X]) ‚â† X :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ball_congr (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X k : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : ‚Ñù) = X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r ‚àà Set.center A :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X l : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X d : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_X (m : ‚Ñ§) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X g : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem splits_X_pow (n : ‚Ñï) : (X ^ n).Splits i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : ùïê) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem constVAdd_symm (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X u : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_X (m : ùïç) : (m ‚Ä¢ X : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : ùïÜ) = X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X : ùïè) = X :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem smul_X (m : M) : (m ‚Ä¢ X o : R[X]) = X :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the property of \"SupIndep\" holds for any function  'f' when applied to an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=",
        "label": true
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ennreal_mass {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_left_iterate : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_union_left (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivalence_of_oneOneEquiv {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b ‚â§ abv (a - b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_symmDiff : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ne_zero : p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the size of an ordered tree `t` is equal to the size of its dual tree.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) = size t :=",
        "label": true
      },
      {
        "response": "theorem size_dual (t : Ordnode Œ±) : size (dual t) ‚â† size t :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Œπ_sndSigmaMap (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem product_nil : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem reflect_neg (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigO_map {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem bind‚ÇÇ_C_right (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem roots_one : (1 : R[X]).roots = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_ndunion {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_lt_cosh : 1 < cosh x ‚Üî x ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Duplicate.elim_singleton {y : Œ±} (h : x ‚àà+ [y]) : False :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = ùüô X :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a sequence F.N where each term is generated by applying a function F, prove that there exists an index n‚ÇÄ such that for any k, the term at index (n‚ÇÄ + k) is equal to the term at index n‚ÇÄ multiplied by the k-th power of some constant I.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": true
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) ‚â† I ^ k ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k+4) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coeffs_lc (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k+5) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k+2) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem coe_fn_injective : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k+3) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k-3) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k-5) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem subset_union_right (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toIocMod_add_zsmul (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem l_sup : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Stable.exists_pow_smul_eq : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ (k-4) ‚Ä¢ F.N n‚ÇÄ :=",
        "label": false,
        "misalign_type": "exponent"
      },
      {
        "response": "theorem apply_zero (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 is less than or equal to the rounded up value of a number x if and only if 1 is less than or equal to x itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": true
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 8 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_floor_iff (x : ‚Ñï) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : ‚Ñù) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_le_floor_iff (x : ùîπ) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem preimage_coe_Ioi : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 51 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_pell {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : ùïÜ) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem add_nsmul (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 75 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : Œ±) : 26 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem one_le_floor_iff (x : ùïç) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_le_floor_iff (x : ‚Ñ§) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_le_floor_iff (x : ùïå) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem one_le_floor_iff (x : √ó) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic sine function (sinh) is infinitely differentiable for all degrees of differentiation 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contDiff_sinh {n} : ContDiff ‚Ñù n sinh :=",
        "label": true
      },
      {
        "response": "theorem isAlgebraic_root (hf : f ‚â† 0) : IsAlgebraic R (root f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem union_union_distrib_left (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Icc_subset_Icc_left (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymm_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_le_mul_left (h : M ‚â§ N) : M * P ‚â§ N * P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_span_singleton {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem refl : IntervalIntegrable f Œº a a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem antitone_continuousOn {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem span_singleton_eq_bot : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equiv_neg_iff {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rel_bind : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a collection of sets, indexed by 'i', and we can pick an element from each set.  We represent this picking process as functions 'f' and 'g', where  'f(i)' gives us the element picked from the i-th set by 'f', and similarly for 'g'. Now, suppose both 'f' and 'g' have a property called \"Mem‚Ñìp\" with respect to some condition 'p'.  Prove that if we were to instead pick elements by taking the difference between the picks of 'f' and 'g' (that is, for each set 'i', we choose the element 'f(i) - g(i)'), then this new way of picking will also satisfy the property \"Mem‚Ñìp\" with respect to 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": true
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf u : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg y : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg c : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_app' (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_punitProd : ‚áë(punitProd Œ±) = Prod.snd :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf y : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem injective_of_top_hom (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem congr_fun {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem transitive_of_trans (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem le_none {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg r : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg h : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf e : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg p : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf f : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sub {f g : ‚àÄ i, E i} (hf k : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number 'a' and any natural number 'n', the floor of the sum of 'a' and 'n' is equal to the sum of the floor of 'a' and 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": true
      },
      {
        "response": "theorem floor_add_nat (ha : 72 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ùïç) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n u : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ùïä) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä ‚â† ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ‚Üî x i < a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 66 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n c : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n v : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ùïÑ) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem compress_self (u a : Œ±) : compress u u a = a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 40 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem floor_add_nat (ha : 85 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mem_falling : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n q : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_nat (ha : 98 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n o : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem floor_add_nat (ha : 0 ‚â§ a) (n : ùïè) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' in a multiplicative structure 'M', the set of all powers of 'x' forms a submonoid of 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": true
      },
      {
        "response": "theorem powers.isSubmonoid (x : ùïÑ) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ‚Ñí) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ‚Ñï) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ‚Ñö) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ùïÄ) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem infs_union_left : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ùïã) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ùïÜ) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem powers.isSubmonoid (x : Œ±) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem length_scanl : ‚àÄ a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ‚Ñ§) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem range_eval·µ¢ [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Fin.image_succAbove_univ {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : √ó) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ùïå) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem powers.isSubmonoid (x : ùïä) : IsSubmonoid (powers x) :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sign function (which outputs -1 for negative numbers, 0 for 0, and 1 for positive numbers) is continuous at any negative number 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": true
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 40) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem closure_range : closure (range Œπ) = univ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h o : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h x : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem aleph0_le_continuum : ‚Ñµ‚ÇÄ ‚â§ ùî† :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 93) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h p : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h q : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 88) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 9) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h a : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h v : a < 0) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem continuousAt_sign_of_neg {a : Œ±} (h : a < 55) : ContinuousAt SignType.sign a :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem coe_toCompl‚Çó·µ¢ : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two fractions represented as pairs (a‚ÇÅ, a‚ÇÇ) and (b‚ÇÅ, b‚ÇÇ), where a‚ÇÅ, a‚ÇÇ, b‚ÇÅ, and b‚ÇÇ are natural numbers, the fraction (a‚ÇÅ/a‚ÇÇ) is less than or equal to the fraction (b‚ÇÅ/b‚ÇÇ) if and only if b‚ÇÇ * a‚ÇÅ is less than or equal to a‚ÇÇ * b‚ÇÅ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": true
      },
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem approx_mono ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Ioc_bot_coe : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_doset {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_eq_top : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sequence_mono : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs\n   | [], [], Forall‚ÇÇ.nil => le_rfl\n   | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\(f\\) reverses order (is antitone) and does not repeat outputs for different inputs (is injective), then it strictly reverses order (is strictly antitone).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=",
        "label": true
      },
      {
        "response": "theorem add_nat (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ p : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ w : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_div_singleton (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isEmpty_subtype (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ f : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ o : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ b : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t\n   | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_eval (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ a : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ d : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Flat.pointed {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ n : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem toFun_eq_coe (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ e : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Antitone.strictAnti_of_injective (h‚ÇÅ : Antitone f) (h‚ÇÇ s : Injective f) : StrictAnti f :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any isomorphism `Œ±` between sets `X` and `Y`, composing `Œ±` with its inverse `Œ±.symm` results in the identity isomorphism on `X`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": true
      },
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm ‚â† Iso.refl X :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem smul_mem_smul_finset_iff (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_pow (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pairwiseDisjoint_empty : (‚àÖ : Set Œπ).PairwiseDisjoint f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem powerset_aux'_perm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem rank_le_domain (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_zero {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn ùïú f ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two vectors `v` and `w` of the same length, prove that the dot product of the `i`-th row of the diagonal matrix of `v` and `w` is equal to the product of the `i`-th element of `v` and the `i`-th element of `w`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": true
      },
      {
        "response": "theorem diagonal_dotProduct (i : ùïä) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i ‚¨ù·µ• w ‚â† v i * w i :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem floor_add_one (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ùïé) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem toDual_intCast [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem find_min' {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sups_singleton : s ‚äª {b} = s.image fun a => a ‚äî b :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ‚Ñï) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ùïã) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ùîπ) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem ext_iff {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ‚Ñö) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ‚Ñù) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ùïÑ) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem eq_zero_iff_even {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diagonal_dotProduct (i : ‚Ñ§) : diagonal v i ‚¨ù·µ• w = v i * w i :=",
        "label": false,
        "misalign_type": "variable_type"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(t\\) is open and disjoint from another set \\(s\\), then the frontier of \\(s\\) is also disjoint from \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": true
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem erase_neg (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd t : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem forall_mem_target {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd e : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd o : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd g : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd c : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natCast_ne_top (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd b : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd f : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd k : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem map_star (a : A) : œÉ (star a) = star (œÉ a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd u : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem antitone_nat_of_succ_le {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that adding an element to the beginning of a list is an injective operation. In other words, if adding the same element 'a' to the beginning of two lists results in the same list, then the original two lists must be identical.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_injective {a : Œ±} : Injective (cons a) :=",
        "label": true
      },
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem frequently_comap : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_field_closure (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sigma_apply {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono Œ± ‚Üî MulPosMono Œ± :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_mono : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y ‚äì y \\ x = ‚ä• :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem toOpens_top : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the absolute value of any unit (invertible element) in the integers is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": true
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 31 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ ‚â† 1 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e s : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_units (e : ùîπ) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 34 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e z : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_units (e : ùïÄ) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 2 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 8 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e h : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e k : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem norm_coe_units (e : ùîπÀ£) : ‚Äñ(e : ùîπ)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 88 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem norm_coe_units (e : ‚Ñ§À£) : ‚Äñ(e e : ‚Ñ§)‚Äñ = 1 :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that in a certain algebraic structure (a chain complex), the sum of two specific morphisms, PInfty.f n and QInfty.f n, is equal to the identity morphism (ùüô).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": true
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = 101 _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : Œ±) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n q : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ùïä) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n ‚â† ùüô _ :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = 74 _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : Œ≤) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n v : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñö) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ùïã) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = 43 _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n c : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = 12 _ :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ‚Ñ§) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ùïè) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem mk_le_mk : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : ùïÄ) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_bot : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the content of the zero polynomial in the ring of polynomials over a commutative ring R is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": true
      },
      {
        "response": "theorem content_zero : content (62 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem Nonempty.star [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 m : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem content_zero : content (0 : ùïÄ) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem content_zero : content (0 : R[X]) ‚â† 0 :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem snorm_inner_lt_top (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (95 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (0 j : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem content_zero : content (0 : ùïä) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem coe_injective ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem content_zero : content (94 : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem content_zero : content (0 : Œ≤) = 0 :=",
        "label": false,
        "misalign_type": "variable_type"
      },
      {
        "response": "theorem content_zero : content (0 e : R[X]) = 0 :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem yn_modEq_two : ‚àÄ n, yn a1 n ‚â° n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Prime.neg {p : Œ±} (hp : Prime p) : Prime (-p) :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a polynomial has a degree of 1, then it is irreducible.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": true
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 81) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p ‚â† 1) : Irreducible p :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem Set.Finite.measurableSet {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem pow_le_one' {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem mul_nonpos {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 80) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 76) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem eval‚ÇÇ_sub : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prime_of_factor {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 99) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 14) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 12) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 18) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 9) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem differentiableOn : DifferentiableOn ùïú iso s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 41) : Irreducible p :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem snorm_lt_top (f : Lp E p Œº) : snorm f p Œº < ‚àû :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that infinity multiplied by infinity equals infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû = ‚àû :=",
        "label": true
      },
      {
        "response": "theorem congr_fun {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem top_mul_top : ‚àû * ‚àû ‚â† ‚àû :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem isUnit_exp (x : ùî∏) : IsUnit (exp ùïÇ x) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem smuld_val (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem diag_zero [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem evaln_complete {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem norm_eq_iSup_norm : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem order_monomial_of_ne_zero (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem isBigOWith_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=",
        "label": false,
        "misalign_type": "unpaired"
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any system of numbers where zero behaves normally, the conversion from integers to those numbers preserves distinctness. This means that if two integers are different, their representations in the other system will also be different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": true
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.37\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.5\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast q : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem sdiff_self (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ ‚â†> cast_inj.1\n :=",
        "label": false,
        "misalign_type": "equality"
      },
      {
        "response": "theorem singleton_add (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.62\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.99\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast t : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s‚Åª¬π.Nonempty :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem coe_upperClosure (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.41\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.4\n :=",
        "label": false,
        "misalign_type": "constant"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast z : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast d : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=",
        "label": false,
        "misalign_type": "unpaired"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast r : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "variable_new"
      },
      {
        "response": "theorem cast_injective [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast p : ‚Ñ§ ‚Üí Œ±)\n   | _, _ => cast_inj.1\n :=",
        "label": false,
        "misalign_type": "variable_new"
      }
    ]
  }
]