[
  {
    "input": "Statement in natural language:\nProve that the Borel sigma-algebra, which is a collection of subsets of a set, exhibits a property called \"antitonicity\" with respect to subset inclusion. In simpler terms, if we have two sets where one is contained within the other, the Borel sigma-algebra generated by the smaller set is also contained within the Borel sigma-algebra generated by the larger set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem borel_anti : Antitone (@borel \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product sigma-algebra generated by the Cartesian products of measurable sets in two spaces is equal to the product sigma-algebra on the product space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem generateFrom_prod :\n    generateFrom (image2 (\u00b7 \u00d7\u02e2 \u00b7) { s : Set \u03b1 | MeasurableSet s } { t : Set \u03b2 | MeasurableSet t }) =\n      Prod.instMeasurableSpace :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the volume of the entire real number line (\u211d) is infinite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem volume_univ : volume (univ : Set \u211d) = \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Borel \u03c3-algebra on a totally ordered set \u03b1 is equal to the \u03c3-algebra generated by the collection of all open intervals of the form (-\u221e, a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem borel_eq_generateFrom_Iio : borel \u03b1 = .generateFrom (range Iio) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function that maps each element to itself (the identity function) on a measurable space results in the same measurable space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_id : m.map id = m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the collection of Cartesian products of measurable sets forms a \u03c0-system.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isPiSystem_prod :\n    IsPiSystem (image2 (\u00b7 \u00d7\u02e2 \u00b7) { s : Set \u03b1 | MeasurableSet s } { t : Set \u03b2 | MeasurableSet t }) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the standard volume measure on the real line is equivalent to the measure induced by the identity function through the Stieltjes construction.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem volume_eq_stieltjes_id : (volume : Measure \u211d) = StieltjesFunction.id.measure :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the smallest sigma-algebra under any function is still the smallest sigma-algebra.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_bot : (\u22a5 : MeasurableSpace \u03b1).comap g = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two relations (or functions) \\(m_1\\) and \\(m_2\\), and a function \\(g\\). The theorem states that taking the inverse image of the union of \\(m_1\\) and \\(m_2\\) under \\(g\\) is the same as taking the union of the inverse images of \\(m_1\\) and \\(m_2\\) under \\(g\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_sup : (m\u2081 \u2294 m\u2082).comap g = m\u2081.comap g \u2294 m\u2082.comap g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Borel \u03c3-algebra on any topological space \u03b1 is equal to the \u03c3-algebra generated by the collection of all closed intervals in \u03b1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem borel_eq_generateFrom_Ici : borel \u03b1 = MeasurableSpace.generateFrom (range Ici) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Borel \u03c3-algebra on a second-countable topological space is generated by the collection of all open intervals of the form (a, \u221e).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem borel_eq_generateFrom_Ioi : borel \u03b1 = .generateFrom (range Ioi) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Borel \u03c3-algebra on the real line can be generated by the collection of all closed intervals.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem borel_eq_generateFrom_Iic :\n    borel \u03b1 = MeasurableSpace.generateFrom (range Iic) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function 'f' and a mapping 'm' (you can imagine a mapping as a way to associate elements from one set to another).  If we first apply 'f' to the input of 'm', then use 'm', and finally consider all possible inputs to 'f' that lead to the same output, this resulting mapping will be \"smaller\" than or equal to our original mapping 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_map_le : (m.map f).comap f \u2264 m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the pre-image of a measurable set under the identity function results in the same measurable set. In other words, if we have a measurable space and apply the identity function, the measurable sets remain unchanged.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_id : m.comap id = m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a function 'f', the operation of mapping measurable spaces under 'f' is monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_map : Monotone (MeasurableSpace.map f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_sin : Measurable sin :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic sine function (sinh) is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_sinh : Measurable sinh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_cos : Measurable cos :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic cosine function (cosh) is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_cosh : Measurable cosh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the exponential function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_exp : Measurable exp :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function `f`, the pushforward of the largest sigma-algebra on a set `\u03b1` through `f` is equal to the largest sigma-algebra on the codomain of `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_top : (\u22a4 : MeasurableSpace \u03b1).map f = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the arcsine function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_arcsin : Measurable arcsin :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function (log) is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_log : Measurable log :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have an order-preserving map, 'g', between two partially ordered sets. If we first use 'g' to relate elements in the first set to elements in the second, and then use its inverse, 'comap g', to relate elements back to the first set, the resulting order relations will be a subset of the original order relations in the first set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_map_comap : m \u2264 (m.comap g).map g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( g \\), the function \\( \\text{MeasurableSpace.comap g} \\) is monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_comap : Monotone (MeasurableSpace.comap g) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_sin : Measurable sin :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function to the intersection of two sets is equivalent to taking the intersection of the images of those sets under the same function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_inf : (m\u2081 \u2293 m\u2082).map f = m\u2081.map f \u2293 m\u2082.map f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of a measurable set under a continuous function is also a measurable set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_im : Measurable im :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real part function, which takes a complex number and returns its real component, is a measurable function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_re : Measurable re :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which maps a real number to its corresponding complex number is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_ofReal : Measurable ((\u2191) : \u211d \u2192 \u2102) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic sine function (sinh) is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_sinh : Measurable sinh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic cosine function (cosh) is a measurable function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_cosh : Measurable cosh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the exponential function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_exp : Measurable exp :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_cos : Measurable cos :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the arccosine function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_arccos : Measurable arccos :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the argument function, which takes a complex number and returns its angle in the complex plane, is a measurable function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_arg : Measurable arg :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conditional expectation of a random variable 'f' given a sigma-algebra 'm' is integrable with respect to a measure '\u03bc'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem integrable_condexp : Integrable (\u03bc[f|m]) \u03bc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complex logarithm function is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurable_log : Measurable log :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conditional expectation of the zero function is always zero, regardless of the measure space or the sigma-algebra we condition on.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem condexp_zero : \u03bc[(0 : \u03b1 \u2192 F')|m] = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the essential supremum of the zero function is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snormEssSup_zero : snormEssSup (0 : \u03b1 \u2192 F) \u03bc = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the outer measure of a set 's' with respect to a function 'p' is equal to the sum over all points 'x', of the value of the function 'p' at 'x' multiplied by the indicator function of 's' at 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOuterMeasure_apply : p.toOuterMeasure s = \u2211' x, s.indicator p x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero element of the kernel of a linear map between vector spaces, when mapped through the map itself, results in the zero vector in the target space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_zero : \u21d1(0 : kernel \u03b1 \u03b2) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the \"norm\" of the zero function is always zero, regardless of the exponent used in the norm calculation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snorm_zero : snorm (0 : \u03b1 \u2192 F) p \u03bc = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero function is a member of the space  \u2112\ud835\udc5d  with respect to a measure  \ud835\udf07 .\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mem\u2112p : Mem\u2112p (0 : \u03b1 \u2192 E) p \u03bc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any probability mass function \\( p \\) and any set \\( s \\), the outer measure of the intersection of \\( s \\) and the support of \\( p \\) is equal to the outer measure of \\( s \\) itself, with respect to \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOuterMeasure_apply_inter_support :\n    p.toOuterMeasure (s \u2229 p.support) = p.toOuterMeasure s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(p\\) be a function that assigns a non-negative \"weight\" to each element in a set. The \"outer measure\" of a subset \\(s\\) is the total weight of elements in \\(s\\). The \"support\" of \\(p\\) is the set of all elements with non-zero weight. Prove that the outer measure of \\(s\\) equals 1 if and only if the support of \\(p\\) is contained within \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOuterMeasure_apply_eq_one_iff : p.toOuterMeasure s = 1 \u2194 p.support \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Carath\u00e9odory outer measure induced by the outer measure generated by a premeasure 'p' is equal to the top element of the lattice, meaning it assigns infinite measure to all sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOuterMeasure_caratheodory : p.toOuterMeasure.caratheodory = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a premeasure `p` and a set `s`, prove that the outer measure of `s` with respect to `p` is zero if and only if the support of `p` is disjoint from `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOuterMeasure_apply_eq_zero_iff : p.toOuterMeasure s = 0 \u2194 Disjoint p.support s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conditional expectation of a random variable, given a sub-sigma-algebra, is strongly measurable with respect to that sub-sigma-algebra.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem stronglyMeasurable_condexp : StronglyMeasurable[m] (\u03bc[f|m]) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the (i, j)-th entry of the characteristic matrix of a matrix M is equal to the difference between the (i, j)-th entry of a diagonal matrix with all diagonal entries equal to X and C times the (i, j)-th entry of M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem charmatrix_apply :\n    charmatrix M i j = (Matrix.diagonal fun _ : n => X) i j - C (M i j) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the \"evaluation\" operation to a multilinear map is the same as the multilinear map itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_multilinearMap : \u21d1(f : MultilinearMap R (fun _ : \u03b9 => M) N) = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of the identity linear map on a module M over a ring R is equal to the entire module M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_id : range (LinearMap.id : M \u2192\u2097[R] M) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying `.toFun` to a function `f` doesn't change the function itself; that is, `f.toFun` is equal to `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFun_eq_coe : f.toFun = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two functions, Q and Q', are equal if and only if they produce the same output for every input x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff : Q = Q' \u2194 \u2200 x, Q x = Q' x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the matrix polynomial equivalent of the characteristic matrix of a matrix M is equal to the polynomial X - C(M), where C(M) represents the companion matrix of M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem matPolyEquiv_charmatrix : matPolyEquiv (charmatrix M) = X - C M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the element at the \\(i\\)-th row and \\(i\\)-th column of the characteristic matrix of a matrix \\(M\\) is equal to \\(X\\) minus the image of the element at the \\(i\\)-th row and \\(i\\)-th column of \\(M\\) under the canonical ring homomorphism \\(C\\) from a ring \\(R\\) to the polynomial ring \\(R[X]\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem charmatrix_apply_eq : charmatrix M i i = (X : R[X]) - C (M i i) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `Q.toFun` is equal to the coercion function `\u21d1Q`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFun_eq_coe : Q.toFun = \u21d1Q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a linear map (between modules) to a function between sets is injective. In other words, if two linear maps act the same way as functions, they must be the same linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Injective ((\u2191) : M [\u22c0^\u03b9]\u2192\u2097[R] N \u2192 (\u03b9 \u2192 M) \u2192 N) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the map `\u03b9Inv` is a left inverse of the canonical map `\u03b9` from a module `M` to its exterior algebra over a commutative ring `R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem \u03b9_leftInverse : Function.LeftInverse \u03b9Inv (\u03b9 R : M \u2192 ExteriorAlgebra R M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying `.toFun` to a function `f` is the same as directly applying `f` using the notation `\u21d1f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFun_eq_coe : f.toFun = \u21d1f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `algebraMapInv` is the left inverse of the function `algebraMap` when applied to the exterior algebra over a module.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| ExteriorAlgebra R M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function Q that takes elements from a module M (over a ring R) and outputs elements in R, prove that there exists a bilinear form B on M such that for any x and y in M, the equation Q(x + y) = Q(x) + Q(y) + B(x, y) holds.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_companion : \u2203 B : BilinForm R M, \u2200 x y, Q (x + y) = Q x + Q y + B x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a linear transformation, denoted by Q, to the zero vector of a vector space results in the zero vector of another vector space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_zero : Q 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a multilinear map to a function is injective. In other words, if two multilinear maps act the same way as functions, they must be the same multilinear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Injective ((\u2191) : MultilinearMap R M\u2081 M\u2082 \u2192 (\u2200 i, M\u2081 i) \u2192 M\u2082) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a linear map from a tensor power of a module to a multilinear map is an injective operation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_multilinearMap_injective :\n    Function.Injective ((\u2191) : M [\u22c0^\u03b9]\u2192\u2097[R] N \u2192 MultilinearMap R (fun _ : \u03b9 => M) N) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function B that takes two inputs from a set M.  Prove that if we apply B to two equal pairs of inputs, the outputs will also be equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_congr : \u2200 {x x' y y' : M}, x = x' \u2192 y = y' \u2192 B x y = B x' y'\n  | _, _, _, _, rfl, rfl => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero bilinear form, when coerced into a linear map, results in the zero linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : \u21d1(0 : BilinForm R M) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the inverse of the algebra map (`algebraMapInv`) after the algebra map (`algebraMap`) on any element of a tensor algebra results in the original element. In other words, the inverse algebra map is a left inverse of the algebra map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| TensorAlgebra R M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a bilinear form into a function of three vectors is injective. In simpler terms, if two bilinear forms always produce the same output for any three input vectors, then the two bilinear forms must be the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective ((\u2191) : BilinForm R M \u2192 M \u2192 M \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two functions, B and D, are equal if and only if they produce the same output for all possible input pairs (x, y).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff : B = D \u2194 \u2200 x y, B x y = D x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the characteristic polynomial of a linear transformation `f` on a module `M` is equal to the characteristic polynomial of the matrix representation of `f` with respect to any basis of `M`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem charpoly_def : f.charpoly = (toMatrix (chooseBasis R M) (chooseBasis R M) f).charpoly :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\(f\\) on a finite-dimensional vector space, evaluating the characteristic polynomial of \\(f\\) at \\(f\\) itself results in the zero transformation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aeval_self_charpoly : aeval f f.charpoly = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any module \\(M\\) over a ring \\(R\\), the rank of \\(M\\) is less than or equal to the cardinality of \\(M\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rank_le_card : Module.rank R M \u2264 #M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toOuterMeasure`, which converts a probability mass function (PMF) to an outer measure, is injective. In other words, prove that if two PMFs `p` and `q` are mapped to the same outer measure, then `p` and `q` must be the same PMF.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOuterMeasure_injective : (toOuterMeasure : PMF \u03b1 \u2192 OuterMeasure \u03b1).Injective :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every linear transformation *f* from a vector space *V* to itself over a field *R* is an integral element over *R*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isIntegral : IsIntegral R f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which maps a point in projective space to its corresponding submodule is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem submodule_injective :\n    Function.Injective (Projectivization.submodule : \u2119 K V \u2192 Submodule K V) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the characteristic polynomial of any square matrix is monic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem charpoly_monic : f.charpoly.Monic :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the identity linear map to the components of any vector in a vector space V, using the identity linear equivalence as a mapping between vectors, is the same as simply taking the vector itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_id : map (LinearMap.id : V \u2192\u2097[K] V) (LinearEquiv.refl K V).injective = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which checks for equality to `True` is the same as the identity function when applied to boolean values.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_true_eq_id : Eq True = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the encoding of the single value of the `PUnit` type is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem encode_star : encode PUnit.unit = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the negation of a statement p implies a contradiction (False), then the statement p itself must be true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem by_contradiction : (\u00acp \u2192 False) \u2192 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that, given propositions \\( a \\), \\( b \\), and \\( c \\), the statement \"either both \\( a \\) and \\( b \\) are true, or \\( a \\) implies \\( c \\)\" is equivalent to the statement \"if \\( a \\) is true, then either \\( b \\) or \\( c \\) is true.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_or_imp : a \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the positive tangent cone of the universal set (the set containing everything) at any point 'a' is equal to the universal set itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem posTangentConeAt_univ : posTangentConeAt univ a = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that decoding the natural number 0 results in the unit value wrapped in the `some` constructor.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem decode_unit_zero : decode 0 = some PUnit.unit :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function has a gradient at a point if and only if it has a Fr\u00e9chet derivative at that point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientAt_iff_hasFDerivAt :\n    HasGradientAt f f' x \u2194 HasFDerivAt f (toDual \ud835\udd5c F f') x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(s\\) is a subset of another set \\(t\\), then the positive tangent cone of \\(s\\) at a point \\(a\\) is a subset of the positive tangent cone of \\(t\\) at the same point \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem posTangentConeAt_mono : Monotone fun s => posTangentConeAt s a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that saying \"a implies b is equivalent to b\" is logically the same as saying \"either a is true or b is true\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem imp_iff_right_iff : (a \u2192 b \u2194 b) \u2194 a \u2228 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there exists a surjective function from a set \u03b1 to a set \u03b2 if and only if the set of all functions from \u03b1 to \u03b2 is not empty and there exists an injective function from \u03b2 to \u03b1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_surjective_iff :\n    (\u2203 f : \u03b1 \u2192 \u03b2, Surjective f) \u2194 Nonempty (\u03b1 \u2192 \u03b2) \u2227 Nonempty (\u03b2 \u21aa \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nA function \\(f\\) has a gradient \\(f'\\) at a point \\(x\\) with respect to a limit \\(L\\) if and only if the difference between \\(f(x')\\) and the linear approximation of \\(f\\) at \\(x\\) (given by \\(f(x) + \u27e8f', x' - x\u27e9\\)) approaches zero faster than \\(x' - x\\) as \\(x'\\) approaches \\(x\\) along \\(L\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientAtFilter_iff_isLittleO :\n    HasGradientAtFilter f f' x L \u2194\n    (fun x' : F => f x' - f x - \u27eaf', x' - x\u27eb) =o[L] fun x' => x' - x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) has a gradient \\( f' \\) at a point \\( x \\) within a set \\( s \\) if and only if the difference between \\( f(x') \\) and the linear approximation of \\( f \\) at \\( x \\) (given by \\( f(x) + f'(x'-x) \\)) approaches zero faster than \\( x' - x \\) as \\( x' \\) approaches \\( x \\) within the set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientWithinAt_iff_isLittleO :\n    HasGradientWithinAt f f' s x \u2194\n    (fun x' : F => f x' - f x - \u27eaf', x' - x\u27eb) =o[\ud835\udcdd[s] x] fun x' => x' - x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the gradient of a function g at a point u is equal to the conjugate of the derivative of g at u, considering a field \ud835\udd5c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gradient_eq_deriv : \u2207 g u = starRingEnd \ud835\udd5c (deriv g u) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) has a gradient \\( f' \\) at a point \\( x \\) within the entire domain if and only if \\( f \\) has a gradient \\( f' \\) at point \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientWithinAt_univ : HasGradientWithinAt f f' univ x \u2194 HasGradientAt f f' x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nA function \\(f\\) has a gradient \\(f'\\) at a point \\(x\\) within a set \\(s\\) if and only if the following condition holds: as a point \\(x'\\) approaches \\(x\\) within the set \\(s\\), the normalized difference between the function's change (\\(f(x') - f(x)\\)) and its linear approximation using the gradient (\\(\\langle f', x' - x \\rangle\\)) approaches zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientWithinAt_iff_tendsto :\n    HasGradientWithinAt f f' s x \u2194\n    Tendsto (fun x' => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - \u27eaf', x' - x\u27eb\u2016) (\ud835\udcdd[s] x) (\ud835\udcdd 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nA function \\(f\\) has a gradient \\(f'\\) at a point \\(x\\) if and only if the difference between the function's value at a point near \\(x\\) and the linear approximation given by the gradient at \\(x\\) is very small compared to the distance between the two points.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientAt_iff_isLittleO : HasGradientAt f f' x \u2194\n    (fun x' : F => f x' - f x - \u27eaf', x' - x\u27eb) =o[\ud835\udcdd x] fun x' => x' - x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function *f* applied to any value *x* always results in a non-negative value.  We are working within a context involving a specific type of function called a \"continuously differentiable bump function\" related to a set *E*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonneg : 0 \u2264 f x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) has a gradient \\(f'\\) at a point \\(x\\) if and only if the difference between the function's value at a point near \\(x\\) and the linear approximation given by the gradient is very small compared to the distance between the two points.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientAt_iff_isLittleO_nhds_zero : HasGradientAt f f' x \u2194\n    (fun h => f (x + h) - f x - \u27eaf', h\u27eb) =o[\ud835\udcdd 0] fun h => h :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a function \\( f \\) and a point \\( x \\) within a specific interval determined by the context \\( E \\), the value of the function, \\( f(x) \\), is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_one : f x \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the topological support of a function 'f' is equivalent to the closed ball centered at 'c' with radius 'f.rOut'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tsupport_eq : tsupport f = closedBall c f.rOut :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the support of a function \\(f\\) is equivalent to a ball centered at point \\(c\\) with radius \\(f.rOut\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_eq : Function.support f = Metric.ball c f.rOut :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is always positive, then there exists a neighborhood around a point `c` such that for all points within that neighborhood, the function `f` evaluates to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eventuallyEq_one : f =\u1da0[\ud835\udcdd c] 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function having a strict derivative at a point is equivalent to the function having a strict Fr\u00e9chet derivative at the same point, where the Fr\u00e9chet derivative is represented as a linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasStrictDerivAt_iff_hasStrictFDerivAt :\n    HasStrictDerivAt f f' x \u2194 HasStrictFDerivAt f (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) f') x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the constant function that always returns zero is infinitely differentiable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contDiff_zero_fun : ContDiff \ud835\udd5c n fun _ : E => (0 : F) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity function, which maps each element of a space E to itself, is infinitely differentiable (smooth).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contDiff_id : ContDiff \ud835\udd5c n (id : E \u2192 E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nA function \\(f\\) has a gradient \\(f'\\) at a point \\(x\\) if and only if the following condition holds: As a point \\(x'\\) approaches \\(x\\), the ratio of the norm of the difference between the function's actual change (\\(f(x') - f(x)\\)) and its linear approximation using the gradient (\\(\\langle f', x' - x \\rangle\\)) to the distance between \\(x'\\) and \\(x\\) approaches zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasGradientAt_iff_tendsto :\n    HasGradientAt f f' x \u2194\n    Tendsto (fun x' => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - \u27eaf', x' - x\u27eb\u2016) (\ud835\udcdd x) (\ud835\udcdd 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) has a directional derivative \\(f'\\) at a point \\(x\\) in the direction of a vector \\(v\\) if and only if the slope of the secant line passing through \\(f(x)\\) and \\(f(x + tv)\\) approaches \\(f'\\) as \\(t\\) approaches \\(0\\) (excluding \\(t = 0\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasLineDerivAt_iff_tendsto_slope_zero :\n    HasLineDerivAt \ud835\udd5c f f' x v \u2194\n      Tendsto (fun (t : \ud835\udd5c) \u21a6 t\u207b\u00b9 \u2022 (f (x + t \u2022 v) - f x)) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd f') :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nA function \\(f\\) has directional derivative \\(f'\\) at point \\(x\\) along vector \\(v\\) if and only if the difference between the function's change and the linear approximation given by \\(f'\\) is negligible (in the little-o sense) as \\(t\\) approaches \\(0\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasLineDerivAt_iff_isLittleO_nhds_zero :\n    HasLineDerivAt \ud835\udd5c f f' x v \u2194\n      (fun t : \ud835\udd5c => f (x + t \u2022 v) - f x - t \u2022 f') =o[\ud835\udcdd 0] fun t => t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is linearly differentiable at a point \\(x\\) with respect to a vector \\(v\\) if and only if it is linearly differentiable at \\(x\\) with respect to \\(v\\) within the entire domain of \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lineDifferentiableWithinAt_univ :\n    LineDifferentiableWithinAt \ud835\udd5c f univ x v \u2194 LineDifferentiableAt \ud835\udd5c f x v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the directional derivative of a function 'f' at a point 'x' in the direction of a vector 'v' within the entire domain is the same as the directional derivative of 'f' at 'x' in the direction of 'v' without any domain restriction.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lineDerivWithin_univ : lineDerivWithin \ud835\udd5c f univ x v = lineDeriv \ud835\udd5c f x v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine function (sin) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_sin : Continuous sin :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function (log) is surjective, meaning that for every real number y, there exists a real number x such that log(x) = y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_surjective : Surjective log :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every real number is the logarithm of some positive real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_log : range log = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic sine function (sinh) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_sinh : Continuous sinh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function (cos) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_cos : Continuous cos :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function is injective on the set of positive real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_injOn_pos : Set.InjOn log (Set.Ioi 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function (log) is surjective when its domain is restricted to the set of positive real numbers (Ioi 0) and its codomain is the set of all real numbers (univ).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surjOn_log : SurjOn log (Ioi 0) univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function (log) is strictly decreasing for all numbers less than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAntiOn_log : StrictAntiOn log (Set.Iio 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm of 1 is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_one : log 1 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function (log) is strictly monotonically increasing on the set of positive real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMonoOn_log : StrictMonoOn log (Set.Ioi 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic sine function (sinh) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_sinh : Continuous sinh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic cosine function (cosh) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_cosh : Continuous cosh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 2 is less than or equal to pi (\u03c0).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem two_le_pi : (2 : \u211d) \u2264 \u03c0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine function (sin) is continuous for all real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_sin : Continuous sin :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function cosh(z) is continuous for all complex numbers z.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_cosh : Continuous cosh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there exists an angle between 1 and 2 radians whose cosine is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_cos_eq_zero : 0 \u2208 cos '' Icc (1 : \u211d) 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the mathematical constant \u03c0 (pi) is less than or equal to 4.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_le_four : \u03c0 \u2264 4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that \u03c0/2 is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_div_two_pos : 0 < \u03c0 / 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine of \u03c0/2 radians is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_pi_div_two : cos (\u03c0 / 2) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function (cos) is continuous for all real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_cos : Continuous cos :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 is less than or equal to \u03c0/2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_pi_div_two : (1 : \u211d) \u2264 \u03c0 / 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that \u03c0 / 2 is less than or equal to 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_div_two_le_two : \u03c0 / 2 \u2264 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine of \u03c0 (pi) radians is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sin_pi : sin \u03c0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function is antiperiodic with period \u03c0. In other words, prove that for any angle x, cos(x + \u03c0) = -cos(x).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_antiperiodic : Function.Antiperiodic cos \u03c0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine of twice the angle \u03c0 (pi) is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sin_two_pi : sin (2 * \u03c0) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function is periodic with a period of 2\u03c0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_periodic : Function.Periodic cos (2 * \u03c0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine of 2\u03c0 is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_two_pi : cos (2 * \u03c0) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Gamma function evaluated at 1 is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem GammaIntegral_one : GammaIntegral 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine function is antiperiodic with period \u03c0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sin_antiperiodic : Function.Antiperiodic sin \u03c0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(\ud835\udd5c\\) be a field. Given two sets \\(s\\) and \\(t\\) in a vector space over \\(\ud835\udd5c\\), prove that \\(s\\) absorbs \\(t\\) if and only if for all nonzero scalars \\(c\\) in a sufficiently small neighborhood of 0,  multiplying all elements of  \\(t\\) by \\(c\\) results in a set that is contained within \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem absorbs_iff_eventually_nhdsWithin_zero :\n    Absorbs \ud835\udd5c s t \u2194 \u2200\u1da0 c : \ud835\udd5c in \ud835\udcdd[\u2260] 0, MapsTo (c \u2022 \u00b7) t s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sine function is periodic with a period of 2\u03c0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sin_periodic : Function.Periodic sin (2 * \u03c0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is a balanced set in any vector space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem balanced_empty : Balanced \ud835\udd5c (\u2205 : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set containing only the zero vector in a vector space is balanced.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem balanced_zero : Balanced \ud835\udd5c (0 : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine of \u03c0 (pi) radians is equal to -1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_pi : cos \u03c0 = -1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(s\\) be a subset of a vector space \\(E\\) over a field \\(\ud835\udd5c\\). Prove that \\(s\\) is balanced if and only if for any scalar \\(a\\) in \\(\ud835\udd5c\\) with absolute value less than or equal to 1, and any vector \\(x\\) in \\(s\\), the scalar multiplication of \\(a\\) and \\(x\\) is also in \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem balanced_iff_smul_mem : Balanced \ud835\udd5c s \u2194 \u2200 \u2983a : \ud835\udd5c\u2984, \u2016a\u2016 \u2264 1 \u2192 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 a \u2022 x \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a partition  \u03c0\u2081 is a refinement of a partition \u03c0\u2082 (denoted as \u03c0\u2081 \u2264 \u03c0\u2082) if and only if for every set J in \u03c0\u2081, there exists a set J' in \u03c0\u2082 such that J is a subset of J'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_def : \u03c0\u2081 \u2264 \u03c0\u2082 \u2194 \u2200 J \u2208 \u03c0\u2081, \u2203 J' \u2208 \u03c0\u2082, J \u2264 J' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a set 'I', and we want to divide it into smaller, non-overlapping sets. We call this division a 'partition'. A 'prepartition' is like a partition, but it's allowed to have some empty sets in it. The biggest possible prepartition, denoted by '\u22a4', is the one that simply contains the entire set 'I' as its only part. Prove that a set 'J' belongs to this biggest prepartition '\u22a4' if and only if 'J' is equal to the original set 'I'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_top : J \u2208 (\u22a4 : Prepartition I) \u2194 J = I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector space E over a field \ud835\udd5c, the entire set E (denoted as 'univ') is balanced.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem balanced_univ : Balanced \ud835\udd5c (univ : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set *s* in a vector space *E* over a field *\ud835\udd5c* is absorbent if and only if for every vector *x* in *E*, there exists a punctured neighborhood around zero in *\ud835\udd5c* such that for all scalars *c* within this neighborhood, the scalar multiplication of *c* and *x* belongs to *s*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem absorbent_iff_eventually_nhdsWithin_zero :\n    Absorbent \ud835\udd5c s \u2194 \u2200 x : E, \u2200\u1da0 c : \ud835\udd5c in \ud835\udcdd[\u2260] 0, c \u2022 x \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a set \\(s\\) and a field \\(\ud835\udd5c\\), the set \\(-s\\) (which is the set of all elements of \\(s\\) multiplied by -1) is balanced over the field \\(\ud835\udd5c\\) if and only if the set \\(s\\) itself is balanced over the field \\(\ud835\udd5c\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem balanced_neg : Balanced \ud835\udd5c (-s) \u2194 Balanced \ud835\udd5c s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `boxes`, which maps a prepartition of a set to a finite set of boxes, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem injective_boxes : Function.Injective (boxes : Prepartition I \u2192 Finset (Box \u03b9)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' over a field '\ud835\udd5c' is balanced if and only if the set 's' contains all scalar multiples of its elements by scalars from the closed unit ball centered at 0 in '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem balanced_iff_closedBall_smul : Balanced \ud835\udd5c s \u2194 Metric.closedBall (0 : \ud835\udd5c) 1 \u2022 s \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a box J belongs to the set of boxes of a partition \u03c0 if and only if J belongs to the partition \u03c0 itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_boxes : J \u2208 \u03c0.boxes \u2194 J \u2208 \u03c0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of boxes of the top element in the prepartition of a set I is equal to the set containing only I.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem top_boxes : (\u22a4 : Prepartition I).boxes = {I} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any index set 'I', the indexed union of the top element of the prepartition of 'I' is equal to the index set 'I' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iUnion_top : (\u22a4 : Prepartition I).iUnion = I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that no element belongs to the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_mem_bot : J \u2209 (\u22a5 : Prepartition I) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) belongs to the union of a family of sets \\( \\pi \\) if and only if there exists a set \\( J \\) in the family \\( \\pi \\) such that \\(x\\) belongs to \\( J \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_iUnion : x \u2208 \u03c0.iUnion \u2194 \u2203 J \u2208 \u03c0, x \u2208 J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any interval \\(I\\), the lower bound of \\(I\\) is less than or equal to the upper bound of \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lower_le_upper : I.lower \u2264 I.upper :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the union of all sets within a family of sets `\u03c0` is the same as taking the union of all elements `J` in `\u03c0`, where each `J` is lifted to be a set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iUnion_def : \u03c0.iUnion = \u22c3 J \u2208 \u03c0, \u2191J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is integrable over a region \\( I \\) with integral value \\( y \\) if and only if for any positive error margin, we can find a way to partition \\( I \\) into smaller regions such that the Riemann sum of \\( f \\) over these subregions is arbitrarily close to \\( y \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasIntegral_iff : HasIntegral I l f vol y \u2194\n    \u2200 \u03b5 > (0 : \u211d), \u2203 r : \u211d\u22650 \u2192 \u211d\u207f \u2192 Ioi (0 : \u211d), (\u2200 c, l.RCond (r c)) \u2227\n      \u2200 c \u03c0, l.MemBaseSet I c (r c) \u03c0 \u2192 IsPartition \u03c0 \u2192 dist (integralSum f vol \u03c0) y \u2264 \u03b5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any interval \\(I\\), there exists an element \\(x\\) that belongs to \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_mem : \u2203 x, x \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of boxes of the bottom element (\u22a5) in the prepartition of any set I is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_boxes : (\u22a5 : Prepartition I).boxes = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the indexed union of an empty prepartition is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iUnion_bot : (\u22a5 : Prepartition I).iUnion = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function *x* is an element of the set *I*, where *I* is a set of functions from  *\u03b9* to real numbers (\u211d), if and only if *x* is an element of *I*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_coe : x \u2208 (I : Set (\u03b9 \u2192 \u211d)) \u2194 x \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any interval \\(I\\), the upper bound of \\(I\\) is an element of \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem upper_mem : I.upper \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the indexed union of a family of sets is empty if and only if the family of sets itself is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iUnion_eq_empty : \u03c0\u2081.iUnion = \u2205 \u2194 \u03c0\u2081 = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a point belongs to an interval if and only if each of its coordinates lies within the corresponding lower and upper bounds of that interval.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_def : x \u2208 I \u2194 \u2200 i, x i \u2208 Ioc (I.lower i) (I.upper i) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets I and J,  I is a subset of J ( I \u2264 J) if and only if every element x in set I is also an element of set J.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_def : I \u2264 J \u2194 \u2200 x \u2208 I, x \u2208 J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all functions from \u03b9 to the set of real numbers (\u211d) is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_coe : Set.Nonempty (I : Set (\u03b9 \u2192 \u211d)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set of functions from an arbitrary type  \\( \\iota \\) to real numbers (\\( \\mathbb{R} \\)) is equivalent to a specific construction of a \"product set\" (a set of tuples) where each component of the tuple corresponds to a function's output for a specific input from \\( \\iota \\), bounded by the lower and upper bounds of the function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_eq_pi : (I : Set (\u03b9 \u2192 \u211d)) = pi univ fun i \u21a6 Ioc (I.lower i) (I.upper i) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all functions from a set  '\u03b9' to the set of real numbers '\u211d' is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ne_empty : (I : Set (\u03b9 \u2192 \u211d)) \u2260 \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that defining an interval `Icc` using the `Box` type is equivalent to defining it directly using its lower and upper bounds.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc_def : Box.Icc I = Icc I.lower I.upper :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an interval defined as a \"box\" in a multi-dimensional space is equivalent to the Cartesian product of individual intervals for each dimension.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc_eq_pi : Box.Icc I = pi univ fun i \u21a6 Icc (I.lower i) (I.upper i) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real number intervals I and J, I is less than or equal to J if and only if the closed interval from negative infinity to I is a subset of the closed interval from negative infinity to J.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_iff_Icc : I \u2264 J \u2194 Box.Icc I \u2286 Box.Icc J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is not equal to the set of all functions from an arbitrary type  '\u03b9' to the set of real numbers '\u211d'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem empty_ne_coe : \u2205 \u2260 (I : Set (\u03b9 \u2192 \u211d)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that for any two sets I and J, where each element in I and J is a function from a set \u03b9 to the set of real numbers, I is a subset of J if and only if I is less than or equal to J.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_subset_coe : (I : Set (\u03b9 \u2192 \u211d)) \u2286 J \u2194 I \u2264 J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the lower bound of a box is antitone. In other words, for any two boxes, if the first box is contained within the second box, then the lower bound of the second box is less than or equal to the lower bound of the first box.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_lower : Antitone fun I : Box \u03b9 \u21a6 I.lower :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two intervals I and J, I is a subset of J (i.e., I \u2264 J) if and only if the lower bound of J is less than or equal to the lower bound of I, and the upper bound of I is less than or equal to the upper bound of J.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_iff_bounds : I \u2264 J \u2194 J.lower \u2264 I.lower \u2227 I.upper \u2264 J.upper :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets, I and J, which are sets of functions from a set \u03b9 to the set of real numbers, are equal if and only if their corresponding subtypes are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_inj : (I : Set (\u03b9 \u2192 \u211d)) = J \u2194 I = J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any index set `\u03b9`, the function that maps each box (a closed interval) in `\u03b9` to its upper bound is monotone. In simpler terms, we need to show that for any two boxes, if the first box is entirely contained within the second box, then the upper bound of the first box is less than or equal to the upper bound of the second box.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_upper : Monotone fun I : Box \u03b9 \u21a6 I.upper :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any interval I, if we convert it to a hypercube with the same bounds, then the original interval is a subset of the hypercube.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_subset_Icc : \u2191I \u2286 Box.Icc I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the absolute value function is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that calculates the square of the norm of a vector is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_normSq : Continuous normSq :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the neighborhood of 0 under the absolute value function is the same as the neighborhood of 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_abs_nhds_zero : comap abs (\ud835\udcdd 0) = \ud835\udcdd 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `equivRealProd`, which maps a pair of real numbers to a single real number, is anti-Lipschitz with constant \u221a2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antilipschitz_equivRealProd : AntilipschitzWith (NNReal.sqrt 2) equivRealProd :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the bottom element (\u22a5) of the type `WithBot (Box \u03b9)` corresponds to the empty set when interpreted as a set of functions from `\u03b9` to `\u211d`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : ((\u22a5 : WithBot (Box \u03b9)) : Set (\u03b9 \u2192 \u211d)) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the standard bijection between the set of real numbers and the set of pairs of real numbers is a uniform embedding.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniformEmbedding_equivRealProd : UniformEmbedding equivRealProd :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the square of the magnitude of complex numbers tends to infinity as the complex numbers themselves grow infinitely large within a bounded region.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_normSq_cocompact_atTop : Tendsto normSq (cocompact \u2102) atTop :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that maps a closed interval of real numbers to the set of functions whose range lies within that interval is injective. In simpler terms, if two intervals map to the same set of functions, then the intervals must be the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem injective_coe : Injective ((\u2191) : Box \u03b9 \u2192 Set (\u03b9 \u2192 \u211d)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the absolute value of complex numbers tends to infinity as the complex numbers approach infinity in a way that avoids neighborhoods of the origin.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_abs_cocompact_atTop : Tendsto abs (cocompact \u2102) atTop :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `equivRealProd`, which maps a pair of real numbers to a single real number, is Lipschitz continuous with Lipschitz constant 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lipschitz_equivRealProd : LipschitzWith 1 equivRealProd :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complex number 0, when considered as an element within the set of complex numbers (\u2102), is equal to the complex number 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : ((0 : \ud835\udd3b) : \u2102) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that converts a dual number to a complex number is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Injective ((\u2191) : \ud835\udd3b \u2192 \u2102) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set  's' is convex if and only if for any two non-negative numbers 'a' and 'b' that sum to 1, any linear combination of elements from 's' with weights 'a' and 'b' is also in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_iff_pointwise_add_subset :\n    Convex \ud835\udd5c s \u2194 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 s + b \u2022 s \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the entire space (the universe of all points) is convex.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_univ : Convex \ud835\udd5c (Set.univ : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set  's' is convex if and only if, for any two points 'x' and 'y' in the set, the line segment connecting 'x' and 'y' is entirely contained within the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_iff_segment_subset : Convex \ud835\udd5c s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 [x -[\ud835\udd5c] y] \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that as natural numbers \\(n\\) grow infinitely large, their reciprocals \\( \\frac{1}{n} \\), when considered as real numbers, approach 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_inverse_atTop_nhds_zero_nat : Tendsto (fun n : \u2115 \u21a6 (n : \u211d)\u207b\u00b9) atTop (\ud835\udcdd 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set  's' is convex if and only if for any two points 'x' and 'y' in the set, any linear combination of 'x' and 'y' with positive coefficients that sum to 1 is also in the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_iff_forall_pos :\n    Convex \ud835\udd5c s \u2194\n      \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set  's' is convex if and only if for any two points 'x' and 'y' in the set, the open line segment between 'x' and 'y' is entirely contained within the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_iff_openSegment_subset :\n    Convex \ud835\udd5c s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 openSegment \ud835\udd5c x y \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conjugate of the complex number 0 is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem conj_zero : conj 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sequence {1/(n+1)} approaches 0 as n approaches infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_one_div_add_atTop_nhds_zero_nat :\n    Tendsto (fun n : \u2115 \u21a6 1 / ((n : \u211d) + 1)) atTop (\ud835\udcdd 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set  's' over a field '\ud835\udd5c' is convex if and only if for any two distinct points 'x' and 'y' in 's', all points on the line segment connecting 'x' and 'y' are also in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_iff_pairwise_pos : Convex \ud835\udd5c s \u2194\n    s.Pairwise fun x y => \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the set of all convex sets in a vector space E over a field \ud835\udd5c is the same as considering the convex add submonoid generated by E.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_convexAddSubmonoid : \u2191(convexAddSubmonoid \ud835\udd5c E) = {s : Set E | Convex \ud835\udd5c s} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a point *x* is a vertex of a simplicial complex *K* if and only if the set containing only *x* is a face of *K*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_vertices : x \u2208 K.vertices \u2194 {x} \u2208 K.faces :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of vertices of a simplicial complex K is equal to the union of all its faces.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vertices_eq : K.vertices = \u22c3 k \u2208 K.faces, (k : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that all facets of a polytope K are also faces of K.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem facets_subset : K.facets \u2286 K.faces :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(I\\) and \\(J\\) represent sets of real-valued functions defined on some domain  \\(\u03b9\\). Prove that the following statements are equivalent:\n1. \\(I\\) is a subset of \\(J\\) when viewed as sets of functions.\n2. \\(I\\) is a subset of \\(J\\) when viewed as sets of points in a function space.\n3. The interval enclosure of \\(I\\) is a subset of the interval enclosure of \\(J\\).\n4. The lower bound of \\(J\\) is less than or equal to the lower bound of \\(I\\), and the upper bound of \\(I\\) is less than or equal to the upper bound of \\(J\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_TFAE : List.TFAE [I \u2264 J, (I : Set (\u03b9 \u2192 \u211d)) \u2286 J,\n    Icc I.lower I.upper \u2286 Icc J.lower J.upper, J.lower \u2264 I.lower \u2227 I.upper \u2264 J.upper] :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the top element of a convex cone to a set results in the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_top : \u2191(\u22a4 : ConvexCone \ud835\udd5c E) = (univ : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of points belonging to both convex cone S and convex cone T is equal to the intersection of the set of points in S and the set of points in T.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_inf : ((S \u2293 T : ConvexCone \ud835\udd5c E) : Set E) = \u2191S \u2229 \u2191T :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of vertices of a convex set K is a subset of the space containing K.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vertices_subset_space : K.vertices \u2286 K.space :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the smallest convex cone over a vector space E, when viewed as a set, is actually the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : \u2191(\u22a5 : ConvexCone \ud835\udd5c E) = (\u2205 : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set S in a vector space E over a field \ud835\udd5c is convex.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex : Convex \ud835\udd5c (S : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the exponential function (exp) is strictly convex on the set of all real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictConvexOn_exp : StrictConvexOn \u211d univ exp :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is a facet of a polytope 'K' if and only if 's' is a face of 'K' and no other face of 'K' contains 's' as a proper subset.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_facets : s \u2208 K.facets \u2194 s \u2208 K.faces \u2227 \u2200 t \u2208 K.faces, s \u2286 t \u2192 s = t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the result of applying a linear transformation 'f' to a vector 'x' is less than or equal to the product of the operator norm of 'f' and the norm of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_opNorm : \u2016f x\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the exponential function (exp) is convex over the set of all real numbers (\u211d).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convexOn_exp : ConvexOn \u211d univ exp :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operator norm of the zero linear map between two normed spaces is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem opNorm_zero : \u2016(0 : E \u2192SL[\u03c3\u2081\u2082] F)\u2016 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithmic function (log) is strictly concave on the set of positive real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictConcaveOn_log_Ioi : StrictConcaveOn \u211d (Ioi 0) log :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number of elements in the language L is equal to the sum of the number of functions and the number of relations in L.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_eq_card_functions_add_card_relations :\n    L.card =\n      (Cardinal.sum fun l => Cardinal.lift.{v} #(L.Functions l)) +\n        Cardinal.sum fun l => Cardinal.lift.{u} #(L.Relations l) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the identity linear transformation on a normed vector space E is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_id_le : \u2016id \ud835\udd5c E\u2016 \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the logarithm function (log) is strictly concave on the set of negative real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictConcaveOn_log_Iio : StrictConcaveOn \u211d (Iio 0) log :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven three sets `a\u2080`, `a\u2081`, and `a\u2082`, prove that the sum of the sizes of all possible sequences formed by taking elements from these sets is equal to the sum of the sizes of the individual sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sum_card : Cardinal.sum (fun i => #(Sequence\u2082 a\u2080 a\u2081 a\u2082 i)) = #a\u2080 + #a\u2081 + #a\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conjugate operation (denoted by *) on elements of a space E (e.g., complex numbers) is an isometry.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_isometry : Isometry (star : E \u2192 E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the language of rings has exactly 5 symbols.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_ring : card Language.ring = 5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is an upper set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_empty : IsUpperSet (\u2205 : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all elements, denoted as \"univ\", is an upper set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_univ : IsUpperSet (univ : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is a lower set if and only if the preimage of 's' under the `ofDual` function is an upper set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_preimage_ofDual_iff : IsUpperSet (ofDual \u207b\u00b9' s) \u2194 IsLowerSet s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is a lower set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_empty : IsLowerSet (\u2205 : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is an upper set if and only if the preimage of 's' under the 'ofDual' function is a lower set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_preimage_ofDual_iff : IsLowerSet (ofDual \u207b\u00b9' s) \u2194 IsUpperSet s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all numbers greater than a particular number 'a' is an upper set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_Ioi : IsUpperSet (Ioi a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all elements (the universal set, denoted as \"univ\") is a lower set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_univ : IsLowerSet (univ : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of a set \\(s\\) is a lower set if and only if the set \\(s\\) itself is an upper set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_compl : IsLowerSet s\u1d9c \u2194 IsUpperSet s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a point \\(x\\) belongs to the space defined by a polytope \\(K\\) if and only if there exists a face \\(s\\) of the polytope \\(K\\) such that \\(x\\) lies within the convex hull of the points in \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_space_iff : x \u2208 K.space \u2194 \u2203 s \u2208 K.faces, x \u2208 convexHull \ud835\udd5c (s : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all numbers greater than or equal to a given number 'a' is an upper set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_Ici : IsUpperSet (Ici a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two numbers 'a' and 'b', prove that  'a' being less than or equal to both 'a' and 'b' is the same as 'a' being less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_himp_iff_left : a \u2264 a \u21e8 b \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is an upper set if and only if for every element 'a' in 's', the set of all elements greater than or equal to 'a' is a subset of 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_iff_Ici_subset : IsUpperSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Ici a \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three elements \\( a \\), \\( b \\), and \\( c \\) in a generalized Heyting algebra, \\( a \\) being less than or equal to \\( b \\) implies \\( c \\) is equivalent to the meet of \\( a \\) and \\( b \\) being less than or equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_himp_iff : a \u2264 b \u21e8 c \u2194 a \u2293 b \u2264 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all numbers less than or equal to a given number 'a' forms a lower set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_Iic : IsLowerSet (Iic a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all numbers strictly less than a given number 'a' forms a lower set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_Iio : IsLowerSet (Iio a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is a lower set if and only if, for every element 'a' in 's', the initial interval below 'a' is a subset of 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLowerSet_iff_Iic_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iic a \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any three numbers a, b, and c, prove that \"if a is less than or equal to b, then c is true\" is logically equivalent to \"if b is less than or equal to a, then c is true.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_himp_comm : a \u2264 b \u21e8 c \u2194 b \u2264 a \u21e8 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of a set \\(s\\) is an upper set if and only if the set \\(s\\) itself is a lower set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUpperSet_compl : IsUpperSet s\u1d9c \u2194 IsLowerSet s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set `s` is an element of the set `f.sets` if and only if `s` is an element of `f`, where `f` represents a family of sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sets : s \u2208 f.sets \u2194 s \u2208 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have both \"a implies b\" and \"a\", then we can conclude \"b\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem himp_inf_le : (a \u21e8 b) \u2293 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets,  \\( f \\) and \\( g \\), are equal if and only if they contain exactly the same elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff : f = g \u2194 \u2200 s, s \u2208 f \u2194 s \u2208 g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two filters \\( f \\) and \\( g \\) on a given set, if the sets of \\( f \\) are equal to the sets of \\( g \\), then the filters \\( f \\) and \\( g \\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem filter_eq : \u2200 {f g : Filter \u03b1}, f.sets = g.sets \u2192 f = g\n  | \u27e8_, _, _, _\u27e9, \u27e8_, _, _, _\u27e9, rfl => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two filters are equal if and only if the sets they contain are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem filter_eq_iff : f = g \u2194 f.sets = g.sets :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any proposition 'a' implies itself, resulting in a tautology (represented by '\u22a4').\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem himp_self : a \u21e8 a = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two sets, let's say  'f' and 'g', have the exact same elements, then the sets 'f' and 'g' are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext : (\u2200 s, s \u2208 f \u2194 s \u2208 g) \u2192 f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is antitone on a set \\(s\\) if and only if the composition of \\(f\\) with the duality function (denoted by \\(ofDual\\)) is monotone on the same set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotoneOn_comp_ofDual_iff : MonotoneOn (f \u2218 ofDual) s \u2194 AntitoneOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is antitone on a set \\(s\\) if and only if the composition of \\(f\\) and the duality function (which reverses the order) is monotone on the same set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotoneOn_toDual_comp_iff : MonotoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 AntitoneOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider two ordered sets and a function \\(f\\) between them. Prove that the function \\(f\\) is antitone (order-reversing) if and only if composing \\(f\\) with the duality function (which reverses the order) results in a monotone (order-preserving) function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_comp_ofDual_iff : Monotone (f \u2218 ofDual) \u2194 Antitone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there exists an element 't' in a set 'f' such that 't' is a subset of 's', if and only if 's' is an element of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_mem_subset_iff : (\u2203 t \u2208 f, t \u2286 s) \u2194 s \u2208 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet f be a function between two partially ordered sets. Prove that the function f is monotone if and only if the function (f \u2218 ofDual) is antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_comp_ofDual_iff : Antitone (f \u2218 ofDual) \u2194 Monotone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is monotone if and only if the composition of \\( f \\) and the duality function (which reverses the order of elements) is antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_toDual_comp_iff : Antitone (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 Monotone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is antitone if and only if the composition of the function \\( toDual \\) with \\( f \\) is monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_toDual_comp_iff : Monotone (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 Antitone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` is monotone on a set `s` if and only if the composition of `f` and the duality function `toDual` is antitone on the same set `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitoneOn_toDual_comp_iff : AntitoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is strictly antitone if and only if the composition of \\( f \\) with the duality function is strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f \u2218 ofDual) \u2194 StrictAnti f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function and \\(s\\) be a set. Prove that  \\(f\\) is monotone on \\(s\\) if and only if the composition of \\(f\\) and the dual function is antitone on \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitoneOn_comp_ofDual_iff : AntitoneOn (f \u2218 ofDual) s \u2194 MonotoneOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` is strictly antitone if and only if the composition of `f` and the duality function (`toDual`) is strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMono_toDual_comp_iff : StrictMono (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictAnti f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function and \\(s\\) be a set. Prove that \\(f\\) is strictly antitone on \\(s\\) if and only if the composition of \\(f\\) and the dual order function (which reverses the order of its arguments) is strictly monotone on \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMonoOn_comp_ofDual_iff : StrictMonoOn (f \u2218 ofDual) s \u2194 StrictAntiOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function *f* is strictly monotone if and only if the composition of *f* and the duality function (which reverses the order) is strictly antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAnti_toDual_comp_iff : StrictAnti (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictMono f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to reverse the order of things (like flipping a list backwards), which we'll call \"ofDual\".  Prove that composing a function \"f\" with this reversing operation (\"ofDual\") results in a strictly anti-monotonic function if and only if the original function \"f\" is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAnti_comp_ofDual_iff : StrictAnti (f \u2218 ofDual) \u2194 StrictMono f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is strictly monotonically increasing on a set \\( s \\) if and only if the composition of \\( f \\) with the duality function (which reverses the order of elements) is strictly anti-monotonic on \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f \u2218 ofDual) s \u2194 StrictMonoOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function *f* is monotonic if and only if the function obtained by first reversing the order in both the input and output sets, applying *f*, and then reversing the order again is also monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_dual_iff : Monotone (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 Monotone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function 'f' is strictly monotone on a set 's' if and only if the composition of 'toDual' and 'f' is strictly antitone on the same set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAntiOn_toDual_comp_iff : StrictAntiOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictMonoOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is antitone (order-reversing) on a set \\(s\\) if and only if the dual of \\(f\\) is antitone on the dual of the set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitoneOn_dual_iff : AntitoneOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 AntitoneOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` is strictly antitone on a set `s` if and only if the composition of `f` and the duality function (`toDual`) is strictly monotone on the same set `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMonoOn_toDual_comp_iff : StrictMonoOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictAntiOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is monotone (increasing) on a set \\(s\\) if and only if its \"dual function\" is also monotone on the \"dual set\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotoneOn_dual_iff : MonotoneOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) between two sets is strictly monotone if and only if the composition of \\( f \\) with the duality functions (which reverse the order of elements) is also strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMono_dual_iff : StrictMono (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictMono f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\)  is strictly antitone if and only if the function obtained by first mapping from the dual of the input to the input, then applying \\( f \\), and finally mapping from the output to the dual of the output is also strictly antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAnti_dual_iff : StrictAnti (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictAnti f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is strictly monotone on a set \\(s\\) if and only if the dual of \\(f\\) is strictly monotone on the dual of \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMonoOn_dual_iff :\n    StrictMonoOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictMonoOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is antitone (order-reversing) if and only if the composition of \\(f\\) with the duality functions is also antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_dual_iff : Antitone (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 Antitone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a function 'f' that takes elements from a set 'r' to another set 's'. We also know that 'f' is an injection, meaning it maps distinct elements in 'r' to distinct elements in 's'. This injection 'f', along with the proof of its injective property 'h', can be viewed as a structure, denoted by \u27e8f, h\u27e9. This structure essentially represents an injective function from 'r' to 's'. Now, applying this structure \u27e8f, h\u27e9 to an element in 'r' is the same as just applying the function 'f' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mk : \u21d1(\u27e8f, h\u27e9 : r \u21aar s) = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function `f` that embeds the elements of a set `r` into another set `s`, converting this function into an \"embedding function\" and then treating it as a regular function from `\u03b1` to `\u03b2` results in the same original function `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toEmbedding : ((f : r \u21aar s).toEmbedding : \u03b1 \u2192 \u03b2) = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\(a\\), the successor of  \\(a\\) is less than or equal to \\(a\\) if and only if \\(a\\) is the largest natural number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succ_le_iff_isMax : succ a \u2264 a \u2194 IsMax a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `s` and a number `a`, `a` is an upper bound of `s` if and only if every element in `s` is less than or equal to `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_upperBounds : a \u2208 upperBounds s \u2194 \u2200 x \u2208 s, x \u2264 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that maps a function `f` from one set to another to its underlying representation as a function from a type `\u03b1` to a type `\u03b2` is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_fn_injective : Injective fun (f : r \u2192r s) => (f : \u03b1 \u2192 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that maps an injective function to itself (but viewed as a regular function) is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_fn_injective : Injective fun f : r \u21aar s => (f : \u03b1 \u2192 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is bounded below if and only if there exists a number 'x' such that 'x' is less than or equal to every element 'y' in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bddBelow_def : BddBelow s \u2194 \u2203 x, \u2200 y \u2208 s, x \u2264 y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is bounded above if and only if there exists a number 'x' such that 'x' is greater than or equal to every element in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bddAbove_def : BddAbove s \u2194 \u2203 x, \u2200 y \u2208 s, y \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` is strictly antitone on a set `s` if and only if the dual of `f` is strictly antitone on the dual of `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAntiOn_dual_iff :\n    StrictAntiOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictAntiOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a' and set 's', 'a' is a lower bound of 's' if and only if 'a' is less than or equal to every element in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_lowerBounds : a \u2208 lowerBounds s \u2194 \u2200 x \u2208 s, a \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number `a`, prove that `a` is less than its successor (`succ a`) if and only if `a` is not the largest natural number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_succ_iff_not_isMax : a < succ a \u2194 \u00acIsMax a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet f, f', and g be functions such that the outputs of f and f' can be subtracted, and the outputs of f and f' are valid inputs to g.  Prove that composing the difference of f and f' with g is the same as composing f and f' with g separately and then taking the difference of the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_comp : (f - f') \u226b g = f \u226b g - f' \u226b g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the \"whiskering\" operation to the \"preadditive Yoneda embedding\" results in the standard Yoneda embedding.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem whiskering_preadditiveYoneda :\n    preadditiveYoneda \u22d9\n        (whiskeringRight C\u1d52\u1d56 AddCommGroupCat (Type v)).obj (forget AddCommGroupCat) =\n      yoneda :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `i` has the lifting property with respect to a function `p` if and only if the opposite function of `p` has the lifting property with respect to the opposite function of `i`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iff_op : HasLiftingProperty i p \u2194 HasLiftingProperty p.op i.op :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing the negations of two functions, `f` and `g`, is the same as composing the original functions `f` and `g`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_comp_neg : (-f) \u226b (-g) = f \u226b g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any morphism 'f' in category 'C', there exists an image factorization of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasImages : HasImages C :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\), \\(g\\), and \\(g'\\) be functions such that the outputs of \\(g\\) and \\(g'\\) can be meaningfully subtracted, and the output of \\(g - g'\\) can be used as input for \\(f\\). Prove that composing \\(f\\) with the difference of \\(g\\) and \\(g'\\) is the same as composing \\(f\\) with \\(g\\) and \\(f\\) with \\(g'\\) separately and then taking the difference of the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_sub : f \u226b (g - g') = f \u226b g - f \u226b g' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any functions \\( f \\) and \\( g \\),  negating the function \\( f \\) before composing it with \\( g \\) is the same as negating the result of composing \\( f \\) with \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_comp : (-f) \u226b g = -f \u226b g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given two functions \\(f\\) and \\(g\\) from a set to itself, composing \\(f\\) with the negation of \\(g\\) is the same as composing the negation of \\(f\\) with \\(g\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_neg : f \u226b (-g) = -f \u226b g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the differential map `d` in the complex of inhomogeneous cochains is equivalent to the differential map in the homogeneous `linearYonedaObjResolution`, considering the isomorphism between the function space `Fun(G\u207f, A)` and the homomorphism space `Hom(k[G\u207f\u207a\u00b9], A)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem that our isomorphism `Fun(G\u207f, A) \u2245 Hom(k[G\u207f\u207a\u00b9], A)` (where the righthand side is\nmorphisms in `Rep k G`) commutes with the differentials in the complex of inhomogeneous cochains\nand the homogeneous `linearYonedaObjResolution`. -/\n@[nolint checkType] theorem d_eq :\n    d n A =\n      (diagonalHomEquiv n A).toModuleIso.inv \u226b\n        (linearYonedaObjResolution A).d n (n + 1) \u226b\n          (diagonalHomEquiv (n + 1) A).toModuleIso.hom :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a linear map \u03c1 to an algebra homomorphism and then lifting it to a group homomorphism is the same as directly lifting \u03c1 to a group homomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem asAlgebraHom_def : asAlgebraHom \u03c1 = (lift k G _) \u03c1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two games \\( x \\) and \\( y \\), \\( x \\) is not less than or equal to \\( y \\) if and only if \\( y \\) is strictly less than \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_le : \u2200 {x y : Game}, \u00acx \u2264 y \u2194 y \u29cf x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the type of the empty relation on the unit type has exactly one element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem type_pUnit : type (@EmptyRelation PUnit) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a two-player combinatorial game, if the second player has a winning strategy when starting from position 'b' and the first player starts from position 'c', then for any position 'a', the second player still has a winning strategy when starting from position 'b + a' given that the first player starts from position 'c + a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_lf_add_right : \u2200 {b c : Game} (_ : b \u29cf c) (a), (b + a : Game) \u29cf c + a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the type of the empty relation on the empty set is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem type_pEmpty : type (@EmptyRelation PEmpty) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets of sets are equivalent if and only if there exists a one-to-one correspondence between their elements, where two sets are considered equivalent if they have the same elements up to equivalence of their corresponding elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equiv_iff :\n    \u2200 {x y : PSet},\n      Equiv x y \u2194 (\u2200 i, \u2203 j, Equiv (x.Func i) (y.Func j)) \u2227 \u2200 j, \u2203 i, Equiv (x.Func i) (y.Func j)\n  | \u27e8_, _\u27e9, \u27e8_, _\u27e9 => Iff.rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two games, x and y, x is not greater than or equal to y if and only if y is less than or equal to x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_lf : \u2200 {x y : Game}, \u00acx \u29cf y \u2194 y \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set membership relation (`\u2208`) is well-founded on the type of all sets (`PSet`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_wf : @WellFounded PSet (\u00b7 \u2208 \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the type of the empty relation on the empty set has zero elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem type_empty : type (@EmptyRelation Empty) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the type of the empty relation on the unit type has only one element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem type_unit : type (@EmptyRelation Unit) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a certain game, we denote games as 'a', 'b', 'c', etc., and use the symbol  '\u29cf' to indicate that the first game is better for the left player than the second game. Prove that if game 'b' is better for the left player than game 'c', then adding any other game 'a' to both 'b' and 'c' will still make 'a + b' better for the left player than 'a + c'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_lf_add_left : \u2200 {b c : Game} (_ : b \u29cf c) (a), (a + b : Game) \u29cf a + c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that, given an adjunction between categories, applying the unit of the adjunction and then the counit in the appropriate way results in the identity morphism.  This is often visualized as part of a \"triangle\" of morphisms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_triangle : whiskerRight adj.unit F \u226b whiskerLeft F adj.counit = \ud835\udfd9 _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 0 is a \"Numeric\" value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem numeric_zero : Numeric 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number 1 can be represented as a \"Numeric\" data structure.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem numeric_one : Numeric 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in category theory, given an adjunction between functors, a specific composition of natural transformations involving the unit and counit of the adjunction results in the identity natural transformation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_triangle : whiskerLeft G adj.unit \u226b whiskerRight adj.counit G = \ud835\udfd9 _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a monad `T`, when converted to a functor using `toFunctor`, is equal to itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monad_toFunctor_eq_coe : T.toFunctor = T :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing the preadditive coyoneda functor with a specific whiskering functor is equivalent to the regular coyoneda functor.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem whiskering_preadditiveCoyoneda :\n    preadditiveCoyoneda \u22d9\n        (whiskeringRight C AddCommGroupCat (Type v)).obj (forget AddCommGroupCat) =\n      coyoneda :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two types, lifting a value to the type with the larger universe level is equivalent to lifting it to the type with the smaller universe level.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift_umax : lift.{max u v, u} = lift.{v, u} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven an adjunction between two functors, prove that applying the functor to the unit of the adjunction followed by the counit of the adjunction results in the identity morphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_triangle_components :\n    F.map (adj.unit.app X) \u226b adj.counit.app (F.obj X) = \ud835\udfd9 (F.obj X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine two functors, G and the identity functor (which maps objects and morphisms to themselves), between categories C and D.  Given an adjunction between these functors, prove that applying the unit of the adjunction to an object Y in D, then applying G to the counit of the adjunction at Y, is equivalent to the identity morphism on G(Y).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_triangle_components :\n    adj.unit.app (G.obj Y) \u226b G.map (adj.counit.app Y) = \ud835\udfd9 (G.obj Y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the left composition of two functions is associative.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_left : (f \u226b g).left = f.left \u226b g.left :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in category theory, for any object X, the right component of the identity morphism on X (considered as a morphism in the comma category over X) is equal to the identity morphism on X itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_right : (\ud835\udfd9 X : CommaMorphism X X).right = \ud835\udfd9 X.right :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type \u03c3, there exists an injection from \u03c3 to the type of cardinal numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_embedding_to_cardinal : Nonempty (\u03c3 \u21aa Cardinal.{u}) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the right composition of the right composition of two functions f and g is equivalent to the right composition of the right composition of f and the right composition of g.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_right : (f \u226b g).right = f.right \u226b g.right :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in category theory, the left component of the identity morphism on an object X, viewed as a morphism in the comma category, is equal to the identity morphism on the left object X.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_left : (\ud835\udfd9 X : CommaMorphism X X).left = \ud835\udfd9 X.left :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any monomial with all exponents equal to zero is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monomial_zero_one : monomial R (0 : \u03c3 \u2192\u2080 \u2115) 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero element (represented as 0) of a module \u03b1 is always a member of any submodule I of \u03b1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mem : (0 : \u03b1) \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a category C is idempotent complete if and only if its opposite category C\u1d52\u1d56 is idempotent complete.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isIdempotentComplete_iff_opposite : IsIdempotentComplete C\u1d52\u1d56 \u2194 IsIdempotentComplete C :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two objects X and Y in a category C, there exists an object Z and morphisms f: X \u2192 Z and g: Y \u2192 Z.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cocone_objs : \u2200 X Y : C, \u2203 (Z : _) (f : X \u27f6 Z) (g : Y \u27f6 Z), True :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any formal power series \u03c6 with coefficients in a ring R, multiplying \u03c6 by the zero power series results in the zero power series.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mul : (0 : MvPowerSeries \u03c3 R) * \u03c6 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn the context of polynomials with coefficients from a set R, prove that the coefficient of the monomial 1 (representing the constant term) in the zero polynomial is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_zero_one : coeff R (0 : \u03c3 \u2192\u2080 \u2115) 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of any polynomial \u03c6 and the zero polynomial is equal to the zero polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_zero : \u03c6 * 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the span of the universal set (the set containing all elements of a vector space) is equal to the entire vector space itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_univ : span (Set.univ : Set \u03b1) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that multiplying any formal power series \u03c6 by the constant power series 1 results in the same power series \u03c6.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_mul : (1 : MvPowerSeries \u03c3 R) * \u03c6 = \u03c6 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two equivalent sets, if one set is well-founded under the membership relation, then the other set is also well-founded under the membership relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_wf_aux : \u2200 {x y : PSet.{u}}, Equiv x y \u2192 Acc (\u00b7 \u2208 \u00b7) y\n  | \u27e8\u03b1, A\u27e9, \u27e8\u03b2, B\u27e9, H =>\n    \u27e8_, by\n      rintro \u27e8\u03b3, C\u27e9 \u27e8b, hc\u27e9\n      cases' H.exists_right b with a ha\n      have H :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nA quiver (or directed graph) is considered \"thin\" if there is at most one arrow between any two objects (vertices). Prove that a quiver C is thin if and only if for every object c in C, the collection of arrows from c to itself has at most one element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isThin_iff : Quiver.IsThin C \u2194 \u2200 c : C, Subsingleton (c \u27f6 c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\( b \\) in a submodule \\( I \\), the product of \\( b \\) with any element \\( a \\) is also in the submodule \\( I \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_mem_left : b \u2208 I \u2192 a * b \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the span of the empty set is equal to the smallest subspace, denoted by \u22a5.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_zero : span (0 : Set \u03b1) = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the span of the empty set is equal to the smallest submodule containing the empty set, denoted by \u22a5.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_empty : span (\u2205 : Set \u03b1) = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set `I` is equal to the universal set (the set containing all elements) if and only if the multiplicative identity element, 1, is in the set `I`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_top_iff_one : I = \u22a4 \u2194 (1 : \u03b1) \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a linear map \\(v\\) from a ring \\(R\\) to a module \\(\u0393\u2080\\) into a function and then applying it is equivalent to applying \\(v\\) directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\( a \\) and \\( b \\) are elements of some set \\( I \\), which is a submodule, then \\( a + b \\) is also an element of \\( I \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_mem : a \u2208 I \u2192 b \u2208 I \u2192 a + b \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(I\\) which is a subset of some larger set \\(\u03b1\\),  \\(I\\) is not equal to the set \\(\u03b1\\) if and only if the element \\(1\\) (considered as an element of \\(\u03b1\\)) is not in the set \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_top_iff_one : I \u2260 \u22a4 \u2194 (1 : \u03b1) \u2209 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a structure 'v' that can be applied to numbers, and assuming 'v' preserves multiplication, prove that applying 'v' to the number 1 results in 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_one : v 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the span of the singleton set containing only the element 1 is equal to the entire set \u03b1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_one : span (1 : Set \u03b1) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a linear map \\(v\\) (a function that preserves addition and scalar multiplication), prove that \\(v(0) = 0\\), where 0 on both sides represents the zero vector in their respective vector spaces.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_zero : v 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers x and y, applying the function 'v' to the product of x and y is the same as multiplying the result of applying 'v' to x and 'v' to y separately.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_mul : \u2200 x y, v (x * y) = v x * v y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the largest element in the lattice of ideals of a module is a compact element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCompactElement_top : CompleteLattice.IsCompactElement (\u22a4 : Ideal \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the span of the singleton set containing only the element 1 is equal to the entire vector space (denoted by \u22a4).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_singleton_one : span ({1} : Set \u03b1) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any subset \\(I\\) of a vector space, the span of \\(I\\) is equal to \\(I\\) itself if and only if \\(I\\) is already a subspace.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_eq : span (I : Set \u03b1) = I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function 'v' that assigns a numerical value to things. Prove that for any two things, 'x' and 'y', the value assigned by 'v' to the combination of 'x' and 'y' is less than or equal to the larger individual value assigned to either 'x' or 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function and then \"undoing\" it with the identity function on the output is the same as applying the original function directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_id : v.comap (RingHom.id R) = v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'x' and any natural number 'n', applying a function 'v' to the n-th power of 'x' is the same as raising the result of applying 'v' to 'x' to the n-th power.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `coe` which maps a Derivation to a function from A to M is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : @Function.Injective (Derivation R A M) (A \u2192 M) DFunLike.coe :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interpretation of the zero derivation as a linear map is the zero map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : \u21d1(0 : Derivation R A M) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying `toFun` to `D` is the same as applying `D` as a function (using the notation `\u21d1D`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFun_eq_coe : D.toFun = \u21d1D :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve the product rule of calculus: the derivative of the product of two functions, a and b, is equal to the first function times the derivative of the second function plus the second function times the derivative of the first function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem leibniz : D (a * b) = a \u2022 D b + b \u2022 D a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a specific derivation, denoted by 'D', to the constant 1 results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_one_eq_zero : D 1 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(D\\) be a function that respects addition.  Prove that for any numbers \\(a\\) and \\(b\\), applying \\(D\\) to the sum of \\(a\\) and \\(b\\) is the same as applying \\(D\\) to \\(a\\) and \\(b\\) individually and then adding the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_add : D (a + b) = D a + D b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a sum of two functions D1 and D2 to a value 'a' is equivalent to applying each function individually to 'a' and then adding the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_apply : (D1 + D2) a = D1 a + D2 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of the algebra homomorphism applied to a constant 'r' is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_algebraMap : D (algebraMap R A r) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any scalar 'r' and any vector 'a', applying a linear transformation 'D' to the scalar multiplication of 'r' and 'a' is the same as first applying 'D' to 'a' and then scaling the result by 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_smul : D (r \u2022 a) = r \u2022 D a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting a value of a subtype `s` of a type `R` to the type `R` is the same as directly viewing the value as an element of `R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeSubtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the 0-th Hermite polynomial is equal to the constant polynomial 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hermite_zero : hermite 0 = C 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid` is injective. This function takes a non-unital subsemiring of a ring R and maps it to its corresponding additive submonoid within the same ring R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_injective :\n    Function.Injective (toAddSubmonoid : NonUnitalSubsemiring R \u2192 AddSubmonoid R)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemigroup`, which converts a non-unital subsemiring of a ring R into a subsemigroup of R, is a strictly monotone function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemigroup_strictMono :\n    StrictMono (toSubsemigroup : NonUnitalSubsemiring R \u2192 Subsemigroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the zero element of any type `s` to the real numbers `R` results in the zero element of the real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : ((0 : s) : R) = (0 : R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid`, which converts a non-unital subsemiring of a ring `R` to an additive submonoid of `R`, is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_strictMono :\n    StrictMono (toAddSubmonoid : NonUnitalSubsemiring R \u2192 AddSubmonoid R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero derivation, when converted to a linear map, is equal to the zero linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero_linearMap : \u2191(0 : Derivation R A M) = (0 : A \u2192\u2097[R] M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid`, which converts a non-unital subsemiring into an additive submonoid, preserves the subset relation. In other words, for any two non-unital subsemirings, if the first is a subset of the second, then the additive submonoid generated by the first is a subset of the additive submonoid generated by the second.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : NonUnitalSubsemiring R \u2192 AddSubmonoid R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a non-unital subsemiring into a subsemigroup is a monotone operation. In other words, show that if one non-unital subsemiring is a subset of another, then the corresponding subsemigroup of the first is also a subset of the corresponding subsemigroup of the second.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemigroup_mono : Monotone (toSubsemigroup : NonUnitalSubsemiring R \u2192 Subsemigroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemigroup`, which converts a non-unital subsemiring of a ring R into a subsemigroup of R, is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemigroup_injective :\n    Function.Injective (toSubsemigroup : NonUnitalSubsemiring R \u2192 Subsemigroup R)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Hermite polynomial of degree 1 is equal to the variable X itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem\ntheorem hermite_one : hermite 1 = X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a polynomial \\( f \\) is weakly Eisenstein at a prime ideal \\( \\mathcal{P} \\) if all its non-leading coefficients are in \\( \\mathcal{P} \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isWeaklyEisensteinAt : IsWeaklyEisensteinAt f \ud835\udcdf :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 is coprime to any natural number x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCoprime_one_left : IsCoprime 1 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet R be a ring and M be an R-module. Prove that M is a flat module if and only if for any finitely generated ideal I of R, the function (lTensor M I.subtype), which takes the tensor product of M with the inclusion map from I to R, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iff_lTensor_injective :\n    Module.Flat R M \u2194 \u2200 \u2983I : Ideal R\u2984 (_ : I.FG), Function.Injective (lTensor M I.subtype) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers x and y, x is coprime to y if and only if y is coprime to x. (Two integers are considered coprime if their greatest common divisor is 1).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCoprime_comm : IsCoprime x y \u2194 IsCoprime y x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number \\(x\\) is coprime to 0 if and only if \\(x\\) is a unit (i.e., has a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCoprime_zero_right : IsCoprime x 0 \u2194 IsUnit x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coefficient of the term \\(x^k\\) in the \\(2n+k\\)-th Hermite polynomial is equal to  \\((-1)^n \\cdot (2n-1)!! \\cdot \\binom{2n+k}{k}\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_hermite_explicit :\n    \u2200 n k : \u2115, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)\u203c * Nat.choose (2 * n + k) k\n  | 0, _ => by simp\n  | n + 1, 0 => by\n    convert coeff_hermite_succ_zero (2 * n + 1) using 1\n    -- Porting note: ring_nf did not solve the goal on line 165\n    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :\n      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,\n      Nat.choose_one_right, pow_succ]\n    push_cast\n    ring\n  | n + 1, k + 1 => by\n    let hermite_explicit : \u2115 \u2192 \u2115 \u2192 \u2124 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemiring`, which converts a subring of a ring R into a subsemiring of the same ring R, is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemiring_injective : Function.Injective (toSubsemiring : Subring R \u2192 Subsemiring R)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a subring to a subsemiring is a monotone operation. In other words, if one subring is contained within another, then after converting both to subsemirings, the containment relationship still holds.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemiring_mono : Monotone (toSubsemiring : Subring R \u2192 Subsemiring R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number is coprime with itself if and only if it is a unit (i.e., it has a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCoprime_self : IsCoprime x x \u2194 IsUnit x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 0 and a number 'x' are coprime if and only if 'x' is a unit (i.e., has a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCoprime_zero_left : IsCoprime 0 x \u2194 IsUnit x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any natural number 'x' is coprime with 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCoprime_one_right : IsCoprime x 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemiring`, which maps a subring of a ring R to itself (within the set of subrings of R), is a strictly monotonic function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemiring_strictMono : StrictMono (toSubsemiring : Subring R \u2192 Subsemiring R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any function `s` that maps elements of a set `s` to a set `R`, taking an element of the subset defined by `s` and then applying the inclusion map (which treats the element as belonging to the bigger set `R`) is the same as applying the function `s` directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeSubtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubgroup`, which converts a subring of a ring R into an additive subgroup of R, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubgroup_injective : Function.Injective (toAddSubgroup : Subring R \u2192 AddSubgroup R)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a subring to a submonoid preserves the subset relation. In other words, if one subring is a subset of another subring, then the submonoid generated by the first subring is a subset of the submonoid generated by the second subring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubmonoid_mono : Monotone (fun s : Subring R => s.toSubmonoid) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the closure of the empty set with respect to a relation R always results in the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem adjoin_empty : adjoin R (\u2205 : Set A) = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that adjoining all elements of a set A to a ring R results in the largest possible ring that can be created from R, denoted as \u22a4 (top).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem adjoin_univ : adjoin R (Set.univ : Set A) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubgroup`, which converts a subring of a ring R into an additive subgroup of R, is strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubgroup_strictMono : StrictMono (toAddSubgroup : Subring R \u2192 AddSubgroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set 's' and a relation 'R', 's' is a subset of the set obtained by adjoining 's' to 'R'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_adjoin : s \u2286 adjoin R s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which takes a subring of a ring R and outputs the corresponding submonoid is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubmonoid_injective : Function.Injective (fun s : Subring R => s.toSubmonoid)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function 'toAddSubgroup', which takes a subring of a ring R and outputs an additive subgroup of R, is a monotone function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubgroup_mono : Monotone (toAddSubgroup : Subring R \u2192 AddSubgroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a subsemiring of a ring R into a submonoid always produces a larger submonoid if we start with a larger subsemiring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subsemiring R \u2192 Submonoid R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet R be a ring and S be a subset of R. Prove that the submodule generated by the subalgebra generated by S is equal to the submodule generated by the multiplicative closure of S.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem adjoin_eq_span : Subalgebra.toSubmodule (adjoin R s) = span R (Submonoid.closure s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid`, which converts a subsemiring of a ring R into the corresponding additive submonoid, is a strictly monotone function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting a value from a subtype `s` of a type `R` to the type `R` is the same as directly using the embedding function from `s` to `R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_subtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the support of the zero element in the Hahn series is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_zero : support (0 : HahnSeries \u0393 R) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a subring to a submonoid is a strictly monotone operation. In other words, show that if one subring is strictly contained within another, then the submonoid generated by the first subring is also strictly contained within the submonoid generated by the second subring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubmonoid_strictMono : StrictMono (fun s : Subring R => s.toSubmonoid) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(R\\) be a ring and \\(A\\) be an \\(R\\)-algebra. For any subset \\(s\\) of \\(A\\), prove that the \\(R\\)-subalgebra generated by \\(s\\) (denoted as  adjoin \\(R\\) \\(s\\)) is equal to the intersection of all \\(R\\)-subalgebras of \\(A\\) that contain \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem adjoin_eq_sInf : adjoin R s = sInf { p : Subalgebra R A | s \u2286 p } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubmonoid`, which converts a subsemigroup of a ring R into a submonoid of R, is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subsemiring R \u2192 Submonoid R)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a function that maps only the element 'a' to a value 'r' and all other elements to the default value, the support of this function is a subset of the set containing only the element 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_single_subset : support (single a r) \u2286 {a} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid`, which converts a subsemiring of a ring R into an additive submonoid of R, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_injective :\n    Function.Injective (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R)\n  | _, _, h => ext (SetLike.ext_iff.mp h : _)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coefficient function for Hahn series is injective. In other words, if two Hahn series have the same coefficients, then they are the same Hahn series.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_injective : Injective (coeff : HahnSeries \u0393 R \u2192 \u0393 \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting subsemirings to additive submonoids preserves the order of inclusion. In other words, if one subsemiring is a subset of another, then the additive submonoid generated by the first subsemiring is a subset of the additive submonoid generated by the second subsemiring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a single-term polynomial with coefficient 'r' at position 'a' (we call this polynomial \"single a r\"), prove that the coefficient of this polynomial at any position 'b' is 'r' if 'b' equals 'a', and 0 otherwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem single_coeff : (single a r).coeff b = if b = a then r else 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a subsemiring of a ring R into a submonoid always preserves the order of inclusion. In other words, if we have two subsemirings of R, where the first is a subset of the second, then the corresponding submonoids (formed from the same sets) will also maintain that subset relationship.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubmonoid_mono : Monotone (toSubmonoid : Subsemiring R \u2192 Submonoid R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `basisMonomials R`, which maps a natural number `s` to the `s`-th basis monomial in the polynomial ring `R[X]`, is equivalent to the function that maps `s` to the monomial with coefficient 1 and exponent `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_basisMonomials : (basisMonomials R : \u2115 \u2192 R[X]) = fun s => monomial s 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number 'a', multiplying 'a' by 0 results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem single_eq_zero : single a (0 : R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `basisMonomials` which constructs a multivariate polynomial from a function mapping variables to their exponents is equivalent to creating a monomial with coefficient 1 for each term.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_basisMonomials :\n    (basisMonomials \u03c3 R : (\u03c3 \u2192\u2080 \u2115) \u2192 MvPolynomial \u03c3 R) = fun s => monomial s 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the order of the zero element in the Hahn series ring (HahnSeries \u0393 R) is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem order_zero : order (0 : HahnSeries \u0393 R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a localization map to a regular map results in the algebra map from R to S.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toLocalizationMap_toMap : (toLocalizationMap M S).toMap = (algebraMap R S : R \u2192*\u2080 S) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a way to break down elements of a set 'A' into simpler parts and then put them back together (like taking apart a toy and rebuilding it). This theorem states that if we break down the number '1' from our set and then immediately rebuild it, we get back the same '1' we started with.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem decompose_symm_one : (decompose \ud835\udc9c).symm 1 = (1 : A) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet R be a ring and S be a multiplicative subset of R. Let M be the localization of R at S. Prove that for any two elements z and w in S, there exist elements z' and w' in R and an element d in M such that z multiplied by the image of d under the canonical map from R to M is equal to the image of z' and similarly, w multiplied by the image of d is equal to the image of w'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surj\u2082 : \u2200 z w : S, \u2203 z' w' : R, \u2203 d : M,\n    (z * algebraMap R S d = algebraMap R S z') \u2227 (w * algebraMap R S d = algebraMap R S w') :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any element 'x' raised to the power 0 is equal to 1, where the power is defined using the 'selfZPow' function with base 'B'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem selfZPow_zero : selfZPow x B 0 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of monomials, each consisting of a single variable raised to the power of 1, is linearly independent over a ring R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem linearIndependent_X : LinearIndependent R (X : \u03c3 \u2192 MvPolynomial \u03c3 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two linear transformations, `f` and `g`, prove that applying a change of basis to their sum (`f + g`) is the same as applying the change of basis to each transformation individually and then summing the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem baseChange_add : (f + g).baseChange A = f.baseChange A + g.baseChange A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a way to map elements from a ring R to a larger ring S (like embedding integers into rational numbers), and if M represents the set of units in R (elements with multiplicative inverses), then every element in M, when mapped to S, will also be a unit in S.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_units : \u2200 y : M, IsUnit (algebraMap R S y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet R be a commutative ring and let S be a multiplicative subset of R. Prove that for any element z in the localization of R with respect to S, there exists an element x in R and an element m in S such that z multiplied by the image of m under the canonical homomorphism is equal to the image of x under the canonical homomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surj : \u2200 z : S, \u2203 x : R \u00d7 M, z * algebraMap R S x.2 = algebraMap R S x.1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that changing the basis of a linear map is the same as taking its tensor product with the identity map on the new basis.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem baseChange_eq_ltensor : (f.baseChange A : A \u2297 M \u2192 A \u2297 N) = f.lTensor A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `sec` to the output of the function `toLocalizationMap` applied to arguments `M` and `S`, is equal to applying the function `sec` directly to `M`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toLocalizationMap_sec : (toLocalizationMap M S).sec = sec M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the multiplicative identity element in the tensor product of two algebraic structures A and B (with respect to some ring R) is equivalent to the tensor product of the individual identity elements from A and B.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_def : (1 : A \u2297[R] B) = (1 : A) \u2297\u209c (1 : B) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'f' to the sum of two elements, x and y, is equivalent to applying 'f' to each element individually and then adding the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add : mapFun f (x + y) = mapFun f x + mapFun f y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two linear maps  'f' and 'g', prove that the base change of the difference of these maps with respect to a module 'A' is equal to the difference of their individual base changes with respect to 'A'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem baseChange_sub : (f - g).baseChange A = f.baseChange A - g.baseChange A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'f' to the zero vector in a vector space results in the zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero : mapFun f (0 : \ud835\udd4e R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two lists 'x' and 'y' of numbers and a function 'f' that operates on numbers, prove that applying the function 'f' to each element of the difference between lists 'x' and 'y' is equivalent to applying 'f' to each element of 'x' and 'y' separately and then taking the difference between the resulting lists.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub : mapFun f (x - y) = mapFun f x - mapFun f y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number of k-th roots of unity in a ring R is less than or equal to k.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_rootsOfUnity : Fintype.card (rootsOfUnity k R) \u2264 k :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that performing a base change on a zero linear transformation results in another zero linear transformation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem baseChange_zero : baseChange A (0 : M \u2192\u2097[R] N) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that negating a linear map and then changing its basis is equivalent to changing the basis first and then negating.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem baseChange_neg : (-f).baseChange A = -f.baseChange A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'f' to the product of two elements 'x' and 'y' is equivalent to multiplying the result of applying 'f' to 'x' with the result of applying 'f' to 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul : mapFun f (x * y) = mapFun f x * mapFun f y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function called \"ghostFun\" that operates on some type of object, prove that applying ghostFun to the sum of two objects, x and y, is the same as applying ghostFun to x and y separately and then adding the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ghostFun_add : ghostFun (x + y) = ghostFun x + ghostFun y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a linear map *f* between two vector spaces and a scalar *r*, prove that scaling the linear map *f* by *r* and then performing a change of basis yields the same result as performing the change of basis first and then scaling by *r*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem baseChange_smul : (r \u2022 f).baseChange A = r \u2022 f.baseChange A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'f' to the multiplicative identity element (1) in a wheel structure (\ud835\udd4e R) results in the identity element itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one : mapFun f (1 : \ud835\udd4e R) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function \\( f \\) to the negation of an element \\( x \\) is equivalent to negating the result of applying \\( f \\) to \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg : mapFun f (-x) = -mapFun f x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coefficient of the linear term (term with exponent 1) in the polynomial \"X\" is always 1, regardless of the underlying ring of coefficients.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_one_X : coeff R 1 (X : R\u27e6X\u27e7) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that extracting the coefficient of the zero term of a polynomial is the same as obtaining its constant term.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_zero_eq_constantCoeff : \u21d1(coeff R 0) = constantCoeff R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a monomial with coefficient ring R and exponent 0 is equivalent to a constant polynomial with value R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monomial_zero_eq_C : \u21d1(monomial R 0) = C R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the formal power series 'X' is equal to the monomial with coefficient 1 and degree 1 in the ring of formal power series R\u27e6X\u27e7.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem X_eq : (X : R\u27e6X\u27e7) = monomial R 1 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function called \"ghostFun\" that operates on some mathematical objects (let's call them \"X\"), prove that applying ghostFun to the difference of two objects, x and y, is the same as applying ghostFun to x and y separately and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ghostFun_sub : ghostFun (x - y) = ghostFun x - ghostFun y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that decomposing the multiplicative identity element (1) of a ring always results in the multiplicative identity itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem decompose_one : decompose \ud835\udc9c (1 : A) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a ring R which is a principal ideal domain and has a maximal ideal, there exists an irreducible element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_irreducible : \u2203 \u03d6 : R, Irreducible \u03d6 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function 'ghostFun' to the product of two elements (x and y) is equivalent to multiplying the results of applying 'ghostFun' to each element separately.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ghostFun_mul : ghostFun (x * y) = ghostFun x * ghostFun y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coefficient of the constant term (the term with no 'X') in the power series representation of 'X' is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_zero_X : coeff R 0 (X : R\u27e6X\u27e7) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toNonUnitalSubsemiring`, which converts a non-unital subring of a ring R into a non-unital subsemiring of the same ring R, is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toNonUnitalSubsemiring_injective :\n    Function.Injective (toNonUnitalSubsemiring : NonUnitalSubring R \u2192 NonUnitalSubsemiring R)\n  | _r, _s, h => ext (SetLike.ext_iff.mp h : _):=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toNonUnitalSubsemiring`, which converts a non-unital subring of a ring R into another non-unital subring of R, is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toNonUnitalSubsemiring_strictMono :\n    StrictMono (toNonUnitalSubsemiring : NonUnitalSubring R \u2192 NonUnitalSubsemiring R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a given ring \\( R \\) is not a field.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_isField : \u00acIsField R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the set of all real numbers, there exists a number that is a prime number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_prime : \u2203 \u03d6 : R, Prime \u03d6 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any ring R, the maximal ideal is never empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_a_field : maximalIdeal R \u2260 \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 0 (as a real number) is an element of a set  's' (where 's' is assumed to be a set of real numbers containing 0).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mem : (0 : R) \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a non-unital subring to a non-unital subsemiring preserves the subset relation. In other words, if one non-unital subring is a subset of another, then the corresponding non-unital subsemiring of the first is also a subset of the corresponding non-unital subsemiring of the second.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toNonUnitalSubsemiring_mono :\n    Monotone (toNonUnitalSubsemiring : NonUnitalSubring R \u2192 NonUnitalSubsemiring R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(R\\) be an integral domain. Suppose for every non-zero and non-unit element \\(x\\) in \\(R\\), there exists a prime element \\(p\\) that divides \\(x\\). Prove that \\(R\\) is a unique factorization domain.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toUniqueFactorizationMonoid : UniqueFactorizationMonoid R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the default permutation on any type is equal to the identity permutation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem default_eq : (default : Perm \u03b1) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a collection of subsets of a ring that are closed under subtraction and multiplication, then taking a larger subset from this collection will always result in a larger additive subgroup.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubgroup_mono : Monotone (toAddSubgroup : NonUnitalSubring R \u2192 AddSubgroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubgroup`, which converts a non-unital subring of a ring R into an additive subgroup of R, is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubgroup_strictMono :\n    StrictMono (toAddSubgroup : NonUnitalSubring R \u2192 AddSubgroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemigroup`, which converts a non-unital subring of a ring R into a subsemigroup of R, is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemigroup_strictMono :\n    StrictMono (toSubsemigroup : NonUnitalSubring R \u2192 Subsemigroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubgroup`, which converts a non-unital subring of a ring R into an additive subgroup of R, is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubgroup_injective :\n    Function.Injective (toAddSubgroup : NonUnitalSubring R \u2192 AddSubgroup R)\n  | _r, _s, h => ext (SetLike.ext_iff.mp h : _):=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that converts a fractional ideal (a specific algebraic structure) into a submodule (another algebraic structure) is injective. In other words, different fractional ideals always map to different submodules.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeToSubmodule_injective :\n    Function.Injective (fun (I : FractionalIdeal S P) \u21a6 (I : Submodule R P)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the identity permutation on any type is equal to the identity permutation itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl_inv : (Equiv.refl \u03b1 : Perm \u03b1)\u207b\u00b9 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the identity permutation is itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_symm : (1 : Perm \u03b1).symm = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemigroup`, which converts a non-unital subring of a ring R into a subsemigroup of R, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemigroup_injective :\n    Function.Injective (toSubsemigroup : NonUnitalSubring R \u2192 Subsemigroup R)\n  | _r, _s, h => ext (SetLike.ext_iff.mp h : _):=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\(f\\), elements \\(x\\) and \\(y\\) are in the same cycle if and only if elements \\(y\\) and \\(x\\) are in the same cycle.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_comm : SameCycle f x y \u2194 SameCycle f y x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a non-unital subring to a subsemigroup is a monotone operation. In other words, show that if one non-unital subring is a subset of another, then the subsemigroup generated by the first is also a subset of the subsemigroup generated by the second.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemigroup_mono : Monotone (toSubsemigroup : NonUnitalSubring R \u2192 Subsemigroup R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider two permutations, 'f' and 'g', and two elements 'x' and 'y'. Prove that 'x' and 'y' are in the same cycle of the permutation (g * f * g\u207b\u00b9) if and only if the elements (g\u207b\u00b9 x) and (g\u207b\u00b9 y) are in the same cycle of the permutation 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_conj : SameCycle (g * f * g\u207b\u00b9) x y \u2194 SameCycle f (g\u207b\u00b9 x) (g\u207b\u00b9 y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that points x and y are on the same cycle of a permutation f if and only if they are on the same cycle of the inverse permutation f\u207b\u00b9.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_inv : SameCycle f\u207b\u00b9 x y \u2194 SameCycle f x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there is a cycle of length 1 containing elements x and y if and only if x and y are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_one : SameCycle 1 x y \u2194 x = y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that points  'f(x)' and 'y' are in the same cycle of function 'f' if and only if points 'x' and 'y' are in the same cycle of function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_apply_left : SameCycle f (f x) y \u2194 SameCycle f x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the element 1 belongs to the set S, given that 1 is an element of type M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_mem : (1 : M) \u2208 S :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) and elements \\( x \\) and \\( y \\), applying \\( f \\) to \\( y \\) doesn't change whether \\( x \\) and \\( y \\) are in the same cycle of \\( f \\). More formally, \\( x \\) and \\( f(y) \\) are in the same cycle if and only if \\( x \\) and \\( y \\) are in the same cycle.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_apply_right : SameCycle f x (f y) \u2194 SameCycle f x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\), points \\( x \\) and \\( y \\) lie on the same cycle of \\( f \\) if and only if \\( x \\) and the pre-image of \\( y \\) under \\( f \\) lie on the same cycle of \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_inv_apply_right : SameCycle f x (f\u207b\u00b9 y) \u2194 SameCycle f x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\(f\\), points \\(x\\), and \\(y\\), applying \\(f\\) repeatedly will map \\(f^{-1}(x)\\) to \\(y\\) if and only if it will also map \\(x\\) to \\(y\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sameCycle_inv_apply_left : SameCycle f (f\u207b\u00b9 x) y \u2194 SameCycle f x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of the monoid homomorphism from a monoid M to the trivial monoid N is equal to the trivial monoid N.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mrange_mk : MonoidHom.mrange (@mk M N _ _) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of fixed points of a function M on a set \u03b1 is equal to the intersection of all sets fixed by each element of M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fixed_eq_iInter_fixedBy : fixedPoints M \u03b1 = \u22c2 m : M, fixedBy \u03b1 m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the bottom element (\u22a5) of the subtype of all subsemigroups of a magma M, when interpreted as a set of elements from M, is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : ((\u22a5 : Subsemigroup M) : Set M) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any pair `p` consisting of an element of type `\u03b1` and a boolean value, it is not possible to reach an empty list `L` by applying the `Step` operation to a list containing only `p`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_step_singleton : \u2200 {p : \u03b1 \u00d7 Bool}, \u00acStep [p] L\n  | (a, b) => by simp [Step.cons_left_iff, not_step_nil]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the largest possible sub-semigroup of a set M is equal to M itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_top : ((\u22a4 : Subsemigroup M) : Set M) = Set.univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the free product of two monoids M and N, denoted by M \u2217 N, the smallest submonoid that contains every element from both M and N is the entire monoid M \u2217 N.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mclosure_range_inl_union_inr :\n    Submonoid.closure (range (inl : M \u2192* M \u2217 N) \u222a range (inr : N \u2192* M \u2217 N)) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an empty list cannot take a \"step\" according to a given relation \"Step\". In other words, there's no list L that can be reached from an empty list with one application of the \"Step\" relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_step_nil : \u00acStep [] L :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the natural embedding of natural numbers into integers is strictly monotonic. In other words, if  'a' and 'b' are natural numbers and 'a' is less than 'b', then 'a' as an integer is less than 'b' as an integer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_nat_strictMono : StrictMono (\u00b7 : \u2115 \u2192 \u2124) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a set of words and rules to transform these words.  If you can transform a word 'w1' into both 'w2' and 'w3' using these rules, then there exists another word 'w4' that both 'w2' and 'w3' can be transformed into.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\nrespectively. This is also known as Newman's diamond lemma. -/\n@[to_additive\n  \"**Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\n  to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\n  respectively. This is also known as Newman's diamond lemma.\"]\ntheorem church_rosser : Red L\u2081 L\u2082 \u2192 Red L\u2081 L\u2083 \u2192 Join Red L\u2082 L\u2083 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number `n` greater than 0, if we subtract 1 from `n` (within the realm of natural numbers), then treat the result as a real number, it's the same as subtracting 1 from `n` directly within the real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_pred : \u2200 {n}, 0 < n \u2192 ((n - 1 : \u2115) : R) = n - 1\n  | 0, h => by cases h\n  | n + 1, _ => by rw [cast_succ, add_sub_cancel_right]; rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a free product of two monoids, M and N, every element can be generated by taking products of elements coming from M or N.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mrange_inl_sup_mrange_inr :\n    MonoidHom.mrange (inl : M \u2192* M \u2217 N) \u2294 MonoidHom.mrange (inr : N \u2192* M \u2217 N) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the integer 2 to a real number results in the real number 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_two : ((2 : \u2124) : R) = 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the integer 1 to a real number results in the real number 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_one : ((1 : \u2124) : R) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the integer 0 to a real number results in the real number 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_zero : ((0 : \u2124) : R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer 'a', the absolute value of 'a' is equal to the natural number absolute value of 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem abs_eq_natAbs : \u2200 a : \u2124, |a| = natAbs a\n  | (n : \u2115) => abs_of_nonneg <| ofNat_zero_le _\n  | -[_+1] => abs_of_nonpos <| le_of_lt <| negSucc_lt_zero _\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers, if they have the same sign, then their sum has the same sign as each of them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sign_add_eq_of_sign_eq : \u2200 {m n : \u2124}, m.sign = n.sign \u2192 (m + n).sign = n.sign :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a natural number 'n' to an optional natural number using 'WithTop.some' is equivalent to converting 'n' to an optional natural number using 'Nat.cast'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem some_eq_coe : (WithTop.some : \u2115 \u2192 \u2115\u221e) = Nat.cast :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers *m* and *n*, adding them as integers and then treating the result as a real number is the same as treating *m* and *n* as real numbers first and then adding them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_add : \u2200 m n, ((m + n : \u2124) : R) = m + n\n  | (m : \u2115), (n : \u2115) => by simp [-Int.natCast_add, \u2190 Int.ofNat_add]\n  | (m : \u2115), -[n+1] => by erw [cast_subNatNat, cast_ofNat, cast_negSucc, sub_eq_add_neg]\n  | -[m+1], (n : \u2115) => by\n    erw [cast_subNatNat, cast_ofNat, cast_negSucc, sub_eq_iff_eq_add, add_assoc,\n      eq_neg_add_iff_add_eq, \u2190 Nat.cast_add, \u2190 Nat.cast_add, Nat.add_comm]\n  | -[m+1], -[n+1] =>\n    show (-[m + n + 1+1] : R) = _ by\n      rw [cast_negSucc, cast_negSucc, cast_negSucc, \u2190 neg_add_rev, \u2190 Nat.cast_add,\n        Nat.add_right_comm m n 1, Nat.add_assoc, Nat.add_comm]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer 'n', casting '-n' from an integer to a real number is equal to the negation of 'n' as a real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_neg : \u2200 n, ((-n : \u2124) : R) = -n\n  | (0 : \u2115) => by erw [cast_zero, neg_zero]\n  | (n + 1 : \u2115) => by erw [cast_ofNat, cast_negSucc]\n  | -[n+1] => by erw [cast_ofNat, cast_negSucc, neg_neg]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number 1, when considered as an element of the extended natural numbers (natural numbers including infinity), is still equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_one : ((1 : \u2115) : \u2115\u221e) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the integer 3 to a real number results in the real number 3.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_three : ((3 : \u2124) : R) = 3 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the integer 4 to a real number results in the same value, 4.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_four : ((4 : \u2124) : R) = 4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 0, when considered as an element of the extended natural numbers (natural numbers including infinity), is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : ((0 : \u2115) : \u2115\u221e) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two complex numbers z and w, prove that the real part of their product (z * w) is equal to the product of the real parts of z and w minus the product of the imaginary parts of z and w.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_re : \u2200 z w : K, re (z * w) = re z * re w - im z * im w :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, 1 is less than or equal to *n* if and only if *n* is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_iff_ne_zero : 1 \u2264 n \u2194 n \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any extended natural number `n` (natural numbers including infinity), converting `n` to a natural number and back is equal to the original `n` if and only if `n` is not infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toNat_eq_self : ENat.toNat n = n \u2194 n \u2260 \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, 1 is less than or equal to *n* if and only if 0 is less than *n*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_iff_pos : 1 \u2264 n \u2194 0 < n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that embeds real numbers (\u211d) into an arbitrary field (K) is injective. In simpler terms, show that if two real numbers map to the same element in the field K, then those two real numbers must be equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_injective : Function.Injective ((\u2191) : \u211d \u2192 K) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real part of the complex number 1 is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_re : re (1 : K) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the imaginary part of the complex number 1 (when viewed as an element of any type `K` that supports complex number operations) is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_im : im (1 : K) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a real number to an element of an arbitrary type \"K\" (which has been given an appropriate structure to be compatible with real numbers) using the standard conversion function (`algebraMap`) is the same as directly converting the real number to an element of type \"K\" using a function specifically designed for that purpose (`ofReal`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_eq_ofReal : \u21d1(algebraMap \u211d K) = ofReal :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting the real number 0 to any field K results in the additive identity (zero element) of K.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_zero : ((0 : \u211d) : K) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two complex numbers z and w, the imaginary part of their product (z * w) is equal to the sum of the product of the real part of z and the imaginary part of w and the product of the imaginary part of z and the real part of w.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_im : \u2200 z w : K, im (z * w) = re z * im w + im z * re w :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number 'r', the imaginary part of 'r' when treated as a complex number is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_im : \u2200 r : \u211d, im (r : K) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number 'r', if we consider it as a complex number and then take its real part, it will be equal to the original real number 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_re : \u2200 r : \u211d, re (r : K) = r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real number 1, when considered as an element of any field K, is equal to the multiplicative identity 1 in K.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_one : ((1 : \u211d) : K) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the infimum (greatest lower bound) of two sets is the same as their intersection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_eq_inter : ((\u00b7 \u2293 \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b1) = (\u00b7 \u2229 \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets, the result of taking their union is the same as taking their supremum.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_eq_union : ((\u00b7 \u2294 \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b1) = (\u00b7 \u222a \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type \u03b1, the less than or equal to relation (\u2264) on sets of type \u03b1 is equivalent to the subset relation (\u2286).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_eq_subset : ((\u00b7 \u2264 \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Prop) = (\u00b7 \u2286 \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type \u03b1, the relation of one set being a strict subset of another set is the same as the relation of one set being strictly less than another.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_eq_ssubset : ((\u00b7 < \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Prop) = (\u00b7 \u2282 \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set  's' is a subset of another set 't' if and only if every element in set 's' is also an element of set 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_def : (s \u2286 t) = \u2200 x, x \u2208 s \u2192 x \u2208 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set containing only the element '1' has a size of 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_one : ({1} : Set \u03b1) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `setOf`, which converts a predicate (a function that maps elements to truth values) into a set containing all elements satisfying the predicate, is a bijection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem setOf_bijective : Bijective (setOf : (\u03b1 \u2192 Prop) \u2192 Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a relation `r` holds pairwise for a set containing only two distinct elements `a` and `b` if and only if  `r` holds in both directions between `a` and `b` whenever `a` and `b` are different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwise_pair : Set.Pairwise {a, b} r \u2194 a \u2260 b \u2192 r a b \u2227 r b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two equal sets \\( s \\) and \\( t \\) (meaning they contain the same elements), and an element \\( x \\) belonging to set \\( s \\), prove that casting \\( x \\) from the type of elements of set \\( s \\) to the type of elements of set \\( t \\) is equivalent to constructing an element in the type of set \\( t \\) using the value of \\( x \\) and the proof that \\( s \\) equals \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem set_coe_cast :\n    \u2200 {s t : Set \u03b1} (H' : s = t) (H : \u21a5s = \u21a5t) (x : s), cast H x = \u27e8x.1, H' \u25b8 x.2\u27e9\n  | _, _, rfl, _, _ => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set containing only the element 1 is a subset of a set 's' if and only if the element 1 is in the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_subset : 1 \u2286 s \u2194 (1 : \u03b1) \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a relation \\( r \\) holds pairwise for all elements in the universal set (the set containing all possible elements) if and only if the relation \\( r \\) holds pairwise for all elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwise_univ : (univ : Set \u03b1).Pairwise r \u2194 Pairwise r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is a subset of the set containing only the element 1 if and only if 's' is either an empty set or the set containing only the element 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_one_iff_eq : s \u2286 1 \u2194 s = \u2205 \u2228 s = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the element 1 belongs to the set {1} where both the element and the set are of the same arbitrary type.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_mem_one : (1 : \u03b1) \u2208 (1 : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set formed by inserting an element 'a' into a set 's' satisfies a pairwise relation 'r' if and only if: (1) the original set 's' already satisfies the pairwise relation 'r', and (2) the inserted element 'a' satisfies the relation 'r' with every element in 's', assuming 'a' is distinct from those elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwise_insert :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `s`, the property that the always-false relation holds pairwise for `s` is equivalent to `s` being a singleton set (a set with at most one element).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwise_bot_iff : s.Pairwise (\u22a5 : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 (s : Set \u03b1).Subsingleton :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type \u03b1, the inverse image of the empty set (\u2205) is also the empty set (\u2205).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_empty : (\u2205 : Set \u03b1)\u207b\u00b9 = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a relation  'r' holds pairwise for elements in the union of two sets 's' and 't' if and only if:\n    1. 'r' holds pairwise for elements within set 's', \n    2. 'r' holds pairwise for elements within set 't', and \n    3. for any distinct elements 'a' from set 's' and 'b' from set 't', 'r' holds for both (a, b) and (b, a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwise_union :\n    (s \u222a t).Pairwise r \u2194\n    s.Pairwise r \u2227 t.Pairwise r \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the intersection of two sets \\(s\\) and \\(t\\) is equal to the intersection of the inverse of \\(s\\) and the inverse of \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_inv : (s \u2229 t)\u207b\u00b9 = s\u207b\u00b9 \u2229 t\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set containing only the element '1' is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_nonempty : (1 : Set \u03b1).Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( a \\) belongs to the inverse set \\( s\u207b\u00b9 \\) if and only if the inverse of \\( a \\) belongs to the original set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_inv : a \u2208 s\u207b\u00b9 \u2194 a\u207b\u00b9 \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any relation 's', the inverse relation 's\u207b\u00b9' is empty if and only if the original relation 's' is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_eq_empty : s\u207b\u00b9 = \u2205 \u2194 s = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the universal set (the set containing all elements of a particular type) is equal to the universal set itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_univ : (univ : Set \u03b1)\u207b\u00b9 = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the union of two sets s and t is equal to the union of the inverse of s and the inverse of t.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_inv : (s \u222a t)\u207b\u00b9 = s\u207b\u00b9 \u222a t\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `singletonOneHom`, which takes an element and puts it into a singleton set, is the same as the `singleton` function which also takes an element and produces a singleton set containing that element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_singletonOneHom : (singletonOneHom : \u03b1 \u2192 Set \u03b1) = singleton :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set 's', the preimage of 's' under the inverse function is equal to the inverse of the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_preimage : Inv.inv \u207b\u00b9' s = s\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function and a set, the preimage of the complement of the set is equal to the complement of the preimage of that set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_inv : s\u1d9c\u207b\u00b9 = s\u207b\u00b9\u1d9c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the image of a set \\(s\\) under the inverse operation is equivalent to finding the set of inverses of elements in \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_inv : Inv.inv '' s = s\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\(a\\) and set \\(s\\), \\(a\\) is an element of \\(s\\) if and only if the inverse of \\(a\\) is an element of the inverse of set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_mem_inv : a\u207b\u00b9 \u2208 s\u207b\u00b9 \u2194 a \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any relation \\( s \\), the inverse relation \\( s^{-1} \\) is nonempty if and only if the original relation \\( s \\) is nonempty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_inv : s\u207b\u00b9.Nonempty \u2194 s.Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function *op* and set *s*, applying *op* to the preimage of a set *s* is equivalent to taking the preimage of the set obtained by applying *op* to *s*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_op_inv : op '' s\u207b\u00b9 = (op '' s)\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two relations  \\( s \\) and \\( t \\), the inverse of \\( s \\) is a subset of \\( t \\) if and only if \\( s \\) is a subset of the inverse of \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_subset : s\u207b\u00b9 \u2286 t \u2194 s \u2286 t\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two relations \\( s \\) and \\( t \\) defined on a set, the inverse relation of \\( s \\) is a subset of the inverse relation of \\( t \\) if and only if the relation \\( s \\) is a subset of the relation \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_subset_inv : s\u207b\u00b9 \u2286 t\u207b\u00b9 \u2194 s \u2286 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number 'a' cannot be an element of the open interval (a, b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_mem_Ioo : a \u2208 Ioo a b \u2194 False :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( a \\) belongs to the singleton set containing only the element 1 if and only if \\( a \\) is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_one : a \u2208 (1 : Set \u03b1) \u2194 a = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the statement \"a belongs to the open interval from 'a' (exclusive) to 'b'\" is always false.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_mem_Ioc : a \u2208 Ioc a b \u2194 False :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number 'a' belongs to the closed interval [a, b] if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_mem_Icc : a \u2208 Icc a b \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number \\( b \\) cannot be an element of the open interval \\((a, b)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_mem_Ioo : b \u2208 Ioo a b \u2194 False :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', it is always false to say that 'b' belongs to the interval open on the left and closed on the right, denoted by (a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_mem_Ico : b \u2208 Ico a b \u2194 False :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number 'b' belongs to the interval (a, b] if and only if 'a' is strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_mem_Ioc : b \u2208 Ioc a b \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number 'b' belongs to the closed interval from 'a' to 'b' if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of elements less than or equal to the dual of 'a' is equivalent to the preimage of the set of elements greater than or equal to 'a' under the 'ofDual' function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Iic : Iic (toDual a) = ofDual \u207b\u00b9' Ici a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the dual of the set of all elements strictly greater than `a` is equal to the preimage of the set of all elements strictly less than `a` under the `ofDual` function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Ioi : Ioi (toDual a) = ofDual \u207b\u00b9' Iio a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of the interval [b, a] under the inverse dual map is equal to the interval from the dual of 'a' to the dual of 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Icc : Icc (toDual a) (toDual b) = ofDual \u207b\u00b9' Icc b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers, a and b,  'a' is an element of the interval [a, b) if and only if 'a' is strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_mem_Ico : a \u2208 Ico a b \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of the upper set of the dual of an element 'a' under the inverse dual embedding is equal to the lower set of 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Ici : Ici (toDual a) = ofDual \u207b\u00b9' Iic a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all elements strictly less than the dual of 'a' is equal to the preimage of the set of all elements strictly greater than 'a' under the function 'ofDual'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Iio : Iio (toDual a) = ofDual \u207b\u00b9' Ioi a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval [a, \u221e) is nonempty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ici : (Ici a).Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of the set of elements strictly between `b` and `a` under the inverse dual function is equal to the set of elements strictly between the dual of `a` and the dual of `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Ico : Ico (toDual a) (toDual b) = ofDual \u207b\u00b9' Ioc b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers, 'a' and 'b', the interval [a, b] is non-empty if and only if a is less than or equal to b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Icc : (Icc a b).Nonempty \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of the open interval between \\(b\\) and \\(a\\) under the inverse dual map is equal to the open interval between the dual of \\(a\\) and the dual of \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Ioo : Ioo (toDual a) (toDual b) = ofDual \u207b\u00b9' Ioo b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an empty list, when converted to a string, results in an empty string.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nil_asString_eq_empty : [].asString = \"\" :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of natural numbers less than or equal to a given natural number 'a' is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Iic : (Iic a).Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting an empty string to a list results in an empty list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_empty : \"\".toList = [] :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the interval starting at 'a' (inclusive) and ending at 'b' (exclusive) is non-empty if and only if 'a' is strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ico : (Ico a b).Nonempty \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-empty string, converting it to a list is equivalent to creating a new list where the head is the first character of the string and the tail is the list representation of the remaining string.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_nonempty : \u2200 {s : String}, s \u2260 \"\" \u2192 s.toList = s.head :: (s.drop 1).toList\n  | \u27e8s\u27e9, h => by\n    cases s with\n    | nil => simp at h\n    | cons c cs =>\n      simp only [toList, data_drop, List.drop_succ_cons, List.drop_zero, List.cons.injEq, and_true]\n      rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the open interval between the dual of 'a' and the dual of 'b' is equal to the inverse image of the closed interval between 'b' and 'a' under the function 'ofDual'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dual_Ioc : Ioc (toDual a) (toDual b) = ofDual \u207b\u00b9' Ico b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval (a, b] is non-empty if and only if a is strictly less than b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that accessing the first element of an empty string results in the default value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem head_empty : \"\".data.head! = default :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the predecessor function (`natPred`) on natural numbers is strictly monotonic.  In other words, prove that for any natural numbers `m` and `n`, if `m` is less than `n`, then the predecessor of `m` is less than the predecessor of `n`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natPred_strictMono : StrictMono natPred :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the predecessor function on natural numbers (which subtracts 1 from any natural number greater than or equal to 1, and maps 0 to 0) is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the \"inl\" function, which takes an element of type \u03b1 and creates an element of type \"Sum \u03b1 \u03b2\" by tagging it as \"left\", is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inl_injective : Function.Injective (inl : \u03b1 \u2192 Sum \u03b1 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two strings, the first string is lexicographically smaller than the second string if and only if the list of characters of the first string is lexicographically smaller than the list of characters of the second string.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_iff_toList_lt : \u2200 {s\u2081 s\u2082 : String}, s\u2081 < s\u2082 \u2194 s\u2081.toList < s\u2082.toList\n  | \u27e8s\u2081\u27e9, \u27e8s\u2082\u27e9 => show ltb \u27e8\u27e8s\u2081\u27e9, 0\u27e9 \u27e8\u27e8s\u2082\u27e9, 0\u27e9 \u2194 s\u2081 < s\u2082 by\n    induction s\u2081 generalizing s\u2082 <;> cases s\u2082\n    \u00b7 decide\n    \u00b7 rename_i c\u2082 cs\u2082; apply iff_of_true\n      \u00b7 unfold ltb\n        -- Adaptation note: v4.7.0-rc1 exclude reduceMk from simp\n        simp [-reduceMk, Iterator.hasNext, csize_pos]\n      \u00b7 apply List.nil_lt_cons\n    \u00b7 rename_i c\u2081 cs\u2081 ih; apply iff_of_false\n      \u00b7 unfold ltb\n        -- Adaptation note: v4.7.0-rc1 exclude reduceMk from simp\n        simp [-reduceMk, Iterator.hasNext]\n      \u00b7 apply not_lt_of_lt; apply List.nil_lt_cons\n    \u00b7 rename_i c\u2081 cs\u2081 ih c\u2082 cs\u2082; unfold ltb\n      simp only [Iterator.hasNext, Pos.byteIdx_zero, endPos, utf8ByteSize, utf8ByteSize.go,\n        add_pos_iff, csize_pos, or_true, decide_eq_true_eq, \u2193reduceIte, Iterator.curr, get,\n        utf8GetAux, Iterator.next, next, Bool.ite_eq_true_distrib]\n      split_ifs with h\n      \u00b7 subst c\u2082\n        suffices ltb \u27e8\u27e8c\u2081 :: cs\u2081\u27e9, (0 : Pos) + c\u2081\u27e9 \u27e8\u27e8c\u2081 :: cs\u2082\u27e9, (0 : Pos) + c\u2081\u27e9 =\n          ltb \u27e8\u27e8cs\u2081\u27e9, 0\u27e9 \u27e8\u27e8cs\u2082\u27e9, 0\u27e9 by rw [this]; exact (ih cs\u2082).trans List.Lex.cons_iff.symm\n        apply ltb_cons_addChar\n      \u00b7 refine \u27e8List.Lex.rel, fun e \u21a6 ?_\u27e9\n        cases e <;> rename_i h'\n        \u00b7 contradiction\n        \u00b7 assumption\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `inr` is injective. `inr` takes an element of type `\u03b2` and creates an element of type `Sum \u03b1 \u03b2`, which represents either an element of type `\u03b1` or an element of type `\u03b2`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inr_injective : Function.Injective (inr : \u03b2 \u2192 Sum \u03b1 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `swap`, when applied twice in a row, returns the original input.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_leftInverse : Function.LeftInverse (@swap \u03b1 \u03b2) swap :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the successor function on positive natural numbers is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succPNat_injective : Function.Injective succPNat :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that swaps the elements of a pair is its own right inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_rightInverse : Function.RightInverse (@swap \u03b1 \u03b2) swap :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two positive natural numbers 'a' and 'b',  'a + 1' is less than or equal to 'b' if and only if 'a' is strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_one_le_iff : \u2200 {a b : \u2115+}, a + 1 \u2264 b \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `natPred`, which returns the predecessor of a natural number (or 0 if the input is 0), is a monotone function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natPred_monotone : Monotone natPred :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the successor function on natural numbers is strictly monotonic. In other words, prove that for any two natural numbers, if the first number is smaller than the second number, then the successor of the first number is smaller than the successor of the second number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succPNat_strictMono : StrictMono succPNat :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `coeMonoidHom`, which converts a positive natural number to a natural number, is equivalent to the natural embedding function `Coe.coe`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_coeMonoidHom : (coeMonoidHom : \u2115+ \u2192 \u2115) = Coe.coe :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the successor function on natural numbers is a monotonic function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succPNat_mono : Monotone succPNat :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function that does nothing to a container doesn't change the container.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_map : \u2200 x : P \u03b1, P.map id x = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two positive natural numbers 'a' and 'b', 'a' is strictly less than 'b + 1' if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_add_one_iff : \u2200 {a b : \u2115+}, a < b + 1 \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any ordered pair, if we swap the elements twice, we get back the original ordered pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_swap : \u2200 x : \u03b1 \u00d7 \u03b2, swap (swap x) = x\n  | \u27e8_, _\u27e9 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for every positive natural number `n` that is not equal to 1, there exists a positive natural number `k` such that `n` is equal to `k + 1`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_eq_succ_of_ne_one : \u2200 {n : \u2115+} (_ : n \u2260 1), \u2203 k : \u2115+, n = k + 1\n  | \u27e81, _\u27e9, h\u2081 => False.elim <| h\u2081 rfl\n  | \u27e8n + 2, _\u27e9, _ => \u27e8\u27e8n + 1, by simp\u27e9, rfl\u27e9\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that swaps the elements of a pair is its own left inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_leftInverse : Function.LeftInverse (@swap \u03b1 \u03b2) swap :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two types \u03b1 and \u03b2, the `swap` function, which takes a function from \u03b1 to \u03b2 and returns a function from \u03b2 to \u03b1 by reversing the input and output types, is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_surjective : Function.Surjective (@swap \u03b1 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that swapping the elements of a pair is an injective function. In other words, if swapping two pairs results in the same pair, then the original pairs were the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_injective : Function.Injective (@swap \u03b1 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that swaps the elements of an ordered pair is bijective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_bijective : Function.Bijective (@swap \u03b1 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that swaps the elements of a pair is its own right inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_rightInverse : Function.RightInverse (@swap \u03b1 \u03b2) swap :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two ordered pairs are equal if and only if their corresponding components are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_iff_fst_eq_snd_eq : \u2200 {p q : \u03b1 \u00d7 \u03b2}, p = q \u2194 p.1 = q.1 \u2227 p.2 = q.2\n  | \u27e8p\u2081, p\u2082\u27e9, \u27e8q\u2081, q\u2082\u27e9 => by simp\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that swapping the elements of a pair twice results in the original pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_swap_eq : swap \u2218 swap = @id (\u03b1 \u00d7 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any pair (a, b), the second element of the pair (b) is equal to some value x if and only if the pair itself is equal to (a, x).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snd_eq_iff : \u2200 {p : \u03b1 \u00d7 \u03b2} {x : \u03b2}, p.2 = x \u2194 p = (p.1, x)\n  | \u27e8a, b\u27e9, x => by simp\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any ordered pair (a, b), the first element 'a' is equal to a value 'x' if and only if the entire ordered pair (a, b) is equal to the ordered pair (x, b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fst_eq_iff : \u2200 {p : \u03b1 \u00d7 \u03b2} {x : \u03b1}, p.1 = x \u2194 p = (x, p.2)\n  | \u27e8a, b\u27e9, x => by simp\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element `w` of a specific type called `WType \u03b2`, applying the function `toSigma` to `w` and then applying the function `ofSigma` to the result always gives back the original element `w`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofSigma_toSigma : \u2200 w : WType \u03b2, ofSigma (toSigma w) = w\n  | \u27e8_, _\u27e9 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a dependent function to a regular function is injective. In other words, if two dependent functions are different, their corresponding regular function representations are also different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_injective : @Function.Injective (\u03a0\u2080 i, \u03b2 i) (\u2200 i, \u03b2 i) (\u21d1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `fst` (which takes a pair and returns its first element) from the dependent sum type `\u03a3 a, \u03b2 a` to `\u03b1` is surjective if and only if for every `a` in `\u03b1`, the type `\u03b2 a` is nonempty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fst_surjective_iff : Surjective (fst : (\u03a3 a, \u03b2 a) \u2192 \u03b1) \u2194 \u2200 a, Nonempty (\u03b2 a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function defined piecewise (using `piecewise`) is equivalent regardless of the order in which the conditions are checked.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_piecewise : \u21d1(x.piecewise y s) = s.piecewise x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `fst` (which takes a pair and returns its first element) is injective if and only if for every possible first element `a`, there is at most one possible second element `b` to form a pair `(a, b)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fst_injective_iff : Injective (fst : (\u03a3 a, \u03b2 a) \u2192 \u03b1) \u2194 \u2200 a, Subsingleton (\u03b2 a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the algebra map from a ring R to the ring of multivariate polynomials with coefficients in R over a set of variables \u03c3 is equivalent to the canonical ring homomorphism from R to the ring of multivariate polynomials.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_eq : algebraMap R (MvPolynomial \u03c3 R) = C :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the constant polynomial 1 and viewing it as a multivariate polynomial results in the constant multivariate polynomial 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_1 : C 1 = (1 : MvPolynomial \u03c3 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any dependent pair `s` (which consists of an element `a` of type `\u03b1` and a function from `\u03b2 a` to a type `\u03b2`), converting `s` to a sigma type and then back results in the original pair `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSigma_ofSigma : \u2200 s : \u03a3a : \u03b1, \u03b2 a \u2192 WType \u03b2, toSigma (ofSigma s) = s\n  | \u27e8_, _\u27e9 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'C' to the number 0 results in a zero polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_0 : C 0 = (0 : MvPolynomial \u03c3 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that multiplying two polynomials is equivalent to summing up the product of each term in the first polynomial with each term in the second polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_def : p * q = p.sum fun m a => q.sum fun n b => monomial (m + n) (a * b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a constant 'a' into a multivariate polynomial is the same as creating a monomial with coefficient 'a' and exponent 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_apply : (C a : MvPolynomial \u03c3 R) = monomial 0 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the product of two monomials \\( a \\) and \\( a' \\) into a constant polynomial is equivalent to multiplying the constant polynomials derived from \\( a \\) and \\( a' \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_mul : (C (a * a') : MvPolynomial \u03c3 R) = C a * C a' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v`, converting it to a list and then back to a vector using the same underlying data representation results in the original vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_toList : \u2200 (v : Vector \u03b1 n) (h), (\u27e8toList v, h\u27e9 : Vector \u03b1 n) = v\n  | \u27e8_, _\u27e9, _ => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that multiplying a constant `a` with a monomial (a polynomial with a single term) with coefficient 1 and variable term `s` raised to the power `a'`, is equivalent to a single monomial with coefficient `a * a'` and the same variable term `s` raised to the power `a'`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_mul_monomial : C a * monomial s a' = monomial s (a * a') :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two vectors, `v` and `w`, of the same size, if each corresponding element of `v` and `w` are equal, then the vectors `v` and `w` are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext : \u2200 {v w : Vector \u03b1 n} (_ : \u2200 m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | \u27e8v, hv\u27e9, \u27e8w, hw\u27e9, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h \u27e8m, hv \u25b8 hm\u27e9)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v` containing exactly one element, the tail of `v` is an empty vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_tail : \u2200 (v : Vector \u03b1 1), v.tail = Vector.nil\n  | \u27e8[_], _\u27e9 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider polynomial expressions with variables coming from a set '\u03c3' and coefficients from a set 'R'. The 'C' in the expression represents taking the constant term of a polynomial. Prove that taking the constant term of the sum of two polynomials (a + a') is equivalent to adding the constant terms of each polynomial individually (C a + C a').\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_add : (C (a + a') : MvPolynomial \u03c3 R) = C a + C a' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting lists of a fixed length 'n' to lists preserves distinctness. In other words, if two lists of length 'n' are different, their conversions to lists are also different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_injective : Function.Injective (@toList \u03b1 n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that accessing the i-th element of a vector `v` using the `get` function is equivalent to accessing the i-th element of the list obtained by converting `v` into a list using the `toList` function and then accessing the i-th element of that list using the `nthLe` function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nth_eq_nthLe :\n    \u2200 (v : Vector \u03b1 n) (i), get v i = v.toList.nthLe i.1 (by rw [toList_length]; exact i.2)\n  | \u27e8_, _\u27e9, _ => rfl:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the tail of an empty list is an empty list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_nil : (@nil \u03b1).tail = nil :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v`, taking the tail of the vector and then accessing its elements is the same as accessing the elements of the vector and then taking the tail of the resulting list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_val : \u2200 v : Vector \u03b1 n.succ, v.tail.val = v.val.tail\n  | \u27e8_ :: _, _\u27e9 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that accessing the only element of a singleton list (a list with only one element) returns that element itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem get_cons_nil : \u2200 {ix : Fin 1} (x : \u03b1), get (x ::\u1d65 nil) ix = x\n  | \u27e80, _\u27e9, _ => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v` with length `n+1`, accessing the `i`-th element of the tail of `v` is the same as accessing the `i+1`-th element of `v` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem get_tail_succ : \u2200 (v : Vector \u03b1 n.succ) (i : Fin n), get (tail v) i = get v i.succ\n  | \u27e8a :: l, e\u27e9, \u27e8i, h\u27e9 => by simp [get_eq_get]; rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v` containing elements of type `\u03b1` and having a length that is the successor of some natural number `n`, accessing the element at index 0 is equivalent to retrieving the head of the vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem get_zero : \u2200 v : Vector \u03b1 n.succ, get v 0 = head v\n  | \u27e8_ :: _, _\u27e9 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the polynomial represented by the zero function is equal to the zero polynomial in the ring of polynomials R[X].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofFinsupp_zero : (\u27e80\u27e9 : R[X]) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the polynomial \"1\" (a constant polynomial) is equal to the polynomial represented by the coefficient 1 at the term with degree 0 in the polynomial ring R[X].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofFinsupp_one : (\u27e81\u27e9 : R[X]) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the graph of the zero function from a set \u03b1 to a set M is the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem graph_zero : graph (0 : \u03b1 \u2192\u2080 M) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the multiplicative identity (1) in the polynomial ring R[X] to a finitely supported function results in the multiplicative identity (1) in the space of finitely supported functions.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFinsupp_one : (1 : R[X]).toFinsupp = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the `toFinsupp` function, when applied to the zero polynomial in the ring of polynomials over a ring R, results in the zero function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFinsupp_zero : (0 : R[X]).toFinsupp = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `val`, which converts a finite set into a multiset (a set that allows duplicates), is injective. In other words, if two finite sets are converted into the same multiset, then the original finite sets must have been equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_injective : Injective (val : Finset \u03b1 \u2192 Multiset \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toFinsupp`, which maps a polynomial to its representation as a formal sum with finite support, is injective. In other words, different polynomials always have different representations as formal sums.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFinsupp_injective : Function.Injective (toFinsupp : R[X] \u2192 AddMonoidAlgebra _ _) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers, 'a' and 'b', the interval from 'a' (inclusive) to 'b' (exclusive) is empty if and only if 'a' is not less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_eq_empty_iff : Ioc a b = \u2205 \u2194 \u00aca < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\(s\\) and \\(t\\), if the underlying collections of elements in \\(s\\) and \\(t\\) are equal, then the sets \\(s\\) and \\(t\\) themselves are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_of_veq : \u2200 {s t : Finset \u03b1}, s.1 = t.1 \u2192 s = t\n  | \u27e8s, _\u27e9, \u27e8t, _\u27e9, h => by cases h; rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the closed interval from 'a' to 'b' is empty if and only if 'a' is not less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc_eq_empty_iff : Icc a b = \u2205 \u2194 \u00aca \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval (a, b) is nonempty if and only if a < b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval of natural numbers from `a` (inclusive) to `b` (exclusive) is nonempty if and only if `a` is strictly less than `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ico : (Ico a b).Nonempty \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers 'a' and 'b', the set of natural numbers between 'a' and 'b' (excluding 'b') is empty if and only if 'a' is not less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_eq_empty_iff : Ico a b = \u2205 \u2194 \u00aca < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval [a, b] is nonempty if and only if a is less than or equal to b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Icc : (Icc a b).Nonempty \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number is not an element of the open interval (a, b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_not_mem_Ioo : a \u2209 Ioo a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', 'a' is not an element of the open interval (a, b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_not_mem_Ioc : a \u2209 Ioc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number 'a' belongs to the interval [a, b) if and only if 'a' is strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_mem_Ico : a \u2208 Ico a b \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a function `f` defined on the first `n` natural numbers to a list, is equivalent to directly constructing a list from the same function `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_ofFn : \u2200 {n} (f : Fin n \u2192 \u03b1), toList (ofFn f) = List.ofFn f\n  | 0, f => rfl\n  | n + 1, f => by rw [ofFn, List.ofFn_succ, toList_cons, toList_ofFn]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number 'a' belongs to the closed interval [a, b] if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_mem_Icc : a \u2208 Icc a b \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', 'b' belongs to the closed interval from 'a' to 'b' if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', 'b' belongs to the interval open on the left and closed on the right (a, b] if and only if 'a' is strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_mem_Ioc : b \u2208 Ioc a b \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the open interval (a, b) is a subset of the half-open interval (a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioo_subset_Ico_self : Ioo a b \u2286 Ico a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', 'b' is not an element of the open interval (a, b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_not_mem_Ioo : b \u2209 Ioo a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the open interval (a, b) is a subset of the closed interval [a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioo_subset_Icc_self : Ioo a b \u2286 Icc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the open interval (a, b) is a subset of the closed interval [a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_subset_Icc_self : Ioc a b \u2286 Icc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', 'b' is not an element of the interval open on the right '[a, b)'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_not_mem_Ico : b \u2209 Ico a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the interval including 'a' but excluding 'b' is a subset of the interval including both 'a' and 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b \u2286 Icc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the factorial of any natural number is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorial_pos : \u2200 n, 0 < n !\n  | 0 => Nat.zero_lt_one\n  | succ n => Nat.mul_pos (succ_pos _) (factorial_pos n)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 0 is not coprime to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_coprime_zero_zero : \u00acCoprime 0 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the open interval (a, b) is a subset of the half-open interval (a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioo_subset_Ioc_self : Ioo a b \u2286 Ioc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number k, the ascending factorial of k starting from 1 is equal to the factorial of k.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_ascFactorial : \u2200 (k : \u2115), (1 : \u2115).ascFactorial k = k.factorial\n  | 0 => ascFactorial_zero 1\n  | (k+1) => by\n    rw [ascFactorial_succ, one_ascFactorial k, Nat.add_comm, factorial_succ]:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive integer *m* less than or equal to another integer *n*, *m* divides *n*!.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_factorial : \u2200 {m n}, 0 < m \u2192 m \u2264 n \u2192 m \u2223 n !\n  | succ _, _, _, h => Nat.dvd_trans (Nat.dvd_mul_right _ _) (factorial_dvd_factorial h)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number k, the ascending factorial of 0 up to (k + 1) is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_ascFactorial : \u2200 (k : \u2115), (0 : \u2115).ascFactorial k.succ = 0\n  | 0 => by\n    rw [ascFactorial_succ, ascFactorial_zero, Nat.zero_add, Nat.zero_mul]\n  | (k+1) => by\n    rw [ascFactorial_succ, zero_ascFactorial k, Nat.mul_zero]:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number n, n is less than or equal to its factorial (n!).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_le_factorial : \u2200 n : \u2115, n \u2264 n !\n  | 0 => Nat.zero_le _\n  | k + 1 => Nat.le_mul_of_pos_right _ (Nat.one_le_of_lt k.factorial_pos)\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers `m` and `n`, the product of the factorial of `m` and (m+1) raised to the power of `n` is less than or equal to the factorial of (m+n).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorial_mul_pow_le_factorial : \u2200 {m n : \u2115}, m ! * (m + 1) ^ n \u2264 (m + n)!\n  | m, 0 => by simp\n  | m, n + 1 => by\n    rw [\u2190 Nat.add_assoc, factorial_succ, Nat.mul_comm (_ + 1), Nat.pow_succ, \u2190 Nat.mul_assoc]\n    exact Nat.mul_le_mul factorial_mul_pow_le_factorial (succ_le_succ (le_add_right _ _))\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Fibonacci sequence is monotonically increasing, meaning that each Fibonacci number is greater than or equal to the one before it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fib_mono : Monotone fib :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the factorial of *n* equals 1 if and only if *n* is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorial_eq_one : n ! = 1 \u2194 n \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Fibonacci sequence starting from the third term is strictly increasing. That is, each Fibonacci number from the third one onwards is strictly greater than the one before it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the prime factorization of a natural number (excluding zero) is unique. In other words, if two non-zero natural numbers have the same prime factorization, they must be the same number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorization_inj : Set.InjOn factorization { x : \u2115 | x \u2260 0 } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the factorization of 0 is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorization_zero : factorization 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers n and k, (n+1) times the binomial coefficient \"n choose k\" is equal to (k+1) times the binomial coefficient \"(n+1) choose (k+1)\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succ_mul_choose_eq : \u2200 n k, succ n * choose n k = choose (succ n) (succ k) * succ k\n  | 0, 0 => by decide\n  | 0, k + 1 => by simp [choose]\n  | n + 1, 0 => by simp [choose, mul_succ, succ_eq_add_one, Nat.add_comm]\n  | n + 1, k + 1 => by\n    rw [choose_succ_succ (succ n) (succ k), Nat.add_mul, \u2190 succ_mul_choose_eq n, mul_succ, \u2190\n      succ_mul_choose_eq n, Nat.add_right_comm, \u2190 Nat.mul_add, \u2190 choose_succ_succ, \u2190 succ_mul]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the prime factorization of 1 has a size of 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorization_one : factorization 1 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which maps an element `a` of type `A` to the corresponding singleton set `{a}` (of type `Set B`) is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective (SetLike.coe : A \u2192 Set B) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that if we have a subset \\(p\\) of a set \\(B\\), considering \\(p\\) as a type is the same as \\(p\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sort_coe : ((p : Set B) : Type _) = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers n and k, if k is less than or equal to n, then the binomial coefficient \"n choose k\" is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem choose_pos : \u2200 {n k}, k \u2264 n \u2192 0 < choose n k\n  | 0, _, hk => by rw [Nat.eq_zero_of_le_zero hk]; decide\n  | n + 1, 0, _ => by simp\n  | n + 1, k + 1, hk => Nat.add_pos_left (choose_pos (le_of_succ_le_succ hk)) _\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative integers n and k, if n is strictly less than k, then \"n choose k\" is equal to 0. (\"n choose k\" represents the number of ways to choose k objects from a set of n distinct objects).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem choose_eq_zero_of_lt : \u2200 {n k}, n < k \u2192 choose n k = 0\n  | _, 0, hk => absurd hk (Nat.not_lt_zero _)\n  | 0, k + 1, _ => choose_zero_succ _\n  | n + 1, k + 1, hk => by\n    have hnk : n < k :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given two sets A and B, if A is a subset of B, then the image of A under a function is a subset of the image of B under the same function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mono : Monotone (SetLike.coe : A \u2192 Set B) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `Fin.val` is injective. In other words, prove that for any two distinct elements `a` and `b` in `Fin n`, their values under `Fin.val` are also distinct.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\( p \\) and \\( q \\) which are subsets of a set \\( B \\),  \\( p \\) and \\( q \\) are equal if and only if they are equal as sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_set_eq : (p : Set B) = q \u2194 p = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(p\\) is a strict subset of another set \\(q\\), then there exists an element \\(x\\) that belongs to set \\(q\\) but not to set \\(p\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_of_lt : p < q \u2192 \u2203 x \u2208 q, x \u2209 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set \\( p \\) is not a subset of another set \\( q \\) if and only if there exists an element \\( x \\) that belongs to set \\( p \\) but not to set \\( q \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_le_iff_exists : \u00acp \u2264 q \u2194 \u2203 x \u2208 p, x \u2209 q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a way to view elements of set A as subsets of set B, then this viewing operation is \"strictly monotone.\" This means that if we have two elements in A, where one is strictly smaller than the other, then the corresponding subsets we get in B also have a strict subset relationship.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_strictMono : StrictMono (SetLike.coe : A \u2192 Set B) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `val`, which maps a natural number less than `n` to itself, is strictly monotonic. In other words, if `i` and `j` are natural numbers less than `n` and `i` is less than `j`, then `val(i)` is less than `val(j)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_strictMono : StrictMono (val : Fin n \u2192 \u2115) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets, p and q, are equal if and only if they contain the exact same elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff : p = q \u2194 \u2200 x, x \u2208 p \u2194 x \u2208 q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing the embedding from a subtype of natural numbers less than 'n' back into the natural numbers with the canonical embedding from this subtype to itself results in the embedding function that directly includes this subtype into the natural numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equivSubtype_symm_trans_valEmbedding :\n    equivSubtype.symm.toEmbedding.trans valEmbedding = Embedding.subtype (\u00b7 < n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\( p \\) and \\( q \\), \\( p \\) is a strict subset of \\( q \\) (\\( p \\subset q \\)) if and only if \\( p \\) is a subset of \\( q \\) (\\( p \\subseteq q \\)) and there exists an element \\( x \\) that belongs to \\( q \\) but not to \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_iff_le_and_exists : p < q \u2194 p \u2264 q \u2227 \u2203 x \u2208 q, x \u2209 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing the first element from a list constructed by adding an element 'x' to the beginning of a list 'p' results in the original list 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_cons : tail (cons x p) = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of adding an element to the beginning of a list is injective. In other words, if adding an element 'a' to the beginning of list 'x' results in the same list as adding 'a' to the beginning of list 'y', then lists 'x' and 'y' must be the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_injective2 : Function.Injective2 (@cons n \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that accessing the element after the \\(i\\)-th position in a sequence obtained by adding an element \\(x\\) at the beginning is the same as accessing the \\(i\\)-th element in the original sequence \\(p\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_succ : cons x p i.succ = p i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that updating a sequence `q` at index 0 with a value `z` does not change the tail of the sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_update_zero : tail (update q 0 z) = tail q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a sequence of elements and we want to update an element at a particular position 'i + 1' in this sequence to a new value 'y'. This theorem states that taking the tail of this updated sequence (removing the first element) is the same as first removing the first element and then updating the element at position 'i' to 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_update_succ : tail (update q i.succ y) = update (tail q) i y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a list, and we want to update its element at a specific position. We can either add an element to the beginning of the list and then update the list at the position shifted by one, or we can update the list first and then add the element at the beginning. Prove that these two operations result in the same list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_update : cons x (update p i y) = update (cons x p) i.succ y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sequence *q*, if we take the first element of *q*, and prepend it to the tail of *q* (the sequence *q* without the first element), we get back the original sequence *q*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_self_tail : cons (q 0) (tail q) = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cauchy real number represented by the sequence with constant value 0 is equal to the real number 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofCauchy_zero : (\u27e80\u27e9 : \u211d) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that updating the 0th element of a list to `z`, where the list is constructed by adding `x` at the beginning of list `p`, results in the same list as adding `z` at the beginning of `p`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem update_cons_zero : update (cons x p) 0 z = cons z p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cauchy completion of the real number 1 is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_one : (1 : \u211d).cauchy = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cauchy sequence representation of the real number 0 is equal to the real number 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_zero : (0 : \u211d).cauchy = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cauchy product of two real numbers is equal to the sum of their individual Cauchy sequences.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_add : \u2200 a b, (a + b : \u211d).cauchy = a.cauchy + b.cauchy\n  | \u27e8a\u27e9, \u27e8b\u27e9 => show (add _ _).cauchy = _ by rw [add_def]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative integers n and k where k is less than or equal to n, the product of \"n choose k\", k factorial, and (n-k) factorial is equal to n factorial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem choose_mul_factorial_mul_factorial : \u2200 {n k}, k \u2264 n \u2192 choose n k * k ! * (n - k)! = n !\n  | 0, _, hk => by simp [Nat.eq_zero_of_le_zero hk]\n  | n + 1, 0, _ => by simp\n  | n + 1, succ k, hk => by\n    rcases lt_or_eq_of_le hk with hk\u2081 | hk\u2081\n    \u00b7 have h : choose n k * k.succ ! * (n - k)! = (k + 1) * n ! :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number 'a', taking the Cauchy sequence representation of '-a' is equivalent to taking the Cauchy sequence representation of 'a' and then negating each element of the sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_neg : \u2200 a, (-a : \u211d).cauchy = -a.cauchy\n  | \u27e8a\u27e9 => show (neg _).cauchy = _ by rw [neg_def]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the value of 0 in the modulo *n* system is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_zero : \u2200 {n}, (0 : ZMod n).val = 0\n  | 0 => rfl\n  | _ + 1 => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n* and any element *i* in the set of integers modulo *n* (denoted as ZMod n), casting *i* to ZMod *n* results in the same element *i*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_id : \u2200 (n) (i : ZMod n), (ZMod.cast i : ZMod n) = i\n  | 0, _ => Int.cast_id\n  | _ + 1, i => nat_cast_zmod_val i\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function between sets of real numbers preserves the property of being a Cauchy sequence under inversion, meaning a sequence is a Cauchy sequence if and only if its inverse is also a Cauchy sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_inv : \u2200 f, (f\u207b\u00b9 : \u211d).cauchy = f.cauchy\u207b\u00b9\n  | \u27e8f\u27e9 => show (inv' _).cauchy = _ by rw [inv']\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cauchy product of two real numbers, represented as Cauchy sequences, is equal to the product of their individual Cauchy representations.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_mul : \u2200 a b, (a * b : \u211d).cauchy = a.cauchy * b.cauchy\n  | \u27e8a\u27e9, \u27e8b\u27e9 => show (mul _ _).cauchy = _ by rw [mul_def]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the casting operation from integers (\u2124) to integers modulo n (ZMod n) is surjective. In other words, show that for every element in the set of integers modulo n, there exists an integer that maps to it under this casting operation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem int_cast_surjective : Function.Surjective ((\u2191) : \u2124 \u2192 ZMod n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two real numbers are equal if and only if their Cauchy sequences are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_cauchy_iff : \u2200 {x y : Real}, x = y \u2194 x.cauchy = y.cauchy\n  | \u27e8a\u27e9, \u27e8b\u27e9 => by rw [ofCauchy.injEq]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers, the Cauchy sequence of their difference is equal to the difference of their Cauchy sequences.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cauchy_sub : \u2200 a b, (a - b : \u211d).cauchy = a.cauchy - b.cauchy\n  | \u27e8a\u27e9, \u27e8b\u27e9 => by\n    rw [sub_eq_add_neg, \u2190 cauchy_neg, \u2190 cauchy_add]\n    rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the element 0 from the integers modulo n (ZMod n) to a real number (R) results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_zero : (cast (0 : ZMod n) : R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that directly coercing a function `f` (using `DFunLike.coe`) is equivalent to applying a function that coerces its input (`fun f => \u2191f`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_eq_coe_fn : (DFunLike.coe (F :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting an integer to its residue class modulo n and then converting it back to an integer is the same as the original integer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem int_cast_rightInverse : Function.RightInverse (cast : ZMod n \u2192 \u2124) ((\u2191) : \u2124 \u2192 ZMod n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any Boolean value `a`, if `a` is not equal to `true`, then `a` must be equal to `false`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_false_of_ne_true : \u2200 {a : Bool}, a \u2260 true \u2192 a = false :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two matrices M and N are equal if and only if all of their corresponding elements are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff : (\u2200 i j, M i j = N i j) \u2194 M = N :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that negates a boolean value is not equal to the identity function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_ne_id : not \u2260 id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values `a` and `b`, `a` is logically equivalent to `b` if and only if `a` is equal to `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_iff_coe : \u2200 {a b : Bool}, (a \u2194 b) \u2194 a = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True or False) `a` and `b`, if `a` and `b` are both True, then `a` is True.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_elim_left : \u2200 {a b : Bool}, a && b \u2192 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values `a` and `b`, if `a` is true and `b` is true, then the logical conjunction of `a` and `b` is also true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_intro : \u2200 {a b : Bool}, a \u2192 b \u2192 a && b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that casting an integer modulo n to an integer and then to a real number is the same as directly casting it to a real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem int_cast_comp_cast : ((\u2191) : \u2124 \u2192 R) \u2218 (cast : ZMod n \u2192 \u2124) = cast :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two functions are equal when viewed as functions from a type \u03b1 to a dependent function type (\u2200 a : \u03b1, \u03b2 a), then they are actually the same function in the original function type F.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective (fun f : F \u21a6 (f : \u2200 a : \u03b1, \u03b2 a)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values `a` and `b`, if `a` and `b` are both true, then `b` is true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_elim_right : \u2200 {a b : Bool}, a && b \u2192 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any Boolean value `a`, if `a` is not false, then `a` must be true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_true_of_ne_false : \u2200 {a : Bool}, a \u2260 false \u2192 a = true :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True or False) `a` and `b`, the negation of the negation of `a` being equal to `b` is logically equivalent to `a` being equal to `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_not_eq : \u2200 {a b : Bool}, \u00ac(!a) = b \u2194 a = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values `x` and `y`, the exclusive or (xor) of `x` and `y` is true if and only if `x` is not equal to `y`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem xor_iff_ne : \u2200 {x y : Bool}, xor x y = true \u2194 x \u2260 y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the propositional logic, \"false\" is less than \"true\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem false_lt_true : false < true :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values `x` and `y`, `x` is less than `y` if and only if `x` is false and `y` is true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_iff : \u2200 {x y : Bool}, x < y \u2194 x = false \u2227 y = true :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any boolean value `b`, prove that the logical negation of `b` (`!b`) is equivalent to `b` being false (`\u00acb`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_iff_not : \u2200 {b : Bool}, !b \u2194 \u00acb :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True or False) 'a' and 'b', the negation of 'a' being equal to the negation of 'b' is equivalent to 'a' being equal to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_eq_not : \u2200 {a b : Bool}, \u00aca = !b \u2194 a = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a recursive function over multisets to an empty multiset always results in the base case value for the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem recOn_0 : @Multiset.recOn \u03b1 C (0 : Multiset \u03b1) C_0 C_cons C_cons_heq = C_0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty multiset, when interpreted as a natural number, is equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_nil : (@nil \u03b1 : Multiset \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values `x` and `y`, the logical AND of `x` and `y` is always less than or equal to `x`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_le_left : \u2200 x y : Bool, (x && y) \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True/False)  `x` and `y`, the logical AND of `x` and `y`  is always less than or equal to `y`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_le_right : \u2200 x y : Bool, (x && y) \u2264 y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the least upper bound of the empty set of non-negative extended real numbers is infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem none_eq_top : (none : \u211d\u22650\u221e) = \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty multiset is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem empty_eq_zero : (\u2205 : Multiset \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True or False),  x is less than or equal to y if and only if x implies y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_iff_imp : \u2200 {x y : Bool}, x \u2264 y \u2194 x \u2192 y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `q` preserves supports if and only if `q` is a uniform function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem suppPreservation_iff_isUniform : q.SuppPreservation \u2194 q.IsUniform :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-infinite non-negative extended real number `a`, converting it to a non-negative real number and back results in the same value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toNNReal : \u2200 {a : \u211d\u22650\u221e}, a \u2260 \u221e \u2192 \u2191a.toNNReal = a\n  | ofNNReal _, _ => rfl\n  | \u22a4, h => (h rfl).elim\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a given property 'q', preserving the property when lifting to powersets ('LiftPPreservation') is equivalent to 'q' being a uniform property ('IsUniform').\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem liftpPreservation_iff_uniform : q.LiftPPreservation \u2194 q.IsUniform :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a non-negative extended real number to a non-negative real number and back results in the same number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toNNReal_coe : (r : \u211d\u22650\u221e).toNNReal = r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function that maps an element to a singleton set containing only that element is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_injective : Injective fun a : \u03b1 => [a] :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative extended real number, converting it to a non-negative real number and then back to an extended real number results in a value less than or equal to the original number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toNNReal_le_self : \u2200 {a : \u211d\u22650\u221e}, \u2191a.toNNReal \u2264 a\n  | ofNNReal r => by rw [toNNReal_coe]\n  | \u22a4 => le_top\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the real number 0 to an extended non-negative real number results in the same value, 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : \u2191(0 : \u211d\u22650) = (0 : \u211d\u22650\u221e) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a real number 'p' to an extended non-negative real number and then treating it as a real number again will result in the original real number 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_coe_nnreal : ENNReal.ofReal p = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a mathematical structure 'q', preserving supports is equivalent to preserving liftings of predicates.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem suppPreservation_iff_liftpPreservation : q.SuppPreservation \u2194 q.LiftPPreservation :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of the function `ofNNReal` is equal to the set of all real numbers except for infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_coe' : range ofNNReal = Iio \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `joinM` is equivalent to the function `join`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem joinM_eq_join : joinM = @join \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set '\u03b1' is countable if and only if there exists an injection (a one-to-one function) from '\u03b1' to the set of natural numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable \u03b1 \u2194 Nonempty (\u03b1 \u21aa \u2115) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(a\\) belongs to a multiset formed by adding an element \\(b\\) to an existing multiset \\(s\\) (denoted as \\(b ::\u209b s\\)) if and only if either \\(a\\) is equal to \\(b\\), or \\(a\\) belongs to the original multiset \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_cons : a \u2208 b ::\u209b s \u2194 a = b \u2228 a \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set \\( \u03b1 \\) is uncountable if and only if there is no injective function from \\( \u03b1 \\) to the set of natural numbers \\( \u2115 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uncountable_iff_isEmpty_embedding : Uncountable \u03b1 \u2194 IsEmpty (\u03b1 \u21aa \u2115) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting an empty vector of length 0 to a permutation of length 0 results in an empty permutation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofVector_nil : \u2191(Vector.nil : Vector \u03b1 0) = (Sym.nil : Sym \u03b1 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list containing `n` copies of an element `a` into a multiset is equivalent to creating a multiset with `n` copies of `a` directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_replicate : (replicate n a : Multiset \u03b1) = Multiset.replicate n a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `re` is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem re_surjective : Surjective re :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a permutation (an arrangement of elements from a set) to a multiset (a set that allows for duplicate elements) is an injective operation. In simpler terms, if two permutations are different, then the multisets formed by their elements will also be different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Injective ((\u2191) : Sym \u03b1 n \u2192 Multiset \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( b \\) is in a multiset containing \\( n \\) copies of an element \\( a \\) if and only if \\( n \\) is not zero and \\( b \\) is equal to \\( a \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_replicate : b \u2208 replicate n a \u2194 n \u2260 0 \u2227 b = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a multiset 's' and an element 'a', prove that 's' is equal to a multiset containing 'n' copies of 'a' if and only if every element in 's' is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_replicate_iff : s = replicate n a \u2194 \u2200 b \u2208 s, b = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `im` is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem im_surjective : Surjective im :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which maps a real number to its corresponding complex number is injective. In other words, different real numbers are always represented by different complex numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_injective : Function.Injective ((\u2191) : \u211d \u2192 \u2102) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any two complex numbers are equal if their real parts and imaginary parts are equal, respectively.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext : \u2200 {z w : \u2102}, z.re = w.re \u2192 z.im = w.im \u2192 z = w\n  | \u27e8_, _\u27e9, \u27e8_, _\u27e9, rfl, rfl => rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of the image function is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_im : range im = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the imaginary part of the complex number  `I` is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem I_im : I.im = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complex number 0 is equal to the real number 0 when viewed as a complex number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_zero : ((0 : \u211d) : \u2102) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every non-negative real number is the square of some real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_re : range re = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every element belongs to the set containing all elements of a particular type.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_univ_val : \u2200 x, x \u2208 (univ : Finset \u03b1).1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complex number 1 is equal to the real number 1 when considered as a complex number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_one : ((1 : \u211d) : \u2102) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real part of the imaginary unit is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem I_re : I.re = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets, 's' and 't', are codisjoint \u2013 meaning their union comprises all possible elements \u2013 if and only if any element not present in set 's' must be present in set 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem codisjoint_left : Codisjoint s t \u2194 \u2200 \u2983a\u2984, a \u2209 s \u2192 a \u2208 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the imaginary unit, denoted as 'I', when multiplied by itself, results in -1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem I_mul_I : I * I = -1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the largest possible finite subset (denoted as \u22a4) of any set (represented by the type \u03b1) is equal to the set containing all elements of that type (denoted as univ).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem top_eq_univ : (\u22a4 : Finset \u03b1) = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is equal to the universal set ('univ') if and only if every element 'x' belongs to the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_univ_iff_forall : s = univ \u2194 \u2200 x, x \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if every element belongs to a set 's', then the set 's' is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_univ_of_forall : (\u2200 x, x \u2208 s) \u2192 s = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\( a \\) and any set \\( s \\),  \\( a \\) not being an element of the complement of \\( s \\) is equivalent to \\( a \\) being an element of \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_mem_compl : a \u2209 s\u1d9c \u2194 a \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( a \\) belongs to the complement of a set \\( s \\) if and only if \\( a \\) does not belong to the set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_compl : a \u2208 s\u1d9c \u2194 a \u2209 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets,  's' and 't', are codisjoint - meaning they have no common elements except possibly for a specific element 'a' - if and only if, for every 'a', if 'a' is not in set 't', then 'a' must be in set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem codisjoint_right : Codisjoint s t \u2194 \u2200 \u2983a\u2984, a \u2209 t \u2192 a \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of the empty set is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_empty : (\u2205 : Finset \u03b1)\u1d9c = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' of elements of type '\u03b1' is equal to the universal set (the set containing all elements of type '\u03b1') if and only if 's' is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_eq_univ : (s : Set \u03b1) = Set.univ \u2194 s = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set is empty if and only if the set containing all elements of that set is also empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem univ_eq_empty_iff : (univ : Finset \u03b1) = \u2205 \u2194 IsEmpty \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type \u03b1, the statement \"the set of all elements of type \u03b1 is not empty\" is equivalent to the statement \"the type \u03b1 is not empty\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem univ_nonempty_iff : (univ : Finset \u03b1).Nonempty \u2194 Nonempty \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the finite set containing all elements of a type to a regular set results in a set that contains all elements of that type.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_univ : \u2191(univ : Finset \u03b1) = (Set.univ : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the universe set in a metric space has the property of \"UniqueMDiffOn\" with respect to any interval I.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniqueMDiffOn_univ : UniqueMDiffOn I (univ : Set M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity function on a manifold M is continuously differentiable of any order n on any set s in M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contMDiffOn_id : ContMDiffOn I I n (id : M \u2192 M) s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any interval \\(I\\) and any point \\(x\\), the property \"unique differentiable within \\(I\\) at \\(x\\)\" holds for the entire real line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniqueMDiffWithinAt_univ : UniqueMDiffWithinAt I univ x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of the set obtained by inserting an element 'a' into a set 's' is equal to the set obtained by first taking the complement of 's' and then removing 'a' from it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_insert : (insert a s)\u1d9c = s\u1d9c.erase a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set of points is concyclic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem concyclic_empty : Concyclic (\u2205 : Set P) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the definition of the inversion function is equivalent to the formula  (R / dist x c) ^ 2 \u2022 (x -\u1d65 c) +\u1d65 c, where c is the center of inversion, R is the radius of inversion, x is the point to be inverted, dist is the distance function, -\u1d65 is vector subtraction, and +\u1d65 is vector addition.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inversion_def :\n    inversion = fun (c : P) (R : \u211d) (x : P) => (R / dist x c) ^ 2 \u2022 (x -\u1d65 c) +\u1d65 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of the universal set is the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_univ : (univ : Finset \u03b1)\u1d9c = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity function on a smooth manifold is continuously differentiable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contMDiff_id : ContMDiff I I n (id : M \u2192 M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(s\\) and any element \\(a\\), the complement of the set obtained by removing \\(a\\) from \\(s\\) is equal to the set obtained by adding \\(a\\) to the complement of \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_erase : (s.erase a)\u1d9c = insert a s\u1d9c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers,  'a' divides 'a - b' if and only if 'a' divides 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_sub_self_left : a \u2223 a - b \u2194 a \u2223 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers a, b, and c,  a divides (b - c) if and only if a divides (c - b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_sub_comm : a \u2223 b - c \u2194 a \u2223 c - b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 2 divides the bitwise expression `bit1 a` if and only if 2 divides 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem two_dvd_bit1 : 2 \u2223 bit1 a \u2194 (2 : \u03b1) \u2223 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\(f\\) mapping into a type \\(\u03b2\\) where \\(0 = 1\\), the range of \\(f\\) consists only of the element \\(0\\). Furthermore, prove the converse: if the range of a function \\(f\\) is the singleton set \\({0}\\), then in the codomain of \\(f\\), \\(0 = 1\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem codomain_trivial_iff_range_eq_singleton_zero : (0 : \u03b2) = 1 \u2194 Set.range f = {0} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers 'a' and 'b',  '-a' divides 'b' if and only if 'a' divides 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_dvd : -a \u2223 b \u2194 a \u2223 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers 'a' and 'b', 'a' divides 'b - a' if and only if 'a' divides 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_sub_self_right : a \u2223 b - a \u2194 a \u2223 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the unit element '1' in any type '\u03b1' that has a notion of '1' and a 'normUnit' function, is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normUnit_one : normUnit (1 : \u03b1) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a normalization operation to the zero element of any type results in zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normalize_zero : normalize (0 : \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function has a derivative at a point x within its entire domain if and only if it has a derivative at point x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasMFDerivWithinAt_univ : HasMFDerivWithinAt I I' f univ x f' \u2194 HasMFDerivAt I I' f x f' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers *a* and *b*, *a* divides *-b* if and only if *a* divides *b*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_neg : a \u2223 -b \u2194 a \u2223 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of all elements in an empty list is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_nil : ([] : List M).prod = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a normalization function to the multiplicative identity (1) of any type \u03b1 results in the identity itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normalize_one : normalize (1 : \u03b1) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type `\u03b1` with an associated \"multiplication\" operation, the \"out\" value of the multiplicative identity (represented as `1`) is equal to the multiplicative identity itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem out_one : (1 : Associates \u03b1).out = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list  'l' of natural numbers, the product of the elements of the list 'l' is equal to the product of the elements of the list obtained by inserting 1 at the beginning of 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_one_cons : (1 :: l).prod = l.prod :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number of elements removed from an initially empty collection after any sequence of operations is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem out_top : (\u22a4 : Associates \u03b1).out = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `l` and a number `a`, the product of the elements in the list obtained by appending `a` to `l` is equal to the product of the elements in `l` multiplied by `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_concat : (l.concat a).prod = l.prod * a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list, the product of all elements in the list is equal to the product of the first element and the product of the rest of the list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_cons : (a :: l).prod = a * l.prod :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of zero numbers is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_zero : @prod \u03b1 _ 0 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of a list containing only one element is equal to that element itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_singleton : [a].prod = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of a list concatenated from two lists (l\u2081 and l\u2082) is equal to the product of the individual products of l\u2081 and l\u2082.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_append : (l\u2081 ++ l\u2082).prod = l\u2081.prod * l\u2082.prod :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list L and a natural number i, multiplying the product of the first i elements of L and the product of the remaining elements equals the product of all elements in L.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_take_mul_prod_drop : \u2200 (L : List M) (i : \u2115), (L.take i).prod * (L.drop i).prod = L.prod\n  | [], i => by simp [Nat.zero_le]\n  | L, 0 => by simp\n  | h :: t, n + 1 => by\n    dsimp\n    rw [prod_cons, prod_cons, mul_assoc, prod_take_mul_prod_drop t]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list of elements where each element is a unit (i.e., has a multiplicative inverse), the product of all elements in the list is also a unit.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_isUnit : \u2200 {L : List M}, (\u2200 m \u2208 L, IsUnit m) \u2192 IsUnit L.prod\n  | [], _ => by simp\n  | h :: t, u => by\n    simp only [List.prod_cons]\n    exact IsUnit.mul (u h (mem_cons_self h t)) (prod_isUnit fun m mt => u m (mem_cons_of_mem h mt))\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a multiset `m` of any elements, prove that multiplying 1 by itself for as many times as the number of elements in the multiset results in 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_map_one : prod (m.map fun _ => (1 : \u03b1)) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that calculating the product of elements in a list is equivalent to folding the list from the right using the multiplication operation, starting with an initial value of 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_eq_foldr : \u2200 {l : List M}, l.prod = foldr (\u00b7 * \u00b7) 1 l\n  | [] => rfl\n  | cons a l => by rw [prod_cons, foldr_cons, prod_eq_foldr]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the real number 0 to an element of an algebra A results in the additive identity (zero element) of A.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : (\u2191(0 : R) : A) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list L, replacing the element at index n with element 'a' and then taking the product of the elements in the resulting list is equivalent to calculating the product in the following way:\n * Calculate the product of the first n elements of the original list.\n * If n is within the bounds of the list, multiply the result by 'a'; otherwise, multiply by 1.\n * Finally, multiply by the product of all elements after index n + 1 in the original list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_set :\n    \u2200 (L : List M) (n : \u2115) (a : M),\n      (L.set n a).prod =\n        ((L.take n).prod * if n < L.length then a else 1) * (L.drop (n + 1)).prod\n  | x :: xs, 0, a => by simp [set]\n  | x :: xs, i + 1, a => by simp [set, prod_set xs i a, mul_assoc, Nat.succ_eq_add_one]\n  | [], _, _ => by simp [set, (Nat.zero_le _).not_lt, Nat.zero_le]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the image of the set of all elements in a ring R under the algebra homomorphism from R to A is a subset of S, given that S is a subset of A.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_subset : Set.range (algebraMap R A) \u2286 S :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list \\(L\\), taking the product of the first \\(i + 1\\) elements is equivalent to multiplying the product of the first \\(i\\) elements by the (\\(i+1\\))th element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_take_succ :\n    \u2200 (L : List M) (i : \u2115) (p), (L.take (i + 1)).prod = (L.take i).prod * L.get \u27e8i, p\u27e9\n  | [], i, p => by cases p\n  | h :: t, 0, _ => rfl\n  | h :: t, n + 1, p => by\n    dsimp\n    rw [prod_cons, prod_cons, prod_take_succ t n (Nat.lt_of_succ_lt_succ p), mul_assoc]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a subsemiring  'S' of a semiring 'A', and a ring homomorphism 'algebraMap' from a ring 'R' to 'A', the image of 'R' under 'algebraMap' is a subset of 'S'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rangeS_le : (algebraMap R A).rangeS \u2264 S.toSubsemiring :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a list of numbers and two functions, f and g, prove that calculating the product of applying f and g to each element individually and then multiplying the results is the same as applying f to each element, applying g to each element, calculating the product of each of those results, and then multiplying those two products together.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_map_mul : (m.map fun i => f i * g i).prod = (m.map f).prod * (m.map g).prod :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of the algebra homomorphism from R to A is a subset of S.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_le : Set.range (algebraMap R A) \u2264 S :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubsemiring`, which converts a subalgebra to a subsemiring, is injective. In other words, if two subalgebras are mapped to the same subsemiring, then the two subalgebras must be the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubsemiring_injective :\n    Function.Injective (toSubsemiring : Subalgebra R A \u2192 Subsemiring A) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\( a \\), 1 is less than the inverse of \\( a \\) (\\( 1 < a^{-1} \\)) if and only if \\( a \\) is a positive number less than 1 ( \\( 0 < a \\) and \\( a < 1 \\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_lt_inv_iff : 1 < a\u207b\u00b9 \u2194 0 < a \u2227 a < 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 0 belongs to the set S, given that S contains the element 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mem : (0 : A) \u2208 S :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the embedding of the constant Cauchy sequence 1 into the real numbers is equal to the real number 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_one : \u21d1(1 : CauSeq \u03b2 abv) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of a number 'a' is less than or equal to 1 if and only if 'a' is less than or equal to 0 or 'a' is greater than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_le_one_iff : a\u207b\u00b9 \u2264 1 \u2194 a \u2264 0 \u2228 1 \u2264 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any field, dividing 1 by -1 equals -1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_div_neg_one_eq_neg_one : (1 : K) / -1 = -1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of a number 'a' is less than 1 if and only if 'a' is less than or equal to 0 or 'a' is greater than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_lt_one_iff : a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Lie bracket operation distributes over addition. In other words, for any elements x, y, and m, the Lie bracket of the sum of x and y with m is equal to the sum of the Lie bracket of x with m and the Lie bracket of y with m.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_lie : \u2045x + y, m\u2046 = \u2045x, m\u2046 + \u2045y, m\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number 'a', its inverse (1/a) is greater than or equal to 1 if and only if 'a' is greater than 0 and less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_inv_iff : 1 \u2264 a\u207b\u00b9 \u2194 0 < a \u2227 a \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a special operation denoted by the brackets \u2045 , \u2046 that combines elements from two potentially different sets. This operation is called the \"Lie bracket\".  Prove that for any elements x, m, and n, taking the Lie bracket of x with the sum of m and n is the same as taking the Lie bracket of x with m and then adding it to the Lie bracket of x with n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lie_add : \u2045x, m + n\u2046 = \u2045x, m\u2046 + \u2045x, n\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the negation of a number is equal to the negation of the inverse of that number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_inv : -a\u207b\u00b9 = (-a)\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a Lie algebra, scaling a Lie bracket by a scalar is the same as taking the Lie bracket with the scaled element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lie_smul : \u2045x, t \u2022 m\u2046 = t \u2022 \u2045x, m\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a special operation denoted by the brackets \"\u2045 , \u2046\" that combines two elements. This operation is not necessarily commutative (meaning the order matters). This theorem, often called the Jacobi identity, states that for any three elements x, y, and m:  combining x with the result of combining y and m (\u2045y, m\u2046) is the same as first combining x and y, then combining the result with m, plus combining y with the result of combining x and m.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem leibniz_lie : \u2045x, \u2045y, m\u2046\u2046 = \u2045\u2045x, y\u2046, m\u2046 + \u2045y, \u2045x, m\u2046\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a Lie algebra, scaling a Lie bracket by a scalar is the same as taking the Lie bracket with the scaled element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_lie : \u2045t \u2022 x, m\u2046 = t \u2022 \u2045x, m\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the negative of the Lie bracket of elements y and x is equal to the Lie bracket of elements x and y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lie_skew : -\u2045y, x\u2046 = \u2045x, y\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Lie bracket of an element 'x' with the difference of two elements 'm' and 'n' is equal to the difference of the Lie bracket of 'x' with 'm' and the Lie bracket of 'x' with 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lie_sub : \u2045x, m - n\u2046 = \u2045x, m\u2046 - \u2045x, n\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Lie bracket of the negation of an element 'x' with an element 'm' is equal to the negation of the Lie bracket of 'x' with 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_lie : \u2045-x, m\u2046 = -\u2045x, m\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the Lie bracket of an element 'x' with the negation of an element 'm' is equal to the negation of the Lie bracket of 'x' with 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lie_neg : \u2045x, -m\u2046 = -\u2045x, m\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the equivalence class of (x - y) modulo m is equal to the difference between the equivalence class of x modulo m and the equivalence class of y modulo m.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_lie : \u2045x - y, m\u2046 = \u2045x, m\u2046 - \u2045y, m\u2046 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers, 'a' divides 'b' if and only if there exists an integer 'c' such that 'b' is equal to 'c' multiplied by 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a \u2223 b \u2194 \u2203 c, b = c * a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers a, b, and c, if a divides b and b divides c, then a divides c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_trans : a \u2223 b \u2192 b \u2223 c \u2192 a \u2223 c\n  | \u27e8d, h\u2081\u27e9, \u27e8e, h\u2082\u27e9 => \u27e8d * e, h\u2081 \u25b8 h\u2082.trans <| mul_assoc a d e\u27e9\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the equivalence class of the Cauchy sequence with all terms equal to 0 is the 0 element in the completion of a metric space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : \u21d1(0 : CauSeq \u03b2 abv) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have an algebra A over a ring R, then the multiplicative identity of R, when considered as an element of A, is equal to the multiplicative identity of A.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_one : (\u2191(1 : R) : A) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, c, and d, if a divides b and c divides d, then a multiplied by c divides b multiplied by d.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_dvd_mul : \u2200 {a b c d : \u03b1}, a \u2223 b \u2192 c \u2223 d \u2192 a * c \u2223 b * d\n  | a, _, c, _, \u27e8e, rfl\u27e9, \u27e8f, rfl\u27e9 => \u27e8e * f, by simp\u27e9\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number is considered \"radical\" if and only if it is either square-free or equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isRadical_iff_squarefree_or_zero : IsRadical x \u2194 Squarefree x \u2228 x = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list to a list using the functions `ofList` and `toList` results in the original list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_comp_ofList : @toList \u03b1 \u2218 ofList = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the multiplicative identity element (represented as `1`) of any free monoid to a list results in an empty list (`[]`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_one : toList (1 : FreeMonoid \u03b1) = [] :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve the Jacobi identity: for any three elements x, y, and z in a Lie algebra, the following equation holds: [x, [y, z]] + [y, [z, x]] + [z, [x, y]] = 0. Here, [a, b] denotes the Lie bracket of a and b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lie_jacobi : \u2045x, \u2045y, z\u2046\u2046 + \u2045y, \u2045z, x\u2046\u2046 + \u2045z, \u2045x, y\u2046\u2046 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of two natural numbers x and y is squarefree if and only if x and y are relatively prime (i.e., their greatest common divisor is 1) and both x and y are themselves squarefree.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem squarefree_mul_iff : Squarefree (x * y) \u2194 IsRelPrime x y \u2227 Squarefree x \u2227 Squarefree y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list to a sequence and then back to a list results in the original list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofList_symm : (@ofList \u03b1).symm = toList :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list to a list and then back to the original representation results in the same list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toList_symm : (@toList \u03b1).symm = ofList :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'x' and a ring 'R', casting 'x' into the ring 'R' results in zero if and only if the characteristic of the ring 'R' divides 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem spec : \u2200 x : \u2115, (x : R) = 0 \u2194 ringChar R \u2223 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven vector spaces V and W over a field K, the theorem states that the object associated with W by the internal hom functor (ihom V) is the same as the free K-linear module consisting of K-linear maps from V to W.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ihom_obj : (ihom V).obj W = FGModuleCat.of K (V \u2192\u2097[K] W) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a category with dual objects and a suitable tensor product, prove that the composition of coevaluation followed by evaluation, with appropriate coherence isomorphisms, is equivalent to the composition of a morphism related to the dual object with an isomorphism related to the tensor product.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coevaluation_evaluation :\n    letI V' : FGModuleCat K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting an empty list to a natural number using the function `ofList` results in 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofList_nil : ofList ([] : List \u03b1) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `of` which takes an element and puts it into a single-element list is injective. In other words, if `of a` equals `of b` then `a` must equal `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_injective : Function.Injective (@of \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `tropEquiv`, which maps a real number to its corresponding element in the Tropical Semiring, is equivalent to the predefined function `trop`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tropEquiv_coe_fn : (tropEquiv : R \u2192 Tropical R) = trop :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 raised to any integer power is still 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_zpow : \u2200 n : \u2124, (1 : \u03b1) ^ n = 1\n  | (n : \u2115)       => by rw [zpow_natCast, one_pow]\n  | .negSucc n => by rw [zpow_negSucc, one_pow, inv_one]\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list to a linked list and then back to a list results in the original list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofList_comp_toList : @ofList \u03b1 \u2218 toList = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `untrop` which maps elements from the Tropical Semiring  to the set of real numbers is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem untrop_injective : Function.Injective (untrop : Tropical R \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the inverse of the \"tropicalization\" function to an element is the same as directly \"untropicalizing\" it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tropEquiv_symm_coe_fn : (tropEquiv.symm : Tropical R \u2192 R) = untrop :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `trop`, which maps a real number to its corresponding element in the tropical semiring, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trop_injective : Function.Injective (trop : R \u2192 Tropical R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that applying the coevaluation map in the category of finite-dimensional vector spaces over a field K to the multiplicative identity of K results in a specific sum of tensor products. This sum is taken over the basis elements of the vector space, and each term is the tensor product of a basis vector and its corresponding coordinate function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem FGModuleCatCoevaluation_apply_one :\n    FGModuleCatCoevaluation K V (1 : K) =\n      \u2211 i : Basis.ofVectorSpaceIndex K V,\n        (Basis.ofVectorSpace K V) i \u2297\u209c[K] (Basis.ofVectorSpace K V).coord i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `untrop` is a left inverse of the function `trop`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem leftInverse_trop : Function.LeftInverse (trop : R \u2192 Tropical R) untrop :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `trop`, which maps a real number to its corresponding element in the tropical semiring, is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surjective_trop : Function.Surjective (trop : R \u2192 Tropical R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `untrop` is a right inverse of the function `trop`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rightInverse_trop : Function.RightInverse (trop : R \u2192 Tropical R) untrop :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `trop`, which maps a real number to its corresponding element in the tropical semiring, is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem injective_trop : Function.Injective (trop : R \u2192 Tropical R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a specific algebraic setting involving categories and functors, the composition of certain natural transformations (representing morphisms between functors) is equivalent to another specific composition of natural transformations.  This demonstrates a key relationship between evaluation and coevaluation morphisms within this categorical framework.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem evaluation_coevaluation :\n    FGModuleCatCoevaluation K V \u25b7 V \u226b\n        (\u03b1_ V (FGModuleCatDual K V) V).hom \u226b V \u25c1 FGModuleCatEvaluation K V =\n      (\u03bb_ V).hom \u226b (\u03c1_ V).inv :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number x, multiplying x by 2 is the same as adding x to itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem two_smul : (2 : R) \u2022 x = x + x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid`, which converts a submodule of a module to the corresponding additive submonoid, is a strictly monotone function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAddSubmonoid`, which converts a submodule of a module over a ring into an additive submonoid, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_injective : Injective (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two objects, 'p' and 'q', are equal if and only if the additive submonoids generated by 'p' and 'q' are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_eq : p.toAddSubmonoid = q.toAddSubmonoid \u2194 p = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `untrop` which maps elements from the tropical numbers to real numbers is an injective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem injective_untrop : Function.Injective (untrop : Tropical R \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(p\\) and \\(q\\) be two submodules of a module \\(M\\) over a ring \\(R\\). Prove that \\(p\\) and \\(q\\) are the same submodule if and only if they contain the exact same elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem carrier_inj : p.carrier = q.carrier \u2194 p = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers *p* and *q*, *p* is less than or equal to *q* if and only if the set of all multiples of *p* is a subset of the set of all multiples of *q*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_le : p.toAddSubmonoid \u2264 q.toAddSubmonoid \u2194 p \u2264 q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a smaller mathematical structure (specifically, a submodule) to a larger one (an additive submonoid) always results in a larger or equal structure.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the multiplicative identity element ('1') in a monoid algebra is equivalent to creating a single term element with coefficient '1' and monoid identity element '1'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_def : (1 : MonoidAlgebra k G) = single 1 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubMulAction`, which converts a submodule of a module to its corresponding submodule action, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubMulAction_injective : Injective (toSubMulAction : Submodule R M \u2192 SubMulAction R M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) belongs to the carrier of a subtype \\(p\\) if and only if \\(x\\) belongs to the set \\(p\\) itself, where \\(p\\) is a subset of some larger set \\(M\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_carrier : x \u2208 p.carrier \u2194 x \u2208 (p : Set M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero element (represented as '0') of any additive monoid 'M' is always present in a submonoid 'p' of 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mem : (0 : M) \u2208 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubMulAction`, which converts a submodule over a ring \\(R\\) to a submodule with a scalar multiplication action from \\(R\\), is strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubMulAction_strictMono :\n    StrictMono (toSubMulAction : Submodule R M \u2192 SubMulAction R M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toSubMulAction`, which converts a Submodule to a SubMulAction, is a monotone function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubMulAction_mono : Monotone (toSubMulAction : Submodule R M \u2192 SubMulAction R M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type R, 0 is left-regular if and only if R has at most one element (i.e., R is a singleton or empty).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLeftRegular_zero_iff_subsingleton : IsLeftRegular (0 : R) \u2194 Subsingleton R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements 'a' and 'b', the product 'a * b' and 'b * a' are both \"regular\" if and only if both 'a' and 'b' are \"regular\" themselves.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isRegular_mul_and_mul_iff :\n    IsRegular (a * b) \u2227 IsRegular (b * a) \u2194 IsRegular a \u2227 IsRegular b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that multiplying any element in M by the multiplicative identity 1 is the same as applying the identity function to that element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_mul_eq_id : ((1 : M) * \u00b7) = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two objects, p and q, are equal if and only if the result of applying a specific operation, \"toSubMulAction\", to them yields the same result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toSubMulAction_eq : p.toSubMulAction = q.toSubMulAction \u2194 p = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers, 'a' and 'b',  'a' multiplied by 'b' is not equal to 'a' if and only if 'b' is not equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_right_ne_self : a * b \u2260 a \u2194 b \u2260 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a multiplicative structure M with an identity 1, multiplying 'a' by 1 results in 'a' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_one_eq_id : (\u00b7 * (1 : M)) = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements a, b, and c in a group G, the following equation holds: (a * b) * c = (a * c) * b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_right_comm : \u2200 a b c : G, a * b * c = a * c * b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a' and 'b',  'a' multiplied by 'b' equals 'a' if and only if 'b' equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_right_eq_self : a * b = a \u2194 b = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a' and 'b',  'a' is equal to 'a' multiplied by 'b' if and only if 'b' is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_eq_mul_right : a = a * b \u2194 b = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements a, b, and c in a group G, the following equation holds: a * (b * c) = b * (a * c).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_left_comm : \u2200 a b c : G, a * (b * c) = b * (a * c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a' and 'b',  'a' is not equal to 'a' multiplied by 'b' if and only if 'b' is not equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_ne_mul_right : a \u2260 a * b \u2194 b \u2260 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the inverse of an element in a group twice results in the original element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_involutive : Function.Involutive (Inv.inv : G \u2192 G) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers,  a times b equals b if and only if a equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_left_eq_self : a * b = b \u2194 a = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `untrop` which maps from the Tropical Semiring of Real numbers (Tropical R) to the set of Real numbers (R) is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surjective_untrop : Function.Surjective (untrop : Tropical R \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers, 'a' and 'b',  'b' is not equal to 'a' multiplied by 'b' if and only if 'a' is not equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_ne_mul_left : b \u2260 a * b \u2194 a \u2260 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers,  a number (let's call it 'b') is equal to the product of itself and another number (let's call it 'a') if and only if 'a' is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_eq_mul_left : b = a * b \u2194 a = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a group, applying the inverse operation twice is the same as the identity operation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_comp_inv : Inv.inv \u2218 Inv.inv = @id G :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse operation in a group is injective. In other words, prove that if two elements in a group have the same inverse, then the two elements must be the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_injective : Function.Injective (Inv.inv : G \u2192 G) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse operation in a group is surjective. In other words, show that for every element 'a' in the group, there exists an element 'b' such that the inverse of 'b' is 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_surjective : Function.Surjective (Inv.inv : G \u2192 G) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two invertible elements 'a' and 'b', the inverse of 'a' is equal to 'b' if and only if 'a' is equal to the inverse of 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_eq_iff_eq_inv : a\u207b\u00b9 = b \u2194 a = b\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying any function 'f' lifted into a structure that preserves addition and multiplication to the number 1 results in 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift_one : lift f 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a' and 'b', if the product of 'a' and 'b' is not equal to 0, then 'b' cannot be 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem right_ne_zero_of_mul : a * b \u2260 0 \u2192 b \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that maps an element to its inverse in a monoid is the same as the inverse function itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_invMonoidHom : (invMonoidHom : \u03b1 \u2192 \u03b1) = Inv.inv :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a' and 'b',  'a' multiplied by 'b' is not equal to 'b' if and only if 'a' is not equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_left_ne_self : a * b \u2260 b \u2194 a \u2260 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements \\(a\\), \\(x\\), and \\(y\\) in a group where inverses exist,  \\(x\\) is conjugate to \\(y\\) by \\(a^{-1}\\) if and only if \\(y\\) is conjugate to \\(x\\) by \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_inv_symm_iff : SemiconjBy a\u207b\u00b9 x\u207b\u00b9 y\u207b\u00b9 \u2194 SemiconjBy a y x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any multiplicative structure M\u2080, multiplying any element by 0 always results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_mul_eq_const : ((0 : M\u2080) * \u00b7) = Function.const _ 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the product of two numbers is not zero, then the first number cannot be zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem left_ne_zero_of_mul : a * b \u2260 0 \u2192 a \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the identity function and then embedding the result into a monoid is the same as directly embedding the element into the monoid.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_id : map (MulHom.id \u03b1) = MonoidHom.id (WithOne \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements 'a' and 'b', the inverse of 'a' commutes with the inverse of 'b' if and only if 'a' commutes with 'b'. Note:  We are assuming that 'a' and 'b' are elements of a group, where each element has an inverse and a notion of commutation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_inv_iff : Commute a\u207b\u00b9 b\u207b\u00b9 \u2194 Commute a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two numbers are equal if and only if their inverses are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_inj : a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a multiplicative structure M\u2080, multiplying 'a' by 0 always results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_zero_eq_const : (\u00b7 * (0 : M\u2080)) = Function.const _ 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any numbers a, b, and c, prove that  a * c = b * c  if and only if  a = b or c = 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_eq_mul_right_iff : a * c = b * c \u2194 a = b \u2228 c = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any mathematical system M\u2080 that has the numbers 0 and 1, prove that either 0 is not equal to 1, or every element in M\u2080 is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_ne_one_or_forall_eq_0 : (0 : M\u2080) \u2260 1 \u2228 \u2200 a : M\u2080, a = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type M\u2080, the type M\u2080 has only one element if and only if 0 is equal to 1 in M\u2080.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subsingleton_iff_zero_eq_one : (0 : M\u2080) = 1 \u2194 Subsingleton M\u2080 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of 0 is 0 in a nontrivial multiplicative monoid.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inverse_zero : inverse (0 : M\u2080) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers, \\(a\\) and \\(b\\),  \\(a * b = b\\) if and only if \\(a = 1\\) or \\(b = 0\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_left_eq_self\u2080 : a * b = b \u2194 a = 1 \u2228 b = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers 'a' and 'b',  'a' multiplied by 'b' equals 'a' if and only if 'b' equals 1 or 'a' equals 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_right_eq_self\u2080 : a * b = a \u2194 b = 1 \u2228 a = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two elements, 'a' and 'b', commute (i.e., their product is the same regardless of the order), then their inverses, denoted by 'a\u207b\u00b9' and 'b\u207b\u00b9', also commute.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_inv : Commute a b \u2192 Commute a\u207b\u00b9 b\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number is a unit if and only if it is not equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_iff_ne_zero : IsUnit a \u2194 a \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a multiplicative monoid M\u2080, 0 is a unit if and only if 0 equals the multiplicative identity 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_zero_iff : IsUnit (0 : M\u2080) \u2194 (0 : M\u2080) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any numbers a, b, and c,  prove that  a * b = a * c  if and only if either b = c or a = 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_eq_mul_left_iff : a * b = a * c \u2194 b = c \u2228 a = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `transReflReparamAux` to 0 results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem transReflReparamAux_zero : transReflReparamAux 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `reflTransSymmAux` is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_reflTransSymmAux : Continuous reflTransSymmAux :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a specific function called `transAssocReparamAux` is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_transAssocReparamAux : Continuous transAssocReparamAux :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a specific function, called `transReflReparamAux`, is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_transReflReparamAux : Continuous transReflReparamAux :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `transReflReparamAux` to the number 1 results in 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem transReflReparamAux_one : transReflReparamAux 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the minimal polynomial of an element x in an algebra A, when evaluated at x, equals zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aeval : aeval x (minpoly A x) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `transAssocReparamAux` to 0 results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet A and B be fields, and let x be an element of field B.  The minimal polynomial of x over A has degree 1 if and only if x is in the image of the algebra homomorphism from A to B.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_eq_one_iff :\n    (minpoly A x).natDegree = 1 \u2194 x \u2208 (algebraMap A B).range :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `transAssocReparamAux` to the number 1 results in 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem transAssocReparamAux_one : transAssocReparamAux 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number `n`, if `n` is not equal to 0, then `bit0 n` is also not equal to 0. Where `bit0 n` is defined as `n + n`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bit0_ne_zero : \u2200 {n : \u2115}, n \u2260 0 \u2192 bit0 n \u2260 0\n  | 0, h => absurd rfl h\n  | n + 1, _ =>\n    suffices n + 1 + (n + 1) \u2260 0 from this\n    suffices succ (n + 1 + n) \u2260 0 from this\n    fun h => Nat.noConfusion h\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there is a special relationship, called a Galois connection, between ideals of a ring and subsets of its prime spectrum. This relationship is established through two functions: one that maps an ideal to its zero locus and another that maps a subset of the prime spectrum to its vanishing ideal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gc :\n    @GaloisConnection (Ideal R) (Set (PrimeSpectrum R))\u1d52\u1d48 _ _ (fun I => zeroLocus I) fun t =>\n      vanishingIdeal t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet A and B be rings where you can \"multiply\" elements of A by elements of B. Given an element 'x' from B, prove that the minimal polynomial of 'x' over A has degree 1 if and only if 'x' can be obtained by multiplying some element in A with '1' in B.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem degree_eq_one_iff : (minpoly A x).degree = 1 \u2194 x \u2208 (algebraMap A B).range :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an integer \\( n \\) can be represented as the negation of a natural number \\( a \\) (i.e., \\( n = -a \\)), then the absolute value of \\( n \\) can be represented by the natural number \\( a \\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isNat_natAbs_neg : {n : \u2124} \u2192 {a : \u2115} \u2192 IsInt n (.negOfNat a) \u2192 IsNat n.natAbs a\n  | _, _, \u27e8rfl\u27e9 => \u27e8by simp\u27e9:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n' which is not equal to 0, 0 is always less than twice the value of 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_lt_bit0 : \u2200 {n : Nat}, n \u2260 0 \u2192 0 < bit0 n\n  | 0, h => absurd rfl h\n  | succ n, _ =>\n    calc\n      0 < succ (succ (bit0 n)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( x \\) belongs to the set of fixed points of a function \\( f \\) if and only if \\( x \\) is a fixed point of \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_fixedPoints : x \u2208 fixedPoints f \u2194 IsFixedPt f x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every element of a type is a fixed point of the identity function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fixedPoints_id : fixedPoints (@id \u03b1) = Set.univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function  'f', the set of fixed points of 'f' is a subset of the range of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fixedPoints_subset_range : fixedPoints f \u2286 Set.range f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is always a closed set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isClosed_empty : IsClosed (\u2205 : Set X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there is a special relationship called a Galois Connection between two collections of objects:\n   1. The collection of all subsets of a ring R, and\n   2. The collection of all subsets of prime ideals of R.\n  This relationship is defined by two functions: one that associates each subset of R with a corresponding subset of prime ideals, and another that does the reverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gc_set :\n    @GaloisConnection (Set R) (Set (PrimeSpectrum R))\u1d52\u1d48 _ _ (fun s => zeroLocus s) fun t =>\n      vanishingIdeal t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the entire space (denoted as 'univ') is a closed set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isClosed_univ : IsClosed (univ : Set X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_empty : IsOpen (\u2205 : Set X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any topological space, the entire space (the universal set) is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_univ : IsOpen (univ : Set X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interior of a set 's' is a subset of 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem interior_subset : interior s \u2286 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set is closed if and only if its complement is open.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_compl_iff : IsOpen s\u1d9c \u2194 IsClosed s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the multiplicative identity (1) in a field M\u2080 is equal to the multiplicative identity itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inverse_one : inverse (1 : M\u2080) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interior of any set is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_interior : IsOpen (interior s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we take a type `X` and view it as a topological space with the discrete topology (where every subset is open), then the underlying type of this space is still `X`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_of : (CompHaus.of X : Type _) = X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) maps from a space of functions to another space, and if for every point in the input space, there exists a neighborhood where the function is continuous, then the function \\( f \\) is continuous everywhere.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_continuous : Continuous (f : (\u2200 i, M\u2081 i) \u2192 M\u2082) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is preconnected.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isPreconnected_empty : IsPreconnected (\u2205 : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a multilinear map `f` to its function representation and then back to a multilinear map results in the original multilinear map `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_coe : (f.toMultilinearMap : (\u2200 i, M\u2081 i) \u2192 M\u2082) = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the identity function within the context of continuous order homomorphisms is the same as applying the regular identity function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_id : \u21d1(ContinuousOrderHom.id \u03b1) = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a point \\(x\\) belongs to the interior of a set \\(s\\) if and only if there exists an open set \\(t\\) such that \\(t\\) is a subset of \\(s\\) and \\(x\\) belongs to \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_interior : x \u2208 interior s \u2194 \u2203 t, t \u2286 s \u2227 IsOpen t \u2227 x \u2208 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(M\u2081\\) be a set equipped with a topology induced by a function \\(f\\), and let \\(R\\) be the set of real numbers. Prove that the scalar multiplication operation, which takes a real number and an element of \\(M\u2081\\) and produces another element of \\(M\u2081\\), is a continuous function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousSMul_induced : @ContinuousSMul R M\u2081 _ u (t.induced f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toMultilinearMap`, which converts a continuous multilinear map to a multilinear map, is injective. In other words, if two continuous multilinear maps become equal after applying `toMultilinearMap`, then they were the same map to begin with.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toMultilinearMap_injective :\n    Function.Injective\n      (ContinuousMultilinearMap.toMultilinearMap :\n        ContinuousMultilinearMap R M\u2081 M\u2082 \u2192 MultilinearMap R M\u2081 M\u2082)\n  | \u27e8f, hf\u27e9, \u27e8g, hg\u27e9, h => by subst h; rfl\n:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the zero continuous multilinear map to a multilinear map results in the zero multilinear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toMultilinearMap_zero : (0 : ContinuousMultilinearMap R M\u2081 M\u2082).toMultilinearMap = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toContinuousMultilinearMap`, which transforms a continuous alternating map to a continuous multilinear map, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toContinuousMultilinearMap_injective :\n    Injective (ContinuousAlternatingMap.toContinuousMultilinearMap :\n      M [\u22c0^\u03b9]\u2192L[R] N \u2192 ContinuousMultilinearMap R (fun _ : \u03b9 => M) N)\n  | \u27e8_, _\u27e9, \u27e8_, _\u27e9, rfl => rfl:=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that swapping the elements of every pair in the identity relation on a set results in the same identity relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_idRel : Prod.swap '' idRel = @idRel \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a function `f` to an alternating map and then applying it is the same as applying `f` directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toAlternatingMap : \u21d1f.toAlternatingMap = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `toAlternatingMap` is injective. This function takes a multilinear map and transforms it into an alternating multilinear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAlternatingMap_injective :\n    Injective (toAlternatingMap : (M [\u22c0^\u03b9]\u2192L[R] N) \u2192 (M [\u22c0^\u03b9]\u2192\u2097[R] N)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the zero linear map to a continuous multilinear map results in the zero continuous multilinear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toContinuousMultilinearMap_zero : (0 : M [\u22c0^\u03b9]\u2192L[R] N).toContinuousMultilinearMap = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` has a sum equal to `a` if and only if the restriction of `f` to its support also has a sum equal to `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasSum_subtype_support : HasSum (f \u2218 (\u2191) : support f \u2192 \u03b1) a \u2194 HasSum f a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type \u03b2, the sum of the function that maps every element of \u03b2 to 0 is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasSum_zero : HasSum (fun _ \u21a6 0 : \u03b2 \u2192 \u03b1) 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of the function 'toContinuousMultilinearMap' is exactly the set of all continuous multilinear maps that vanish on linearly dependent vectors.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_toContinuousMultilinearMap :\n    Set.range\n        (toContinuousMultilinearMap :\n          M [\u22c0^\u03b9]\u2192L[R] N \u2192 ContinuousMultilinearMap R (fun _ : \u03b9 => M) N) =\n      {f | \u2200 (v : \u03b9 \u2192 M) (i j : \u03b9), v i = v j \u2192 i \u2260 j \u2192 f v = 0} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking any function between specific mathematical structures (called modules) and transforming it into a linear and continuous function results in a set that is precisely the set of all linear and continuous functions between those structures.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_toAlternatingMap :\n    Set.range (toAlternatingMap : M [\u22c0^\u03b9]\u2192L[R] N \u2192 (M [\u22c0^\u03b9]\u2192\u2097[R] N)) =\n      {f : M [\u22c0^\u03b9]\u2192\u2097[R] N | Continuous f} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the uniformity on a set \u03b1 equipped with a pseudo-emetric is equal to the intersection of all sets of pairs of points whose pseudo-distance is less than a given positive number \u03b5.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniformity_pseudoedist : \ud835\udce4 \u03b1 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function that always outputs zero is summable, and its sum is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem summable_zero : Summable (fun _ \u21a6 0 : \u03b2 \u2192 \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a topology on a group G is the discrete topology if and only if the singleton set containing the identity element 1 is open.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem discreteTopology_iff_isOpen_singleton_one : DiscreteTopology G \u2194 IsOpen ({1} : Set G) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the uniform space generated by a pseudo emetric space is the same as the uniform space defined directly from the emetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniformSpace_edist :\n    \u2039PseudoEMetricSpace \u03b1\u203a.toUniformSpace =\n      uniformSpaceOfEDist edist edist_self edist_comm edist_triangle :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBounded_empty : IsBounded (\u2205 : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of a set 's' is bounded if and only if the set 's' is cobounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBounded_compl_iff : IsBounded s\u1d9c \u2194 IsCobounded s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set's complement is cobounded if and only if the original set is bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCobounded_compl_iff : IsCobounded s\u1d9c \u2194 IsBounded s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any space \u03b1 with a notion of distance (edist), the set of all pairs of points closer than a given positive distance forms a basis for the uniformity of the space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniformity_basis_edist :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of two sets s and t is cobounded if and only if both sets s and t are individually cobounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCobounded_inter : IsCobounded (s \u2229 t) \u2194 IsCobounded s \u2227 IsCobounded t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the universal set (the set containing all elements) is cobounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isCobounded_univ : IsCobounded (univ : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(s\\) and any element \\(x\\), the set obtained by inserting \\(x\\) into \\(s\\) is bounded if and only if the original set \\(s\\) is bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBounded_insert : IsBounded (insert x s) \u2194 IsBounded s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the union of all bounded sets within a universe is equal to the universe itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sUnion_bounded_univ : \u22c3\u2080 { s : Set \u03b1 | IsBounded s } = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the union of two sets *s* and *t* is bounded if and only if both *s* and *t* are bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBounded_union : IsBounded (s \u222a t) \u2194 IsBounded s \u2227 IsBounded t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' is bounded if and only if every element in 's' is bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBounded_iff_forall_mem : IsBounded s \u2194 \u2200 x \u2208 s, IsBounded s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a singleton set (a set containing only one element) is always bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBounded_singleton : IsBounded ({x} : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coercion function from the type of continuous functions between two types to the type of functions between those types is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : @Function.Injective C(\u03b1, \u03b2) (\u03b1 \u2192 \u03b2) (\u2191) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a closed ball centered at any point 'x' with radius 0 only contains the point 'x' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem closedBall_zero : closedBall x 0 = {x} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a sphere with center x and radius 0 consists only of the point x itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sphere_zero : sphere x 0 = {x} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the identity function within the context of continuous maps is equivalent to applying the general identity function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_id : \u21d1(ContinuousMap.id \u03b1) = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the modular form represented by the zero element is equal to the zero function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : \u21d1(0 : ModularForm \u0393 k) = (0 : \u210d \u2192 \u2102) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the ring of integers, denoted as \u2124, is not a field when considered as a subring of any field K.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_isField : \u00acIsField (\ud835\udcde K) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number d, the square root of d multiplied by itself equals d.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dmuld : sqrtd (d :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that K is an algebraic extension of the rational numbers (\u211a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isAlgebraic : Algebra.IsAlgebraic \u211a K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Legendre symbol of 0 modulo an odd prime p is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem at_zero : legendreSym p 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a field extension B of A is a cyclotomic extension of order n if and only if two conditions hold: (1) there exists an element r in B that is a primitive nth root of unity, and (2) every element in B belongs to the subfield generated by A and all nth roots of unity in B.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iff_singleton :\n    IsCyclotomicExtension {n} A B \u2194\n      (\u2203 r : B, IsPrimitiveRoot r n) \u2227 \u2200 x, x \u2208 adjoin A {b : B | b ^ (n : \u2115) = 1} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a field extension B of A is a cyclotomic extension with respect to a set of positive integers S if and only if two conditions hold: \n1. For every integer n in S, there exists an element r in B that is a primitive n-th root of unity.\n2. The field B is generated by adjoining to A all elements b in B such that b raised to the power of some n in S equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iff_adjoin_eq_top :\n    IsCyclotomicExtension S A B \u2194\n      (\u2200 n : \u2115+, n \u2208 S \u2192 \u2203 r : B, IsPrimitiveRoot r n) \u2227\n        adjoin A {b : B | \u2203 n : \u2115+, n \u2208 S \u2227 b ^ (n : \u2115) = 1} = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Legendre symbol of 1 with respect to any prime number p is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem at_one : legendreSym p 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the quadratic character of 0 in any field F is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem quadraticChar_zero : quadraticChar F 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any field F, the quadratic character function evaluated at 0 is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem quadraticCharFun_zero : quadraticCharFun F 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a field 'F', 'a' is either a quadratic residue or a non-quadratic residue.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem quadraticChar_isQuadratic : (quadraticChar F).IsQuadratic :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any field F, the quadratic character of 1 is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem quadraticCharFun_one : quadraticCharFun F 1 = 1 :=",
        "label": true
      }
    ]
  }
]