[
  {
    "input": "Statement in natural language:\nProve that for any natural number n, n is even if and only if n leaves no remainder when divided by 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_zero_iff_even {n : \u2115} : (n : ZMod 2) = 0 \u2194 Even n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two elements \\( a \\) and \\( b \\) from a set \\( \\alpha \\) where any two elements can be compared, if a property \\( p \\) holds for both \\( a \\) and \\( b \\), then \\( p \\) also holds for the least upper bound (or supremum), denoted by \\( a \\sqcup b \\), of \\( a \\) and \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_ind (a b : \u03b1) {p : \u03b1 \u2192 Prop} (ha : p a) (hb : p b) : p (a \u2294 b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers 'm' and 'n' where 'n' is less than or equal to 'm', the difference 'm - n' is odd if and only if 'm' being odd is equivalent to 'n' being even.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem odd_sub (h : n \u2264 m) : Odd (m - n) \u2194 (Odd m \u2194 Even n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of two open sets of complex numbers is also an open set in the complex plane.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s \u00d7\u2102 t) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'm' from set '\u03b1' to set '\u03b2' and an element 'b' in '\u03b2', prove that the inverse image of the singleton set '{b}' under 'm', is equal to the power set of the inverse image of 'b' under 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_pure {b : \u03b2} : comap m (pure b) = \ud835\udcdf (m \u207b\u00b9' {b}) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a complete metric space, the distance between any point and itself is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dist_self (x : Completion \u03b1) : dist x x = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers `a` and `b`, the set of natural numbers from `a + 1` (inclusive) to `b` (exclusive) is the same as the set of natural numbers from `a` (exclusive) to `b` (exclusive).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_succ_left : Ico a.succ b = Ioo a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function from a set  'X' to the empty set (denoted as '0') must be equal to a function that does nothing.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_of_to_zero {X : C} (f : X \u27f6 0) : f = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(K\\) be a convex set in a Euclidean space \\(E\\). Prove that if \\(s\\) is a face of \\(K\\), then \\(s\\) is a subset of \\(K\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_space (hs : s \u2208 K.faces) : (s : Set E) \u2286 K.space :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property P defined over infinite sequences, there exists an infinite sequence satisfying P if and only if there exists an element 'a' and an infinite sequence 'v' such that the sequence formed by prepending 'a' to 'v' also satisfies P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_fin_succ_pi {P : (\u2200 i, \u03b1 i) \u2192 Prop} : (\u2203 x, P x) \u2194 \u2203 a v, P (Fin.cons a v) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the measure of an open ball in a metric space is always greater than 0, given that the radius of the ball is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measure_ball_pos (x : X) {r : \u211d} (hr : 0 < r) : 0 < \u03bc (ball x r) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood of a point 'a' is equivalent to the union of the punctured neighborhood of 'a' and the set containing only 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_compl_singleton_sup_pure (a : \u03b1) : \ud835\udcdd[\u2260] a \u2294 pure a = \ud835\udcdd a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two angles \\(x\\) and \\(y\\) in an interval \\(I\\), the cotangent of \\(x\\) equals the cotangent of \\(y\\) if and only if the difference between \\(x\\) and \\(y\\) is a multiple of \\(\\pi\\) (i.e., \\(x - y\\) belongs to the set of all integral multiples of \\(\\pi\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y \u2194 (x - y : R) \u2208 I ^ 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the polynomial \\(1\\) (interpreted as a constant polynomial with real coefficients) has no roots.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem roots_one : (1 : R[X]).roots = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s_1 \\), \\( s_2 \\), and \\( t \\), the intersection of the union of \\( s_1 \\) and \\( s_2 \\) with \\( t \\) is equal to the union of the intersection of  \\( s_1 \\)  and \\( t \\) with the intersection of \\( s_2 \\) and \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infs_union_left : (s\u2081 \u222a s\u2082) \u22bc t = s\u2081 \u22bc t \u222a s\u2082 \u22bc t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of closing a sieve under a certain condition (J\u2081) always produces a larger sieve, or more formally, the closure operation associated with J\u2081 is monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_close {X : C} : Monotone (J\u2081.close : Sieve X \u2192 Sieve X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'a' has finite order with respect to another element 'b', then 'a' cannot be a unit (i.e., it doesn't have a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_unit_of_finite {a b : \u03b1} (h : Finite a b) : \u00acIsUnit a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set of points is always cospherical.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cospherical_empty [Nonempty P] : Cospherical (\u2205 : Set P) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in an inner product space, the real part of the inner product of any vector with itself is greater than or equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inner_self_nonneg {x : E} : 0 \u2264 re \u27eax, x\u27eb :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property \\( p \\) that takes two arguments, saying \"for all x and for all y, p(x, y) holds\" is equivalent to saying \"for all y and for all x, p(x, y) holds.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall_swap {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 x y, p x y) \u2194 \u2200 y x, p x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property \\( p \\) defined on elements of type \\( \\alpha \\), and for any element \\( x \\) of type \\( \\alpha \\), \\( x \\) satisfies the property \\( p \\) if and only if \\( x \\) belongs to the set of elements for which \\( p \\) holds true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem setOf_app_iff {p : \u03b1 \u2192 Prop} {x : \u03b1} : { x | p x } x \u2194 p x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\( s \\) and \\( t \\), if \\( s \\) is a subset of \\( t \\), then the intersection of \\( s \\) and \\( t \\) is equal to \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_eq_self_of_subset_left {s t : Set \u03b1} : s \u2286 t \u2192 s \u2229 t = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any nontrivial multiplicative group `M\u2080`, the element `0` is a primitive root of unity of order `0`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero [Nontrivial M\u2080] : IsPrimitiveRoot (0 : M\u2080) 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a sequence of elements in a normed vector space. Prove that if \\(f\\) is \\(q\\)-summable (i.e., the \\(q\\)-th powers of the norms of its elements form a convergent series) for some non-negative real number \\(q\\), then \\(f\\) is also \\(p\\)-summable for any \\(p\\) greater than or equal to \\(q\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_exponent_ge {p q : \u211d\u22650\u221e} {f : \u2200 i, E i} (hfq : Mem\u2113p f q) (hpq : q \u2264 p) : Mem\u2113p f p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the order of a monomial (a term in a polynomial with a single term) is equal to the exponent of its variable, given that the coefficient of the monomial is not zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem order_monomial_of_ne_zero (n : \u2115) (a : R) (h : a \u2260 0) : order (monomial R n a) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two groups, N and G, and a homomorphism \u03c6 from G to the automorphism group of N. This data allows us to construct a new group called the semidirect product of N and G, denoted by N \u22ca[\u03c6] G.  Now, let's say we have another semidirect product with groups N' and G', and a homomorphism \u03c6' from G' to the automorphism group of N'. \n\nGiven a group element 'g' from the semidirect product N \u22ca[\u03c6] G, and functions f\u2081 (a homomorphism from N to N'), f\u2082 (a homomorphism from G to G'), and h (satisfying a specific property related to \u03c6 and \u03c6'), prove that if we map 'g' using a function called 'map' constructed from f\u2081, f\u2082, and h, and then extract the 'right' component (which would be an element of G'), it's the same as first extracting the 'right' component of 'g' (an element of G) and then applying f\u2082 to it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_right (g : N \u22ca[\u03c6] G) : (map f\u2081 f\u2082 h g).right = f\u2082 g.right :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the diagonal of a zero matrix of size n x n is a zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem diag_zero [Zero \u03b1] : diag (0 : Matrix n n \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the product of a finite collection of elements is equal to the product of the norms of those elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnnorm_prod (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u2016\u220f b in s, f b\u2016\u208a = \u220f b in s, \u2016f b\u2016\u208a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `ghostMap` is a bijection between the set of infinite sequences of real numbers (denoted as \ud835\udd4e R) and the set of functions from natural numbers to real numbers (denoted as \u2115 \u2192 R).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : \ud835\udd4e R \u2192 \u2115 \u2192 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\(f\\) from a vector space \\(V\\) to another vector space \\(V_1\\) (both over the same field \\(K\\)), the rank of \\(f\\) is less than or equal to the dimension of \\(V\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rank_le_domain (f : V \u2192\u2097[K] V\u2081) : rank f \u2264 Module.rank K V :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function  f(x) = x^(-1/x), where x is a real number, approaches 1 as x approaches positive infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : \u211d) / x)) atTop (\ud835\udcdd 1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\) and any natural number \\( n \\),  the sine of the difference between \\( x \\) and \\( n \\) times two pi is equal to the sine of \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sin_sub_nat_mul_two_pi (x : \u211d) (n : \u2115) : sin (x - n * (2 * \u03c0)) = sin x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the non-negative norm of the zero function in the Lp space is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnnorm_zero : \u2016(0 : Lp E p \u03bc)\u2016\u208a = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(G\\) be a group and \\(P\\) be a Sylow \\(p\\)-subgroup of \\(G\\). Prove that the kernel of the transfer homomorphism from \\(G\\) to \\(P\\) is a complement of \\(P\\) in \\(G\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to represent a mathematical expression called \"P\". This expression \"P\" has a specific term we call \"b\". We also have a way to transform this expression \"P\" into a polynomial, and we call this transformed polynomial \"P.toPoly\".  Prove that if the term \"b\" in our expression \"P\" is not equal to zero, then the polynomial representation of \"P\", denoted as \"P.toPoly\", is also not equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_zero_of_b_ne_zero (hb : P.b \u2260 0) : P.toPoly \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the homogeneous component of a polynomial  is indeed homogeneous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n \u03c6).IsHomogeneous n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\(f\\) is injective, then two elements \\(x\\) and \\(y\\) are different if and only if their images under \\(f\\) (i.e., \\(f(x)\\) and \\(f(y)\\)) are different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Injective.ne_iff (hf : Injective f) {x y : \u03b1} : f x \u2260 f y \u2194 x \u2260 y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a set \u03b1 with a largest element (denoted by \u22a4) and a subset of \u03b1, called Subtype p, which also has its own largest element (also denoted by \u22a4, but representing the largest element within the subset).  Given that the largest element of \u03b1 satisfies the condition 'p' which defines the subset, prove that the largest element of the subset, when viewed as an element of the original set \u03b1, is the same as the largest element of \u03b1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_top [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) : ((\u22a4 : Subtype p) : \u03b1) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(H\\) be a set and \\(I\\) be a function from \\(H\\) to another set. This theorem states that for every element \\(x\\) in \\(H\\), the image of the neighborhood of \\(x\\) under the function \\(I\\) is equal to the neighborhood of the image of \\(x\\) within the range of \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_nhds_eq (x : H) : map I (\ud835\udcdd x) = \ud835\udcdd[range I] I x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\(a\\) which can be positive, negative or zero, the negation of \\(a\\) is equal to \\(a\\) if and only if \\(a\\) is equal to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_eq_self_iff (a : SignType) : -a = a \u2194 a = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\(s\\) and \\(t\\), and an element \\(a\\), if \\(a\\) is not an element of \\(s\\), then the intersection of \\(s\\) with the union of \\(a\\) and \\(t\\) is equal to the intersection of \\(s\\) and \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_insert_of_not_mem (h : a \u2209 s) : s \u2229 insert a t = s \u2229 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) be a function from a set \\( \u03b1 \\) to a set \\( \u03b2 \\). Let \\( m \\) and \\( m' \\) be two outer measures on \\( \u03b1 \\). Prove that for any subset \\( s \\) of \\( \u03b2 \\), the outer measure of \\( s \\) under the image of the supremum of \\( m \\) and \\( m' \\) is equal to the supremum of the outer measure of \\( s \\) under the image of \\( m \\) and the outer measure of \\( s \\) under the image of \\( m' \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_sup {\u03b2} (f : \u03b1 \u2192 \u03b2) (m m' : OuterMeasure \u03b1) : map f (m \u2294 m') = map f m \u2294 map f m' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers 'm' and 'n', and any element 'a' from a set with an operation denoted by '\u2022', the following holds: (m + n) \u2022 a = (m \u2022 a) + (n \u2022 a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_nsmul (a : A) (m n : \u2115) : (m + n) \u2022 a = m \u2022 a + n \u2022 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list of elements 'l', if every element 'x' in 'l' is also a member of a set 's', then the sum of all elements in 'l' is also a member of the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem list_sum_mem {l : List K} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.sum \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) and a property \\(p\\), prove that \\(p\\) holds frequently for elements in the preimage of a set \\(l\\) under \\(f\\) if and only if there are frequently elements \\(b\\) in \\(l\\) such that there exists an element \\(a\\) where \\(f(a) = b\\) and \\(p(a)\\) is true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem frequently_comap : (\u2203\u1da0 a in comap f l, p a) \u2194 \u2203\u1da0 b in l, \u2203 a, f a = b \u2227 p a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three positive natural numbers  \\(m\\), \\(n\\), and  \\(k\\), if  \\(k\\) and \\(n\\) are coprime, then the greatest common divisor (GCD) of \\(m \\times k\\) and \\(n\\) is equal to the GCD of \\(m\\) and \\(n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Coprime.gcd_mul_right_cancel (m : \u2115+) {n k : \u2115+} : k.Coprime n \u2192 (m * k).gcd n = m.gcd n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a subgroup \\(p\\) and an element \\(x\\) within that subgroup, prove that the difference between \\(x\\) and any element \\(y\\) belongs to the subgroup \\(p\\) if and only if \\(y\\) itself belongs to the subgroup \\(p\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_mem_iff_right (hx : x \u2208 p) : x - y \u2208 p \u2194 y \u2208 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is an isometry, then it is anti-Lipschitz with constant 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antilipschitz : AntilipschitzWith 1 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three finite sets \\( s\u2081 \\), \\( s\u2082 \\), and \\( s\u2083 \\), if \\( s\u2081 \\) is a superset of \\( s\u2082 \\) and \\( s\u2082 \\) is a superset of \\( s\u2083 \\), then \\( s\u2081 \\) is a superset of \\( s\u2083 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Superset.trans {s\u2081 s\u2082 s\u2083 : Finset \u03b1} : s\u2081 \u2287 s\u2082 \u2192 s\u2082 \u2287 s\u2083 \u2192 s\u2081 \u2287 s\u2083 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two functions \\( f \\) and \\( g \\), the set of points where \\( f + g \\) differs from \\( f \\) is precisely the set of points where \\( g \\) is nonzero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `fromLocalizedModule S f` is bijective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a collection of simple graphs, all defined on the same set of vertices \\(V\\), prove that two distinct vertices \\(a\\) and \\(b\\) are adjacent in the intersection of these graphs if and only if they are adjacent in every individual graph in the collection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iInf_adj {f : \u03b9 \u2192 SimpleGraph V} : (\u2a05 i, f i).Adj a b \u2194 (\u2200 i, (f i).Adj a b) \u2227 a \u2260 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of lower bounds of the empty set is equal to the universal set (the set containing all elements).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lowerBounds_empty : lowerBounds (\u2205 : Set \u03b1) = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\( s \\) is unbounded with respect to the less than or equal to relation (\u2264), then it is also unbounded with respect to the strictly less than relation (<).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unbounded_lt_of_unbounded_le [Preorder \u03b1] (h : Unbounded (\u00b7 \u2264 \u00b7) s) : Unbounded (\u00b7 < \u00b7) s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a basket and a box. Inside the basket, you have pairs of items, where the first item in each pair comes from a specific group called \"left\" and the second item comes from a specific group called \"right.\"  This basket represents \"Sigma.\" Now, you have two ways to get to the second item (\"right\") of a specific pair (let's call this pair \"b\"):\n\n   **Method 1:**\n     1. You first take the pair \"b\" from the basket.\n     2. Then, you directly take the second item from the pair.\n\n   **Method 2:** \n     1. You first take all the second items from every pair in the basket and put them in the box.\n     2. Then, you find the second item that originally belonged to pair \"b\" inside the box.\n\n This theorem states that both methods will lead you to the same second item from pair \"b.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem \u03b9_sndSigmaMap (b) : Sigma.\u03b9 I.left b \u226b I.sndSigmaMap = I.snd b \u226b Sigma.\u03b9 I.right _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any type of objects \u03b1, if we have a specific object 'd' of type \u03b1 and another object 'x' of the same type, then applying a function called \"unbot'\" with 'd' and 'x' as inputs will always result in 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unbot'_coe {\u03b1} (d x : \u03b1) : unbot' d x = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any irrational number \\( x \\) and a non-zero natural number \\( m \\), the division of \\( x \\) by \\( m \\) is also irrational.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_nat (h : Irrational x) {m : \u2115} (hm : m \u2260 0) : Irrational (x / m) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( s \\), \\( t \\), and \\( u \\), if \\( s \\) is a subset of \\( u \\), then \\( s \\) is also a subset of the union of \\( t \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_union_of_subset_right {s u : Set \u03b1} (h : s \u2286 u) (t : Set \u03b1) : s \u2286 t \u222a u :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative numbers x and y, if the square of x is less than y, then x is less than the square root of y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine a collection of boxes indexed by a set called \"\u03b9\". Each box can hold a value of a certain type. Consider a function 'f' that assigns a value to each box. Now, let's say we have a special function called \"single\" that takes an index 'i' and a value, and puts that value only in the box with index 'i', leaving all other boxes empty. There's also a function \"erase\" that takes a function like 'f' and an index 'i', and removes the value from the box with index 'i', leaving other boxes untouched.  Prove that if we add the result of  \"single i (f i)\" (which puts the value of 'f' at index 'i' into the box 'i') to the result of \"f.erase i\" (which removes the value at index 'i' from 'f'), we get back the original function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem single_add_erase (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) : single i (f i) + f.erase i = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n', the length of its binary representation is equal to the number of bits required to represent it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem size_eq_bits_len (n : \u2115) : n.bits.length = n.size :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the successor of *n* is oddly bounded if and only if *n* is not oddly bounded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bodd_succ (n : \u2115) : bodd (succ n) = not (bodd n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet M, N, and P be subsets of a larger set R that has addition and subtraction defined on it. Prove that the product set of M and N is a subset of P if and only if for every element m in M and every element n in N, their product m * n is an element of P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le {M N P : AddSubmonoid R} : M * N \u2264 P \u2194 \u2200 m \u2208 M, \u2200 n \u2208 N, m * n \u2208 P :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function is continuous on a set, then its inverse function (assuming it exists) is continuous on the image of that set under the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousOn_symm {s} : ContinuousOn I.symm s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers x and y, applying the exponential map to their sum is the same as multiplying the results of applying the exponential map to each number individually.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem expMapCircle_add (x y : \u211d) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of two open intervals (a, \u221e) and (b, \u221e) is equal to the open interval (max(a, b), \u221e).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioi_inter_Ioi : Ioi a \u2229 Ioi b = Ioi (a \u2294 b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any homomorphism 'f' between two Heyting algebras \u03b1 and \u03b2, composing 'f' with the identity homomorphism on \u03b2 results in 'f' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp (f : HeytingHom \u03b1 \u03b2) : (HeytingHom.id \u03b2).comp f = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have two functions, `f` and `g`, both of which map elements from a set `X` to a set `Y`. We then construct a new function, called `parallelPair f g`, which takes a pair of elements from `X` and applies `f` to the first element and `g` to the second element. Prove that applying this new function to a special pair, where both elements are the 'zero' element of `X`, results in the set `X` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem parallelPair_obj_zero (f g : X \u27f6 Y) : (parallelPair f g).obj zero = X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two objects, \\(A\\) and \\(B\\), and a diagram consisting of two parallel arrows, \\(f\\) and \\(g\\), pointing from \\(A\\) to \\(B\\). Let's say we have a cocone \\(s\\) over this diagram, which essentially means we have another object, let's call it \\(C\\), along with an arrow \\(s.\\pi\\) going from \\(B\\) to \\(C\\).  Additionally, assume that \\(s\\) is not just any cocone, but a colimit of the diagram. Now, if we have another cocone \\(t\\) over the same diagram (meaning there's an arrow \\(t.\\pi\\) from \\(B\\) to some object), then we can find a unique map from the colimit object \\(C\\) to the object pointed to by \\(t.\\pi\\), such that everything commutes. This unique map is denoted by \\(hs.desc\\ t\\). The theorem then states that composing the arrow \\(s.\\pi\\) with this unique map \\(hs.desc\\ t\\) is the same as the arrow \\(t.\\pi\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Cofork.IsColimit.\u03c0_desc {s t : Cofork f g} (hs : IsColimit s) : s.\u03c0 \u226b hs.desc t = t.\u03c0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all scalar multiples of a vector 'x' only contains the zero vector if and only if the vector 'x' itself is the zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_singleton_eq_bot : (R \u2219 x) = \u22a5 \u2194 x = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a special kind of \"sieve\" called a filter (represented by `G`) that helps us pick out certain elements from a set \u03b4. We also have four transformations: \u03c6, \u03c8, \u03b8, and \u03c1, which can be thought of as ways to rearrange or map elements between different sets. The problem is to prove that applying the transformations in a specific order doesn't matter when working with these filters.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_comm (G : Filter \u03b4) : comap \u03c6 (comap \u03c8 G) = comap \u03b8 (comap \u03c1 G) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an isomorphism (a structure-preserving map between two sets that has an inverse) between sets  is differentiable everywhere on its domain.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiableOn : DifferentiableOn \ud835\udd5c iso s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number 4 satisfies a specific property called \"Admissible E'\". (Note: We won't define \"Admissible E'\" precisely, as it requires deeper knowledge of a specific formal system. The focus here is on how the proof works structurally.)\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem admissible_E'4 : Admissible (E' 4) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if you convert a finite set into a regular set, the resulting set is countable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Finset.countable_toSet (s : Finset \u03b1) : Set.Countable (\u2191s : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that the function `inl R A B`, which takes an element `x` of type `A` and returns the pair `(x, 0)` of type `A \u00d7 B`, is equivalent to the function `fun x => (x, 0)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_inl : (inl R A B : A \u2192 A \u00d7 B) = fun x => (x, 0) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) from a set \\( \u03b1 \\) to a set \\( \u03b2 \\), and any subset \\( o \\) of \\( \u03b1 \\), if an element \\( a \\) belongs to \\( o \\), then the image of \\( a \\) under \\( f \\) (i.e., \\( f(a) \\)) belongs to the image of the subset \\( o \\) under  \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_map (f : \u03b1 \u2192 \u03b2) {o : Part \u03b1} : \u2200 {a}, a \u2208 o \u2192 f a \u2208 map f o\n   | _, \u27e8_, rfl\u27e9 => \u27e8_, rfl\u27e9\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cardinality of the set of natural numbers (aleph-null, denoted as \u2135\u2080) is less than or equal to the cardinality of the set of real numbers (continuum, denoted as \ud835\udd20).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aleph0_le_continuum : \u2135\u2080 \u2264 \ud835\udd20 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\(x\\), the square of the hyperbolic sine of  \\(x\\) is equal to the square of the hyperbolic cosine of \\(x\\) minus 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a direct product of two modules (like combining two separate lines into a plane), any element can be expressed as the sum of an element from the first module and an element from the second module.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fst_sup_snd : Submodule.fst R M M\u2082 \u2294 Submodule.snd R M M\u2082 = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function \\(f\\) and a factorization of \\(f\\) into two functions, \\(e\\) and \\(m\\), where \\(m\\) is a monomorphism (a function that preserves distinctness of elements). This factorization can be visualized as \\(f = e \\circ m\\). Now, consider the image of \\(f\\), denoted as \\(Im(f)\\). We can lift the function \\(e\\) to a function from \\(Im(f)\\) to the codomain of \\(f\\), denoted as \\(lift(e)\\). Prove that the composition of \\(lift(e)\\) and \\(m\\) is equal to the inclusion map from \\(Im(f)\\) to the codomain of \\(f\\), denoted as \\(\u03b9\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' \u226b F'.m = Image.\u03b9 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function `f` from a set `\u03b9` to a set `\u03b1` is \"monovariant\" with itself. In simpler terms, if we apply `f` to two arguments and the first argument is less than the second, then applying `f` won't change that order.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monovary_self (f : \u03b9 \u2192 \u03b1) : Monovary f f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of natural numbers, ordered by the less-than relation (<), is well-founded.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_wf : @WellFounded NatOrdinal (\u00b7 < \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the exponential of any element in a normed field is a unit (i.e., has a multiplicative inverse).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_exp (x : \ud835\udd38) : IsUnit (exp \ud835\udd42 x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of zero numbers is equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_zero : @prod \u03b1 _ 0 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is an isometry, then it is Lipschitz continuous with Lipschitz constant 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\( f \\) between vector spaces \\( B \\) and \\( C \\), if \\( f \\) is injective (one-to-one), then the sequence consisting of the zero map from the zero vector space to \\( B \\) followed by \\( f \\) is exact.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exact_zero_mono {B C : V} (f : B \u27f6 C) [Mono f] : Exact (0 : 0 \u27f6 B) f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any permutation \\( f \\) of a set and any element \\( x \\) in that set, applying the inverse permutation \\( f^{-1} \\) to the result of applying \\( f \\) to \\( x \\) gives us back the original element \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_apply_self (f : Perm \u03b1) (x) : f\u207b\u00b9 (f x) = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\( a \\) and finite set \\( s \\), checking if \\( a \\) belongs to \\( s \\) is the same as checking if \\( a \\) belongs to the underlying implementation of \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_def {a : \u03b1} {s : Finset \u03b1} : a \u2208 s \u2194 a \u2208 s.1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic cosine of a number x is strictly less than the hyperbolic cosine of another number y if and only if the absolute value of x is strictly less than the absolute value of y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cosh_lt_cosh : cosh x < cosh y \u2194 |x| < |y| :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number \\(x\\) is a factor of a number \\(a\\) (where \\(a\\) is not zero), then \\(x\\) must be a prime number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prime_of_factor {a : \u03b1} (x : \u03b1) (hx : x \u2208 factors a) : Prime x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements 'a' and 'b', applying a strictly increasing function 'ofAdd' to them preserves the order, meaning if 'a' is less than or equal to 'b', then 'ofAdd(a)' is less than or equal to 'ofAdd(b)', and vice versa.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofAdd_le {a b : \u03b1} : ofAdd a \u2264 ofAdd b \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a relation `r` that holds between elements of a set `N`. There is also a function `\u03bc` that takes an element from a set `M` and an element from `N` and returns a new element in `N`. The statement says that if the relation `r` holds between the results of applying `\u03bc` with `m` to `a` and `b` respectively, then the relation `r` must also hold directly between `a` and `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (\u03bc m a) (\u03bc m b)) : r a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a ring called \\(R\\), a module over that ring called \\(M\\), and a subset of the ring called \\(s\\). We can create a special subgroup of \\(M\\) called the \"torsion subset by \\(s\\)\", written as (torsionBySet R M s). This subset consists of all elements in \\(M\\) that can be \"annihilated\" (sent to zero) by multiplying with some element from our subset \\(s\\).  Prove that this torsion subset is indeed a torsion subset with respect to the set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements \\(a\\), \\(b\\), and \\(c\\) in a set with a defined least upper bound operation (\\(\\sqcup\\)), the following holds:  \\(a \\sqcup b \\sqcup c = a \\sqcup c \\sqcup (b \\sqcup c)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_sup_distrib_right (a b c : \u03b1) : a \u2294 b \u2294 c = a \u2294 c \u2294 (b \u2294 c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vectors u, v, and w (where w is non-zero), the absolute value of the difference between the lengths of u/w and v/w is less than or equal to the length of (u/w - v/w).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_div_sub_norm_div_le_norm_div (u v w : E) : \u2016u / w\u2016 - \u2016v / w\u2016 \u2264 \u2016u / v\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the open interval (b, c) under the function that adds a constant 'a' to a number is equal to the open interval (b - a, c - a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_add_const_Ioc : (fun x => x + a) \u207b\u00b9' Ioc b c = Ioc (b - a) (c - a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a ring \\(R\\) and an ideal \\(I\\) of \\(R\\), prove that the product of the annihilator of \\(I\\) and \\(I\\) is equal to the zero ideal (denoted by \u22a5).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem annihilator_mul (I : Ideal R) : annihilator I * I = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing any function \\(f\\) with the identity function results in the function \\(f\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp : id.comp f = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the projection function, which takes an ordered pair (x, y) and returns the first element x, is infinitely differentiable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contDiffAt_fst {p : E \u00d7 F} : ContDiffAt \ud835\udd5c n (Prod.fst : E \u00d7 F \u2192 E) p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a matrix representing a linear transformation that maps everything to zero, all the entries are zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a function to a function with finite support and then taking its support is the same as directly taking the support of the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_ofFintype : (ofFintype f h).support = Function.support f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet A be a Noetherian ring, and let f be a ring homomorphism from A to B. Prove that the algebra B is finitely generated over A if and only if B is finitely presented as an A-algebra.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_finiteType [IsNoetherianRing A] {f : A \u2192\u2090[R] B} : f.FiniteType \u2194 f.FinitePresentation :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn any category, the pullback of a morphism along a morphism from the initial object is isomorphic to the initial object.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_left (X : C) : IsPullback (0 : 0 \u27f6 X) (0 : (0 : C) \u27f6 0) (\ud835\udfd9 X) (0 : 0 \u27f6 X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two functions, \\( e \\) and \\( e' \\), always produce the same output for any given input, then the two functions are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext (h : \u2200 x, e x = e' x) : e = e' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the multiplicative inverse of a positive number 'a' is greater than 1 if and only if the number 'a' itself is less than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Right.one_lt_inv_iff : 1 < a\u207b\u00b9 \u2194 a < 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a constant real polynomial has no roots.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem roots_C (x : R) : (C x).roots = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have two objects, X and Y, and a map (like a function) called 'f' that goes from X to Y.  This map 'f' lives in a special world where everything is \"opposite\" - we call this the \"opposite category.\" In this opposite world, there's a way to turn 'f' into a map that goes from Y to X (going backwards). We call this backwards map \"f.unop\". Now, sometimes a map is special because it has an \"inverse\" - another map that undoes it completely. We call these special maps \"isomorphisms.\" This theorem wants to prove that:  f.unop is an isomorphism if and only if the original map f is an isomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isIso_unop_iff {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) : IsIso f.unop \u2194 IsIso f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, and c, adding 'a' to every number within the open interval (b, c) is equivalent to shifting the interval (b, c) by 'a' units to the right on the number line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two groups, H and K, where H is a subgroup of K (denoted by H \u2264 K). Prove that if H has finite index in K, then K also has finite index.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finiteIndex_of_le [FiniteIndex H] (h : H \u2264 K) : FiniteIndex K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number c, b divided by c is less than a if and only if b is less than a multiplied by c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_lt_iff (hc : 0 < c) : b / c < a \u2194 b < a * c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\( E \\) and a positive real number \\( \\delta \\), the \\( \\delta \\)-thickening of \\( E \\) is a neighborhood of \\( E \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem thickening_mem_nhdsSet (E : Set \u03b1) {\u03b4 : \u211d} (h\u03b4 : 0 < \u03b4) : thickening \u03b4 E \u2208 \ud835\udcdd\u02e2 E :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function that takes two indices, \\(i\\) and \\(j\\), and returns a downward-closed set (a \"lower set\") of elements from some set \u03b1. Prove that an element \\(a\\) belongs to the union of all these lower sets if and only if there exists some indices \\(i\\) and \\(j\\) such that \\(a\\) belongs to the lower set \\(f(i, j)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1} : (a \u2208 \u2a06 (i) (j), f i j) \u2194 \u2203 i j, a \u2208 f i j :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that shifting any three points in a vector space by the same vector does not change the angle between them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem angle_const_add (v : V) (v\u2081 v\u2082 v\u2083 : V) : \u2220 (v + v\u2081) (v + v\u2082) (v + v\u2083) = \u2220 v\u2081 v\u2082 v\u2083 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(a\\) be a point and \\(s\\) and \\(t\\) be sets. If \\(s\\) is a neighborhood of \\(a\\) within the set \\(t\\), then a set is a neighborhood of \\(a\\) within the intersection of \\(s\\) and \\(t\\) if and only if it is a neighborhood of \\(a\\) within \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_inter_of_mem {a : \u03b1} {s t : Set \u03b1} (h : s \u2208 \ud835\udcdd[t] a) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[t] a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'f' between two structures 'C\u2081' and 'C\u2082' that preserves certain properties (Hom), applying a specific construction 'sqFrom' at an index 'i' and then projecting to the 'left' component is the same as directly applying 'f' at index 'i'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sqFrom_left (f : Hom C\u2081 C\u2082) (i : \u03b9) : (f.sqFrom i).left = f.f i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\(f\\) is injective (meaning it maps distinct elements to distinct elements), then the function \\(map f\\) is strictly monotonic.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_strictMono_of_injective : StrictMono (map f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a quotient set of lower sets back to a regular set results in the same quotient set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_div (s t : LowerSet \u03b1) : (\u2191(s / t) : Set \u03b1) = s / t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a value 'a' is not the successor of another value if and only if 'a' is in the range of the successor function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_isSuccLimit_iff' : \u00acIsSuccLimit a \u2194 a \u2208 range (@succ \u03b1 _ _) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a walk in a graph is Eulerian, then it is also a trail.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set  \\(\ud835\udc9c\\) and a natural number \\(k\\), prove that a set \\(s\\) belongs to the \"falling set\"  \\(falling \\; k \\; \ud835\udc9c\\)  if and only if:\n 1. There exists a set \\(t\\) in \\(\ud835\udc9c\\) such that \\(s\\) is a subset of \\(t\\), AND\n 2. The number of elements in \\(s\\) (its cardinality) is equal to \\(k\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_falling : s \u2208 falling k \ud835\udc9c \u2194 (\u2203 t \u2208 \ud835\udc9c, s \u2286 t) \u2227 s.card = k :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers m and n, the sum (m + n) is odd if and only if exactly one of m or n is odd and the other is even.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem odd_add : Odd (m + n) \u2194 (Odd m \u2194 Even n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\( s\u2081 \\) and \\( s\u2082 \\), the elements of the intersection of \\( s\u2081 \\) and \\( s\u2082 \\) are the same as the elements in the intersection of the underlying sets of \\( s\u2081 \\) and \\( s\u2082 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_val (s\u2081 s\u2082 : Finset \u03b1) : (s\u2081 \u2229 s\u2082).1 = s\u2081.1 \u2229 s\u2082.1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a specific element 'a' and a function 'e'. 'e' takes an element from a set we'll call \u03b2\u2081 and gives us back an element from another set (it doesn't matter what this other set is for this problem). Now, let's say we have a pair containing 'a' and an element 'b' from \u03b2\u2081. If we use a special operation called 'prodExtendRight' on this pair, 'a', and our function 'e', it should be the same as creating a new pair. This new pair will still have 'a' as its first element, but the second element will be the result of applying the function 'e' to 'b'. Prove that this is true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prodExtendRight_apply_eq (b : \u03b2\u2081) : prodExtendRight a e (a, b) = (a, e b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets  \\( s\u2081 \\), \\( s\u2082 \\), and \\( t \\), the image of the union of sets \\( s\u2081 \\) and \\( s\u2082 \\) under a function \\( \u2022 \\) with elements of set \\( t \\) is equal to the union of the images of \\( s\u2081 \\) and \\( s\u2082 \\) under the function \\( \u2022 \\) with elements of \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_smul [DecidableEq \u03b1] : (s\u2081 \u222a s\u2082) \u2022 t = s\u2081 \u2022 t \u222a s\u2082 \u2022 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the constant coefficient of a formal power series \\( \\phi \\) is equal to the coefficient of the term with degree 0 in \\( \\phi \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem constantCoeff_coe : PowerSeries.constantCoeff R \u03c6 = \u03c6.coeff 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(s\\), \\(t\\), and \\(u\\) be sets. Prove that the product set \\(s * t\\) is a subset of \\(u\\) if and only if for every element \\(b\\) in \\(t\\), the set obtained by multiplying each element of \\(s\\) by \\(b\\) (denoted as \\(op b \u2022 s\\)) is a subset of \\(u\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_subset_iff_right : s * t \u2286 u \u2194 \u2200 b \u2208 t, op b \u2022 s \u2286 u :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any partisan game 'x', prove that 'x' is less than or equal to the game obtained by performing a right move on 'x' for any value of 'j'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lf_moveRight {x : PGame} : \u2200 j, x \u29cf x.moveRight j :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the distance between a solution (soln) and a point 'a' is less than the norm of the derivative of a function F evaluated at 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem soln_dist_to_a_lt_deriv : \u2016soln - a\u2016 < \u2016F.derivative.eval a\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the closure of a countable set \\(s\\) in a topological space with respect to a linear operator \\(L\\) is countably generated.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number `n`, there is no natural number that comes after the last element within the range from 0 to `n` (inclusive).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) that maps each ordinal number smaller than 1 to another ordinal number, prove that the smallest ordinal number greater than or equal to all \\(f(a)\\) (where \\(a\\) is an ordinal smaller than 1) is equal to \\(f(0)\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bsup_one (f : \u2200 a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the square of 'a' is equal to the square of 'b' if and only if 'a' is equal to 'b' or 'a' is equal to the negative of 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the order of the identity element in a group is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem orderOf_one : orderOf (1 : G) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any filter \\( l \\) on a set \\( \\alpha \\), the intersection of all sets in the neighborhood filter of \\( l \\) is equal to the principal filter generated by \\( l \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInter_nhds (l : Filter \u03b1) : \u22c2\u2080 { s | s \u2208 \ud835\udcdd l } = Iic l :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the top element of a convex cone to a set results in the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_top : \u2191(\u22a4 : ConvexCone \ud835\udd5c E) = (univ : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood of infinity in the one-point compactification of a topological space X is equal to the union of the image of the collection of co-closed compact sets under the inclusion map and the set containing only infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhds_infty_eq : \ud835\udcdd (\u221e : OnePoint X) = map (\u2191) (coclosedCompact X) \u2294 pure \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the addition operation is associative for morphisms between objects in a category C. In simpler terms, if we have three morphisms (a, b, and c) between the same objects, then adding a to the sum of b and c is the same as adding the sum of a and b to c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_assoc {X Y : C} (a b c : X \u27f6 Y) : a + b + c = a + (b + c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of real numbers between any two distinct real numbers a and b is infinite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc.infinite : Infinite (Icc a b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\(s\\) and \\(t\\) which are subsets of a larger set, the preimage of set \\(t\\) under the inclusion map from \\(s\\) to the larger set is empty if and only if the intersection of sets \\(s\\) and \\(t\\) is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_coe_eq_empty {s t : Set \u03b1} : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t = \u2205 \u2194 s \u2229 t = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function from \\(A\\) to \\(\u03b2\\) that is already known to satisfy a certain property (represented by \\(n\\)). The function \\(mk\\) takes \\(f\\) and a proof \\(h\\) of this property as input and produces a new function from \\(A\\) to \\(\u03b2\\). Prove that the function produced by \\(mk\\) is actually the same as the original function \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_coe (f : A \u2192*[n] \u03b2) (h) : mk f h = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we take a path (a continuous curve) between two points and reparameterize it using the identity function, we get the same path back.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reparam_id (\u03b3 : Path x y) : \u03b3.reparam id continuous_id rfl rfl = \u03b3 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet M be a set with a binary operation and an identity element.  For elements a in M and invertible elements x, y in M, the element obtained by first applying the inverse of y, then the inverse of x, and finally conjugating by a is the same as first conjugating a by x and then by y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem units_inv_right_iff {a : M} {x y : M\u02e3} : SemiconjBy a \u2191x\u207b\u00b9 \u2191y\u207b\u00b9 \u2194 SemiconjBy a x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that reversing a pair formed by \"single\" results in a new pair with the elements swapped.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symm_single (a : \u03b1) (b : \u03b2) : (single a b).symm = single b a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn category theory, prove that the left unitor and right unitor are equal when applied to the identity morphism of an object in a monoidal category.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unitors_equal : (\u03bb_ (\ud835\udfd9 a)).hom = (\u03c1_ (\ud835\udfd9 a)).hom :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\(a\\) and natural numbers \\(m\\) and \\(n\\) where  \\(m \u2264 n\\),  \\(a^m * a^{(n-m)} = a^n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_mul_pow_sub (a : M) {m n : \u2115} (h : m \u2264 n) : a ^ m * a ^ (n - m) = a ^ n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a finite linear combination 'l' of elements from a set '\u03b9' with coefficients in a ring 'R'.  Given a specific element 'e' from '\u03b9', we can construct a dual basis element 'DualBases.lc e l'. This theorem states that if we extract the coefficients of this dual basis element using 'h.coeffs', we recover our original linear combination 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeffs_lc (l : \u03b9 \u2192\u2080 R) : h.coeffs (DualBases.lc e l) = l :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers *m* and *n*, *m* divides *n* if and only if *m* as an integer divides *n* as an integer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_nat_dvd {m n : \u2115} : (\u2191m : \u2124) \u2223 \u2191n \u2194 m \u2223 n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of a function plus a constant is equal to the derivative of the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fderiv_add_const (c : F) : fderiv \ud835\udd5c (fun y => f y + c) x = fderiv \ud835\udd5c f x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \u03c6 that maps elements from a set with an operation ^ (like repeated multiplication), prove that applying \u03c6 to the n-th power of an element x is the same as taking the n-th power of \u03c6(x).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_pow (x : A) (n : \u2115) : \u03c6 (x ^ n) = \u03c6 x ^ n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that scaling a ball of radius \u03b4 around the point 1 by a factor of 1/s is the same as taking a thickening of the point 1 with radius \u03b4/s.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_div_one : ball 1 \u03b4 / s = thickening \u03b4 s\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a function that maps elements from a set to itself.  Assume that for any element \\(x\\), \\(f(x)\\) is always less than or equal to \\(x\\). Prove that for any natural number \\(n\\), applying \\(f\\) repeatedly \\(n\\) times will result in a value less than or equal to the initial input.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iterate_le_id_of_le_id (h : f \u2264 id) (n : \u2115) : f^[n] \u2264 id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets, A and B, if we have two subsets of A, A1 and A2, such that A1 is a subset of A2, and two subsets of B, B1 and B2, such that B1 is a subset of B2, then the Cartesian product of A1 and B1 is a subset of the Cartesian product of A2 and B2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_mono : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) (@prod G _ N _) (@prod G _ N _) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'a' in a set 's' is a minimum point of a function 'f' over the set 's', then 'a' is also an extreme point of 'f' over 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element belongs to the symmetric difference of two sets if and only if it belongs to exactly one of the two sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_symmDiff : a \u2208 s \u2206 t \u2194 a \u2208 s \u2227 a \u2209 t \u2228 a \u2208 t \u2227 a \u2209 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three integers i, j, and k, the greatest common divisor (GCD) of the product of i and j and the product of i and k is equal to the product of the absolute value of i and the GCD of j and k.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gcd_mul_left (i j k : \u2124) : gcd (i * j) (i * k) = natAbs i * gcd j k :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of indices of non-zero coefficients of the zero polynomial is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_zero : (0 : R[X]).support = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a property `p` that holds for some positive natural number `m`, prove that the smallest positive natural number satisfying `p` (denoted by `PNat.find h`) is less than or equal to `m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem find_min' {m : \u2115+} (hm : p m) : PNat.find h \u2264 m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative number 'a' in the set of numbers of the form  x + y\u221ad, where x and y are integers and d is a fixed non-square integer, it can be expressed in one of the following forms:\n1. x + y\u221ad, where x and y are both natural numbers.\n2. x - y\u221ad, where x and y are both natural numbers.\n3. -x + y\u221ad, where x and y are both natural numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonneg_cases : \u2200 {a : \u2124\u221ad}, Nonneg a \u2192 \u2203 x y : \u2115, a = \u27e8x, y\u27e9 \u2228 a = \u27e8x, -y\u27e9 \u2228 a = \u27e8-x, y\u27e9\n   | \u27e8(x : \u2115), (y : \u2115)\u27e9, _ => \u27e8x, y, Or.inl rfl\u27e9\n   | \u27e8(x : \u2115), -[y+1]\u27e9, _ => \u27e8x, y + 1, Or.inr <| Or.inl rfl\u27e9\n   | \u27e8-[x+1], (y : \u2115)\u27e9, _ => \u27e8x + 1, y, Or.inr <| Or.inr rfl\u27e9\n   | \u27e8-[_+1], -[_+1]\u27e9, h => False.elim h\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any nonzero natural number `n`, taking the set of numbers from 0 to `n` and filtering it to keep only the divisors of `n` results in the same set as the set of divisors of `n`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem filter_dvd_eq_divisors (h : n \u2260 0) : (Finset.range n.succ).filter (\u00b7 \u2223 n) = n.divisors :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any real number 'r', a function 'p' that measures the size of elements in a space 'E' (like measuring the length of a vector), and an element 'x' in the space 'E', applying the scaled function '(r \u2022 p)' to 'x' is the same as scaling the result of applying 'p' to 'x' by 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r \u2022 p) x = r \u2022 p x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a scalar 's', and a matrix 'a' over some field '\ud835\udd5c' and set 'A', prove that scaling the matrix 'a' by 's' and then applying a transformation (represented by '.toProd') is the same as first applying the transformation to 'a' and then scaling the result by 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_toProd (s : S) (a : \ud835\udcdc(\ud835\udd5c, A)) : (s \u2022 a).toProd = s \u2022 a.toProd :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' has an upper bound, then the image of 's' under a function 'f' also has an upper bound.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_bddAbove : BddAbove s \u2192 BddAbove (f '' s)\n   | \u27e8C, hC\u27e9 => \u27e8f C, Hf.mem_upperBounds_image hC\u27e9\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a scenario where we are working with elements from a set '\u03b1' and we have a specific element 'p'. We can think of 'toIocMod hp' as an operation that takes two elements from '\u03b1' and gives us a new element, potentially modified based on 'hp' and 'p'. This theorem aims to prove that applying this operation on elements 'a' and 'b + m \u2022 p' yields the same result as applying it on 'a' and 'b', where 'm' is an integer and '\u2022' represents an operation between an integer and an element from '\u03b1'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIocMod_add_zsmul (a b : \u03b1) (m : \u2124) : toIocMod hp a (b + m \u2022 p) = toIocMod hp a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function \\( f \\) is differentiable on the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiableOn_empty : DifferentiableOn \ud835\udd5c f \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function \\( f \\) that maps elements from set \\( R \\) to set \\( S \\) while preserving some structure \\( M \\) (like addition or multiplication), then applying \\( f \\) directly is the same as first converting \\( f \\) into a regular function and then applying it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_fn_coe' (f : R \u2192+*[M] S) : \u21d1(f : R \u2192+[M] S) = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that the number of elements in a finite set containing 'n' natural numbers is equal to 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Fintype.card_fin (n : \u2115) : Fintype.card (Fin n) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the p-adic valuation of 1 is 0, for any prime number p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one : padicValNat p 1 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if you reverse a list twice, you get back the original list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem invRev_invRev : invRev (invRev L\u2081) = L\u2081 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two lists l\u2081 and l\u2082, if an element 'a' belongs to list l\u2081, then 'a' also belongs to the union of lists l\u2081 and l\u2082.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_union_left (h : a \u2208 l\u2081) (l\u2082 : List \u03b1) : a \u2208 l\u2081 \u222a l\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two functions, viewed as mere mappings from one set to another, are equal, then they are also equal when considered as specific constructions called \"subtypes.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective \u2983f g : \u03b1 \u2192\u209b \u03b2\u2984 (H : (f : \u03b1 \u2192 \u03b2) = g) : f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given two pairs, if the first pair is less than or equal to the second pair, then the second element of the first pair is less than or equal to the second element of the second pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_snd : Monotone (@Prod.snd \u03b1 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any proposition \\( p \\) that is decidable (meaning we can determine whether it is true or false), proving \\( p \\) is the same as evaluating the truth of  \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p \u2194 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any finite set 's' is measurable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Set.Finite.measurableSet {s : Set \u03b1} (hs : s.Finite) : MeasurableSet s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural numbers \\(b\\) and \\(n\\) where \\(b\\) is greater than 1 and \\(n\\) is not 0, prove that the logarithm base \\(b\\) of (\\(n\\) multiplied by \\(b\\)) is equal to the logarithm base \\(b\\) of \\(n\\) plus 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_mul_base {b n : \u2115} (hb : 1 < b) (hn : n \u2260 0) : log b (n * b) = log b n + 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the linear transformation represented by a matrix A to a vector v is the same as multiplying the matrix A with the vector v.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toLinear_apply (v : n \u2192 R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (\u2191A) v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number 'n', prove that calculating 'bit1 n' and then casting it to type 'R' is the same as first casting 'n' to type 'R' and then calculating 'bit1' of the result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_bit1 [AddMonoidWithOne R] (n : \u2115) : ((bit1 n : \u2115) : R) = bit1 (n : R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a family of sets {X_i} indexed by elements 'i' from a set 'I', and a function 'f' that takes an element 'i' from 'I' and returns a function from a set 'A' to the corresponding set X_i, prove that evaluating the function 'pi f' at an element 'a' from 'A' is the same as defining a new function that takes an element 'i' from 'I' and returns the result of applying the function f(i) to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_eval (f : \u2200 i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set `s` is a subset of another set `t` if and only if the nonempty interval represented by `s` is contained within the nonempty interval represented by `t`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_subset_coe : (s : Set \u03b1) \u2286 t \u2194 (s : NonemptyInterval \u03b1) \u2264 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function that adds a constant value 'a' to any input 'x', prove that the preimage of the open interval (b, c) under this function is equal to the open interval (b-a, c-a).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_const_add_Ioo : (fun x => a + x) \u207b\u00b9' Ioo b c = Ioo (b - a) (c - a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing duplicates from a multiset formed by adding an element 'a' to a multiset 's' is equivalent to adding 'a' to the multiset obtained by removing duplicates from 's', but only if 'a' is not already present in the de-duplicated version of 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dedup_cons {a : \u03b1} {s : Multiset \u03b1} : dedup (a ::\u2098 s) = ndinsert a (dedup s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `t`, the set product of the empty set and `t` is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem empty_smul : (\u2205 : Set \u03b1) \u2022 t = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a structure that preserves a specific operation (like addition or multiplication) and a specific element 'z', applying a function that essentially doesn't change the elements within this structure to 'z' will result in 'z' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_id (z : N) : f.map (fun y \u21a6 show MonoidHom.id M y \u2208 S from y.2) f z = z :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any type \\( \\alpha \\) and a type \\( \\beta \\) that has a smallest element (denoted as \\( \\bot \\)), applying the bottom infimum homomorphism (represented as \\( \\bot \\)) from \\( \\alpha \\) to \\( \\beta \\) to any element \\( a \\) of type \\( \\alpha \\) will always result in the smallest element (\\( \\bot \\)) of type  \\( \\beta \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_apply [Bot \u03b2] (a : \u03b1) : (\u22a5 : InfHom \u03b1 \u03b2) a = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(b\\) be an ultrafilter on a set \\(\\alpha\\). Prove that the preimage of the neighborhood filter of \\(b\\) under the function \\(pure\\) is a subset of \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter \u03b1) : comap pure (\ud835\udcdd b) \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `g` directly to a value `x` is equivalent to first packaging `x` into a constant function (represented by `C x`) and then evaluating it using a generalized evaluation function `aevalTower` with arbitrary arguments `g` and `y`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any cardinal numbers `a` and `b`, if `b` is not equal to 0 and `a` divides `b`, then `a` is less than or equal to `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_dvd : \u2200 {a b : Cardinal}, b \u2260 0 \u2192 a \u2223 b \u2192 a \u2264 b\n   | a, x, b0, \u27e8b, hab\u27e9 => by\n     simpa only [hab, mul_one] using\n       mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a given function 'e' is an isometry.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isometry : Isometry e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a list of characters `l`, the length of the string representation of `l` is equal to the length of `l`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem List.length_asString (l : List Char) : l.asString.length = l.length :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have two balls centered at the same point \\(x\\) with radii \\(\u03b5\u2081\\) and \\(\u03b5\u2082\\), and if \\(\u03b5\u2081\\) is less than or equal to \\(\u03b5\u2082\\), then the ball with radius \\(\u03b5\u2081\\) is entirely contained within the ball with radius \\(\u03b5\u2082\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_subset_ball (h : \u03b5\u2081 \u2264 \u03b5\u2082) : ball x \u03b5\u2081 \u2286 ball x \u03b5\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the restriction of any measure \u03bc to a singleton set {a} is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Measure.restrict_singleton' {a : \u03b1} : \u03bc.restrict {a} = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two integers, \\(z_1\\) and \\(z_2\\), are equal if and only if their residues modulo a prime number \\(p\\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_int_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\( f_0 \\) and \\( f_1 \\), and a continuous deformation (homotopy) \\( F \\) between them that preserves a property \\( P \\). Then, for any input \\( x \\), evaluating the homotopy \\( F \\) at the starting point of the deformation (represented by 0) yields the same result as applying the initial function \\( f_0 \\) to \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem apply_zero (F : HomotopyWith f\u2080 f\u2081 P) (x : X) : F (0, x) = f\u2080 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an ordered pair (x, y), where x is an element of a set with a multiplicative identity (denoted as 1) and y is an element of another set with a multiplicative identity (also denoted as 1), is equal to the ordered pair (1, 1) if and only if x equals 1 and y equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 \u2194 x = 1 \u2227 y = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers `n`, `m`, and `l`,  `l` belongs to the interval `[n, m)` if and only if `n \u2264 l` and `l < m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem {n m l : \u2115} : l \u2208 Ico n m \u2194 n \u2264 l \u2227 l < m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the limit superior of a sequence is always less than or equal to its supremum.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem limsup_le_iSup {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : limsup u f \u2264 \u2a06 n, u n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two ordered pairs, swapping the elements of the first pair results in the same ordered pair as swapping the elements of the second pair if and only if the two original pairs are the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_inj {p q : \u03b1 \u00d7 \u03b2} : swap p = swap q \u2194 p = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a vector space element to an element in its completion using the canonical linear isometry is equivalent to directly embedding the element into the completion.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toCompl\u2097\u1d62 : \u21d1(toCompl\u2097\u1d62 : E \u2192\u2097\u1d62[\ud835\udd5c] Completion E) = ((\u2191) : E \u2192 Completion E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet K and L be fields where K is a subfield of L. Let s represent an intermediate field between K and L. Prove that an element x of L belongs to the subalgebra generated by s if and only if x belongs to s itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x \u2208 s.toSubalgebra \u2194 x \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we construct a cone from a bicone, the apex of the cone will be the same as the apex of the original bicone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element \\( x \\) is a duplicate within a singleton set (a set containing only one element, \\( y \\)), then we have a contradiction (False).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Duplicate.elim_singleton {y : \u03b1} (h : x \u2208+ [y]) : False :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the entire space under any function is still the entire space.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_top (f : F) : comap f \u22a4 = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a non-negative extended real number x, when considered as a general extended real number, equals 1 if and only if x itself equals 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ennreal_eq_one {x : \u211d\u22650\u221e} : (x : EReal) = 1 \u2194 x = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) be an ultrafilter and \\( g \\) be a filter on a set \\( \u03b1 \\). Prove that if the infimum (greatest lower bound) of \\( f \\) and \\( g \\) is not the bottom element (the filter containing only the whole set \\( \u03b1 \\)), then \\( f \\) is a subset of \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_inf_neBot (f : Ultrafilter \u03b1) {g : Filter \u03b1} (hg : NeBot (\u2191f \u2293 g)) : \u2191f \u2264 g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) and \\(g\\) represent sets of vectors, and let \\(s\\) be a vector in \\(f\\) and \\(t\\) be a vector in \\(g\\). Prove that the vector difference \\(s - t\\) is an element of the set obtained by taking the difference of every vector in \\(f\\) with every vector in \\(g\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vsub_mem_vsub : s \u2208 f \u2192 t \u2208 g \u2192 s -\u1d65 t \u2208 f -\u1d65 g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if set  'a' is a subset of set 'b', then 'b' cannot be a strict subset of 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_ssubset_of_subset (h : a \u2286 b) : \u00acb \u2282 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all elements that, when multiplied by the inverse of \\( b \\), result in 1 is equal to the set containing only \\( b \\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_mul_right_one' : preimage 1 (\u00b7 * b\u207b\u00b9) ((mul_left_injective _).injOn _) = {b} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of two sets \\(s\\) and \\(t\\) is equal to the universal set (\u22a4) if and only if at least one of the sets \\(s\\) or \\(t\\) is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_eq_top : s \u00d7\u02e2 t = \u22a4 \u2194 s = \u22a4 \u2228 t = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nConsider a function 'x' that takes an index 'i' and returns a real number. This function represents a point in a multi-dimensional space, where each dimension is indexed by 'i'. Suppose we have another function 'a' that also takes an index 'i' and returns a real number, representing a point 'a' in the same multi-dimensional space. If for every index 'i', the value of 'a' at 'i' is strictly less than the value of 'x' at 'i', then the open box with lower bound 'a' is a neighborhood of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_Ioi_mem_nhds (ha : \u2200 i, a i < x i) : Ioi a \u2208 \ud835\udcdd x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Hamming norm of the zero vector is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hammingNorm_zero : hammingNorm (0 : \u2200 i, \u03b2 i) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing an element `a'` from a finite map `s` doesn't affect the result of looking up a different element `a` in the map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lookup_erase_ne {a a'} {s : Finmap \u03b2} (h : a \u2260 a') : lookup a (erase a' s) = lookup a s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the totient of 2 is equal to 1. (The totient of a number 'n', denoted as \u03c6(n), is the count of positive integers less than or equal to 'n' that are relatively prime to 'n', i.e., they share no common divisors other than 1).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem totient_two : \u03c6 2 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) belongs to the set generated by the ideal \\(I\\) if and only if \\(x\\) belongs to the ideal \\(I\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_ofPolynomial (x) : x \u2208 I.ofPolynomial \u2194 x \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' is a subset of the empty set, then 's' must also be the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_empty_of_subset_empty {s : Set \u03b1} : s \u2286 \u2205 \u2192 s = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a category with a strict initial object, any morphism from an object to the initial object is an isomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A \u27f6 I) : IsIso f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine we can form objects by combining objects of three types, \u03b1, \u03b2, and \u03b3. We can denote the combination of, say, 'a' of type \u03b1 and 'b' of type \u03b2 as either (a, b) or inr(a) depending on the context.  Prove that if we have an object 'c' of type \u03b3 and apply the inverse of the natural transformation that re-associates combinations of the three types, specifically for the case (c), we get back 'c'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vector `v`, converting it to a function using `get` and then back to a vector using `ofFn` results in the original vector `v`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofFn_get (v : Vector \u03b1 n) : ofFn (get v) = v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval (a, b] is non-empty if and only if a < b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_Ioc : (Ioc a b).Nonempty \u2194 a < b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the infimum distance between a point \\(x\\) and the closure of a set \\(s\\) is equal to the infimum distance between the point \\(x\\) and the original set \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infDist_closure : infDist x (closure s) = infDist x s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any valuation 'v', applying the 'toFun' operation to 'v' results in 'v' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element `a` of a type `\u03b1` with a top element added (denoted as `WithTop \u03b1`), `a` is less than or equal to the top element (`none`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_none {a : WithTop \u03b1} : @LE.le (WithTop \u03b1) _ a none :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( x \\) belongs to the complement of a set \\( s \\) if and only if \\( x \\) does not belong to the set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_compl : x \u2208 s\u1d9c \u2194 \u00acx \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive numbers a, b, c, and d, the fraction a/b is less than the fraction c/d if and only if the product of a and d is less than the product of c and b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_inv_lt_mul_inv_iff' : a * b\u207b\u00b9 < c * d\u207b\u00b9 \u2194 a * d < c * b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two distinct natural numbers \\( k \\) and \\( l \\), the sets of primitive roots of unity of orders \\( k \\) and \\( l \\)  in the complex numbers are disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint {k l : \u2115} (h : k \u2260 l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vectors x, y, and z in a vector space F, the inner product of x and the difference of y and z is equal to the difference between the inner product of x and y and the inner product of x and z.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inner_sub_right (x y z : F) : \u27eax, y - z\u27eb = \u27eax, y\u27eb - \u27eax, z\u27eb :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a vector space E over a field \ud835\udd5c, any open ball centered at the origin with radius r > 0 is an absorbent set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent \ud835\udd5c (ball p (0 : E) r) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the germ of the top element of a type with a top element is equal to the top element of the germ.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem const_top [Top \u03b2] : (\u2191(\u22a4 : \u03b2) : Germ l \u03b2) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two Lie ideals I and J of a Lie algebra L over a ring R such that I is a subset of J, prove that for any natural number k, the k-th derived ideal of I is a subset of the k-th derived ideal of J.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I \u2264 J) (k : \u2115) : D k I \u2264 D k J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a finite set 's' is not empty if and only if it's true that 's' is not equal to the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonempty_iff_ne_empty {s : Finset \u03b1} : s.Nonempty \u2194 s \u2260 \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero real number x, x is infinitesimal if and only if its inverse 1/x is infinite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infinitesimal_iff_infinite_inv {x : \u211d*} (h : x \u2260 0) : Infinitesimal x \u2194 Infinite x\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real number 1 belongs to the interval I, where I is defined as the set of all real numbers x such that 0 \u2264 x \u2264 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_mem : (1 : \u211d) \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the constant polynomial 1 is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem deg_one : (1 : NumDenSameDeg \ud835\udc9c x).deg = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that scaling a submonoid \\(S\\) by an element \\(a\\) and then viewing it as a set is the same as viewing the submonoid as a set first and then scaling each element by \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_pointwise_smul (a : \u03b1) (S : Submonoid M) : \u2191(a \u2022 S) = a \u2022 (S : Set M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that repeatedly multiplying by a number 'a' for 'n' times is equivalent to multiplying by 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_left_iterate : (a * \u00b7)^[n] = (a ^ n * \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number n greater than 0, n multiplied by the factorial of (n-1) is equal to the factorial of n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the p-adic norm of any non-zero p-adic number is a rational power of p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_values_discrete (a : PadicSeq p) (ha : \u00aca \u2248 0) : \u2203 z : \u2124, a.norm = (p : \u211a) ^ (-z) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet R be a set of numbers with multiplication and a special element \u03b5 (epsilon).  We can form \"dual numbers\" over R, written R[\u03b5], which are expressions of the form  'a + b\u03b5', where 'a' and 'b' belong to R.  Multiplication in R[\u03b5] works similarly to regular numbers, but with the additional rule that \u03b5\u00b2 = 0. Prove that for any 'r' in R, the dual number '0 + r\u03b5' is the same as multiplying 'r' by \u03b5.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r \u2022 \u03b5 : R[\u03b5]) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a polynomial function has a derivative at every point, and the value of the derivative at that point is equal to the evaluation of the derivative polynomial at that point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasDerivAt (x : \ud835\udd5c) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that, for any ordered ring, multiplying a non-positive number by a positive number results in a non-positive number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_nonpos {\u03b1} [OrderedRing \u03b1] {a b : \u03b1} (ha : a \u2264 0) (hb : 0 < b) : b * a \u2264 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, and c, if a is less than b, then c plus a is less than c plus b. Note that a, b and c are numbers of the form  x + y\u221ad, where x and y are integers, and d is a non-negative integer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_lt_add_left (a b : \u2124\u221ad) (h : a < b) (c) : c + a < c + b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any module \\(M\\) over a ring \\(R\\), if there exists a basis \\(b\\) for \\(M\\) indexed by a type \\(\u03b9\\), then \\(M\\) is a free module.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Module.Free.of_basis {\u03b9 : Type w} (b : Basis \u03b9 R M) : Module.Free R M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two multisets \\(s\\) and \\(t\\), prove that an element \\(a\\) belongs to the union of \\(s\\) and \\(t\\) if and only if \\(a\\) belongs to \\(s\\) or \\(a\\) belongs to \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_ndunion {s t : Multiset \u03b1} {a : \u03b1} : a \u2208 ndunion s t \u2194 a \u2208 s \u2228 a \u2208 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the extended real number system, adding any extended real number 'x' to negative infinity (\u22a5) always results in negative infinity (\u22a5).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_add (x : EReal) : \u22a5 + x = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a bag of objects (this is our set). We can add objects to the bag or take them out.  We have two such bags, 'S' and 'T'. We also have a special way to modify these bags using 'a', which acts like a multiplier. We can either multiply everything in a bag by 'a' or by its inverse, 'a\u207b\u00b9'.  The theorem states that:  Having every object from bag 'S' also exist in bag 'T' after multiplying 'T' by 'a' is the same as having every object from bag 'S', after being multiplied by 'a\u207b\u00b9', exist in the original bag 'T'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_pointwise_smul_iff {a : \u03b1} {S T : AddSubmonoid A} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a function 'h' that operates on sets, and we know that this function is \"monotone\". Monotone means that if you input a larger set into 'h', the resulting set will also be larger (or at least not smaller). Now, consider another function 'f' that produces a collection of sets. We're interested in comparing two ways of taking the intersection of sets generated by 'h':\n\n1.  **Method 1:** We first apply 'f' to get a collection of sets, then apply 'h' to each set in this collection, and finally take the intersection of all the resulting sets.\n2.  **Method 2:**  We directly take the intersection of all sets 's' in the collection produced by 'f', where each 's' is transformed by applying 'h'.\n\nProve that given 'h' is monotone, these two methods always produce the same result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInter_lift'_sets (hh : Monotone h) : \u22c2\u2080 { s | s \u2208 f.lift' h } = \u22c2 s \u2208 f, h s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a constant function between two ordered sets is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_const (x : \u03b2) : Continuous (OrderHom.const \u03b1 x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the zero element of the subtype of M, consisting of elements P where P is a linear projection on X, to an element of M itself, results in the zero element of M.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero : \u2191(0 : { P : M // IsLprojection X P }) = (0 : M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the trace of a zero matrix of size n x n is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trace_zero : trace (0 : Matrix n n R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a partition P of a graph G has no parts (i.e., the set of parts is empty), then the partition is a uniform partition with respect to any epsilon.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUniformOfEmpty (hP : P.parts = \u2205) : P.IsUniform G \u03b5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the highest power of \\( X \\) in the polynomial \\( X \\) itself is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_X_le : (X : R[X]).natDegree \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a category C and a presheaf P on C, applying a \"sheafification\" process to P results in a sheaf, denoted as J.sheafify P. This theorem states that if we have the identity map on the presheaf P, then applying the \"sheafification\" process to this identity map results in the identity map on the sheaf J.sheafify P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sheafifyMap_id (P : C\u1d52\u1d56 \u2964 D) : J.sheafifyMap (\ud835\udfd9 P) = \ud835\udfd9 (J.sheafify P) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a ring 'R', the basic open set generated by 'a' is indeed an open set in the Zariski topology on the set of prime ideals of 'R'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any square matrix `A` whose row and column indices come from a \"subsingleton\" type (a type with at most one element) is a diagonal matrix.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isDiag_of_subsingleton [Zero \u03b1] [Subsingleton n] (A : Matrix n n \u03b1) : A.IsDiag :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(E\\) and a positive real number \\( \\delta \\), the set of all points that are within a distance of \\( \\delta \\) from some point in \\( E \\) (this set is called the thickening of \\( E \\) by \\( \\delta \\)) is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_thickening {\u03b4 : \u211d} {E : Set \u03b1} : IsOpen (thickening \u03b4 E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural numbers M, N, and P, if M is less than or equal to N, then M multiplied by P is less than or equal to N multiplied by P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le_mul_left (h : M \u2264 N) : M * P \u2264 N * P :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number p, and any integer z that is greater than or equal to 0, z modulo p is equal to z when z is treated as an element of Z/p (the integers modulo p).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nat_cast_toNat (p : \u2115) : \u2200 {z : \u2124} (_h : 0 \u2264 z), (z.toNat : ZMod p) = z\n   | (n : \u2115), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat]\n   | Int.negSucc n, h => by simp at h\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of a nonempty set  's' and an infinite set 't' is also an infinite set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s \u00d7\u02e2 t).Infinite :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any vertex 'v' in a graph G, the set of neighbors of 'v' and the singleton set containing only 'v' are disjoint. In other words, a vertex 'v' cannot be its own neighbor.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two combinatorial games, \\(x\\) and \\(y\\), prove that either \\(x\\) is less than or equal to \\(y\\), or \\(y\\) is not less than or equal to \\(x\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_or_gf (x y : PGame) : x \u2264 y \u2228 y \u29cf x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two finite sets \\( s \\) and \\( t \\), prove that the number of elements in \\( s \\) that also belong to the intersection of \\( s \\) and \\( t \\) is equal to the number of elements in \\( s \\) that belong to \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s \u2229 t) = condCount s t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element \\( a \\) belongs to the intersection of two sets \\( l\u2081 \\) and \\( l\u2082 \\), then \\( a \\) belongs to the set \\( l\u2081 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_mem_inter_left : a \u2208 l\u2081 \u2229 l\u2082 \u2192 a \u2208 l\u2081 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of the function \\(f(x) = ax^2\\) is \\(f'(x) = 2ax\\), where 'a' is any real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any measure-preserving function \\( f \\) between measurable spaces and a natural number \\( n \\), applying \\( f \\) \\( n \\) times and then taking its equivalence class (with respect to the measure) is the same as first taking the equivalence class of \\( f \\) and then applying it \\( n \\) times.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_pow (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) (n : \u2115) : \u21d1(f ^ n) =\u1d50[\u03bc] (\u21d1f) ^ n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function 'l' to the least upper bound of two elements, a\u2081 and a\u2082, is the same as taking the least upper bound of the images of those elements under 'l'. In simpler terms, the function 'l' preserves the least upper bound operation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem l_sup : l (a\u2081 \u2294 a\u2082) = l a\u2081 \u2294 l a\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\( f \\) that preserves addition and multiplication between two fields \\( K \\) and \\( L \\) (meaning \\( f(a + b) = f(a) + f(b) \\) and \\( f(a \\cdot b) = f(a) \\cdot f(b) \\) ), and a subset \\( s \\) of \\( K \\), prove that the image of the closure of \\( s \\) under \\( f \\) is equal to the closure of the image of \\( s \\) under \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_field_closure (f : K \u2192+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that for any natural number `n` and any element `a` of type `Fin n` (which can be thought of as a natural number strictly less than `n`), if we consider `a` as an element of `Fin (n + 1)`, it is the same as applying the function `castSucc` to `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any derivation D, negating D and then converting it to a linear map is the same as converting D to a linear map and then negating it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_neg_linearMap (D : Derivation R A M) : \u2191(-D) = (-D : A \u2192\u2097[R] M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets 'a' and 'b', the set difference of the symmetric difference of 'a' and 'b' with 'a' is equal to the set difference of 'b' with 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symmDiff_sdiff_left : a \u2206 b \\ a = b \\ a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a pair of functions (f, g) to the components of a pair of elements from two sets is the same as applying f to the first element and g to the second element independently.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet 'f' and 'g' be two functions such that they are monotonic (meaning they preserve order) and operate on sets with some notion of order where we can talk about least upper bounds.  Prove that applying 'f' to the least fixed point of the combined function 'g' after 'f' is the same as finding the least fixed point of 'f' after 'g'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a combinatorial game, if the right player has no moves, then the game is a win for the left player or a draw.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three numbers 'r', 'a', and 'b', multiplying the interval between 'a' and 'b' by 'r' is the same as creating a new interval between 'r' times 'a' and 'r' times 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_Icc : r \u2022 Icc a b = Icc (r \u2022 a) (r \u2022 b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any sequence `u` and a constant `a`, the supremum of `a` and the limit inferior of `u` is equal to the limit inferior of the sequence whose elements are the supremum of `a` and each element of `u`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_liminf (a : \u03b1) : a \u2294 liminf u f = liminf (fun x => a \u2294 u x) f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finite_empty : (\u2205 : Set \u03b1).Finite :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of a family of trivial submodules over all indices in a set 's' is equal to the trivial submodule of the product of the entire family.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_top (s : Set \u03b9) : (pi s fun i : \u03b9 => (\u22a4 : Submodule R (\u03c6 i))) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the dual of a biconditional statement (a if and only if b) is equivalent to the exclusive disjunction (XOR) of the duals of the individual statements (dual of a XOR dual of b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toDual_bihimp : toDual (a \u21d4 b) = toDual a \u2206 toDual b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions, f' and f', and a limit point 'l', prove that if f' is not constantly zero around 'l', then f' is not little-o of itself at 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLittleO_irrefl' (h : \u2203\u1da0 x in l, \u2016f' x\u2016 \u2260 0) : \u00acf' =o[l] f' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a type \u03b1 equipped with a multiplication operation and an ordering relation, multiplication by positive elements on the right preserves order if and only if multiplication by positive elements on the left preserves order.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem posMulMono_iff_mulPosMono : PosMulMono \u03b1 \u2194 MulPosMono \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the zero power series is the zero power series.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_inv : (0 : MvPowerSeries \u03c3 k)\u207b\u00b9 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two fractions a and b, a + b is equal to b + a.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_comm : a + b = b + a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set 's', the edge density of a relation 'r' between 's' and an empty set is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem edgeDensity_empty_right (s : Finset \u03b1) : edgeDensity r s \u2205 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a basis 'e' and an orientation 'x', prove that if we adjust the orientation 'x' to the basis 'e' and then extract the orientation from the resulting basis, we will get back the original orientation 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\(0 < b < 1\\), the logarithm base \\(b\\) approaches negative infinity as its input approaches positive infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tendsto_logb_atTop_of_base_lt_one : Tendsto (logb b) atTop atBot :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the trailing zero in the polynomial representation of any constant 'a' is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two lists of sets, `as` and `bs`, where each set in `as` is a subset of the corresponding set in `bs`, prove that the set of all possible sequences formed by taking one element from each set in `as` is a subset of the set of all possible sequences formed by taking one element from each set in `bs`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sequence_mono : \u2200 as bs : List (Filter \u03b1), Forall\u2082 (\u00b7 \u2264 \u00b7) as bs \u2192 sequence as \u2264 sequence bs\n   | [], [], Forall\u2082.nil => le_rfl\n   | _::as, _::bs, Forall\u2082.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element belongs to a dependent function space (a generalization of a function) if and only if it satisfies the function's definition for every index in the index set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_pi : x \u2208 pi I p \u2194 \u2200 i \u2208 I, x i \u2208 p i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets 's' and 't', prove that the set of all possible quotients obtained by dividing an element of 's' by an element of 't' is non-empty if and only if both 's' and 't' are non-empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_nonempty : (s / t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval [a, b) is a measurable set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two properties, P and Q, and for any object 'x' and proof 'h', P(x, h) is true if and only if Q(x, h) is true. Prove that P(x, h) holds true for all 'x' and 'h' if and only if Q(x, h) holds true for all 'x' and 'h'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_congr (H : \u2200 x h, P x h \u2194 Q x h) : (\u2200 x h, P x h) \u2194 \u2200 x h, Q x h :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine function is differentiable for all real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiable_cos : Differentiable \u211d cos :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two vectors v\u2081 and v\u2082 in a vector space,  v\u2081 and v\u2082 are on the same ray if and only if their negations, -v\u2081 and -v\u2082, are also on the same ray.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equiv_neg_iff {v\u2081 v\u2082 : RayVector R M} : -v\u2081 \u2248 -v\u2082 \u2194 v\u2081 \u2248 v\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we represent a cyclic permutation as a list of elements, this list contains no duplicates.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nodup_toCycle (f : Perm \u03b1) (hf : IsCycle f) : (toCycle f hf).Nodup :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a finite set to a multiset and then back to a finite set results in the original set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_toFinset [DecidableEq \u03b1] (s : Finset \u03b1) : s.val.toFinset = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number `n` and any element `i` from a set of `n+1` elements, taking the elements strictly greater than `i` (within the set) is equivalent to considering the entire set excluding the element `i`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Fin.image_succAbove_univ {n : \u2115} (i : Fin (n + 1)) : univ.image i.succAbove = {i}\u1d9c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative extended real number \\( x \\), \\( x \\) is equal to infinity in the extended real number system if and only if \\( x \\) is equal to infinity in the non-negative extended real number system.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ennreal_eq_top_iff {x : \u211d\u22650\u221e} : (x : EReal) = \u22a4 \u2194 x = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the zero vector in any lp space is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_zero : \u2016(0 : lp E p)\u2016 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a semilinear isometry  'f' between vector spaces E and E\u2082, applying 'f' to a vector 'x' in E preserves its norm.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnnorm_map [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) (x : E) : \u2016f x\u2016\u208a = \u2016x\u2016\u208a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a set 'A', the range of the function that generates all integer multiples of 'a' is equal to the set of all integer multiples of 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function representation of the zero simple function is equal to the zero function almost everywhere (with respect to the measure \u03bc).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p \u03bc) =\u1d50[\u03bc] 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(s\\) and \\(p\\) be sets of vectors. Given that \\(s\\) is a subset of \\(p\\) and that \\(p\\) is a subset of the span of \\(s\\), prove that the span of \\(s\\) is equal to \\(p\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem span_eq_of_le (h\u2081 : s \u2286 p) (h\u2082 : p \u2264 span R s) : span R s = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a sequence `l` satisfies a relation `R` between consecutive elements (i.e., it forms a chain), then the sequence obtained by removing the first `n` elements from `l` also forms a chain under the same relation `R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Chain'.drop (h : Chain' R l) (n : \u2115) : Chain' R (drop n l) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a set of elements where a partial order is defined (meaning some elements can be compared as 'less than' or 'greater than', but not all pairs need to be comparable), prove that the following two statements are equivalent:\\\n  1.  \\( a \\) is not equal to \\( b \\) if and only if \\( a \\) is strictly less than \\( b \\).\n  2.  \\( a \\) is less than or equal to \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_iff_lt_iff_le [PartialOrder \u03b1] {a b : \u03b1} : (a \u2260 b \u2194 a < b) \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a non-zero element 'p' in a mathematical structure called a \"ring\" constructed from a \"direct limit\" of a system of rings G connected by maps 'f', prove that multiplying 'p' by its inverse results in the multiplicative identity element, 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p \u2260 0) : p * inv G f p = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet X, Y, and Z be finite sets, and let f be a function from X to Y and g be a function from Y to Z. Prove that for any element x in X, applying the composition of f and g to x is the same as applying g to the result of applying f to x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_apply {X Y Z : FintypeCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet G be a graph, and H be a subgraph of G. Prove that a vertex v is in the support of H if and only if there exists a vertex w such that v is adjacent to w in H.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_support (H : Subgraph G) {v : V} : v \u2208 H.support \u2194 \u2203 w, H.Adj v w :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(u\\), either \\(u\\) is empty or \\(u\\) is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_empty_or_nonempty (u : ZFSet) : u = \u2205 \u2228 u.Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a set where there's no smallest element and there's a notion of order, there's no upper bound for the entire set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unbounded_gt_univ [Preorder \u03b1] [NoBotOrder \u03b1] : Unbounded (\u00b7 > \u00b7) (@Set.univ \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to \"normalize\" objects.  This theorem states that a normalized object is associated with another object if and only if the original object (before normalization) is associated with that same other object.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normalize_associated_iff {x y : \u03b1} : Associated (normalize x) y \u2194 Associated x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(e\\) be a function, and let \\(s\\) and \\(t\\) be sets. If the image of \\(e\\) restricted to \\(s\\) is exactly \\(t\\), then the image of \\(e\\) restricted to the intersection of its domain and \\(s\\) is equal to the intersection of its range and \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_eq (h : e.IsImage s t) : e '' (e.source \u2229 s) = e.target \u2229 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a partially ordered set, given two elements a and b where a is a bottom element (i.e., smaller than or equal to every element) and b is smaller than or equal to a, prove that b is also a bottom element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsBot.mono (ha : IsBot a) (h : b \u2264 a) : IsBot b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real numbers \\( r \\) and \\( p \\) where \\( p \\) is not zero, \\( r \\) is less than the inverse of \\( p \\) if and only if the product of \\( r \\) and \\( p \\) is less than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_inv_iff_mul_lt {r p : \u211d\u22650} (h : p \u2260 0) : r < p\u207b\u00b9 \u2194 r * p < 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a singleton set (a set containing only one element) is totally disconnected.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number 'a' less than 1, the reciprocal of 'a' is greater than 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there exists a ring isomorphism between two rings R and S, then the homomorphism from R to S associated with this isomorphism preserves non-units, meaning it maps non-units in R to non-units in S.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLocalRingHom_of_iso {R S : CommRingCat} (f : R \u2245 S) : IsLocalRingHom f.hom :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\( a \\) less than or equal to 1 and any natural number \\( n \\), \\( a \\) raised to the power of \\( n \\) is also less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_le_one' {a : M} (H : a \u2264 1) (n : \u2115) : a ^ n \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a list \\(s\\) is a permutation of another list \\(t\\) if and only if \\(s\\) is equivalent to \\(t\\). Note that two lists are considered equivalent if one can be rearranged into the other.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_permutations {s t : List \u03b1} : s \u2208 permutations t \u2194 s ~ t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a', if 'a' is in a sequence 's\u2081', then 'a' is also in the sequence formed by appending another sequence 's\u2082' to 's\u2081'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_append_left {s\u2081 s\u2082 : WSeq \u03b1} {a : \u03b1} : a \u2208 s\u2081 \u2192 a \u2208 append s\u2081 s\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers \\(a\\), \\(b\\), and \\(c\\), the open interval from \\(a\\) to \\(c\\) is a subset of the union of the open interval from \\(a\\) to \\(b\\) and the closed interval from \\(b\\) to \\(c\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c \u2286 Ioc a b \u222a Icc b c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a sequence defined by the recurrence relation `y_{n+2} = a\u2081 * y_{n+1} + y_n`, prove that for any natural number `n`, `y_n` is congruent to `n` modulo 2.  Here, `a\u2081` is a fixed constant natural number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem yn_modEq_two : \u2200 n, yn a1 n \u2261 n [MOD 2]\n   | 0 => by rfl\n   | 1 => by simp; rfl\n   | n + 2 =>\n     (yn_modEq_two n).add_right_cancel <| by\n       rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n       exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three points a, b, and c in a normed vector space, a times c lies within a closed ball centered at (b times c) with radius r if and only if a lies within a closed ball centered at b with radius r.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_mem_closedBall_mul_iff {c : E} : a * c \u2208 closedBall (b * c) r \u2194 a \u2208 closedBall b r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions, \\(f\\) and \\(g\\), and a pair of elements \\(p\\), prove that applying \\(f\\) and \\(g\\) to the elements of \\(p\\) separately and then forming a new pair is the same as applying the combined function of \\(f\\) and \\(g\\) to the pair \\(p\\) directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Prod_map (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) (p : \u03b1 \u00d7 \u03b2) : Prod.map f g p = (f p.1, g p.2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' in a field, the square root of the square of its norm is equal to the norm of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sqrt_normSq_eq_norm (x : F) : sqrt (normSqF x) = \u2016x\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\( f \\) is an isometry. We assume that \\( f \\) is a function between two vector spaces equipped with a norm (a way of measuring the length of vectors), and that \\( f \\) has the property of being a linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isometry : Isometry f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( a \\), \\( b \\), and \\( c \\), the symmetric difference of \\( a \\) and \\( b \\) is equal to the symmetric difference of \\( c \\) and \\( b \\) if and only if \\( a \\) is equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symmDiff_left_inj : a \u2206 b = c \u2206 b \u2194 a = c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the greatest common divisor (GCD) of a multiset (a set where elements can appear multiple times) of numbers is 0 if and only if every number in the multiset is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gcd_eq_zero_iff (s : Multiset \u03b1) : s.gcd = 0 \u2194 \u2200 x : \u03b1, x \u2208 s \u2192 x = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the covering relation of the product of two partially ordered sets is equivalent to the box product of the covering relations of the individual sets.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasse_prod : hasse (\u03b1 \u00d7 \u03b2) = hasse \u03b1 \u25a1 hasse \u03b2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' and computation 's', applying the function 'f' to the result of the computation 's' terminates if and only if the computation 's' itself terminates.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem terminates_map_iff (f : \u03b1 \u2192 \u03b2) (s : Computation \u03b1) : Terminates (map f s) \u2194 Terminates s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two sets, 's' and 't', are separated by neighborhoods, then 's' and the closure of 't' are disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a specific operation called \"polar\" represented by 'Q', which takes two elements from a set 'M' and combines them in some way.  Prove that applying this \"polar\" operation with 'x' and the difference of 'y' and 'y'' is the same as first applying the \"polar\" operation with 'x' and 'y', then separately with 'x' and 'y'', and finally subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a mathematical structure (like a set with operations) and an element 'a' from this structure. Given two substructures S and T, prove that scaling the \"join\" of S and T by 'a' is the same as taking the \"join\" of the individually scaled substructures 'a \u2022 S' and 'a \u2022 T'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_sup (a : M) (S T : Subsemiring R) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of the union of two upper sets \\(s\\) and \\(t\\) is equal to the union of the complements of \\(s\\) and \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_sup (s t : UpperSet \u03b1) : (s \u2294 t).compl = s.compl \u2294 t.compl :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any element 'x' from a ring 'R', prove that the algebra homomorphism applied to 'x' results in zero if and only if 'x' itself is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 \u2194 x = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\(x\\) and \\(y\\) are equal, and \\(y\\) is an element of a set \\(s\\), then \\(x\\) is also an element of \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_eq_of_mem {x y : \u03b1} {s : Set \u03b1} (hx : x = y) (h : y \u2208 s) : x \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two real numbers, \\(x\\) and \\(y\\), prove that applying a conjugation operation three times, with a multiplication in between, is the same as swapping the order of \\(x\\) and \\(y\\) and applying the conjugation to the first element. Assume that applying the conjugation twice returns the original number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number \\(x\\) is irrational, then subtracting any rational number \\(q\\) from it results in another irrational number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_rat (h : Irrational x) : Irrational (x - q) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the range of a linear independent set of vectors is linearly independent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the closure of the range of indices is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem closure_range : closure (range \u03b9) = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a linear function has a derivative equal to its slope at any point within a set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasDerivWithinAt_lineMap : HasDerivWithinAt (lineMap a b) (b - a) s x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we convert an integer `n` to another type that supports integer conversion and then convert it to its dual representation, it remains the same integer `n`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toDual_intCast [IntCast \u03b1] (n : \u2124) : toDual (n : \u03b1) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the `aeval` function to a function `f` is equivalent to applying the `bind\u2081` function to `f`, where `f` is a function that maps from a type `\u03c3` to a multivariate polynomial `MvPolynomial \u03c4 R`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aeval_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : aeval f = bind\u2081 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the tangent of any integer multiple of  \u03c0 (pi) is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tan_nat_mul_pi (n : \u2115) : tan (n * \u03c0) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the zero measure to any set always results in zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_zero {_m : MeasurableSpace \u03b1} : \u21d1(0 : Measure \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets 's' and 't', converting 's' and 't' to Finsets and checking if the Finset of 's' is a subset of the Finset of 't' is equivalent to checking if the set 's' is a subset of the set 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toFinset_subset_toFinset : hs.toFinset \u2286 ht.toFinset \u2194 s \u2286 t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(f\\) be a morphism between objects \\(X\\) and \\(Y\\) in a category \\(C\\). Prove that if the induced morphism on the hom-sets, \\(Hom(A, X) \\to Hom(A, Y)\\) for all objects \\(A\\), is an isomorphism, then \\(f\\) itself is an isomorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isIso {X Y : C} (f : X \u27f6 Y) [IsIso (yoneda.map f)] : IsIso f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\( s \\) and \\( t \\), the set difference of \\( s \\) and \\( t \\) (\\( s \\setminus t \\)) is equal to the intersection of \\( s \\) and the complement of \\( t \\) (\\( s \\cap t^c \\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_eq_inter_compl (s t : Finset \u03b1) : s \\ t = s \u2229 t\u1d9c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the spanning homomorphism of any subgraph of a graph is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in the type of ordinals with the less than relation, the principal segment below the top element of the lift of the ordinal u+1 is equal to the type of all ordinals.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (\u00b7 < \u00b7) _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\(r\\) and any natural number \\(n\\), the product of  \\(r\\) and (-1) raised to the power of \\(n\\) equals zero if and only if \\(r\\) itself is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_neg_one_pow_eq_zero_iff {n : \u2115} {r : R} : r * (-1) ^ n = 0 \u2194 r = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\(x\\) and \\(s\\), if \\(x\\) is a subset of \\(s\\), then \\(x\\) is an element of the power set of \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_powerset {x s : Set \u03b1} (h : x \u2286 s) : x \u2208 \ud835\udcab s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two ideals I and J of a ring, where I is contained in J (I \u2264 J), their product ideal (I * J) is also contained in J (I * J \u2264 J).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le_left : I * J \u2264 J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of two intervals [a\u2081, b\u2081] and [a\u2082, b\u2082] is equal to the interval [(a\u2081 \u2294 a\u2082), (b\u2081 \u2293 b\u2082)], where \u2294 represents the maximum and \u2293 represents the minimum.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_inter_Ioc : Ioc a\u2081 b\u2081 \u2229 Ioc a\u2082 b\u2082 = Ioc (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) be a function from a set \\( \\alpha \\) to a set \\( \\beta \\) equipped with a measure \\( \\mu \\). Let \\( c \\) be an element of \\( \\beta \\). If \\( f(x) \\) is less than or equal to \\( c \\) for almost every \\( x \\) in \\( \\alpha \\) (with respect to the measure  \\( \\mu \\)), then the essential supremum of \\( f \\) with respect to \\( \\mu \\) is less than or equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem essSup_le_of_ae_le {f : \u03b1 \u2192 \u03b2} (c : \u03b2) (hf : f \u2264\u1d50[\u03bc] fun _ => c) : essSup f \u03bc \u2264 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n' greater than 1, the smallest factor of 'n' (excluding 1) satisfies the following properties:\n  1. It is greater than or equal to 2.\n  2. It divides 'n'.\n  3. For any other factor 'k' of 'n', if 'k' is greater than or equal to 2 and divides 'n', then the smallest factor of 'n' is less than or equal to 'k'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem minFac_has_prop {n : \u2115} (n1 : n \u2260 1) : minFacProp n (minFac n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the quotient of two functions, f divided by g, never approaches negative infinity, then the function f itself also never approaches negative infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem NeBot.of_div_left : (f / g).NeBot \u2192 f.NeBot :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the *(n+1)*th Fibonacci number squared plus the *n*th Fibonacci number squared is equal to the Fibonacci number at the index *(2n + 1)*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fib_bit0_succ (n : \u2115) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a function named \"f\" that takes two inputs, one of type '\u03b1' and another of type '\u03b2', and produces an output of type '\u03b3'. We also have a pair of values, let's call it 'x', which consists of one value of type '\u03b1' and one value of type '\u03b2'. This theorem states that applying a transformed version of 'f' to the pair 'x' is the same as applying 'f' to the individual components of 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem curry_symm_apply (f : \u03b1 \u2192o \u03b2 \u2192o \u03b3) (x : \u03b1 \u00d7 \u03b2) : curry.symm f x = f x.1 x.2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that  e^(\u03c0i) = -1, where 'e' is Euler's number, '\u03c0' is pi, and 'i' is the imaginary unit.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exp_pi_mul_I : exp (\u03c0 * I) = -1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers a, b, and c, a divides (b - c) if and only if a divides (c - b).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_sub_comm : a \u2223 b - c \u2194 a \u2223 c - b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number 'x' and any integer 'n', the tangent of (x + n\u03c0) is equal to the tangent of x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tan_add_int_mul_pi (x : \u211d) (n : \u2124) : tan (x + n * \u03c0) = tan x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer \\(z\\), the function that raises elements of a topological group \\(G\\) to the power of \\(z\\) is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_zpow : \u2200 z : \u2124, Continuous fun a : G => a ^ z\n   | Int.ofNat n => by simpa using continuous_pow n\n   | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any collection of sets \\(\u03b1'_i\\), each of which has a least upper bound (supremum), the supremum of two functions \\(f\\) and \\(g\\) (where \\(f(i)\\) and \\(g(i)\\) belong to \\(\u03b1'_i\\)) is equal to the function that returns the supremum of \\(f(i)\\) and \\(g(i)\\) for each \\(i\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_def [\u2200 i, Sup (\u03b1' i)] (f g : \u2200 i, \u03b1' i) : f \u2294 g = fun i => f i \u2294 g i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n', if we encode it using a unary representation and then decode it, we get back the original number 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unary_decode_encode_nat : \u2200 n, unaryDecodeNat (unaryEncodeNat n) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `l`, if a pair `x` is in the result of `revzip (powersetAux l)`, then the sum of the lengths of the elements in `x` is equal to the length of `l`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem revzip_powersetAux {l : List \u03b1} \u2983x\u2984 (h : x \u2208 revzip (powersetAux l)) : x.1 + x.2 = \u2191l :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\( f \\) that takes two arguments of types \\( m \\) and \\( n \\) and returns a value of type \\( \u03b1 \\), scaling the result of applying \\( f \\) to its arguments is equivalent to first scaling \\( f \\) and then applying it to its arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_of [SMul R \u03b1] (r : R) (f : m \u2192 n \u2192 \u03b1) : r \u2022 of f = of (r \u2022 f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any given type \u03b1, the natural mapping from the free ring generated by \u03b1 to the free commutative ring generated by \u03b1 is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_surjective : Surjective ((\u2191) : FreeRing \u03b1 \u2192 FreeCommRing \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' and a list 'l', the length of the list generated by 'scanl f a l' is always one more than the length of the original list 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem length_scanl : \u2200 a l, length (scanl f a l) = l.length + 1\n   | a, [] => rfl\n   | a, x :: l => by\n     rw [scanl, length_cons, length_cons, \u2190 succ_eq_add_one, congr_arg succ]\n     exact length_scanl _ _\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a bijective function 'e' between two sets \u03b1 and \u03b2, and a subset 's' of \u03b2, prove that if we first take the preimage of 's' under 'e' and then take the preimage of that resulting set under the inverse of 'e', we get back the original set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symm_preimage_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b2) : e.symm \u207b\u00b9' (e \u207b\u00b9' s) = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a way to combine two values, taken from sets we'll call 'm' and 'n', into a third value from a set called '\u03b1'. This combination is described by a rule, which we'll name 'f'.  Assume also that for every element in the set '\u03b1', there's a corresponding \"opposite\" element, represented by putting a '-' sign in front of it. We can think of 'of' as a way to apply this \"combination rule\" to 'f'.  Prove that applying 'of' to the \"opposite\" of 'f' is the same as finding the \"opposite\" of applying 'of' to 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_of [Neg \u03b1] (f : m \u2192 n \u2192 \u03b1) : -of f = of (-f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any sets \\(x\\), \\(y\\), and \\(z\\), prove that the set \\(x\\) with the elements of the set difference of \\(y\\) and \\(z\\) removed is equal to the union of the following two sets: the set difference of \\(x\\) and \\(y\\), and the intersection of \\(x\\), \\(y\\), and \\(z\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y \u2294 x \u2293 y \u2293 z :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set 's' of elements of type '\u03b1', the supremum of 's' is equal to the indexed supremum of 's' where each element is indexed by itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sSup_eq_iSup' (s : Set \u03b1) : sSup s = \u2a06 a : s, (a : \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-empty list, the head element of the list is contained in the optional head of the list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem head!_mem_head? [Inhabited \u03b1] : \u2200 {l : List \u03b1}, l \u2260 [] \u2192 head! l \u2208 head? l\n   | [], h => by contradiction\n   | a :: l, _ => rfl\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\( f' \\) and \\( f \\), and a set \\( s \\). If \\( f' \\) is a left inverse of \\( f \\) on the set \\( s \\), then composing \\( f' \\) with \\( f \\) acts like the identity function on \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' \u2218 f) id s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a mathematical structure with multiplication where every element has a multiplicative inverse, for any elements 'x' and 'y', the product of 'y', the inverse of 'x', and 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inverse_mul_cancel_right (x y : M\u2080) (h : IsUnit x) : y * inverse x * x = y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( a \\), \\( b \\), and \\( c \\), if \\( a \\) is disjoint from \\( b \\) and \\( a \\) is disjoint from \\( c \\), then \\( a \\) is disjoint from the union of \\( b \\) and \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b \u2294 c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets \\( s \\) and \\( t \\), if \\( s \\) is a finite set, then the set difference of \\( s \\) and \\( t \\) (denoted as \\( s \\setminus t \\)) is also finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Finite.diff {s : Set \u03b1} (hs : s.Finite) (t : Set \u03b1) : (s \\ t).Finite :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if you take a natural number, consider it as an integer, and then take its absolute value, you get the original natural number back.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_coe_nat (n : \u2115) : \u2016(n : \u2124)\u2016 = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(R\\) and \\(S\\) be sets with binary relations \\(\u03c6\\) and \\((map f \u03c6)\\) defined on them, respectively. Given a function \\(f\\) from \\(R\\) to \\(S\\), prove that if \\(\u03c6\\) is symmetric, then the relation \\((map f \u03c6)\\) is also symmetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map (h\u03c6 : IsSymmetric \u03c6) (f : R \u2192+* S) : IsSymmetric (map f \u03c6) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `t`, if 1 belongs to the set `t`, then the set resulting from multiplying every element in the universal set with every element in `t` is equal to the universal set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem univ_mul_of_one_mem (ht : (1 : \u03b1) \u2208 t) : univ * t = univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet F, K, and E be fields such that F \u2286 K \u2286 E. Prove that if the field extension E/F is separable, then the field extension K/F is also separable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isSeparable_tower_bot_of_isSeparable [h : IsSeparable F E] : IsSeparable F K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a finite-dimensional vector space V over a field K, the dimension of V considered as a finite set (finrank) is equal to the dimension of V considered as a vector space (Module.rank).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element belongs to the set underlying a finite set, then it also belongs to the finite set itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mem {s : Finset \u03b1} (x : (s : Set \u03b1)) : \u2191x \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two points x and y that have the same distance from the origin, prove that the distance from the origin to the midpoint of the line segment connecting x and y is strictly less than the distance from the origin to x if and only if x and y are not the same point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_midpoint_lt_iff (h : \u2016x\u2016 = \u2016y\u2016) : \u2016(1 / 2 : \u211d) \u2022 (x + y)\u2016 < \u2016x\u2016 \u2194 x \u2260 y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two injective functions (embeddings) are equal if and only if they agree on all arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff {\u03b1 \u03b2} {f g : Embedding \u03b1 \u03b2} : (\u2200 x, f x = g x) \u2194 f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a function 'f' which is injective, meaning it maps distinct elements to distinct elements. This function is used to transform the coefficients of a polynomial 'p'. The theorem states that the transformed polynomial 'p.map f' is equal to the zero polynomial if and only if the original polynomial 'p' itself is the zero polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 \u2194 p = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `equivToOpposite`, which maps an element to its opposite in the opposite type, is the same as the `op` function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equivToOpposite_coe : (equivToOpposite : \u03b1 \u2192 \u03b1\u1d52\u1d56) = op :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the `min` function, which takes the minimum of two elements, is left-commutative. In simpler terms, prove that when finding the minimum, it doesn't matter if we swap the first two arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem min_left_commutative : LeftCommutative (min : \u03b1 \u2192 \u03b1 \u2192 \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a circle with \\(n + 1\\) positions numbered from 0 to \\(n\\), and you have a pointer at a position \\(i\\). Prove that rotating the pointer one position clockwise results in the pointer being at position \\(i + 1\\), taking into account that position \\(n + 1\\) wraps around to position 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a structure 's' is nontrivial, then its inhabited infimum separation, denoted as 's.einfsep', is not infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep \u2260 \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing the elements of the union of two sets \\(t_1\\) and \\(t_2\\) from a set \\(s\\) is equivalent to removing the elements of  \\(t_1\\) from \\(s\\) and then taking the union of that result with the set difference of \\(s\\) and \\(t_2\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vsub_union : s -\u1d65 (t\u2081 \u222a t\u2082) = s -\u1d65 t\u2081 \u222a (s -\u1d65 t\u2082) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three real numbers x, y, and z, the absolute value of the difference between the minimum of x and z and the minimum of y and z is less than or equal to the absolute value of the difference between x and y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_inf_sub_inf_le_norm (x y z : \u03b1) : \u2016x \u2293 z - y \u2293 z\u2016 \u2264 \u2016x - y\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that lifting a value to the maximum of `v` and `u` within a universe of size `u` is the same as lifting it to level `v` within a universe of size `u`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element 'x' of a type with a distinguished element '1' is not equal to '1' if and only if there exists an element 'a' in the underlying type such that 'a', when viewed as an element of the type with '1', is equal to 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_one_iff_exists {x : WithOne \u03b1} : x \u2260 1 \u2194 \u2203 a : \u03b1, \u2191a = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse of the intersection of two submonoids S and T is equal to the intersection of the inverses of S and T.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_inf (S T : Submonoid G) : (S \u2293 T)\u207b\u00b9 = S\u207b\u00b9 \u2293 T\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of functions from a set \u03b1 to a set M, which are definable by the empty set, is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : ((\u22a5 : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a linear function from a vector space E to its field of scalars \ud835\udd5c into a seminorm is the same as taking the norm of the output of the function for any element in E.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toSeminorm {f : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c} : \u21d1f.toSeminorm = fun x => \u2016f x\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there is a surjective function from a set \\( \u03b1 \\) to a set \\( \u03b2 \\), then the cardinality (size) of \\( \u03b2 \\) is less than or equal to the cardinality of \\( \u03b1 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_le_of_surjective (f : \u03b1 \u2192 \u03b2) (h : Function.Surjective f) : card \u03b2 \u2264 card \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any group, conjugating an element 'h' by an element 'g' is the same as adding 'g' to 'h', and then adding the inverse of 'g'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two non-infinite hyperreal numbers x and y, the standard part of their product (x * y) is equal to the product of their individual standard parts.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem st_mul {x y : \u211d*} (hx : \u00acInfinite x) (hy : \u00acInfinite y) : st (x * y) = st x * st y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that addition on natural numbers can be defined as a primitive recursive function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number \\(a\\),  \\(a^2 < 1\\) if and only if \\(a < 1\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sq_lt_one_iff {a : R} (ha : 0 \u2264 a) : a ^ 2 < 1 \u2194 a < 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a fixed point 'p', adding 'p' to elements of a group 'G' using the group operation '+\u1d65' results in unique outputs. In other words, if 'a' and 'b' are elements of 'G', and 'a +\u1d65 p' equals 'b +\u1d65 p', then 'a' must equal 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem vadd_right_injective (p : P) : Function.Injective ((\u00b7 +\u1d65 p) : G \u2192 P) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets \\( s\u2081 \\), \\( s\u2082 \\), and \\( t \\), if \\( s\u2081 \\) is a subset of \\( s\u2082 \\), then the intersection of \\( s\u2081 \\) and \\( t \\) is a subset of the intersection of \\( s\u2082 \\) and \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infs_subset_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u22bc t \u2286 s\u2082 \u22bc t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' of a type '\u03b1', the preimage of the set of elements strictly greater than 'a' in 'WithBot \u03b1' under the injection from '\u03b1' to 'WithBot \u03b1' is equal to the set of elements strictly greater than 'a' in '\u03b1'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_coe_Ioi : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioi a = Ioi a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function `f`, if we know that `f` is equal to itself (which is always true), then the isomorphism between the kernels of `f` and `f` derived from this equality is simply the identity isomorphism on the kernel of `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' in a space 'E', applying a distance-preserving function 'f' to 'x' doesn't change its distance from the origin.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_map (x : E) : \u2016f x\u2016 = \u2016x\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number, its absolute value is equal to its corresponding non-negative real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nnabs_of_nonneg {x : \u211d} (h : 0 \u2264 x) : nnabs x = toNNReal x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any subset of a set is bounded by 0 (representing infinity) in the context of non-negative extended real numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem boundedBy_zero : boundedBy (0 : Set \u03b1 \u2192 \u211d\u22650\u221e) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a number 'a' and a non-zero number 'u', prove that dividing 'a' by 'u' and then multiplying the result by 'u' gives back 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem divp_mul_cancel (a : \u03b1) (u : \u03b1\u02e3) : a /\u209a u * u = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the largest open subgroup of a group G to an open set in G results in the entire group G itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toOpens_top : ((\u22a4 : OpenSubgroup G) : Opens G) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets S\u2081 and S\u2082, and a way to construct an element in S\u2082 from an element in S\u2081 (denoted by X), applying this construction to an element 'b' in S\u2081 is the same as applying it after embedding 'b' into the disjoint union of S\u2081 and S\u2082 using the left injection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iterToSum_X (b : S\u2081) : iterToSum R S\u2081 S\u2082 (X b) = X (Sum.inl b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a linear map *f* to a submodule *N* and then considering it as a submodule of the image space is the same as first considering *N* as a submodule of the original space and then applying *f* to it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M \u2192\u2097[R] M') :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the zero polynomial, when considered as a cubic polynomial, is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we can shift points in a space. Shifting a point by a vector 'v' and then shifting it by '-v' brings us back to the original point. This theorem states that this property holds true for a specific type of shift operation represented by `constVAdd`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem constVAdd_symm (v : V\u2081) : (constVAdd k P\u2081 v).symm = constVAdd k P\u2081 (-v) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that adding a single element `a` to a multiset `s` is the same as prepending `a` to the multiset `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_add (a : \u03b1) (s : Multiset \u03b1) : {a} + s = a ::\u2098 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set 's', the set difference between the empty set and 's' is the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem empty_sdiff (s : Finset \u03b1) : \u2205 \\ s = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) is congruent to 0 modulo a submodule \\(U\\) if and only if \\(x\\) is an element of \\(U\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero : x \u2261 0 [SMOD U] \u2194 x \u2208 U :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'n', the norm of 'n' when considered as an element of the quadratic integer ring \u2124\u221ad is equal to 'n' squared.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_nat_cast (n : \u2115) : norm (n : \u2124\u221ad) = n * n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set 's' of elements, the maximum element of 's' is the same as the supremum (least upper bound) of 's' when considering 's' as a set of its own elements.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem max_eq_sup_coe {s : Finset \u03b1} : s.max = s.sup (\u2191) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a real number \\(z\\) is not equal to 1 when considered as a complex number if and only if it is not equal to 1 when considered as a real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_ne_one {z : \u211d} : (z : \u2102) \u2260 1 \u2194 z \u2260 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set \\( \u03b1 \\) and a property \\( p \\) on \\( \u03b1 \\), prove that taking the image of the interval \\( Ioc \\, a \\, b \\) (a set containing all elements between \\( a \\) and \\( b \\) inclusive) under the embedding from the subset of elements satisfying \\( p \\) to the whole set \\( \u03b1 \\) is the same as intersecting the original interval with the subset defined by \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting the multiplicative identity element of a matrix ring to a product of elements always results in the multiplicative identity of the underlying field.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_toProd : (1 : \ud835\udcdc(\ud835\udd5c, A)).toProd = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'a' in a set M has an inverse (i.e., is a unit), then the unit element obtained from 'a' is equal to 'a' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unit_of_val_units {a : M\u02e3} (h : IsUnit (a : M)) : h.unit = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a way to divide elements of a type, prove that a singleton set containing only the element 'a' divided by a singleton set containing only the element 'b' results in a singleton set containing only the element 'a / b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_div_singleton (a b : \u03b1) : ({a} : Finset \u03b1) / {b} = {a / b} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets 's' and 't', the set 's' and the set difference of 't' and 's' are disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_sdiff : Disjoint s (t \\ s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any bijective function \\(e\\) from set \\(\u03b1\\) to set \\(\u03b2\\), composing \\(e\\) with its inverse function \\(e.symm\\) results in the identity function \\(id\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_comp_symm (e : \u03b1 \u2243 \u03b2) : e \u2218 e.symm = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the distance between any point and itself is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dist_self {v : V} : dist G v v = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two lists are permutations of each other, then applying the `powersetAux'` function to each list results in two new lists that are also permutations of each other.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem powerset_aux'_perm {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : powersetAux' l\u2081 ~ powersetAux' l\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a formal power series 'f' with coefficients in a ring 'R' and a scalar 'a' from the same ring, prove that scaling the series 'f' by 'a' is equivalent to multiplying 'f' by a constant series where every term is 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_eq_C_mul (f : MvPowerSeries \u03c3 R) (a : R) : a \u2022 f = C \u03c3 R a * f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the maximum element of a list `l` is `m`, then `m` must be an element of the list `l`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem maximum_mem {l : List \u03b1} {m : \u03b1} : (maximum l : WithTop \u03b1) = m \u2192 m \u2208 l :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all sets in the join of two filters, f and g, is equal to the intersection of the set of all sets in f and the set of all sets in g.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_sets_eq {f g : Filter \u03b1} : (f \u2294 g).sets = f.sets \u2229 g.sets :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two equal functions, \\( f \\) and \\( g \\), that map elements from a set \\(E\\) to a set \\(E_2\\), prove that for any element \\(x\\) in \\(E\\), applying \\(f\\) to \\(x\\) yields the same result as applying \\(g\\) to \\(x\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem congr_fun {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} (h : f = g) (x : E) : f x = g x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite maps,  's' and 't', if the list of key-value pairs in 's' is equal to the list of key-value pairs in 't', then 's' and 't' are the same finite map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext : \u2200 {s t : Finmap \u03b2}, s.entries = t.entries \u2192 s = t\n   | \u27e8l\u2081, h\u2081\u27e9, \u27e8l\u2082, _\u27e9, H => by congr\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there are two equivalent ways to represent a function in the space of p-integrable functions, Lp.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toLp_eq_toLp (f : \u03b1 \u2192\u209b E) (hf : Mem\u2112p f p \u03bc) : (toLp f hf : Lp E p \u03bc) = hf.toLp f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions,  if the output of the first function is always less than or equal to the output of the second function for any input, then applying both functions after another function will preserve this order.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_mono (h : m\u2081 \u2264 m\u2082) : m\u2081.comap g \u2264 m\u2082.comap g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real numbers \\( x \\) and \\( z \\), if \\( 1 \\le x \\) and \\( z \\le 0 \\), then \\( x ^ z \\le 1 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rpow_le_one_of_one_le_of_nonpos {x z : \u211d} (hx : 1 \u2264 x) (hz : z \u2264 0) : x ^ z \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet B be a group that acts on a set X. Let X' be the set obtained by adjoining a new element, denoted \"\u221e\", to X. The action of B on X can be extended to an action on X' by defining b \u2022 \u221e = \u221e for all b in B. Prove that for any elements b and b' in B, and any element x in X', the result of (b * b') acting on x is the same as the result of first letting b' act on x and then letting b act on the result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_smul (b b' : B) (x : X') : (b * b') \u2022 x = b \u2022 b' \u2022 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural numbers `m` and `n`, prove that the truncated subtraction of `n` from `m` equals some value `k` if and only if `k + n = m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem psub_eq_some {m : \u2115} : \u2200 {n k}, psub m n = some k \u2194 k + n = m\n   | 0, k => by simp [eq_comm]\n   | n + 1, k => by\n     apply Option.bind_eq_some.trans\n     simp only [psub_eq_some, ppred_eq_some]\n     simp [add_comm, add_left_comm, Nat.succ_eq_add_one]\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a list `l`, prove that the set of elements obtained by taking `l.getD n d` for all natural numbers `n` is equal to the set containing all elements of `l` and an additional element `d`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_list_getD (d : \u03b1) : (range fun n => l.getD n d) = insert d { x | x \u2208 l } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Laurent series representation of the constant rational function 1 is equal to the constant Laurent series 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_one : ((1 : RatFunc F) : LaurentSeries F) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that subtracting two real numbers and then converting the result to an angle is the same as converting both real numbers to angles first and then subtracting them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sub (x y : \u211d) : \u2191(x - y : \u211d) = (\u2191x - \u2191y : Angle) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the symmetrization of any binary relation V is a symmetric relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symmetric_symmetrizeRel (V : Set (\u03b1 \u00d7 \u03b1)) : SymmetricRel (symmetrizeRel V) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number \\(x\\), the hyperbolic tangent of \\(x\\) (tanh \\(x\\)) is equal to the hyperbolic sine of \\(x\\) (sinh \\(x\\)) divided by the hyperbolic cosine of \\(x\\) (cosh \\(x\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet M be a mathematical structure where elements have inverses (like nonzero numbers with multiplication). Let M\u02e3 represent the set of elements in M that have inverses.  We say that elements x and y in M\u02e3 are \"semiconjugate\" by an element 'a' in M if  a * x * a\u207b\u00b9 = y, where * denotes an operation (like multiplication) and a\u207b\u00b9 is the inverse of 'a'. Prove that x and y are semiconjugate by 'a' considered as an element of M if and only if they are semiconjugate by 'a' considered as an element of M\u02e3.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem units_val_iff {a x y : M\u02e3} : SemiconjBy (a : M) x y \u2194 SemiconjBy a x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the restriction of a measure \u03bc to a measurable set s, evaluated at another set t, is zero if and only if the measure \u03bc of the intersection of t and s is zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : \u03bc.restrict s t = 0 \u2194 \u03bc (t \u2229 s) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any stream 's', applying the identity function to each element of 's' using the 'pure' and '\u229b' operations results in the same stream 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem identity (s : Stream' \u03b1) : pure id \u229b s = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, c, and d, the sum of a and b lies strictly between c and d if and only if b lies strictly between c minus a and d minus a.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_mem_Ioo_iff_right : a + b \u2208 Set.Ioo c d \u2194 b \u2208 Set.Ioo (c - a) (d - a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the 1-norm of the inner product of two functions, f and g, is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snorm_inner_lt_top (f g : \u03b1 \u2192\u2082[\u03bc] E) : snorm (fun x : \u03b1 => \u27eaf x, g x\u27eb) 1 \u03bc < \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any self-adjoint element 'x' and any integer 'z', raising 'x' to the power of 'z' in the context of self-adjoint elements is equivalent to raising 'x' to the power of 'z' directly as a real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_zpow (x : selfAdjoint R) (z : \u2124) : \u2191(x ^ z) = (x : R) ^ z :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two bijective functions,  \\( f \\) and \\( g \\), from set \\( r \\) to set \\( s \\) have the property that for every element \\( x \\) in \\( r \\),  \\( f(x) = g(x) \\), then the functions \\( f \\) and \\( g \\) are the same function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext \u2983f g : r \u2243r s\u2984 (h : \u2200 x, f x = g x) : f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a non-zero polynomial 'f' with coefficients in a ring R, the root of 'f' is algebraic over R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isAlgebraic_root (hf : f \u2260 0) : IsAlgebraic R (root f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two sets 's' and 't', if 's' is a subset of 't' and 't' has a lower bound, then 's' also has a lower bound.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem BddBelow.mono \u2983s t : Set \u03b1\u2984 (h : s \u2286 t) : BddBelow t \u2192 BddBelow s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a function \u03a6 which takes a real number and outputs a vector. This theorem states that:  \u03a6 is differentiable at a point x if and only if each of its component functions is differentiable at x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem differentiableAt_pi : DifferentiableAt \ud835\udd5c \u03a6 x \u2194 \u2200 i, DifferentiableAt \ud835\udd5c (fun x => \u03a6 x i) x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is pairwise disjoint, meaning that there are no two distinct elements in the empty set that map to the same value under any function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pairwiseDisjoint_empty : (\u2205 : Set \u03b9).PairwiseDisjoint f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the second element of the product of two pairs is the same as taking a pair of the second elements of the original pairs.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_snd : (p.prod q).snd = (p.snd, q.snd) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any submodule \\(S\\) of an \\(R\\)-module \\(M\\), the set-theoretic representation of the negative of \\(S\\) is equal to the negative of the set-theoretic representation of \\(S\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_set_neg (S : Submodule R M) : \u2191(-S) = -(S : Set M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an integer 'n' has a multiplicative inverse (i.e., is a unit) if and only if its absolute value is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_iff_natAbs_eq {n : \u2124} : IsUnit n \u2194 n.natAbs = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a monoid M is finitely generated if and only if its additive counterpart, denoted as Additive M, is finitely generated as an additive monoid.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Monoid.fg_iff_add_fg : Monoid.FG M \u2194 AddMonoid.FG (Additive M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the argument function (arg) applied to the result of embedding a real number in the complex plane and then mapping it onto the unit circle using the exponential function (expMapCircle) has an inverse on the interval (-\u03c0, \u03c0).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem invOn_arg_expMapCircle : InvOn (arg \u2218 (\u2191)) expMapCircle (Ioc (-\u03c0) \u03c0) univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( A \\) be an integral domain and \\( K \\) be its field of fractions. Let \\( p(X) \\) be a polynomial with coefficients from  \\( A \\).  If \\( r \\) is a root of \\( p(X) \\) in  \\( K \\) (meaning \\( p(r) = 0 \\)), then the numerator of \\( r \\) divides the constant term of \\( p(X) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r \u2223 p.coeff 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any given function \\(f\\) that is a homomorphism between modules, taking the germ of the inverse function \\(f^{-1}\\) is equivalent to taking the inverse of the germ of the original function \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_toGerm (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : f\u207b\u00b9.toGerm = f.toGerm\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing all the \"empty\" elements from a set after transforming it by wrapping each element with \"Some\" results in the original set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eraseNone_map_some (s : Finset \u03b1) : eraseNone (s.map Embedding.some) = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( b \\) is in the set obtained by applying a function \\( f \\) to each element of a set \\( q \\) if and only if there exists an element \\( a \\) in the original set \\( q \\) such that \\( f(a) = b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_map (f : \u03b1 \u2192 \u03b2) (q : Semiquot \u03b1) (b : \u03b2) : b \u2208 map f q \u2194 \u2203 a, a \u2208 q \u2227 f a = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) that maps natural numbers to elements of a linearly ordered set \\( \u03b1 \\), if the function value decreases or stays the same as the input increases (i.e., \\( f(n + 1) \u2264 f(n) \\) for all natural numbers \\( n \\)), then the function is antitone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_nat_of_succ_le {f : \u2115 \u2192 \u03b1} (hf : \u2200 n, f (n + 1) \u2264 f n) : Antitone f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two pairs of sets, the first set of the first pair being disjoint from the first set of the second pair is equivalent to the two pairs being disjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_val : s.1.Disjoint t.1 \u2194 Disjoint s t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the mathematical constant \u03c0 (pi) is strictly less than 3.141593.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_lt_3141593 : \u03c0 < 3.141593 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a relation 'r' is well-founded on a set formed by adding an element 'a' to a set 's' if and only if the relation 'r' is well-founded on the set 's' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem wellFoundedOn_insert : WellFoundedOn (insert a s) r \u2194 WellFoundedOn s r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number 'a', if 'a' is not the smallest natural number, then the set of natural numbers less than or equal to the predecessor of 'a' is equal to the set of natural numbers strictly less than 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Iic_pred_of_not_isMin (ha : \u00acIsMin a) : Iic (pred a) = Iio a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the family of vectors consisting of the single function from the empty set to any vector space M is linearly independent over any field R.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (\u2205 : Set M) \u2192 M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any elements \\( a \\), \\( b \\), and \\( c \\) in a set with a certain order, the operation \\( \\sqcap \\) (which represents finding a lower bound) satisfies the following property: \\( a \\sqcap (b \\sqcap c) = b \\sqcap (a \\sqcap c) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_left_comm (a b c : \u03b1) : a \u2293 (b \u2293 c) = b \u2293 (a \u2293 c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a special function, denoted by 'f', that takes elements from a set A' and transforms them into elements of set B'. This function 'f' has a property: it preserves the structure of subtraction when applied. Prove that for any two elements 'x' and 'y' from set A', applying function 'f' to the difference of 'x' and 'y' is the same as applying 'f' to 'x' and 'y' separately and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_sub (f : A' \u2192+[M] B') (x y : A') : f (x - y) = f x - f y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any boolean value `a`, the negation of `a` being false is equivalent to `a` being true.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element belongs to the set of results computed by a computation `c` with input `n` if and only if there exists a step `k` at which that element is included in the set of results computed by `c` with input `n` up to step `k`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem evaln_complete {c n x} : x \u2208 eval c n \u2194 \u2203 k, x \u2208 evaln k c n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(F\\) be a set of sets.  If \\(x\\) and \\(y\\) are joined in \\(F\\), meaning they belong to a common set within \\(F\\), then prove that \\(y\\) and \\(x\\) are also joined in \\(F\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any functions \\( f \\) and \\( g \\), if there exists a constant \\( c \\) such that the absolute value of \\( f(x) \\) is always less than or equal to \\( c \\) times the absolute value of \\( g(x) \\), then \\( f(x) \\) is Big O of \\( g(x) \\) with constant \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBigOWith_of_le' (hfg : \u2200 x, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : IsBigOWith c l f g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine a small program that can be in one of two states: still running or halted with a final result. This program uses a special structure called a \"continuation\" (`k`) to keep track of what to do next after each step of execution. \n\nThe theorem asserts that if we take a step in our program where the step is a \"return\" step (`stepRet`), meaning it's about to halt and return a value (`v`), then evaluating this step will always lead to a halted program (`Cfg.halt`) containing the result of evaluating the continuation (`k.eval v`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `g` to the result of a constant function is the same as creating a new constant function that directly outputs the result of applying `g` to the original constant value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_const (g : \u03b2 \u2192 \u03b3) (b : \u03b2) : (const \u03b1 b).map g = const \u03b1 (g b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(K_1\\) and \\(K_2\\) be compact subsets of a group \\(G\\), and let \\(\\mu\\) represent a measure function. Prove that if \\(K_1\\) is a subset of \\(K_2\\), then the measure of \\(K_1\\) is less than or equal to the measure of \\(K_2\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mono (K\u2081 K\u2082 : Compacts G) (h : (K\u2081 : Set G) \u2286 K\u2082) : \u03bc K\u2081 \u2264 \u03bc K\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of the cosine function is the negative sine function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem hasDerivAt_cos (x : \u211d) : HasDerivAt cos (-sin x) x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a vector space E with a scalar field K, prove that the inner product of the zero vector (denoted as 0) in E with any vector x in E is equal to 0 (the zero element in the scalar field K).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inner_zero_left (x : E) : \u27ea0, x\u27eb = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the coefficient of the nth term in the polynomial representation of a constant 'a' is equal to 'a' if n is 0, and 0 otherwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number  \\( c \\), there exists a vector \\( x \\) in a normed vector space \\( E \\) such that the norm of \\( x \\) is equal to \\( c \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_norm_eq {c : \u211d} (hc : 0 \u2264 c) : \u2203 x : E, \u2016x\u2016 = c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any single-term polynomial (monomial) with a non-zero coefficient, the set of powers of the variable present in the monomial is a subset of the set containing only the monomial's exponent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem support_monomial' (n) (a : R) : (monomial n a).support \u2286 singleton n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a number x, considered as a real number, is not equal to zero if and only if x itself is not equal to zero. This might seem obvious, but we want to be careful about how we're thinking of x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ne_zero {x : I} : (x : \u211d) \u2260 0 \u2194 x \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set `S` of upper sets of a set `\u03b1`, the set representation of the infimum of `S` is equal to the union of the set representations of all elements in `S`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sInf (S : Set (UpperSet \u03b1)) : (\u2191(sInf S) : Set \u03b1) = \u22c3 s \u2208 S, \u2191s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the vertices of the intersection of a set of subgraphs is equal to the intersection of the vertices of each subgraph in the set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = \u22c2 G' \u2208 s, verts G' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that lifting a functor `F` to a higher level using `lift` and then composing it with the forgetful functor `functor r` results in the original functor `F`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift_spec : functor r \u22d9 lift r F H = F :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any module M over a ring R, taking the trace of the transpose of a linear map from M to itself is the same as taking the trace of the original linear map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trace_transpose : trace R (Module.Dual R M) \u2218\u2097 Module.Dual.transpose = trace R M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a square diagram `sq` that commutes (meaning that following any path along the arrows yields the same result) and has a lift, prove that composing the lift of `sq` with the arrow `p` is equal to the arrow `g`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fac_right [hsq : HasLift sq] : sq.lift \u226b p = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a finite set 's' to a sorted list and then back to a finite set results in the original set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sort_toFinset [DecidableEq \u03b1] (s : Finset \u03b1) : (sort r s).toFinset = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function `f` that takes an element of type `\u03b1` and returns an element of type `\u03b2`, and a sequence of elements of type `\u03b1`, applying `f` to each element in the sequence and collecting the results in a new sequence is the same as first lifting `f` to operate on sequences and then applying it to the sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_seq {f : \u03b1 \u2192 \u03b2} {x : FreeSemigroup \u03b1} : pure f <*> x = f <$> x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number x, 1 is less than the hyperbolic cosine of x (cosh x) if and only if x is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_lt_cosh : 1 < cosh x \u2194 x \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a pretopology K\u2081 is a subset of another pretopology K\u2082 if and only if K\u2081, when viewed as a function, is a subset of K\u2082 viewed as a function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_def {K\u2081 K\u2082 : Pretopology C} : K\u2081 \u2264 K\u2082 \u2194 (K\u2081 : \u2200 X : C, Set (Presieve X)) \u2264 K\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a balanced structure, if a subset G is a separator, then it is also a detector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G \u2192 IsDetector G :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval of all elements strictly between \\(a\\) and \\(b\\), when interpreted as a set, is the same as the set of all elements strictly between \\(a\\) and \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_Ioo (a b : \u03b1) : (Ioo a b : Set \u03b1) = Set.Ioo a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the algebra map for a ring R to an element r in the Hahn series with coefficients in A is the same as constructing a constant Hahn series whose value is the algebra map applied to r in A.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries \u0393 A) r = C (algebraMap R A r) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `Sum.inr` is a uniform embedding.  A uniform embedding is a function between metric spaces that preserves the distance between points, even when those points are considered within different subsets of the spaces.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : \u03b2 \u2192 \u03b1 \u2295 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the numerator of a rational number `q` is 0, then `q` itself is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zero_of_num_zero {q : \u211a} (hq : q.num = 0) : q = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any linear transformation \\( f \\) between vector spaces L\u2081 and L\u2082, the composition of the identity transformation on L\u2082 with \\( f \\) is equal to \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : (id : L\u2082 \u2192\u2097\u2045R\u2046 L\u2082).comp f = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero real number 'a',  a / a = 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_self {a : R} (a0 : a \u2260 0) : a / a = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number 'r', the absolute value of 'r' is equal to 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_of_nonneg (hr : 0 \u2264 r) : \u2016r\u2016 = r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two structures, P\u2081 and P\u2082, and a way to convert between them (a bijection 'e'). Additionally, assume we have two vector spaces, V\u2081 and V\u2082, over the same field 'k', along with a linear isomorphism 'e'' between them. Finally, let 'h' represent some property that holds between these structures. This theorem states that if we combine 'e', 'e'', and 'h' to create a new way to convert between P\u2081 and P\u2082 (denoted by \u27e8e, e', h\u27e9), then applying this new conversion is the same as just applying the original conversion 'e'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mk (e : P\u2081 \u2243 P\u2082) (e' : V\u2081 \u2243\u2097[k] V\u2082) (h) : ((\u27e8e, e', h\u27e9 : P\u2081 \u2243\u1d43[k] P\u2082) : P\u2081 \u2192 P\u2082) = e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three finite sets \\( s \\), \\( t \\), and \\( u \\), the union of \\( s \\) with the union of \\( t \\) and \\( u \\) is equal to the union of \\( s \\) with \\( t \\), then unioned with the union of \\( s \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_union_distrib_left (s t u : Finset \u03b1) : s \u222a (t \u222a u) = s \u222a t \u222a (s \u222a u) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s \\), \\( t \\), and \\( u \\), the union of these sets is associative. In other words, proving  \\( (s \\cup t) \\cup u = s \\cup (t \\cup u) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sups_assoc : s \u22bb t \u22bb u = s \u22bb (t \u22bb u) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have two functions, \\( f \\) and \\( g \\), and both \\( f \\) and \\( g \\) are bijective (a one-to-one and onto mapping), then the function formed by applying \\( f \\) to the first element of a pair and \\( g \\) to the second element of a pair is also bijective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\(b\\) (the base) and any real number \\(r\\), the ceiling of the logarithm of the inverse of \\(r\\) (i.e., \\(\\frac{1}{r}\\)) to base \\(b\\) is equal to the negative of the logarithm of \\(r\\) to the base \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem clog_inv (b : \u2115) (r : R) : clog b r\u207b\u00b9 = -log b r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' belonging to the Lp space (a space of functions with a specific bounded integral property), the 'snorm' of 'f' is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem snorm_lt_top (f : Lp E p \u03bc) : snorm f p \u03bc < \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a', the fractional part of 'a' is greater than or equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fract_nonneg (a : \u03b1) : 0 \u2264 fract a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\( n \\), the square root of (\\( n \\) squared) is equal to \\( n \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sqrt_eq' (n : \u2115) : sqrt (n ^ 2) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\( x \\) and \\( y \\) are nilpotent, then \\( x + y \\) is also nilpotent. (An element \\( x \\) is called nilpotent if there exists a natural number \\( k \\) such that \\( x^k = 0 \\).)\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element \\( a \\) and any two natural numbers \\( m \\) and \\( n \\), raising \\( a \\) to the power of \\( m \\) and then to the power of \\( n \\) is the same as raising \\( a \\) to the power of \\( n \\) and then to the power of \\( m \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_right_comm (a : M) (m n : \u2115) : (a ^ m) ^ n = (a ^ n) ^ m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a finite set \\(s\\) and a function \\(f\\) that assigns a number to each element of \\(s\\), prove that the square of the sum of all function values is less than or equal to the product of the number of elements in \\(s\\) and the sum of squares of all function values.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sq_sum_le_card_mul_sum_sq : (\u2211 i in s, f i) ^ 2 \u2264 s.card * \u2211 i in s, f i ^ 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomial 'f' with coefficients from a ring R, reversing the coefficients of the negation of 'f' is equivalent to negating the reversed polynomial of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the adjacency matrix of a graph is symmetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isSymm_adjMatrix [Zero \u03b1] [One \u03b1] : (G.adjMatrix \u03b1).IsSymm :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that reindexing a mathematical structure `b` using the identity function results in the same structure `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reindex_refl : b.reindex (Equiv.refl _) = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any metric space, a ball with radius 0 is always empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_zero : ball x 0 = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the zero polynomial is not separable over any nontrivial ring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_separable_zero [Nontrivial R] : \u00acSeparable (0 : R[X]) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a collection of sets, one for each index 'i'.  Let's call this collection 'F'. Each set in 'F' might contain different types of elements. We also have a function 'g' that picks an element from the set corresponding to each index 'i'.  Prove that 'g' picks an element from each set in 'F' if and only if for every index 'i', the element picked by 'g' for that index belongs to the corresponding set in 'F'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_pi {f : \u03a0\u2080 i, Finset (\u03b1 i)} {g : \u03a0\u2080 i, \u03b1 i} : g \u2208 f.pi \u2194 \u2200 i, g i \u2208 f i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the operation of converting a unitary matrix to a general linear matrix preserves matrix multiplication. In simpler terms, if we have two unitary matrices A and B, then converting their product AB to a general linear matrix is the same as converting A and B to general linear matrices individually and then multiplying them.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toGL_mul (A B : unitaryGroup n \u03b1) : toGL (A * B) = toGL A * toGL B :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any natural number `x`, when considered as an element of the extended natural numbers (`PartENat`), can never be equal to the largest extended natural number, denoted by `\u22a4` (pronounced \"top\").\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natCast_ne_top (x : \u2115) : (x : PartENat) \u2260 \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in the set of all elements of type '\u03b1' extended with a top element (\u22a4), the interval open on the right from 'a' to the top element is equal to the set containing all elements strictly greater than 'a' and the element 'None'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_coe_top : Ioc (a : WithTop \u03b1) \u22a4 = insertNone (Ioi a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there exists a bijective map (a one-to-one and onto relationship) between two sets \u03b1 and \u03b2, reversing this map twice results in the same bijective map.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toEquiv_symm (e : \u03b1 \u2243o \u03b2) : e.toEquiv.symm = e.symm.toEquiv :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a specific mathematical structure (where 'h' represents a base change), this theorem states that if we have a function 'g' and an element 'x', applying 'g' directly to 'x' yields the same result as first transforming 'x' using another function 'f' and then applying a transformed version of 'g' (denoted as 'h.lift g') to the transformed 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsBaseChange.lift_eq (g : M \u2192\u2097[R] Q) (x : M) : h.lift g (f x) = g x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a point 'x' lies on the sphere centered at 'y' with radius '\u03b5' if and only if the point 'y' lies on the sphere centered at 'x' with the same radius '\u03b5'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sphere_comm : x \u2208 sphere y \u03b5 \u2194 y \u2208 sphere x \u03b5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements `a` and `b` of a type `\u03b1` with a bottom element,  `Some a` is less than or equal to `Some b` if and only if `a` is less than or equal to `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem some_le_some : @LE.le (WithBot \u03b1) _ (Option.some a) (Option.some b) \u2194 a \u2264 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any numbers a, b, and c, prove that the set of numbers greater than or equal to a and strictly less than b, excluding those strictly greater than c, is the same as the set of numbers greater than or equal to a and strictly less than the smaller of b and c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which converts a function between spaces equipped with neighborhoods to a function between spaces equipped with uniform structures preserves the property of being \"inducing\".  A function is \"inducing\" if the preimage of an open set under this function is also an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inducing_coeFn : Inducing (UniformFun.ofFun \u2218 (\u21d1) : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d64 \u03b2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' and a set 's', an element 'b' belongs to the set 's' if and only if  'a \u2022 b' belongs to the set obtained by  'a \u2022 s' (which means multiplying each element of 's' by 'a').\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_mem_smul_finset_iff (a : \u03b1) : a \u2022 b \u2208 a \u2022 s \u2194 b \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a set with a least element (denoted as \u22a5), the minimum of two elements 'a' and 'b' is equal to the least element if and only if at least one of 'a' or 'b' is equal to the least element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem min_eq_bot [OrderBot \u03b1] {a b : \u03b1} : min a b = \u22a5 \u2194 a = \u22a5 \u2228 b = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number 'p' is prime, then its negation, '-p', is also prime.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Prime.neg {p : \u03b1} (hp : Prime p) : Prime (-p) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers a, b, and c, if a + c is less than b, then a is less than b - c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_tsub_of_add_lt_right : a + c < b \u2192 a < b - c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *k*, the radius of convergence of a power series *p* is less than or equal to the radius of convergence of the power series obtained by shifting the origin of *p* by *k* units.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_changeOriginSeries_radius (k : \u2115) : p.radius \u2264 (p.changeOriginSeries k).radius :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' is an element of a family of sets 'f', then 's' cannot be the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_empty_of_mem (hs : s \u2208 f) : s \u2260 \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\(f\\) and \\(g\\), that are equal. Prove that if we apply both functions to the same input value, \\(x\\), then the outputs of the two functions will also be equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem congr_fun {f g : \u03b1 \u2192+* \u03b2} (h : f = g) (x : \u03b1) : f x = g x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of a continuous function 'f' is equal to the least upper bound of the set of norms of all values of 'f(x)' where 'x' ranges over all possible inputs.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_eq_iSup_norm : \u2016f\u2016 = \u2a06 x : \u03b1, \u2016f x\u2016 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose \\(f\\) and \\(g\\) are two linear transformations from a vector space \\(L_1\\) to another vector space \\(L_2\\) over the same field \\(R\\). Prove that if \\(f(x) = g(x)\\) for all vectors \\(x\\) in \\(L_1\\), then the transformations \\(f\\) and \\(g\\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {f g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082} (h : \u2200 x, f x = g x) : f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two sets, \\(s\\) and \\(t\\), are disjoint if and only if every element in set \\(s\\) is different from every element in set \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjoint_iff_ne : Disjoint s t \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider two functions, 'g' and 'C', that operate on mathematical expressions. These expressions involve variables, addition, and multiplication.  The function 'aevalTower g y' takes such an expression and substitutes variables with specific values according to some rules based on 'g' and 'y'. The '.comp C' part means we first apply the function 'C' to the expression and then apply 'aevalTower g y' to the result. We want to prove that applying 'aevalTower g y .comp C' is the same as just applying 'g' directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aevalTower_comp_C : (aevalTower g y : MvPolynomial \u03c3 R \u2192+* A).comp C = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing a function `f` with the canonical embedding `\u03b9` and then lifting the result is the same as lifting `f` directly.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem \u03b9_comp_lift : lift R f \u2218 \u03b9 R = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\( \u03b1 \\) with the property that all its elements are equal (a \"subsingleton\" set), any finite subset \\( s \\) of \\( \u03b1 \\) has at most one element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_le_one_of_subsingleton [Subsingleton \u03b1] (s : Finset \u03b1) : s.card \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set containing only one point is always convex.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem convex_singleton (c : E) : Convex \ud835\udd5c ({c} : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\) and natural number \\( n \\), converting the product of \\( n \\) and \\( x \\) to an extended non-negative real number is the same as converting \\( x \\) to an extended non-negative real number first and then multiplying by \\( n \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ofReal_nsmul {x : \u211d} {n : \u2115} : ENNReal.ofReal (n \u2022 x) = n \u2022 ENNReal.ofReal x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two multisets (like sets where elements can be repeated) 's' and 't', and a function 'f', prove that if 's' is strictly a subset of 't' (meaning 's' is a subset of 't' and not equal to 't'), then the multiset obtained by applying 'f' to each element of 's' is also strictly a subset of the multiset obtained by applying 'f' to each element of 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_lt_map {f : \u03b1 \u2192 \u03b2} {s t : Multiset \u03b1} (h : s < t) : s.map f < t.map f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `s`, the length of the list `-s` (which is `s` negated) is equal to the length of the original list `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem length_neg : (-s).length = s.length :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood filter operation (which, for any point, gives you the collection of all its neighborhoods) is monotone. In simpler terms, we need to show that if a set  'A' is a subset of another set 'B', then every neighborhood of 'A' is also a neighborhood of 'B'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem monotone_nhds : Monotone (\ud835\udcdd : Filter \u03b1 \u2192 Filter (Filter \u03b1)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the 'unpair' operation to the number 0 results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unpair_zero : unpair 0 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a permutation congruence based on the identity permutation is the same as the identity permutation itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a non-empty index set, the norm of a function `f` is less than or equal to a real number `r` if and only if the norm of `f` applied to each element in the index set is less than or equal to `r`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pi_norm_le_iff_of_nonempty' [Nonempty \u03b9] : \u2016f\u2016 \u2264 r \u2194 \u2200 b, \u2016f b\u2016 \u2264 r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type of elements \u03b1, a specific element 'a' of type \u03b1, a natural number 'n', and a list of elements of type \u03b1 denoted by 'l', the following two statements are equivalent:\n\n1. A list containing 'n' copies of the element 'a' is a subsequence of the list 'l'.\n2. A list containing 'n' copies of the element 'a' is a subpermutation of the list 'l'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem replicate_le_coe {a : \u03b1} {n} {l : List \u03b1} : replicate n a \u2264 l \u2194 List.replicate n a <+ l :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the predecessor function, which returns the previous natural number (or 0 if the input is 0), is a partial recursive function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ppred : Partrec fun n => ppred n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element 'b' belongs to the multiset 's' after an element 'a' has been removed from it, then 'b' must have also been in the original multiset 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_mem_erase : b \u2208 erase s a \u2192 b \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the minimal polynomial of a linear transformation represented by matrix M is equal to the minimal polynomial of the matrix M itself, given that there's a way to represent the linear transformation as a matrix.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the degree of the polynomial \"X + c\" is always 1, where X is a variable and c is any real number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have numbers of the form  a + b\u221ad, where 'a' and 'b' are integers, and 'd' is a fixed non-negative integer. We can add and multiply these numbers. The problem is to prove that when you multiply two such numbers, the \"real part\" of the result (the part without the \u221ad) can be calculated by a specific formula: (a\u2081 + b\u2081\u221ad) * (a\u2082 + b\u2082\u221ad) = (a\u2081a\u2082 + db\u2081b\u2082) + (a\u2081b\u2082 + a\u2082b\u2081)\u221ad.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_re (z w : \u2124\u221ad) : (z * w).re = z.re * w.re + d * z.im * w.im :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse hyperbolic sine function (arsinh) is a bijective function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arsinh_bijective : Bijective arsinh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) has a derivative at a point \\( x \\), then \\( f \\) is continuous at \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any continuously differentiable bump function 'f', the outer radius of its bump is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a finite set of variables \u03c3 and interpretations of these variables, the range of evaluating polynomials (with coefficients in K) over all possible interpretations of variables outside \u03c3 is the set of all polynomials.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem range_eval\u1d62 [Finite \u03c3] : range (eval\u1d62 \u03c3 K) = \u22a4 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any function 'f' that takes a pair of values (one from set \u03b1 and one from set \u03b2) and returns a value in set \u03b3, applying the curried version of 'f' to values 'x' from set \u03b1 and 'y' from set \u03b2 is the same as applying the original function 'f' to the pair (x, y).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem curry_apply (f : \u03b1 \u00d7 \u03b2 \u2192o \u03b3) (x : \u03b1) (y : \u03b2) : curry f x y = f (x, y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set U is open and has a measure of zero, then the set U must be empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h\u2080 : \u03bc U = 0) : U = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the square of any natural number is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem asq_pos : 0 < a * a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property P that applies to the types \"Top\" and natural numbers, if P holds for \"Top\" and P holds for all natural numbers, then P holds for any \"PartENat\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem casesOn {P : PartENat \u2192 Prop} : \u2200 a : PartENat, P \u22a4 \u2192 (\u2200 n : \u2115, P n) \u2192 P a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a boolean value to a ring element and then back is the same as the original boolean value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toBoolRing_symm_eq : (@toBoolRing \u03b1).symm = ofBoolRing :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two finite sets \\( s\u2081 \\) and \\( s\u2082 \\),  \\( s\u2082 \\) is a subset of the union of \\( s\u2081 \\) and \\( s\u2082 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset_union_right (s\u2081 s\u2082 : Finset \u03b1) : s\u2082 \u2286 s\u2081 \u222a s\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any subgraph G' of a graph G, and any vertex 'v' in G', the neighbor set of 'v' in G' is a subset of the vertices of G'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v \u2286 G'.verts :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s \\), \\( t \\), and \\( u \\), the union of \\( s \\) with the union of \\( t \\) and \\( u \\) is equal to the union of \\( s \\) and \\( t \\), unioned with the union of \\( s \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem union_union_distrib_left (s t u : Set \u03b1) : s \u222a (t \u222a u) = s \u222a t \u222a (s \u222a u) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements \\( a \\) and \\( b \\) in a lattice, the greatest lower bound of \\( a \\) and the least upper bound of \\( a \\) and \\( b \\) is equal to \\( b \\) if and only if \\( b \\) is equal to the greatest lower bound of \\( a \\) and \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_inf_bihimp : (a \u2294 b) \u2293 a \u21d4 b = a \u2293 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers x and y, the inverse hyperbolic sine of x is less than the inverse hyperbolic sine of y if and only if x is less than y.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arsinh_lt_arsinh : arsinh x < arsinh y \u2194 x < y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all positive real numbers \\(r\\) such that \\(x\\) belongs to the set \\(r \\cdot s\\) (where \\(s\\) is a set of real numbers) is bounded below.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem gauge_set_bddBelow : BddBelow { r : \u211d | 0 < r \u2227 x \u2208 r \u2022 s } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element x belongs to the span of a singleton set containing element y if and only if y divides x (where x and y are elements of some type \u03b1).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_span_singleton {x y : \u03b1} : x \u2208 span ({y} : Set \u03b1) \u2194 y \u2223 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of open intervals of the form  $(x, \u221e)$, where $x$ is a real number, forms a neighborhood basis for the element $\u221e$ in the extended real line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhds_top_basis : (\ud835\udcdd (\u22a4 : EReal)).HasBasis (fun _ : \u211d \u21a6 True) (Ioi \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function 'f' is integrable over the union of two sets 's' and 't' with respect to a measure '\u03bc' if and only if 'f' is integrable over both 's' and 't' individually with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem integrableOn_union : IntegrableOn f (s \u222a t) \u03bc \u2194 IntegrableOn f s \u03bc \u2227 IntegrableOn f t \u03bc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a relation \\(r\\) is well-founded on a set \\(t\\), then it's also well-founded on any subset \\(s\\) of \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subset (h : t.WellFoundedOn r) (hst : s \u2286 t) : s.WellFoundedOn r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a set with multiplication and multiplicative inverses, for any element 'y' and any invertible element 'x', the product of 'y', 'x', and the inverse of 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_inverse_cancel_right (x y : M\u2080) (h : IsUnit x) : y * x * inverse x = y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any set of real numbers (R), there exists at least one prime number.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_prime : \u2203 \u03d6 : R, Prime \u03d6 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is injective, then the function `map f` is also injective. Note that `map f` applies the function `f` to each element of a list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_injective_of_injective : Function.Injective (map f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any type \u03b1, applying the `pure` function to the element `1` of type \u03b1 results in the element `1` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_one : pure (1 : \u03b1) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose there is an operation called \"K'.elim\" that takes four arguments (a, b, c, d) and returns a function. This function represents a system with a component called \"main\". This system also has an \"update\" operation that can change the value of \"main\". Prove that updating the \"main\" component of the system (represented by the function K'.elim a b c d) to a new value a' is the same as creating a new system with \"main\" initialized to a' and the other components (b, c, d) remaining the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two real numbers, \\( x \\) and \\( y \\), are both elements of a set \\( I \\) that is closed under multiplication and where \\( 0 \\le x \\le 1 \\) and \\( y \\le 1 \\) for all \\( x, y \\in I \\), then their product, \\( x * y \\), is also an element of \\( I \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_mem {x y : \u211d} (hx : x \u2208 I) (hy : y \u2208 I) : x * y \u2208 I :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any ordinal number \\(a\\), adding 1 to it results in the successor of \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nadd_one : a \u266f 1 = succ a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two functions, 'f' and 'g', prove that when we construct a specific mathematical structure (called a \"pullback cone\") based on these functions and then extract a component (denoted by '\u03c0') from this structure, applying this component to a special element (called \"none\") results in the function 'f' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pullbackConeOfRightIso_\u03c0_app_none : (pullbackConeOfRightIso f g).\u03c0.app none = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a polynomial *p*, a value *a* is a root of *p* if and only if dividing *p* by (*X - a*) and then multiplying by (*X - a*) results in the original polynomial *p*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p \u2194 IsRoot p a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the partial derivative of the constant multivariate polynomial \"1\" with respect to any variable is always zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pderiv_one {i : \u03c3} : pderiv i (1 : MvPolynomial \u03c3 R) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets 's' and 't', and an element 'a' that belongs to set 's', prove that the set obtained by taking the union of 'a' with each element of 't' is a subset of either 's' or 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_subset_sups_right : a \u2208 s \u2192 (\u00b7 \u2294 \u00b7) a '' t \u2286 s \u22bb t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an infinite stream consisting only of the element 'a' is equivalent to a stream constructed by prepending 'a' to the same infinite stream.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem const_eq (a : \u03b1) : const a = a::const a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the symmetric difference of the empty set and any set 'a' is equal to the set 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_symmDiff : \u22a5 \u2206 a = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers 'a' and 'b' where 'a' is strictly less than 'b', the neighborhood of 'a' within the open interval (a, b) is equal to the neighborhood of 'a' for all values greater than 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ioo a b] a = \ud835\udcdd[>] a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any two sets \\(x\\) and \\(y\\), the union of the set difference of \\(y\\) and \\(x\\) with \\(x\\) is equal to the union of \\(y\\) and \\(x\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_sup_self' : y \\ x \u2294 x = y \u2294 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the neighborhood system of infinity in the extended rational numbers (\u211d \u222a {\u221e}) is not countably generated.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_countably_generated_nhds_infty_opc : \u00acIsCountablyGenerated (\ud835\udcdd (\u221e : \u211a\u221e)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integers a and b, where a \u2264 b, inserting b into the set of integers from a (inclusive) to b (exclusive) results in the set of integers from a (inclusive) to b (inclusive).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_insert_right (h : a \u2264 b) : insert b (Ico a b) = Icc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a computational process `evaln` that takes as input a fuel limit `k`, a command `c`, an initial value `n`, and returns a set of possible output values `x`. Prove that if the fuel limit `k\u2081` is less than or equal to another fuel limit `k\u2082`, and a value `x` is a possible output of `evaln` with fuel limit `k\u2081`, then `x` is also a possible output of `evaln` with fuel limit `k\u2082`. In simpler words, increasing the fuel limit of a computation can only produce more possible output values, not fewer.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem evaln_mono : \u2200 {k\u2081 k\u2082 c n x}, k\u2081 \u2264 k\u2082 \u2192 x \u2208 evaln k\u2081 c n \u2192 x \u2208 evaln k\u2082 c n\n   | 0, k\u2082, c, n, x, _, h => by simp [evaln] at h\n   | k + 1, k\u2082 + 1, c, n, x, hl, h => by\n     have hl' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'f' that takes elements from a set '\u03b2' and returns numbers, and a one-to-one correspondence 'e' between two sets '\u03b3' and '\u03b2', prove that the sum of 'f' over all elements in '\u03b2' exists if and only if the sum of 'f \u2218 e' over all elements in '\u03b3' exists.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Equiv.summable_iff (e : \u03b3 \u2243 \u03b2) : Summable (f \u2218 e) \u2194 Summable f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is strictly monotonic, then applying `f` to each element of a strictly increasing sequence preserves the strict ordering of the sequence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_strictMono (f : \u03b1 \u2192 \u03b2) : StrictMono (map f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(G\\) be a topological group. Prove that for any fixed element \\(g\\) in \\(G\\), the function that conjugates an element \\(h\\) by \\(g\\) (i.e., maps \\(h\\) to \\(g * h * g^{-1}\\)) is a continuous function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number k, the expression ((2 * k + 1) / (2 * k + 2)) * (\u03c0 / 2) is less than or equal to W(k), where W(k) represents Wallis's product up to k terms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_W (k : \u2115) : ((2 : \u211d) * k + 1) / (2 * k + 2) * (\u03c0 / 2) \u2264 W k :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set  \\(s\\) and element \\(a\\), if \\(a\\) is an upper bound of \\(s\\), then the least upper bound (supremum) of \\(s\\) is less than or equal to \\(a\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem csSup_le' {s : Set \u03b1} {a : \u03b1} (h : a \u2208 upperBounds s) : sSup s \u2264 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\( \\sigma \\) and a set \\( A \\), prove that applying \\( \\sigma \\) to the set of all elements reachable from an element \\( a \\) in \\( A \\) is the same as the set of all elements reachable from \\( \\sigma(a) \\) in the image of \\( \\sigma \\) applied to \\( A \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_star (a : A) : \u03c3 (star a) = star (\u03c3 a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if x and y are self-adjoint, then their sum (x + y) is also self-adjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the index of a subgroup H in itself is always 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem relindex_self : H.relindex H = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set M of elements from a ring R, prove that the subsemiring generated by M (denoted M.subsemiringClosure) is equal to the smallest subsemiring of R containing M (denoted Subsemiring.closure M).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any sets `a`, `b`, and `c`, if `a` is a subset of `b`, then the set difference between `c` and `b` is a subset of the set difference between `c` and `a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_le_sdiff_left (h : a \u2264 b) : c \\ b \u2264 c \\ a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers \\( a \\) and \\( b \\), if we subtract \\( a \\) from \\( b \\), divide the result by \\( p \\), and then add \\( a \\) back, the final result will always fall within the interval starting at \\( a \\) and ending just before \\( a + p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIocMod_mem_Ioc (a b : \u03b1) : toIocMod hp a b \u2208 Set.Ioc a (a + p) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that every integer *a* is congruent to itself modulo *n*.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl (a : \u2124) : a \u2261 a [ZMOD n] :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set 's' of real numbers has a lower bound if and only if the set of its inverses (1/s for each element 's' in the set) has an upper bound.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bddBelow_inv : BddBelow s\u207b\u00b9 \u2194 BddAbove s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(p\\) be a function such that \\(p(x) \\ge 0\\) for all \\(x\\) (non-negativity) and \\(p(a x) = |a| p(x)\\) for any number \\(a\\) and any \\(x\\) (absolute homogeneity). Given that \\(p(1) \\le 1\\), prove that \\(p(1) = 1\\) if and only if \\(p\\) is not the zero function (i.e., there exists some \\(x\\) for which \\(p(x) \\neq 0\\)).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 \u2264 1) : p 1 = 1 \u2194 p \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two ring homomorphisms from ring A to ring B are equal when considered as simple functions, then they are also equal as ring homomorphisms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_ringHom_injective : Function.Injective ((\u2191) : (A \u2192\u2090[R] B) \u2192 A \u2192+* B) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine a game played on a large board (our space \"\u03b2 \u00d7 \u03b2\").  You have two shapes drawn on this board, V and W. You pick any point 'x' on the board.  Prove that if you draw a circle centered at 'x' that fits entirely within both V and W, then this circle also fits entirely within W.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ball_inter_right (x : \u03b2) (V W : Set (\u03b2 \u00d7 \u03b2)) : ball x (V \u2229 W) \u2286 ball x W :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a collection of objects is split into groups labeled by 'i', and we raise this splitting structure to the power of 'n' (meaning we combine 'n' copies of it), then the resulting structure is still split into groups labeled by 'i'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem splits_X_pow (n : \u2115) : (X ^ n).Splits i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number x,  e^x minus the hyperbolic cosine of x is equal to the hyperbolic sine of x.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exp_sub_cosh : exp x - cosh x = sinh x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a set 's' and a function 'f' that operates on elements of this set. Prove that the function 'f' is strictly increasing on the set 's' if and only if the composition of 'f' with the 'ofDual' function is strictly decreasing on the set 's'. Here, the 'ofDual' function essentially reverses the order of elements it compares.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f \u2218 ofDual) s \u2194 StrictMonoOn f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number *n*, the result of `bit1 n` when divided by 2 always leaves a remainder of 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bit1_mod_two : bit1 n % 2 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a list \\( l\u2081 \\) is a subset of another list \\( l\u2082 \\), and \\( l\u2082 \\) is a subset of a third list \\( l\u2083 \\), then \\( l\u2081 \\) is also a subset of \\( l\u2083 \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Subset.trans {l\u2081 l\u2082 l\u2083 : Lists' \u03b1 true} (h\u2081 : l\u2081 \u2286 l\u2082) (h\u2082 : l\u2082 \u2286 l\u2083) : l\u2081 \u2286 l\u2083 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for an open set 's', taking the preimage of the image of 's' under a function 'mk' gives us back the original set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preimage_image_mk_open (hs : IsOpen s) : mk \u207b\u00b9' (mk '' s) = s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the preimage of the smallest element (bottom element) under any function is always the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_bot : comap m \u22a5 = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any type  '\u03b1', taking the interval 'Ico' from the bottom element '\u22a5' of 'WithBot \u03b1' (which is '\u03b1' extended with a bottom element) to an element 'b' is the same as taking all elements strictly less than 'b' in '\u03b1' ('Iio b') and adding an optional 'None' element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_bot_coe : Ico (\u22a5 : WithBot \u03b1) b = insertNone (Iio b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven an element 'x' from a type 'p' that can be embedded into another type 'M' where negation is defined, prove that negating 'x' within 'p' and then considering it as an element of 'M' is the same as negating 'x' directly in 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_neg (x : p) : ((-x : p) : M) = -x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function \\(f\\) is strictly antitone if and only if the composition of \\(f\\) and the duality function (which reverses the order of its input) is strictly monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictMono_comp_ofDual_iff : StrictMono (f \u2218 ofDual) \u2194 StrictAnti f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the norm of the identity transformation on a vector space V is equal to 1, given that there exists a vector in V whose norm is non-zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_id_of_nontrivial_seminorm (h : \u2203 x : V, \u2016x\u2016 \u2260 0) : \u2016id V\u2016 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the empty set is strictly convex for any vector space E over a field \ud835\udd5c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem strictConvex_empty : StrictConvex \ud835\udd5c (\u2205 : Set E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the interpretation function to the sum of two derivations is the same as summing the interpretations of the individual derivations.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_add (D1 D2 : Derivation R A M) : \u21d1(D1 + D2) = D1 + D2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any numbers 'a', 'b', and 'c', where 'a' is not infinity, if 'b' plus 'a' is less than or equal to 'c' plus 'a', then 'b' is less than or equal to 'c'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_add_le_add_right : a \u2260 \u221e \u2192 b + a \u2264 c + a \u2192 b \u2264 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer 'n', if a real number 'a' lies within the interval from 'n' (inclusive) to 'n+1' (exclusive), then the floor of 'a' is equal to 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem floor_eq_on_Ico' (n : \u2124) : \u2200 a \u2208 Set.Ico (n : \u03b1) (n + 1), (\u230aa\u230b : \u03b1) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given two linear transformations, \\(f\\) and \\(g\\), from a module \\(M\\) to a module \\(M\u2082\\) (over some ring with scalars denoted by \u03c3\u2081\u2082), applying the pointwise difference of these linear transformations, (f - g), to an element is the same as applying \\(f\\) and \\(g\\) separately to the element and then taking the difference in \\(M\u2082\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_sub' (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(f - g) = f - g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set considered as a subset of itself only has one element (or is empty), then the set itself only has one element (or is empty).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Subsingleton.coe_sort {s : Set \u03b1} : s.Subsingleton \u2192 Subsingleton s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have two sets, M\u2081 and M\u2082, and a special function 'e' that establishes a one-to-one correspondence between the elements of M\u2081 and M\u2082 while preserving their structure. This function 'e' also ensures that the operations on corresponding elements in both sets yield corresponding results.  Given any two elements 'x' and 'y' from the set M\u2081, prove that applying the function 'e' to the sum of 'x' and 'y' is the same as applying 'e' to 'x' and 'y' individually and then adding the results in M\u2082.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_add (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x y : M\u2081) : e (x + y) = e x + e y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set H is a complement of a set K, then H and K are disjoint (i.e., they have no elements in common).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a nonzero rational number \\(q\\) and a prime number \\(p\\), the p-adic norm of \\(q\\) does not converge to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_equiv_zero_const_of_nonzero {q : \u211a} (hq : q \u2260 0) : \u00acconst (padicNorm p) q \u2248 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two natural numbers n and m, if n and m are both odd, then their product n * m is also odd.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem odd_mul_odd {n m : \u2115} : n % 2 = 1 \u2192 m % 2 = 1 \u2192 n * m % 2 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that accessing the value stored within the \"punit product\" data structure is the same as simply taking the second element of a pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_punitProd : \u21d1(punitProd \u03b1) = Prod.snd :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero integer \\( z \\), its absolute value is greater than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_abs {z : \u2124} (h\u2080 : z \u2260 0) : 1 \u2264 |z| :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative number x, the logarithm of x is less than or equal to 0 if and only if x is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem log_nonpos_iff' (hx : 0 \u2264 x) : log x \u2264 0 \u2194 x \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a period 'p' and two points 'a' and 'b', prove that the function 'toIcoDiv' which determines the number of periods 'p' we need to shift 'a' to reach 'b' is equivalent to taking the floor of (b - a) / p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIcoDiv_eq_floor (a b : \u03b1) : toIcoDiv hp a b = \u230a(b - a) / p\u230b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there are two additive monoid homomorphisms, `f` and `g`, from additive monoid `A` to additive monoid `B`, and if `f` and `g` are equal as functions, then `f` and `g` are equal as additive monoid homomorphisms.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toAddMonoidHom_injective {f g : A \u2192+[M] B} (h : (f : A \u2192+ B) = (g : A \u2192+ B)) : f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set is almost everywhere true in the product measure if it is almost everywhere true in each component measure.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ae_pi_le_pi : (Measure.pi \u03bc).ae \u2264 Filter.pi fun i => (\u03bc i).ae :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that if we have a type `C` which represents some mathematical group, then looking at `C` as just a type is the same as the original `C`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a subobject Y of an object X in a category C is \"simple\" if and only if it is an \"atom.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) \u2194 IsAtom Y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \u03b1 has at least three elements, then its alternating group is nontrivial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nontrivial_of_three_le_card (h3 : 3 \u2264 card \u03b1) : Nontrivial (alternatingGroup \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a collection of things (we'll call this collection \"A\") and each thing in this collection is associated with a certain value (we'll call these values \"R\"). Now, imagine you have a specific thing 'a' from your collection 'A' and a specific value 'r' from your values 'R'. This theorem states that the value 'r' is NOT associated with the thing 'a' if and only if the difference between 'r' and the value associated with 'a' has a multiplicative inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_mem_iff {r : R} {a : A} : r \u2209 \u03c3 a \u2194 IsUnit (\u2191\u2090 r - a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any additive subgroup S of a module M, the canonical map from M to the quotient module M/S (where elements are cosets of S) is surjective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a finite set 's', and two elements 'u' and 'v', compressing 's' by replacing 'u' with 'v' doesn't change the number of elements in the set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_compression (u v : \u03b1) (s : Finset \u03b1) : (\ud835\udcd2 u v s).card = s.card :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three integers a, b, and c, the statement \"a + b = c\" is equivalent to the statement \"b + a = c\".\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comm {a b c : \u2124} : Fermat42 a b c \u2194 Fermat42 b a c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any element `x`, a binary function `f`, an accumulator `b`, and a list `v`, applying `scanl` to the list starting with `x` followed by `v` is equivalent to prepending `b` to the result of applying `scanl` to `v` with the accumulator updated by applying `f` to `b` and `x`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem scanl_cons (x : \u03b1) : scanl f b (x ::\u1d65 v) = b ::\u1d65 scanl f (f b x) v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `f` iteratively to an initial value `b` over an empty sequence results in the value `b` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem foldl_zero (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H b) : foldl f H b 0 = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven three sets A, B, and C, and two functions, \\(f\\) from A to B and \\(g\\) from B to C, if the composition of \\(g\\) and \\(f\\) (applying \\(f\\) first and then \\(g\\)) has the property that its output is \"finite\" when applied to elements from A, then the function \\(g\\) itself also has this \"finite\" property.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_comp_finite {f : A \u2192+* B} {g : B \u2192+* C} (h : (g.comp f).Finite) : g.Finite :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a function called \"compress\" that potentially modifies an input 'a' based on two other inputs 'u'.  We want to prove that if the two 'u' inputs are the same, then the \"compress\" function doesn't change the input 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compress_self (u a : \u03b1) : compress u u a = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set \\(I\\) with elements from a set \\(P\\), where the elements of \\(P\\) have a notion of order (we can say one element is less than or equal to another), if  \\(x\\) is less than or equal to \\(y\\) and \\(x\\) is not in the set \\(I\\), then \\(y\\) is also not in the set \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_compl_of_ge {x y : P} : x \u2264 y \u2192 x \u2208 (I : Set P)\u1d9c \u2192 y \u2208 (I : Set P)\u1d9c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any graph, an empty walk starting and ending at a vertex 'u' is considered a path.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any ring \\(R\\) and algebra \\(A\\) over \\(R\\), the image of any element \\(r\\) of \\(R\\) under the algebra map lies in the center of \\(A\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r \u2208 Set.center A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a sequence 'u' of elements (of the same type), prove that the least upper bound of the entire sequence is the same as the least upper bound of the first element 'u 0' and the least upper bounds of all the remaining elements (from 'u 1' onwards).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_iSup_nat_succ (u : \u2115 \u2192 \u03b1) : (u 0 \u2294 \u2a06 i, u (i + 1)) = \u2a06 i, u i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a special kind of number system where we introduce a new component alongside our familiar integers. In this system, a number is represented as a pair: an integer and a multiple of the square root of a fixed integer \"d\".  We can write this as (a, b\u221ad) where 'a' and 'b' are integers. \n\nThis theorem focuses on multiplying such numbers. Suppose we have:\n\n* A regular integer 'n'\n* A number from our new system represented as (n, 0), essentially 'n' embedded in our new system. \n* Another number from our new system represented as (x, y\u221ad)\n\nThe theorem states that multiplying these three together, i.e.,  \u221ad * (n, 0) * (x, y\u221ad), results in the number (d * n * y, n * x) in our new system.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smuld_val (n x y : \u2124) : sqrtd * (n : \u2124\u221ad) * \u27e8x, y\u27e9 = \u27e8d * n * y, n * x\u27e9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there's no common element between list l\u2081 and list l\u2082, then there's also no common element between list l\u2082 and list l\u2081.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Disjoint.symm (d : Disjoint l\u2081 l\u2082) : Disjoint l\u2082 l\u2081 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number n, if we first find the predecessor of n (the number before n) and then take the successor of the result (the number after the predecessor), we get back n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem succ'_pred' (n) : succ' (pred' n) = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any continuous function \\( f \\) from \\( \\alpha \\) to \\( \\beta \\) and any positive real number \\( \\epsilon \\), the modulus of continuity of \\( f \\) at \\( \\epsilon \\) is positive.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem modulus_pos (f : C(\u03b1, \u03b2)) {\u03b5 : \u211d} {h : 0 < \u03b5} : 0 < f.modulus \u03b5 h :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomial 'p' and a natural number 'n', if the coefficient of the term with degree 'n' in the polynomial 'p' is not zero, then 'n' is less than or equal to the degree of 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_degree_of_ne_zero (h : coeff p n \u2260 0) : (n : WithBot \u2115) \u2264 degree p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function which calculates the shortest distance from a point to a set is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_infDist_pt : Continuous (infDist \u00b7 s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a language \\(L\\), prove that the language formed by taking the union of the empty string with the concatenation of \\(L\\) and \\(L^*\\) is equal to \\(L^*\\).  Here, \\(L^*\\) denotes the Kleene star of \\(L\\), which is the set of all strings formed by concatenating zero or more strings from \\(L\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_add_self_mul_kstar_eq_kstar (l : Language \u03b1) : 1 + l * l\u2217 = l\u2217 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the linear map induced by the sum of two derivations is equal to the sum of the linear maps induced by each derivation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_add_linearMap (D1 D2 : Derivation R A M) : \u2191(D1 + D2) = (D1 + D2 : A \u2192\u2097[R] M) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) in the space of p-integrable functions (\\( L^p \\) space) with real values, taking the positive part of \\( f \\) is essentially equal (equal almost everywhere) to taking the maximum of \\( f \\) and 0 pointwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coeFn_posPart (f : Lp \u211d p \u03bc) : \u21d1(posPart f) =\u1d50[\u03bc] fun a => max (f a) 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero real number \\( a \\) and any polynomial \\( p(x) \\) with real coefficients, the roots of the polynomial \\( a \\cdot p(x) \\) are the same as the roots of \\( p(x) \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem roots_C_mul (p : R[X]) (ha : a \u2260 0) : (C a * p).roots = p.roots :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the cosine of an angle obtained by adding \u03c0 (pi) to any even multiple of \u03c0 is always equal to -1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_nat_mul_two_pi_add_pi (n : \u2115) : cos (n * (2 * \u03c0) + \u03c0) = -1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the open interval (a, b) is a subset of the closed interval [a, b].\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_subset_Icc_self : Ico a b \u2286 Icc a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a scenario where we have a way to transform objects, and also a way to transform functions between those objects. We want to show that transforming a function that's been \"scaled up\" by a natural number is the same as scaling up the transformed version of the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_nsmul {X Y : C} {f : X \u27f6 Y} {n : \u2115} : F.map (n \u2022 f) = n \u2022 F.map f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) and \\( g \\) be functions. Prove that  \\( f \\) is asymptotically bounded above by  \\( g \\) (within a constant factor) with respect to filter \\( map \\, k \\, l \\) if and only if the composition of \\( f \\) and \\( k \\) is asymptotically bounded above by the composition of \\( g \\) and \\( k \\) with respect to filter \\( l \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isBigO_map {k : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} : f =O[map k l] g \u2194 (f \u2218 k) =O[l] (g \u2218 k) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two functions, \\( f' \\) and \\( f \\), and a set \\( t \\). If \\( f' \\) is a right inverse of \\( f \\) on the set \\( t \\), then the composition of \\( f \\) and \\( f' \\) acts like the identity function on \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f \u2218 f') id t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the absolute value function is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_abs : Continuous abs :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set has exactly one element if and only if it has at most one element and is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_eq_one_iff_unique : Nat.card \u03b1 = 1 \u2194 Subsingleton \u03b1 \u2227 Nonempty \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(s\\) is a lower set and non-empty, then it is not bounded below.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty \u2192 \u00acBddBelow s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\(x\\) belongs to the union of two sets \\(p\\) and \\(p'\\) if and only if \\(x\\) can be expressed as the sum of an element \\(y\\) from \\(p\\) and an element \\(z\\) from \\(p'\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sup : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two integers 'a' and 'b', 'a' divides 'b' if and only if there exists an integer 'c' such that 'b' is equal to 'c' multiplied by 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem dvd_iff_exists_eq_mul_left : a \u2223 b \u2194 \u2203 c, b = c * a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we are performing repeated multiplications by a number 'x'. The 'order' of 'x' is the smallest power to which we need to raise 'x' to get 1. Given that raising 'x' to the power of 'p' results in 1 (where 'p' is a prime number) and that 'x' itself is not equal to 1, prove that the order of 'x' is equal to 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x \u2260 1) : orderOf x = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a specific operation, denoted as \"toIdeal\", to the result of combining two mathematical structures, represented by \"I\" and \"J\", is equivalent to combining the results of applying the same \"toIdeal\" operation to \"I\" and \"J\" individually.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIdeal_sup (I J : HomogeneousIdeal \ud835\udc9c) : (I \u2294 J).toIdeal = I.toIdeal \u2294 J.toIdeal :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite measure `\u03bc` on a set `\u03a9`, the total mass of `\u03bc` is equal to the measure of the entire set `\u03a9`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ennreal_mass {\u03bc : FiniteMeasure \u03a9} : (\u03bc.mass : \u211d\u22650\u221e) = (\u03bc : Measure \u03a9) univ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets 's' and 't' that are both closed under multiplication and contain 1 (submonoids), prove that a number 'x' belongs to the set 's \u2294 t' (the smallest set containing both 's' and 't' and closed under multiplication) if and only if 'x' can be represented as the product of two numbers 'y' and 'z', where 'y' belongs to 's' and 'z' belongs to 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_sup {s t : Submonoid N} {x : N} : x \u2208 s \u2294 t \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of the set difference of x and y and the set difference of y and x is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_inf_sdiff : x \\ y \u2293 y \\ x = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(M\\) be a module over a ring \\(R\\). Prove that an element \\(x\\) of \\(M\\) is in the torsion submodule of \\(M\\) if and only if there exists a non-zero element \\(a\\) of \\(R\\) such that \\(a\\) multiplied by \\(x\\) is equal to the zero element of \\(M\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_torsion_iff (x : M) : x \u2208 torsion R M \u2194 \u2203 a : R\u2070, a \u2022 x = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set 's' of ordered pairs, swapping the components of the least upper bound of 's' is the same as taking the least upper bound of the set obtained by swapping the components of each pair in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem swap_sSup [SupSet \u03b1] [SupSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sSup s).swap = sSup (Prod.swap '' s) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a' and any integer 'n', (1/a) raised to the power of 'n' is equal to 1 divided by 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_div_zpow (a : \u03b1) (n : \u2124) : (1 / a) ^ n = 1 / a ^ n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set  's', converting the upper closure of 's' to a set is equivalent to the union of all upper sets of elements in 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_upperClosure (s : Set \u03b1) : \u2191(upperClosure s) = \u22c3 a \u2208 s, Ici a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a polynomial with coefficients from a set 'R' and variables represented by elements of a set '\u03c3'.  This problem focuses on a specific type of polynomial called a monomial, which is a polynomial with only one term.  The monomial in question is represented by  'X i', where 'X' signifies the variable part and 'i' is an element from the set '\u03c3' indicating a specific variable.  We divide this monomial by another monomial that has a coefficient of 1 and the same variable 'i'. The theorem states that the result of this division is always 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem X_divMonomial (i : \u03c3) : (X i : MvPolynomial \u03c3 R) /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'I' from a set 'H' to a set 'E', prove that the target set of 'I' is equal to the range of 'I'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem target_eq : I.target = range (I : H \u2192 E) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' mapping elements from a set \u03b1 to a set \u03b2, applying 'f' to the zero measure on \u03b1 results in the zero measure on \u03b2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_zero (f : \u03b1 \u2192 \u03b2) : (0 : Measure \u03b1).map f = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a convex cone S is flat, then it is also pointed.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Flat.pointed {S : ConvexCone \ud835\udd5c E} (hS : S.Flat) : S.Pointed :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two functions, \\( f \\) and \\( g \\), which map elements from a set \\( M \\) to a set \\( N \\) (potentially with some structure \\( L \\)), are equal if and only if they produce the same output for every input from \\( M \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext_iff {f g : M \u2192[L] N} : f = g \u2194 \u2200 x, f x = g x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given an equivalence between two categories C and D, represented by 'E', the inverse of the functor associated with 'E' is the same as the inverse function provided by the equivalence 'E'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem functor_inv (E : C \u224c D) : E.functor.inv = E.inverse :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if  \\( a\u2081 \u2264 a\u2082 \\), then the closed interval from \\( a\u2082 \\) to \\( b \\) is a subset of the closed interval from \\( a\u2081 \\) to \\( b \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Icc_subset_Icc_left (h : a\u2081 \u2264 a\u2082) : Icc a\u2082 b \u2286 Icc a\u2081 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number \\(n\\), raising the identity linear map to the power of \\(n\\) results in the identity linear map itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_pow (n : \u2115) : (id : M \u2192\u2097[R] M) ^ n = id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any graph homomorphism from the complete graph (where all vertices are connected) to any other graph must be injective, meaning it doesn't map distinct vertices to the same vertex.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem injective_of_top_hom (f : (\u22a4 : SimpleGraph V) \u2192g G') : Function.Injective f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that there exists an embedding from a given space X to the space of bounded real-valued sequences.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem exists_embedding_l_infty : \u2203 f : X \u2192 \u2115 \u2192\u1d47 \u211d, Embedding f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a space called \"M,\" and within this space, we have a specific region marked as \"p.\" This region \"p\" follows the rules of being a \"Submodule,\" meaning it's like a smaller version of the bigger space \"M,\" maintaining similar properties.  Prove that this region \"p\" completely fills the entire space \"M\" if and only if every single point from \"M\" is contained within \"p.\"\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_top_iff' {p : Submodule R M} : p = \u22a4 \u2194 \u2200 x, x \u2208 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set 's' is not empty and there is an operation that maps each element in 's' to another element in 's' such that applying the operation twice returns the original element, then the set 's' with this operation is also not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nonempty.star [InvolutiveStar \u03b1] {s : Set \u03b1} (h : s.Nonempty) : s\u22c6.Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', where 'b' is not infinity, if we add 'b' to 'a' and then subtract 'b', the result is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_sub_cancel_right (hb : b \u2260 \u221e) : a + b - b = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity linear map is symmetric.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isSymmetric_id : (LinearMap.id : E \u2192\u2097[\ud835\udd5c] E).IsSymmetric :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\(x\\), raising \\(x\\) to the real number power 2 is the same as raising \\(x\\) to the natural number power 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rpow_two (x : \u211d) : x ^ (2 : \u211d) = x ^ 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that takes an outer measure and a set, and returns the measure of the set, is injective. In simpler terms, if two outer measures agree on the measure of every set, then the two outer measures are the same.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_fn_injective : Injective fun (\u03bc : OuterMeasure \u03b1) (s : Set \u03b1) => \u03bc s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a function `f` attains its maximum at `a` over its entire domain if and only if for all `x`, `f(x)` is less than or equal to `f(a)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isMaxOn_univ_iff : IsMaxOn f univ a \u2194 \u2200 x, f x \u2264 f a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nConsider a function 'f' that takes an element from a set 'R' and returns a multivariate polynomial (a polynomial with multiple variables) with coefficients in a set 'S'. Let 'C' be a function that takes an element from set 'R' and creates a constant multivariate polynomial. This theorem states that applying 'f' to a constant multivariate polynomial generated from an element 'r' of 'R' is the same as applying 'f' directly to 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bind\u2082_C_right (f : R \u2192+* MvPolynomial \u03c3 S) (r : R) : bind\u2082 f (C r) = f r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any submodule K of a vector space E over a field \ud835\udd5c is star-convex with respect to the zero vector in E.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem starConvex (K : Submodule \ud835\udd5c E) : StarConvex \ud835\udd5c (0 : E) K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the distance between a point 'x' and a point 'y' is less than the shortest distance from the point 'x' to a set 's', then the point 'y' cannot be in the set 's'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y \u2209 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' from a ring 'R', if we map 'x' to the fractional ideal generated by 1 over a subring 'S', then this mapped element belongs to the fractional ideal generated by 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_mem_one (x : R) : algebraMap R P x \u2208 (1 : FractionalIdeal S P) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) from a set to the natural numbers, the multiplicative range of \\( f \\) is equal to the set of all natural numbers if and only if \\( f \\) is surjective (onto).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mrange_top_iff_surjective {f : F} : mrange f = (\u22a4 : Submonoid N) \u2194 Function.Surjective f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a collection of ideals (special subsets) within a set S, indexed by a set \u03b9. The problem at hand is to prove that taking the preimage of the intersection of all these ideals under a function 'f' is equivalent to taking the intersection of the preimages of each individual ideal under the same function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comap_iInf (K : \u03b9 \u2192 Ideal S) : (iInf K).comap f = \u2a05 i, (K i).comap f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative integer \\( z \\), applying the `normalize` function to it results in the same integer \\( z \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normalize_of_nonneg {z : \u2124} (h : 0 \u2264 z) : normalize z = z :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that Aleph-null (\u2135\u2080), the cardinality of the set of natural numbers, is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem aleph0_ne_zero : \u2135\u2080 \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the boundary points of the set of all complex numbers whose real part is less than or equal to a given real number 'a', are precisely those complex numbers whose real part is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem frontier_setOf_re_le (a : \u211d) : frontier { z : \u2102 | z.re \u2264 a } = { z | z.re = a } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a ring homomorphism \\(f\\) to the \\(n\\)-th Witt polynomial \\(W_n\\) doesn't change its value.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_wittPolynomial (f : R \u2192+* S) (n : \u2115) : map f (W n) = W n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the smallest non-unital subsemiring of any ring R, when viewed as a set, contains only the zero element (0).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : ((\u22a5 : NonUnitalSubsemiring R) : Set R) = {0} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a finite set 's' is equal to the singleton set containing the element 'a' if and only if the underlying set of 's' is equal to the singleton set containing 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_eq_singleton_iff {a : \u03b1} {s : Finset \u03b1} : s.val = {a} \u2194 s = {a} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any bounded formula \u03c6 with at least one free variable, the universal closure of \u03c6 is not an atomic formula.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_all_isAtomic (\u03c6 : L.BoundedFormula \u03b1 (n + 1)) : \u00ac\u03c6.all.IsAtomic :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(\u03b9\\) be a set with a locally finite order. Prove that for any element \\(i\\) in \\(\u03b9\\), if the successor of \\(i\\) is less than or equal to \\(i\\), then \\(i\\) is the maximum element of \\(\u03b9\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isMax_of_succFn_le [LocallyFiniteOrder \u03b9] (i : \u03b9) (hi : succFn i \u2264 i) : IsMax i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomials p and q with coefficients in a ring R, if q is not monic, then the remainder of the Euclidean division of p by q is equal to p.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : \u00acMonic q) : p %\u2098 q = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine a function 'e' that transforms elements from a set called 'source' to another set called 'target'.  This theorem states that for any property 'p' that applies to elements in the 'target' set, checking if 'p' holds true for all elements in the 'target' set is equivalent to checking if 'p' holds true for every element obtained by applying 'e' to each element in the 'source' set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall_mem_target {p : \u03b2 \u2192 Prop} : (\u2200 y \u2208 e.target, p y) \u2194 \u2200 x \u2208 e.source, p (e x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a multiset `m` (a set that can have repeated elements) where all elements of `m` belong to another set `S`. Prove that the sum of all elements in `m` also belongs to the set `S`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem multiset_sum_mem {m : Multiset A} (h : \u2200 x \u2208 m, x \u2208 S) : m.sum \u2208 S :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that evaluating a program `c` with input `v` on a Turing machine, by repeatedly applying the transition function `tr`, results in the same output as evaluating `c` with input `v` directly using the `Code.eval` function, and then halting the machine.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any finite set \\(s_1\\), the set difference of \\(s_1\\) and itself is the empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sdiff_self (s\u2081 : Finset \u03b1) : s\u2081 \\ s\u2081 = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that \\( \\omega \\), an infinitely large number, is positive.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem infinitePos_omega : InfinitePos \u03c9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element \\( J \\) is in the subset of \\( \\pi \\) filtered by property \\( p \\) if and only if \\( J \\) is an element of \\( \\pi \\) and \\( J \\) satisfies the property \\( p \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_filter {p : Box \u03b9 \u2192 Prop} : J \u2208 \u03c0.filter p \u2194 J \u2208 \u03c0 \u2227 p J :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider collections of sets with some special properties. These collections are called \"SetSemirings.\"  We can think of \"down s\" as the set of all subsets that can be formed from the elements present in set 's'.  Given two such collections, 's' and 't', prove that all subsets within 's' are also found within 't' if and only if 's' is a strictly smaller collection than 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem down_ssubset_down {s t : SetSemiring \u03b1} : SetSemiring.down s \u2282 SetSemiring.down t \u2194 s < t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function `toDualEquiv` to an element `m` of type `M` is equivalent to applying the function `toDual` to the same element `m`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `join` which takes a list of lists and flattens it into a single list is primitive recursive.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem list_join : Primrec (@List.join \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a group G, and within this group, we have two subgroups S and T. We denote the set of inverses of elements in S as S\u207b\u00b9 and the set of inverses of elements in T as T\u207b\u00b9. Prove that S is a subset of T if and only if S\u207b\u00b9 is a subset of T\u207b\u00b9.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inv_le_inv (S T : Submonoid G) : S\u207b\u00b9 \u2264 T\u207b\u00b9 \u2194 S \u2264 T :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we convert a prime number \\(p\\) to a multiset of positive natural numbers, the resulting multiset will contain only one element, which is the prime number \\(p\\) itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset \u2115+) = {(p : \u2115+)} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any cardinal numbers 'a' and 'b', if 'b' is not equal to 0, then 'a' is less than or equal to the product of 'a' and 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_mul_right {a b : Cardinal} (h : b \u2260 0) : a \u2264 a * b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any object \\(X\\) in a category \\(C\\), the idempotent associated with \\(X\\) in the Karoubi envelope of \\(C\\) is equal to the identity morphism on \\(X\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_p (X : C) : (X : Karoubi C).p = \ud835\udfd9 X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \u03b1, the function `pure`, which maps each element of \u03b1 to its corresponding principal ultrafilter, has a dense image in the space of ultrafilters on \u03b1 equipped with the topology where all sets are open (the discrete topology).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem denseInducing_pure : @DenseInducing _ _ \u22a5 _ (pure : \u03b1 \u2192 Ultrafilter \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set formed by partitioning 'a' into non-overlapping subsets is non-empty if and only if the original set 'a' is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem parts_nonempty_iff : P.parts.Nonempty \u2194 a \u2260 \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a strictly ordered set, the set of all elements less than 'a' is an open set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isOpen_gt' (a : \u03b1) : IsOpen { b : \u03b1 | b < a } :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sum of the k-th powers of the divisors of a natural number n is equal to the result of applying the function \u03c3 (sigma) with arguments k and n.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sigma_apply {k n : \u2115} : \u03c3 k n = \u2211 d in divisors n, d ^ k :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Fibonacci sequence, starting from the third term (fib(2)), is strictly increasing.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two sets A and B that are balanced over a field \ud835\udd5c (meaning that scaling any element of the set by a scalar from \ud835\udd5c still results in an element within the set), prove that their intersection, A \u2229 B, is also balanced over \ud835\udd5c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Balanced.inter (hA : Balanced \ud835\udd5c A) (hB : Balanced \ud835\udd5c B) : Balanced \ud835\udd5c (A \u2229 B) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any given Turing machine M, if we translate it into another Turing machine `tr M`, then every step taken by M can be mirrored by a corresponding step in `tr M` while preserving a specific relationship between their configurations.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any submodule 's' of a module 'M' over a ring 'R', the rank of 's' is less than or equal to the rank of 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s \u2264 Module.rank R M :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the infimum of the empty set, considered as a subset of non-negative real numbers, is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInf_empty : sInf (\u2205 : Set \u211d\u22650) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function that takes the positive part of a function in \\(L^p\\) space is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_posPart [Fact (1 \u2264 p)] : Continuous fun f : Lp \u211d p \u03bc => posPart f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we swap a pair of elements twice, we get back the original pair.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements 'a' and 'b' in a type that can be either a value from a set '\u03b1' or a special element called \"bottom\" (\u22a5),  'a' is strictly less than 'b' if and only if 'b' is a value from the set '\u03b1' and there exists a value 'p' in '\u03b1' such that 'b' is equal to 'p' and 'a' is strictly less than 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_iff_exists_coe : \u2200 {a b : WithBot \u03b1}, a < b \u2194 \u2203 p : \u03b1, b = p \u2227 a < p\n   | a, some b => by simp [coe_eq_coe]\n   | a, \u22a5 => iff_of_false (not_lt_none _) <| by simp\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(L\\) be a Lie algebra over a ring \\(R\\), and let \\(s\\) be a subset of \\(L\\). Prove that an element \\(x\\) belongs to the Lie span of \\(s\\) if and only if \\(x\\) belongs to every Lie subalgebra of \\(L\\) that contains \\(s\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_lieSpan {x : L} : x \u2208 lieSpan R L s \u2194 \u2200 K : LieSubalgebra R L, s \u2286 K \u2192 x \u2208 K :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of any number of ones is equal to one.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_const_one : (\u220f _x in s, (1 : \u03b2)) = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a function 'f' from a set '\u03b1' to a normed space 'F', and a measure '\u03bc', the set of points 'y' in '\u03b1' where the essential supremum norm of 'f' is strictly less than the norm of 'f(y)' has measure zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem meas_snormEssSup_lt {f : \u03b1 \u2192 F} : \u03bc { y | snormEssSup f \u03bc < \u2016f y\u2016\u208a } = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `Fin.val` which converts a natural number less than `n` to its corresponding natural number representation, is injective. In other words, prove that different `Fin n` values always correspond to different natural numbers.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem val_injective : Function.Injective (@Fin.val n) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any property \\( p \\) defined on a computable set \\( \\alpha \\) is one-to-one reducible to itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem oneOneReducible_refl {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) : p \u2264\u2081 p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in an empty graph, no two vertices are adjacent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_adj (v w : V) : (\u22a5 : SimpleGraph V).Adj v w \u2194 False :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the real part of the product of two quaternions is equal to the sum of the products of their corresponding components, subtracting the products of the imaginary components.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the complement of a simple graph G is equivalent to a graph obtained by deleting all the edges of G from a complete graph on the same vertex set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem compl_eq_deleteEdges : G\u1d9c = (\u22a4 : SimpleGraph V).deleteEdges G.edgeSet :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the negation of a self-adjoint element is also self-adjoint.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Witt vector with its first component being 1 and all other components being 0 is equal to the zero vector in the ring of Witt vectors, for any prime number \\(p\\) and any positive integer \\(n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem wittOne_pos_eq_zero (n : \u2115) (hn : 0 < n) : wittOne p n = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `f` to arguments `i` and `j` directly is the same as first transforming `f` using a function called `of` and then applying it to the same arguments.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_apply (f : m \u2192 n \u2192 \u03b1) (i j) : of f i j = f i j :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a finite-dimensional vector space and an affine basis for it, then the set indexing the basis vectors is finite.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem finite [FiniteDimensional k V] (b : AffineBasis \u03b9 k P) : Finite \u03b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two pairs of elements,  (x\u2081, y\u2081) and (x\u2082, y\u2082), where x\u2081 and x\u2082 belong to a set \u03b1, and y\u2081 and y\u2082 belong to a set \u03b2, prove that (x\u2081, y\u2081) is less than or equal to (x\u2082, y\u2082) if and only if x\u2081 is less than or equal to x\u2082 and y\u2081 is less than or equal to y\u2082.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_le_mk [LE \u03b1] [LE \u03b2] {x\u2081 x\u2082 : \u03b1} {y\u2081 y\u2082 : \u03b2} : (x\u2081, y\u2081) \u2264 (x\u2082, y\u2082) \u2194 x\u2081 \u2264 x\u2082 \u2227 y\u2081 \u2264 y\u2082 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f_1 \\), \\( f_2 \\) be collections of subsets of a set \\( \u03b1 \\) and \\( g \\) be a collection of subsets of a set \\( \u03b2 \\).  Suppose that \\( f_1 \\) is a \"smaller\" collection than \\( f_2 \\) in the sense that every subset in \\( f_1 \\) is also in \\( f_2 \\). Prove that the collection of all Cartesian products of sets in  \\( f_1 \\) and \\( g \\) is \"smaller\" than the collection of all Cartesian products of sets in \\( f_2 \\) and \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_mono_left (g : Filter \u03b2) {f\u2081 f\u2082 : Filter \u03b1} (hf : f\u2081 \u2264 f\u2082) : f\u2081 \u00d7\u02e2 g \u2264 f\u2082 \u00d7\u02e2 g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing an element 'a' from a finite set 's' results in an empty set if and only if the original set 's' was either empty or contained only the element 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem erase_eq_empty_iff (s : Finset \u03b1) (a : \u03b1) : s.erase a = \u2205 \u2194 s = \u2205 \u2228 s = {a} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the closure of the union of two sets \\( s \\) and \\( t \\) in the real numbers \\( \\mathbb{R} \\) is equal to the union of the closure of \\( s \\) and the closure of \\( t \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem closure_union (s t : Set R) : closure (s \u222a t) = closure s \u2294 closure t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a group, taking the inverse of the inverse of an element always gives back the original element. In other words, prove that the inverse operation is its own left inverse.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem leftInverse_inv : LeftInverse (fun a : G \u21a6 a\u207b\u00b9) fun a \u21a6 a\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that scaling a sphere by a constant factor results in a new sphere centered at the scaled center and with a radius scaled by the same factor.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_sphere (c : G) (x : X) (r : \u211d) : c \u2022 sphere x r = sphere (c \u2022 x) r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have a box within a box within another box. This is like having three levels of nested boxes.  We can either unpack the outermost box first and then unpack the box we find inside, or we can directly unpack all the way to the innermost box. This theorem states that these two ways of unpacking lead to the same result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem joinM_map_joinM {\u03b1 : Type u} (a : m (m (m \u03b1))) : joinM (joinM <$> a) = joinM (joinM a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the topological support of the normalized version of function f with respect to measure \u03bc is equal to the closed ball centered at c with radius f.rOut.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tsupport_normed_eq : tsupport (f.normed \u03bc) = Metric.closedBall c f.rOut :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function `f` to each element of a multiset `s` and collecting the results into a new multiset is the same as creating a new multiset by individually applying `f` to each element of `s`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bind_singleton (f : \u03b1 \u2192 \u03b2) : (s.bind fun x => ({f x} : Multiset \u03b2)) = map f s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any multiset 's', taking the disjoint sum of 's' with an empty multiset is equivalent to mapping each element in 's' to its corresponding element in the disjoint union of the underlying types.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem disjSum_zero : s.disjSum (0 : Multiset \u03b2) = s.map inl :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( t \\), the expression \\( 2t - 1 \\) lies within the open interval \\( I \\) (equivalent to  \\( -1 < 2t - 1 < 1 \\) ) if and only if \\( t \\) belongs to the closed interval \\( [\\frac{1}{2}, 1] \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem two_mul_sub_one_mem_iff {t : \u211d} : 2 * t - 1 \u2208 I \u2194 t \u2208 Set.Icc (1 / 2 : \u211d) 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine we have a group of people, and we're interested in subgroups within this larger group.  If we have two subgroups, G' and G'', where G' is a subset of G'', and we further restrict both subgroups to only include people who share a certain characteristic 's', then the restricted version of G' will still be a subgroup of the restricted version of G''.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem induce_mono_left (hg : G' \u2264 G'') : G'.induce s \u2264 G''.induce s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a relation 'R' and two elements 'a' and 'b', applying the 'destutter'' function with relation 'R' to 'a' will result in: a list containing both 'a' and 'b' if 'R' holds true for 'a' and 'b', and a list containing only 'a' if 'R' does not hold true for 'a' and 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nImagine you have two boxes, each containing some items. There's a specific rule (R) that might hold between pairs of items from the first box, and another rule (P) that might hold between pairs of items from the second box. \n\nNow, suppose we have a magic function that can transform any item from the first box into a smaller box of items for the second box. \n\nWe want to prove the following: If \n1) every pair of items satisfying rule R in the first box will, after being transformed, result in a pair of smaller boxes where all corresponding items satisfy rule P, and\n2) all the items within each smaller box satisfy rule P, \nthen applying the transformation to all items in the first box will result in a larger combined box where all items satisfy rule P.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem rel_bind : (Forall\u2082 R \u21d2 (R \u21d2 Forall\u2082 P) \u21d2 Forall\u2082 P) List.bind List.bind :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the interval of elements in `WithBot \u03b1` that are greater than or equal to the bottom element (denoted by \u22a5) and less than `b` is equivalent to the interval of elements in `\u03b1` that are less than `b`, with each element being mapped to its corresponding element in `WithBot \u03b1`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_bot_coe : Ioc (\u22a5 : WithBot \u03b1) b = (Iic b).map Embedding.some :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(s\\) is not empty, then its inverse, denoted by \\(s^{-1}\\), is also not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nonempty.inv (h : s.Nonempty) : s\u207b\u00b9.Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'g' in a finite group 'G',  raising 'g' to the power of a natural number 'n' is equivalent to raising 'g' to the power of the remainder when 'n' is divided by the order of the group 'G'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_eq_mod_exponent {n : \u2115} (g : G) : g ^ n = g ^ (n % exponent G) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( f \\) and \\( g \\) be two functions. Given that \\( f \\) is integrable (with respect to some measure \\( \\mu \\)) and that \\( f \\) and \\( g \\) are equal almost everywhere (with respect to the same measure \\( \\mu \\)), prove that \\( g \\) is also integrable.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Integrable.congr {f g : \u03b1 \u2192 \u03b2} (hf : Integrable f \u03bc) (h : f =\u1d50[\u03bc] g) : Integrable g \u03bc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a constant value `b` into a constant function is the same as defining a constant function that always returns `b`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_const (b : \u03b2) : \u21d1(const \u03b1 b) = Function.const \u03b1 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that two propositions, P and Q, are complementary if and only if it is not true that P and Q are logically equivalent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q \u2194 \u00ac(P \u2194 Q) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\), the arcsine of \\( x \\) is greater than 0 if and only if \\( x \\) is greater than 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arcsin_pos {x : \u211d} : 0 < arcsin x \u2194 0 < x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a specific point, denoted as 'x', within a set 'X'. We also have a set 's' which is a subset of a space constructed from 'X' by adding a single new point (denoted as 'OnePoint X'). The theorem aims to prove that the neighborhood of the image of 'x' within the set 's' is equivalent to the image of the neighborhood of 'x' within the preimage of 's', all considered under a specific mapping from 'X' to 'OnePoint X'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : \ud835\udcdd[s] \u2191x = map (\u2191) (\ud835\udcdd[(\u2191) \u207b\u00b9' s] x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a property 'p' that applies to objects of a certain type and another property 'q' that depends on both an object and whether it satisfies property 'p'. This theorem states that checking property 'q' for every object and its proof of satisfying property 'p' is equivalent to checking 'q' only for objects that are already known to satisfy 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall' {q : \u2200 x, p x \u2192 Prop} : (\u2200 x h, q x h) \u2194 \u2200 x : { a // p a }, q x x.2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the identity affine isometry to a point leaves the point unchanged.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_apply (x : P) : (AffineIsometry.id : P \u2192\u1d43\u2071[\ud835\udd5c] P) x = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the identity function on a set \u03b1 is continuous if the topology t is finer than the topology t'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous_id_of_le {t t' : TopologicalSpace \u03b1} (h : t \u2264 t') : Continuous[t, t'] id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for a given relation \\( R \\), there is a chain between two elements \\( x \\) and \\( y \\) in a list containing only \\( x \\) and \\( y \\) if and only if \\( x \\) is related to \\( y \\) by \\( R \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem chain'_pair {x y} : Chain' R [x, y] \u2194 R x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve the trigonometric identity: The square of the cosine of an angle is equal to half the sum of 1 and the cosine of twice the angle.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the intersection of an empty set is an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sInter_empty : \u22c2\u2080 (\u2205 : ZFSet) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn any mathematical category (a collection of objects and arrows between them), if a function 'f' from object 'P' to object 'Q' is surjective (meaning it covers every point in 'Q'), then 'f' is also an epimorphism.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem epi_of_pseudo_surjective {P Q : C} (f : P \u27f6 Q) : Function.Surjective f \u2192 Epi f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we take a rational number 'q', treat it as an element of a type '\u03b1' that supports casting from rational numbers, then consider this element in the 'opposite' type '\u03b1\u1d50\u1d52\u1d56', and finally apply the 'unop' operation (which brings the element back from the opposite type), we get back the original rational number 'q'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unop_ratCast [RatCast \u03b1] (q : \u211a) : unop (q : \u03b1\u1d50\u1d52\u1d56) = q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two potentially infinite sequences are equivalent, then their tails are also equivalent.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem tail_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) : tail s ~\u02b7 tail t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any number 'a' less than or equal to 1, 'a' is less than or equal to its inverse (1/a), denoted as a\u207b\u00b9.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Left.self_le_inv (h : a \u2264 1) : a \u2264 a\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', the interval starting at 'a' and closed at the predecessor of 'b' is the same as the interval starting at 'a' and open at 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ioc_pred_right (a b : \u03b1) : Ioc a (pred b) = Ioo a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two boolean values (True or False),  `x` AND `y`  is always less than or equal to `x`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem and_le_left : \u2200 x y : Bool, (x && y) \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' in a type that includes a top element (\u22a4), subtracting the top element from 'a' always results in 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_top {a : WithTop \u03b1} : a - \u22a4 = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two elements, 'a' and 'b', and we want to subtract them in a specific way (denoted by '-\u1d65') within a certain context (represented by 'Filter'). This subtraction is done on elements placed within individual containers labeled 'pure'. The theorem states that subtracting these containerized elements, 'pure a' and 'pure b', is the same as first subtracting 'a' and 'b' directly, and then placing the result into the 'pure' container.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_vsub_pure : (pure a : Filter \u03b2) -\u1d65 pure b = (pure (a -\u1d65 b) : Filter \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', if 'a' is not less than 'b', then the set of natural numbers between 'a' (inclusive) and 'b' (exclusive) is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Ico_eq_empty (h : \u00aca < b) : Ico a b = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) that preserves addition between two sets \\( A \\) and \\( B \\), applying \\( f \\) to the sum of two elements \\( x \\) and \\( y \\) in set \\( A \\) is the same as applying \\( f \\) to \\( x \\) and \\( y \\) separately in \\( A \\) and then adding the results in \\( B \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_add (f : A \u2192+[M] B) (x y : A) : f (x + y) = f x + f y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the reverse of the zero polynomial is the zero polynomial.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reverse_zero : reverse (0 : R[X]) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the polynomial \"X\" itself is not the zero polynomial within the field of rational functions.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem X_ne_zero : (RatFunc.X : RatFunc K) \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any two real numbers, denoted by 'x' and 'y', prove that reversing the order of multiplication after applying the 'star' operation twice to 'x' and then multiplying by 'y' is equivalent to applying the 'star' operation to 'y' and then multiplying by 'x'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two linear transformations, \\( f \\) and \\( g \\), from a vector space \\( M\u2081 \\) to itself (over a ring \\( R\u2081 \\)), and a vector \\( x \\) in \\( M\u2081 \\), prove that applying the composition of \\( f \\) and \\( g \\) to \\( x \\) is the same as applying \\( f \\) to the result of applying \\( g \\) to \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_apply (f g : M\u2081 \u2192L[R\u2081] M\u2081) (x : M\u2081) : (f * g) x = f (g x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the function 'C' to the difference of two elements 'a' and 'a'' is the same as applying 'C' to each element individually and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem C_sub : (C (a - a') : MvPolynomial \u03c3 R) = C a - C a' :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two integers x and y, and assuming some unspecified properties hold (represented by 'h'), prove that a certain classification property, denoted as 'IsClassified', holds for the pair (x, y).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem classified : h.IsClassified :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have two continuous deformations, denoted by F and G, between paths f\u2080 and f\u2081 that satisfy a property P. If F and G are pointwise equal, meaning they agree at every point x, then the deformations F and G are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {F G : HomotopyWith f\u2080 f\u2081 P} (h : \u2200 x, F x = G x) : F = G :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the infimum (greatest lower bound) of two finite sets is the same as taking their intersection.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_eq_inter : (Inf.inf : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Finset \u03b1) = Inter.inter :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number  'x' divides a natural number 'm' resulting in an irrational number, then 'x' itself must be irrational.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem of_nat_div (m : \u2115) (h : Irrational (m / x)) : Irrational x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the product of two Cauchy sequences that are not converging to zero does not converge to zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : \u00acf \u2248 0) (hg : \u00acg \u2248 0) : \u00acf * g \u2248 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any number 'a', prove that the floor of ('a' plus 1) is equal to the floor of 'a' plus 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem floor_add_one (a : \u03b1) : \u230aa + 1\u230b = \u230aa\u230b + 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer 'i', the least common multiple (lcm) of 0 and 'i' is 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lcm_zero_left (i : \u2124) : lcm 0 i = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that negating the result of applying a binary operation `B\u2081` to two elements `x` and `y` is the same as applying the operation and then negating the result.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_apply (x y : M\u2081) : (-B\u2081) x y = -B\u2081 x y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero, finite number 'a' and any number 'b', (b / a) * a = b.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem div_mul_cancel (h0 : a \u2260 0) (hI : a \u2260 \u221e) : b / a * a = b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is a quotient map, then it is continuous.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuous (hf : QuotientMap f) : Continuous f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set \\( s \\) of vertices forms an n-clique in an empty graph if and only if \\( n \\) is less than or equal to 1 and the size of \\( s \\) is equal to \\( n \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isNClique_bot_iff : (\u22a5 : SimpleGraph \u03b1).IsNClique n s \u2194 n \u2264 1 \u2227 s.card = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any property \\( p \\) defined on a type \\( \\alpha \\), the subtype of \\( \\alpha \\) consisting of elements satisfying \\( p \\) is empty if and only if the property \\( p \\) holds for no element of \\( \\alpha \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isEmpty_subtype (p : \u03b1 \u2192 Prop) : IsEmpty (Subtype p) \u2194 \u2200 x, \u00acp x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function 'f' that maps elements of a type '\u03b1' to elements of a group 'G' with the added condition that only finitely many elements of '\u03b1' map to non-identity elements in 'G', prove that removing the contribution of an element 'a' from the function '-f' (which maps each element to the inverse of the output of 'f') is equivalent to taking the inverse of removing the contribution of 'a' from the original function 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem erase_neg (a : \u03b1) (f : \u03b1 \u2192\u2080 G) : erase a (-f) = -erase a f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all open intervals of the form (-\u221e, r), where r is a real number, forms a neighborhood basis for the element -\u221e in the extended real line.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhds_bot_basis : (\ud835\udcdd (\u22a5 : EReal)).HasBasis (fun _ : \u211d \u21a6 True) (Iio \u00b7) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a specific function called \"polar\" that operates on some objects and a function \"Q\" that transforms one object into another, prove that applying the \"polar\" function with the same input \"x\" twice is equivalent to applying the \"Q\" function to \"x\" and then multiplying the result by 2.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem polar_self (x : M) : polar Q x x = 2 * Q x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function \\(f\\) from a topological space \\(X\\) to a topological space \\(Y\\) that satisfies a property \\(P\\) is homotopic to itself with respect to that property.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any natural number 'n', prove that converting 'n' to an element in a specific mathematical structure (called \"HomogeneousLocalization \ud835\udc9c x\" here) and then extracting its \"value\" ('val') results in the original number 'n' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natCast_val (n : \u2115) : (n : HomogeneousLocalization \ud835\udc9c x).val = n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a ring R is semisimple when acting on a left R-module L, then the center of R with respect to L is trivial (i.e., contains only the zero element).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = \u22a5 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a monotone function `h` between sets, prove that the image under `h` of the smallest filter on a set `\u03b1` is equal to the principal filter generated by the image of the empty set under `h`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lift'_bot (hh : Monotone h) : (\u22a5 : Filter \u03b1).lift' h = \ud835\udcdf (h \u2205) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider a way to compare lists of numbers. Suppose we represent these lists in a specific order based on their indices, similar to how dictionaries use key-value pairs. We are interested in understanding how changing a single element in a list affects the ordering. \n\nSpecifically, we want to prove: Comparing a list 'x' with a modified version of itself, where only the element at index 'i' is updated to value 'a', is equivalent to directly comparing the original element at index 'i' in 'x' with the new value 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) \u2194 x i < a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the entry at the \\(i\\)-th row and \\(j\\)-th column of the identity matrix (denoted as \\(1\\)) of size \\(n \\times n\\) is equal to 1 if \\(i\\) is equal to \\(j\\), and 0 otherwise.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_apply {i j} : (1 : Matrix n n \u03b1) i j = if i = j then 1 else 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven elements 'a' and 'b' from a set '\u03b1', an integer 'm', and a point 'p', prove that calculating the \"toIocDiv\" of 'a' with respect to  '(m times p) plus b' is equivalent to adding 'm' to the \"toIocDiv\" of 'a' with respect to 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toIocDiv_zsmul_add (a b : \u03b1) (m : \u2124) : toIocDiv hp a (m \u2022 p + b) = m + toIocDiv hp a b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function \\(f\\) from a set with only one element to a set of Ordinal numbers, the supremum of the range of  \\(f\\) is equal to the value of \\(f\\) at the single element in its domain.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sup_unique {\u03b9} [Unique \u03b9] (f : \u03b9 \u2192 Ordinal) : sup f = f default :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sum of a geometric series with a positive odd number of terms is always greater than zero, given that the elements of the series belong to a linearly ordered ring.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Odd.geom_sum_pos [LinearOrderedRing \u03b1] (h : Odd n) : 0 < \u2211 i in range n, x ^ i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two functions \\( f \\) and \\( g \\) that map elements from a set \\( \\alpha \\) to a set \\( \\beta \\), if \\( f(a) = g(a) \\) for every element \\( a \\) in \\( \\alpha \\), then the functions \\( f \\) and \\( g \\) are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {f g : \u03b1 \u2192Co \u03b2} (h : \u2200 a, f a = g a) : f = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the predecessor function on natural numbers (which subtracts 1 from any natural number greater than 0, and maps 0 to 0) is injective. An injective function means that different inputs always lead to different outputs.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem natPred_injective : Function.Injective natPred :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that negating the coefficients of a polynomial and then reflecting the polynomial around the y-axis is equivalent to reflecting the polynomial first and then negating the coefficients.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reflect_neg (f : R[X]) (N : \u2115) : reflect N (-f) = -reflect N f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a relation \\( r \\) on a set \\( \u03b1 \\) is transitive, then it satisfies the property of transitivity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem transitive_of_trans (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] : Transitive r :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the natural embedding of a multivariate polynomial into the set of power series is injective. In other words, different polynomials will always be mapped to different power series.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial \u03c3 R \u2192 MvPowerSeries \u03c3 R) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing two structure-preserving maps, and then applying the resulting map, is the same as applying the second map and then the first.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_comp (f : sSupHom \u03b2 \u03b3) (g : sSupHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a' and lists 's' and 't', appending list 't' to the list obtained by adding 'a' to the beginning of 's' is the same as adding 'a' to the beginning of the list obtained by appending 's' and 't'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_append (a : \u03b1) (s t) : append (cons a s) t = cons a (append s t) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a is equal to c multiplied by the multiplicative inverse of b, then a multiplied by b is equal to c.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_eq_of_eq_mul_inv (h : a = c * b\u207b\u00b9) : a * b = c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function \"not\" (negation) is not equal to the identity function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_ne_id : not \u2260 id :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nSuppose we have a value `x` of type `t \u03b1` and a functor `F`. Prove that applying `traverse` with the `pure` function to `x` is the same as applying `pure` directly to `x` and then considering the result as a value of type `F (t \u03b1)`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_traverse (x : t \u03b1) : traverse pure x = (pure x : F (t \u03b1)) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in a commutative square of functions, the second component of the cone is equal to the function 'g'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the smallest seminorm on a vector space E over a field K is the zero function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem bot_eq_zero : (\u22a5 : Seminorm \ud835\udd5c E) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element of the one-point compactification of a set X is not the added point at infinity if and only if it is equal to the image of some element from the original set X.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_infty_iff_exists {x : OnePoint X} : x \u2260 \u221e \u2194 \u2203 y : X, (y : OnePoint X) = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a positive number *p*, prove that *p* is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ne_zero : p \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three multisets \\(s\\), \\(t\\), and \\(u\\), the multiset product is distributive over multiset sum. That is, \\(s \u00d7\u02e2 (t + u) = s \u00d7\u02e2 t + s \u00d7\u02e2 u\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem product_add (s : Multiset \u03b1) : \u2200 t u : Multiset \u03b2, s \u00d7\u02e2 (t + u) = s \u00d7\u02e2 t + s \u00d7\u02e2 u :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven positive integers \\(x\\), \\(y\\), and \\(d\\), if \\(x^2 - dy^2 = 1\\), then there exists a non-negative integer \\(n\\) such that \\(x\\) and \\(y\\) are the \\(n\\)-th terms of the Pell sequence associated with \\(d\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_pell {x y : \u2115} (hp : x * x - d a1 * y * y = 1) : \u2203 n, x = xn a1 n \u2227 y = yn a1 n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(S\\) be a subset of a set \\(A\\) that has a multiplication operation defined on it (like a ring or a field). Also, let \\(R\\) be a set with a multiplication operation that is compatible with \\(A\\) (meaning that elements of \\(R\\) can be multiplied with elements of \\(A\\) in a way that respects the algebraic structure). This theorem states that if we have an element \\(x\\) in our subset \\(S\\), and we multiply it by any element \\(r\\) from \\(R\\), the result (\\(r \\cdot x\\)) will still be an element of the subset \\(S\\).  In simpler terms, this theorem says that \\(S\\) is \"closed under scalar multiplication\" from \\(R\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_mem {x : A} (hx : x \u2208 S) (r : R) : r \u2022 x \u2208 S :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet V be a vector space over a field K. Prove that for any non-zero vector 'v' in V, the subspace spanned by 'v' is an atom. (A subspace W is called an atom if it is non-zero and the only subspace of W properly contained in W is the zero subspace).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nonzero_span_atom (v : V) (hv : v \u2260 0) : IsAtom (span K {v} : Submodule K V) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that an element tagged as belonging to the \"right\" side of a disjoint union cannot be less than or equal to an element tagged as belonging to the \"left\" side, according to the standard order on the disjoint union.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_inl_le_inr [LE \u03b1] [LE \u03b2] {a : \u03b1} {b : \u03b2} : \u00acinl b \u2264 inr a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sign function (which outputs -1 for negative numbers, 0 for 0, and 1 for positive numbers) is continuous at any point that is not zero.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousAt_sign_of_ne_zero {a : \u03b1} (h : a \u2260 0) : ContinuousAt SignType.sign a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing any cocompact map `f` with the identity map is equal to `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_comp (f : CocompactMap \u03b1 \u03b2) : (CocompactMap.id _).comp f = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function \\( f \\) from a set to itself and any element \\( x \\) in the set,  \\( x \\) is a periodic point of \\( f \\) with period equal to the minimal period of \\( x \\) under \\( f \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isPeriodicPt_minimalPeriod (f : \u03b1 \u2192 \u03b1) (x : \u03b1) : IsPeriodicPt f (minimalPeriod f x) x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the order of an element \\(x\\) is 0, then \\(x\\) raised to the power of \\(n\\) equals \\(x\\) raised to the power of \\(m\\) if and only if \\(n\\) equals \\(m\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : \u2115} : x ^ n = x ^ m \u2194 n = m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have an isomorphism `f` between two objects `X` and `Y` in the opposite category of `C`, then taking the opposite of the inverse of `f` and then taking the opposite again, we get back `f`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem unop_op {X Y : C\u1d52\u1d56} (f : X \u2245 Y) : f.unop.op = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) and a way of approximating it (denoted by \\( \\text{approx} \\  f \\)), prove that if  \\( i \\) is less than or equal to  \\( j \\), then the approximation of \\(f\\) at  \\( i \\) is less than or equal to the approximation of \\(f\\) at \\( j \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem approx_mono \u2983i j : \u2115\u2984 (hij : i \u2264 j) : approx f i \u2264 approx f j :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any invertible element 'a' in a system with a notion of multiplication and inverses, the multiplicative inverse of 'a' (denoted as \u215f a) is equal to the right inverse of 'a' (denoted as a\u207b\u00b9).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem invOf_eq_inv (a : \u03b1) [Invertible a] : \u215f a = a\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying a function to the product of two sets is the same as taking the product of applying the function to each set individually.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_mul : m '' (s * t) = m '' s * m '' t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a proof `h` that an index `i` is equal to itself, prove that casting a linear map (between modules `R` and `M`) along this self-equality is the same as doing nothing to the linear map (i.e., it's equivalent to the identity linear map).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any list `l` of elements of type `\u03b1`, the Cartesian product of `l` and an empty list `[]` (of type `\u03b2`) is always an empty list.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem product_nil : \u2200 l : List \u03b1, l \u00d7\u02e2 (@nil \u03b2) = []\n   | [] => rfl\n   | _ :: l => by simp [product_cons, product_nil l]\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the measure of an open ball in a metric space is always greater than 0, given that the radius of the ball is not 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem measure_ball_pos (x : X) {r : \u211d\u22650\u221e} (hr : r \u2260 0) : 0 < \u03bc (ball x r) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the uniformity generated by the infimum of a family of uniform spaces is equal to the infimum of the uniformities generated by each individual space in the family.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem iInf_eq {u : \u03b9 \u2192 UniformSpace \u03b3} : \ud835\udcb0(\u03b1, \u03b3, (\u2a05 i, u i)) = \u2a05 i, \ud835\udcb0(\u03b1, \u03b3, u i) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a bijection \u03b1 between two sets X and Y, and a function f from Y to X, prove that the composition of f and the function from Y to X defined by \u03b1 is the identity function on Y if and only if f is the inverse of the function from X to Y defined by \u03b1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that composing any function \\(f\\) with the identity function results in the original function \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem comp_id : f.comp id = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that encoding the boolean value \"false\" results in the natural number 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem encode_false : encode false = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any finite commutative ring that is also an integral domain must be a field.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the adjoint of a linear operator is equal to its conjugate transpose.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem star_eq_adjoint (A : E \u2192\u2097[\ud835\udd5c] E) : star A = LinearMap.adjoint A :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a set \\(I\\) which is a subset of a ring \\(R\\), prove that if a number \\(x\\) belongs to \\(I\\), then any natural number power of \\(x\\) (\\(x^n\\)) belongs to the set obtained by taking the product of \\(I\\) with itself \\(n\\) times, denoted as \\(I^n\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pow_mem_pow {x : R} (hx : x \u2208 I) (n : \u2115) : x ^ n \u2208 I ^ n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any relation \\(r\\), if a set \\(A\\) is a subset of a set \\(B\\), then the image of \\(A\\) under \\(r\\) is a subset of the image of \\(B\\) under \\(r\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem image_subset : ((\u00b7 \u2286 \u00b7) \u21d2 (\u00b7 \u2286 \u00b7)) r.image r.image :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if we have a function 'f' that takes two arguments (let's call them 'x' of type 'E' and 'y' of type 'F') and returns a value of type 'G', then flipping the order of arguments twice results in the original function.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem flip_flip (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : f.flip.flip = f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer \\(n\\), converting \\(n\\) to a natural number results in 0 if and only if \\(n\\) is less than or equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem toNat_eq_zero : \u2200 {n : \u2124}, n.toNat = 0 \u2194 n \u2264 0\n   | (n : \u2115) =>\n     calc\n       _ \u2194 n = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the Cartesian product of two sets \\( s \\) and \\( t \\) is nonempty if and only if both \\( s \\) and \\( t \\) are nonempty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_nonempty : (s * t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the reflexive function (`refl`) to any element `x` in a type `M` returns the element `x` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl_apply (x : M) : refl L M x = x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the totient of any natural number greater than 2 is even.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem totient_even {n : \u2115} (hn : 2 < n) : Even n.totient :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that given a linear map \\(f\\) between two modules \\(M\\) and \\(N\\) over some ring \\(R\\), applying the negation of \\(f\\) to an element \\(m\\) of \\(M\\) is the same as taking the negation of the result of applying \\(f\\) to \\(m\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem neg_apply (f : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (-f) m = -f m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a natural number 'n', and an element 'm' from a module 'M' over a ring 'R', prove that scaling the element 'm' by 'n' is the same as applying the endomorphism of scaling by 'n' to 'm'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem _root_.Module.End.natCast_apply (n : \u2115) (m : M) : (\u2191n : Module.End R M) m = n \u2022 m :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIf we have a pushout diagram with arrows `f`, `g`, `inl`, and `inr`, then the right arrow of the cocone is equal to `inr`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a value 'c' is a limit point, then it is also a successor limit point.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two codes 'cf' and 'cg' and a natural number 'a', evaluating code 'cf' on input 'a' yields the same result as evaluating the code 'prec cf cg' on the paired input of 'a' and 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eval_prec_zero (cf cg : Code) (a : \u2115) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any integer \\( n \\), casting the multiplicative inverse of \\( n \\) (viewed as a rational number) to any type \\( \\alpha \\) is the same as taking the multiplicative inverse of \\( n \\) after casting it to \\( \\alpha \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_inv_int (n : \u2124) : ((n\u207b\u00b9 : \u211a) : \u03b1) = (n : \u03b1)\u207b\u00b9 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that evaluating the difference of two polynomial expressions, `p` and `q`, using the functions `f` and `g` for variables is equivalent to evaluating each polynomial separately using `f` and `g` and then subtracting the results.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eval\u2082_sub : (p - q).eval\u2082 f g = p.eval\u2082 f g - q.eval\u2082 f g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function `f` is an isometry, then it is norm-nonincreasing.  In simpler terms, if `f` preserves distances, then the norm (or length) of any value `v` will not increase after applying `f` to it.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if two subsets, \\(o\\) and \\(p\\), of a set have the exact same elements, then the two subsets are equal.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem ext {o p : Part \u03b1} (H : \u2200 a, a \u2208 o \u2194 a \u2208 p) : o = p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if \\( I \\) is a maximal ideal of a ring \\( R \\), then \\( I \\) is equal to the unique maximal ideal of \\( R \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a number \\( x \\) lies within the interval from 0 to 1 (inclusive), then \\( x \\) is less than or equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_le_one (x : Icc (0 : \u03b1) 1) : (x : \u03b1) \u2264 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any function 'f' that maps elements from type '\u03b1' to type '\u03b2', applying 'f' after wrapping an element of type '\u03b1' with 'some' is the same as wrapping the result of applying 'f' to the element with 'some'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_comp_some (f : \u03b1 \u2192 \u03b2) : Option.map f \u2218 some = some \u2218 f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is continuous on a larger set, it's also continuous on any smaller subset within that set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem antitone_continuousOn {f : \u03b1 \u2192 \u03b2} : Antitone (ContinuousOn f) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the conversion from a real number to a quaternion (with real components R and complex units c\u2081 and c\u2082) is injective. In other words, different real numbers are always represented by different quaternions.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_injective : Function.Injective (coe : R \u2192 \u210d[R,c\u2081,c\u2082]) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that, for any ultrafilter \\( f \\) and any filter \\( g \\) on a set, the infimum (greatest common subfilter) of \\( f \\) and \\( g \\) is not the bottom filter (the filter containing everything) if and only if \\( f \\) is a subfilter of \\( g \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inf_neBot_iff {f : Ultrafilter \u03b1} {g : Filter \u03b1} : NeBot (\u2191f \u2293 g) \u2194 \u2191f \u2264 g :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any Young Diagram  \u03bc and natural numbers i and j, the pair (i, j) being in the j-th column of \u03bc is equivalent to the pair (i, j) being in \u03bc.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_mem_col_iff {\u03bc : YoungDiagram} {i j : \u2115} : (i, j) \u2208 \u03bc.col j \u2194 (i, j) \u2208 \u03bc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any set \\(s\\) and an element \\(b\\), the set obtained by taking the supremum (least upper bound) of \\(b\\) with each element of \\(s\\) is the same as taking the image of \\(s\\) under the function that maps each element \\(a\\) to the supremum of \\(a\\) and \\(b\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sups_singleton : s \u22bb {b} = s.image fun a => a \u2294 b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a set 's' of elements that are ordered, meaning some elements can be \"less than or equal to\" others. This set has a special element called \"\u22a5\" (bottom), which is the smallest element in the set. An antichain is a set where no two distinct elements are comparable, meaning neither one is \"less than or equal to\" the other. Prove that the bottom element \"\u22a5\" is in our set 's' if and only if 's' contains only the bottom element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem IsAntichain.bot_mem_iff [OrderBot \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : \u22a5 \u2208 s \u2194 s = {\u22a5} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the upper closure of the singleton set containing only the element 'a' is equal to the set of all elements greater than or equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem upperClosure_singleton (a : \u03b1) : upperClosure ({a} : Set \u03b1) = UpperSet.Ici a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for ordinal numbers \\(a\\), \\(b\\), and \\(c\\), where \\(b\\) is a limit ordinal, \\(a * b \\le c\\) if and only if for all ordinals \\(b'\\) less than \\(b\\), \\(a * b' \\le c\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b \u2264 c \u2194 \u2200 b' < b, a * b' \u2264 c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any three sets \\(u\\), \\(s\\), and \\(t\\), if \\(s\\) and \\(t\\) have no common elements, then the intersection of \\(u\\) and \\(s\\) also has no common elements with \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_left' (u : Set \u03b1) (h : Disjoint s t) : Disjoint (u \u2229 s) t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a set '\u03b1' is countable if and only if there exists an injection (a one-to-one function) from '\u03b1' to the set of natural numbers \u2115.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem countable_iff_nonempty_embedding : Countable \u03b1 \u2194 Nonempty (\u03b1 \u21aa \u2115) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\( f \\) is monotone (meaning it preserves order), then the function that maps \\( x \\) to the set of elements strictly less than \\( f(x) \\) is also monotone.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Monotone.Iio (hf : Monotone f) : Monotone fun x => Iio (f x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of all extended non-negative real numbers greater than a given non-negative real number \\(r\\) is not empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem nhdsWithin_Ioi_coe_neBot {r : \u211d\u22650} : (\ud835\udcdd[>] (r : \u211d\u22650\u221e)).NeBot :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 is less than or equal to a constant value 'a' if and only if 1 is less than or equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_const : 1 \u2264 const \u03b2 a \u2194 1 \u2264 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two numbers 'a' and 'b', if 'a' is less than or equal to 0 and 'b' is less than or equal to 1, then 'a' is less than or equal to 'a' multiplied by 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_mul_of_le_one_right (ha : a \u2264 0) (h : b \u2264 1) : a \u2264 a * b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if there is a linear isomorphism 'e' between two modules L\u2081 and L\u2082, then taking the inverse of the inverse of 'e' gives us back 'e'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem symm_symm (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : e.symm.symm = e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\(I\\) and \\(J\\) be ideals of a ring \\(R\\). Prove that if \\(I\\) divides \\(J\\), then \\(J\\) is a subset of \\(I\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_of_dvd {I J : Ideal R} : I \u2223 J \u2192 J \u2264 I\n   | \u27e8_, h\u27e9 => h.symm \u25b8 le_trans mul_le_inf inf_le_left\n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nIn a mathematical structure where elements have multiplication, a zero element, and allow cancellation (like integers), if an element 'p' divides another element 'q' such that 'p' is not a unit (doesn't have a multiplicative inverse), then 'p' and 'q' cannot be the same element.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero \u03b1] {p q : \u03b1} (h : DvdNotUnit p q) : p \u2260 q :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nFor any real number 'x' and quaternion 'y', scaling 'y' by 'x' is the same as converting the product of 'x' and 'y' to a quaternion.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_coe : x \u2022 (y : \u210d[R,c\u2081,c\u2082]) = \u2191(x * y) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven any functor \\(F\\) (a structure-preserving map) between categories \\(C\\) and \\(D\\), and any object \\(X\\) in category \\(C\\), prove that applying the identity natural transformation to \\(F\\) at \\(X\\) is the same as the identity morphism for the object \\(F(X)\\) in category \\(D\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem id_app' (F : C \u2964 D) (X : C) : (NatTrans.id F).app X = \ud835\udfd9 (F.obj X) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any real number \\( x \\), the arccosine of \\( x \\) is equal to  \\( \\frac{\\pi}{2} \\) minus the arcsine of \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem arccos_eq_pi_div_two_sub_arcsin (x : \u211d) : arccos x = \u03c0 / 2 - arcsin x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a Hahn series is a unit (i.e., has a multiplicative inverse) if and only if the coefficient of its leading term is a unit.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isUnit_iff {x : HahnSeries \u0393 R} : IsUnit x \u2194 IsUnit (x.coeff x.order) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two elements \\( a \\) and \\( b \\) in a partially ordered set, if \\( a \\) is strictly less than \\( b \\), then \\( b \\) cannot be less than or equal to \\( a \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem not_le_of_lt [Preorder \u03b1] {a b : \u03b1} (h : a < b) : \u00acb \u2264 a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the derivative of (x + c)^2 is 2(x + c), where x is a variable and c is a constant.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive number \\( y \\), a number \\( x \\) is less than the logarithm of \\( y \\) if and only if the exponential of \\( x \\) is less than \\( y \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y \u2194 exp x < y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'a', 'a' is the least upper bound (LUB) of the set containing only 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem isLUB_singleton : IsLUB {a} a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if the product of two numbers is negative and one of the numbers is non-negative, then the other number must be negative.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Right.neg_of_mul_neg_right [MulPosMono \u03b1] (h : a * b < 0) (h1 : 0 \u2264 b) : a < 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-zero p-adic integer \\( x \\), the p-adic norm of \\( x \\) is equal to \\( p \\) raised to the power of the negative valuation of \\( x \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_eq_pow_val {x : \u2124_[p]} (hx : x \u2260 0) : \u2016x\u2016 = (p : \u211d) ^ (-x.valuation) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that converting a list to a cycle and then to a finite set is the same as directly converting the list to a finite set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_toFinset (l : List \u03b1) : (l : Cycle \u03b1).toFinset = l.toFinset :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the 0th element of the denominators of any fraction g is always equal to 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem zeroth_denominator_eq_one : g.denominators 0 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's consider two sets, M and M\u2082, which have a specific structure that allows us to \"add\" their elements and \"multiply\" them by elements from another set R. We also have a function, 'f', that takes elements from M and transforms them into elements of M\u2082 in a way that respects the addition and scalar multiplication structure. Now, let 'p' be a subset of M that is closed under the operation of taking additive inverses (i.e., if an element belongs to 'p', its additive inverse also belongs to 'p'). We aim to demonstrate that applying the function '-f' (which is essentially 'f' but transforming elements into their additive inverses) to the set 'p' yields the same result as applying the original function 'f' to 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem map_neg (f : M \u2192\u2097[R] M\u2082) : map (-f) p = map f p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven an element 'a' from any type 'B', applying the 'object' function of the 'preinclusion' function on 'B' to 'a' will return 'a' itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem preinclusion_obj (a : B) : (preinclusion B).obj a = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the number of elements in the set of natural numbers from `a` to `b` (inclusive) is equal to `b + 1 - a`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that in any list, the index of an element 'a' within a new list formed by adding 'a' to the beginning of the original list is always 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem indexOf_cons_self (a : \u03b1) (l : List \u03b1) : indexOf a (a :: l) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that taking the product of two sets `p` and `q\u2081` (which are subsets of the Cartesian product of sets `M` and `M'`) is equivalent to taking the Cartesian product of `p` (as a subset of `M`) and `q\u2081` (as a subset of `M'`).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_coe : (prod p q\u2081 : Set (M \u00d7 M')) = (p : Set M) \u00d7\u02e2 (q\u2081 : Set M') :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's imagine a scenario where 'r' represents a relationship between objects.  If 'a' is related to 'b' through 'r', and 'b' is related to 'c' through a chain of 'r' relationships that could potentially be empty (meaning 'b' might be equal to 'c'), then we want to prove that 'a' is related to 'c' through 'r'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the factorization of 1 is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem factorization_one : factorization (1 : \u03b1) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the set of points belonging to the bottom element of the space of compact sets is empty.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem coe_bot : (\u2191(\u22a5 : Compacts \u03b1) : Set \u03b1) = \u2205 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sum of zero vectors over any countable index set is equal to the zero vector.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sum_zero [Countable \u03b9] : (kernel.sum fun _ : \u03b9 => (0 : kernel \u03b1 \u03b2)) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any positive natural number \\( a \\) and any integer \\( n \\),  \\( a \\) raised to the power of \\( n \\) is not equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Nat.zpow_ne_zero_of_pos {a : \u2115} (h : 0 < a) (n : \u2124) : (a : \u03b1) ^ n \u2260 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any polynomial 'f', the degree of the reverse of 'f' is equal to the degree of 'f' minus the trailing degree of 'f'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven three sets \\(s\\), \\(t\\), and a single element \\(a\\), all from the same set, we define a new set called \"doset\" as follows:  The doset of \\(a\\), \\(s\\), and \\(t\\) is the set of all elements that can be formed by picking any element \\(x\\) from \\(s\\), any element \\(y\\) from \\(t\\), and computing \\(x * a * y\\). Prove that an element \\(b\\) belongs to this doset if and only if there exist elements \\(x\\) in \\(s\\) and \\(y\\) in \\(t\\) such that \\(b\\) equals \\(x * a * y\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_doset {s t : Set \u03b1} {a b : \u03b1} : b \u2208 doset a s t \u2194 \u2203 x \u2208 s, \u2203 y \u2208 t, b = x * a * y :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any objects X and Y in a preadditive category C, and any morphisms a, b, c, and d from X to Y, the following equation holds: (a - c) - (b - d) = (a - b) - (c - d).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub_sub_sub {X Y : C} (a b c d : X \u27f6 Y) : a - c - (b - d) = a - b - (c - d) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if an element \\( b \\) belongs to the set obtained by inserting an element \\( a \\) into a set \\( s \\), and \\( b \\) is not equal to \\( a \\), then \\( b \\) must belong to the original set \\( s \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mem_of_mem_insert_of_ne (h : b \u2208 insert a s) : b \u2260 a \u2192 b \u2208 s :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any natural number `o`, taking the predecessor of the successor of `o` always results in `o` itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pred_succ (o) : pred (succ o) = o :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the function `pure`, which takes an element and puts it into a singleton interval, is injective.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem pure_injective : Injective (pure : \u03b1 \u2192 Interval \u03b1) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that applying the \"mapMatrix\" operation to the \"reflexive\" algebraic equivalence on matrices results in the same reflexive algebraic equivalence.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m \u03b1 \u2243\u2090[R] _) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'b' in a set with a decidable equality relation, removing 'b' from the set of elements less than or equal to 'b' results in the set of elements strictly less than 'b'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Iic_erase [DecidableEq \u03b1] (b : \u03b1) : (Iic b).erase b = Iio b :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that any function \\( f \\) is Riemann integrable on an interval where the start and end points are both \\( a \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem refl : IntervalIntegrable f \u03bc a a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven that a relation 'r' does not hold between element 'a' and any other element 'b', prove that 'b' is reachable from 'a' through the reflexive and transitive closure of 'r' if and only if 'b' is equal to 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem reflTransGen_iff_eq (h : \u2200 b, \u00acr a b) : ReflTransGen r a b \u2194 b = a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet F be a field and E be a field extension of F. Let \u03b1 be an element of E, and F\u27ee\u03b1\u27ef be the smallest subfield of E containing both F and \u03b1. Prove that the image of \u03b1 under the natural embedding from F\u27ee\u03b1\u27ef to E is \u03b1 itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem AdjoinSimple.algebraMap_gen : algebraMap F\u27ee\u03b1\u27ef E (AdjoinSimple.gen F \u03b1) = \u03b1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the relation of being in a one-to-one correspondence (bijection) between elements of a set is an equivalence relation.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem equivalence_of_oneOneEquiv {\u03b1} [Primcodable \u03b1] : Equivalence (@OneOneEquiv \u03b1 \u03b1 _ _) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the inverse function is continuous at a point \\(x\\) within a set \\(s\\), given that the inverse function is continuous everywhere.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that swapping the order of multiplication in a product measure results in the same measure.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem prod_swap : map Prod.swap (\u03bc.prod \u03bd) = \u03bd.prod \u03bc :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that removing element `c` from the singleton set `{b}` using vector subtraction (`-\u1d65`) results in a singleton set containing the element `b -\u1d65 c`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem singleton_vsub_singleton : ({b} : Set \u03b2) -\u1d65 {c} = {b -\u1d65 c} :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any irrational number \\(x\\) and any natural number \\(m\\), the sum \\(x + m\\) is also irrational.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem add_nat (h : Irrational x) (m : \u2115) : Irrational (x + m) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that appending an element 'a' to a vector 'v' and then concatenating the result with another vector 'w' is the same as appending 'a' to the concatenation of 'v' and 'w'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem append_cons (a : \u03b1) (v : Vector3 \u03b1 m) (w : Vector3 \u03b1 n) : (a :: v) +-+ w = a :: v +-+ w :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any three sets \\( s \\), \\( t \\), and \\( u \\), the intersection of \\( s \\) with the intersection of \\( t \\) and \\( u \\) is equal to the intersection of \\( s \\) and \\( u \\) with the intersection of \\( t \\) and \\( u \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem inter_inter_distrib_right (s t u : Set \u03b1) : s \u2229 t \u2229 u = s \u2229 u \u2229 (t \u2229 u) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a function \\(f\\) and elements \\(x\\) and \\(y\\), if \\(x\\) and \\(y\\) are in the same cycle of \\(f\\), then \\(y\\) and \\(x\\) are also in the same cycle of \\(f\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem SameCycle.symm : SameCycle f x y \u2192 SameCycle f y x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any two real numbers,  the difference between their absolute values is less than or equal to the absolute value of their difference.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem le_sub (a b : R) : abv a - abv b \u2264 abv (a - b) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that a property \\(p\\) holds for all elements of a type \\(\u03b1\\) if and only if \\(p\\) holds for an arbitrary element of \\(\u03b1\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem forall_iff {p : \u03b1 \u2192 Prop} : (\u2200 a, p a) \u2194 p default :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a collection of prepartitions (sets of disjoint sets)  \\( \\pi_i \\) for each index \\( J \\), and a prepartition \\( \\pi \\), if an element belongs to the union of all sets in all \\( \\pi_i \\), then it also belongs to \\( \\pi \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem biUnion_le (\u03c0i : \u2200 J, Prepartition J) : \u03c0.biUnion \u03c0i \u2264 \u03c0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet \\( R \\) be a ring and \\( M \\) be an \\( R \\)-module. Prove that for any element \\( m \\) in \\( M \\), multiplying the indeterminate \\( X \\) in the polynomial ring \\( R[X] \\) by \\( m \\) is the same as applying a specific function to \\( X \\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem smul_X (m : M) : (m \u2022 X : R[X]) = X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the property of \"SupIndep\" holds for any function  'f' when applied to an empty set.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem supIndep_empty (f : \u03b9 \u2192 \u03b1) : (\u2205 : Finset \u03b9).SupIndep f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the size of an ordered tree `t` is equal to the size of its dual tree.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem size_dual (t : Ordnode \u03b1) : size (dual t) = size t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven a sequence F.N where each term is generated by applying a function F, prove that there exists an index n\u2080 such that for any k, the term at index (n\u2080 + k) is equal to the term at index n\u2080 multiplied by the k-th power of some constant I.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Stable.exists_pow_smul_eq : \u2203 n\u2080, \u2200 k, F.N (n\u2080 + k) = I ^ k \u2022 F.N n\u2080 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that 1 is less than or equal to the rounded up value of a number x if and only if 1 is less than or equal to x itself.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem one_le_floor_iff (x : \u03b1) : 1 \u2264 \u230ax\u230b\u208a \u2194 1 \u2264 x :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the hyperbolic sine function (sinh) is infinitely differentiable for all degrees of differentiation 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem contDiff_sinh {n} : ContDiff \u211d n sinh :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nLet's say we have a collection of sets, indexed by 'i', and we can pick an element from each set.  We represent this picking process as functions 'f' and 'g', where  'f(i)' gives us the element picked from the i-th set by 'f', and similarly for 'g'. Now, suppose both 'f' and 'g' have a property called \"Mem\u2113p\" with respect to some condition 'p'.  Prove that if we were to instead pick elements by taking the difference between the picks of 'f' and 'g' (that is, for each set 'i', we choose the element 'f(i) - g(i)'), then this new way of picking will also satisfy the property \"Mem\u2113p\" with respect to 'p'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem sub {f g : \u2200 i, E i} (hf : Mem\u2113p f p) (hg : Mem\u2113p g p) : Mem\u2113p (f - g) p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any non-negative real number 'a' and any natural number 'n', the floor of the sum of 'a' and 'n' is equal to the sum of the floor of 'a' and 'n'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem floor_add_nat (ha : 0 \u2264 a) (n : \u2115) : \u230aa + n\u230b\u208a = \u230aa\u230b\u208a + n :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any element 'x' in a multiplicative structure 'M', the set of all powers of 'x' forms a submonoid of 'M'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the sign function (which outputs -1 for negative numbers, 0 for 0, and 1 for positive numbers) is continuous at any negative number 'a'.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem continuousAt_sign_of_neg {a : \u03b1} (h : a < 0) : ContinuousAt SignType.sign a :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two fractions represented as pairs (a\u2081, a\u2082) and (b\u2081, b\u2082), where a\u2081, a\u2082, b\u2081, and b\u2082 are natural numbers, the fraction (a\u2081/a\u2082) is less than or equal to the fraction (b\u2081/b\u2082) if and only if b\u2082 * a\u2081 is less than or equal to a\u2082 * b\u2081.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem mk_le_mk : mk a\u2081 a\u2082 \u2264 mk b\u2081 b\u2082 \u2194 \u2191b\u2082 * a\u2081 \u2264 a\u2082 * b\u2081 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a function \\(f\\) reverses order (is antitone) and does not repeat outputs for different inputs (is injective), then it strictly reverses order (is strictly antitone).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Antitone.strictAnti_of_injective (h\u2081 : Antitone f) (h\u2082 : Injective f) : StrictAnti f :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any isomorphism `\u03b1` between sets `X` and `Y`, composing `\u03b1` with its inverse `\u03b1.symm` results in the identity isomorphism on `X`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem self_symm_id (\u03b1 : X \u2245 Y) : \u03b1 \u226a\u226b \u03b1.symm = Iso.refl X :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nGiven two vectors `v` and `w` of the same length, prove that the dot product of the `i`-th row of the diagonal matrix of `v` and `w` is equal to the product of the `i`-th element of `v` and the `i`-th element of `w`.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem diagonal_dotProduct (i : m) : diagonal v i \u2b1d\u1d65 w = v i * w i :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a set \\(t\\) is open and disjoint from another set \\(s\\), then the frontier of \\(s\\) is also disjoint from \\(t\\).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that adding an element to the beginning of a list is an injective operation. In other words, if adding the same element 'a' to the beginning of two lists results in the same list, then the original two lists must be identical.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cons_injective {a : \u03b1} : Injective (cons a) :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the absolute value of any unit (invertible element) in the integers is 1.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem norm_coe_units (e : \u2124\u02e3) : \u2016(e : \u2124)\u2016 = 1 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nShow that in a certain algebraic structure (a chain complex), the sum of two specific morphisms, PInfty.f n and QInfty.f n, is equal to the identity morphism (\ud835\udfd9).\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem PInfty_f_add_QInfty_f (n : \u2115) : (PInfty.f n : X _[n] \u27f6 _) + QInfty.f n = \ud835\udfd9 _ :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that the content of the zero polynomial in the ring of polynomials over a commutative ring R is equal to 0.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem content_zero : content (0 : R[X]) = 0 :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that if a polynomial has a degree of 1, then it is irreducible.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that infinity multiplied by infinity equals infinity.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem top_mul_top : \u221e * \u221e = \u221e :=",
        "label": true
      }
    ]
  },
  {
    "input": "Statement in natural language:\nProve that for any system of numbers where zero behaves normally, the conversion from integers to those numbers preserves distinctness. This means that if two integers are different, their representations in the other system will also be different.\nTranslate the statement in natural language to Lean:",
    "outputs": [
      {
        "response": "theorem cast_injective [AddGroupWithOne \u03b1] [CharZero \u03b1] : Function.Injective (Int.cast : \u2124 \u2192 \u03b1)\n   | _, _ => cast_inj.1\n :=",
        "label": true
      }
    ]
  }
]